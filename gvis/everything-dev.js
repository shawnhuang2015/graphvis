var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var ChartElement = (function () {
                function ChartElement() {
                    this.animationOrder = 0;
                    this.updateOrder = 0;
                    this.paintOrder = 0;
                }
                ChartElement.prototype.remove = function () {
                    // a virtual method
                };
                /** 1 - events on internal changes, be careful, endless loop possible */
                ChartElement.prototype.onSceneChange = function (event) {
                    // a virtual method
                };
                /** 2 - Called on size update, returns array of Base_ChartPanel
                 will call panel.computeSize and panel.placePanel in packingOrder */
                ChartElement.prototype.getPanels = function (forExport) {
                    return [];
                };
                /** 3 -  may set sceneEvent.animating = true if animation is still ongoing */
                ChartElement.prototype.doAnimations = function (sceneEvent) {
                    // a virtual method
                };
                /** 4 - do the paint */
                ChartElement.prototype.paintScene = function (sceneEvent) {
                    // a virtual method
                };
                ChartElement.prototype.previewMouseEvent = function (name, event) {
                    this["preview" + name](event);
                };
                ChartElement.prototype.onMouseEvent = function (name, event) {
                    this["on" + name](event);
                };
                /** events on user actions */
                ChartElement.prototype.onClick = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.onInstantClick = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.onLongPress = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.onRightClick = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.onDoubleClick = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.onTripleClick = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.onPointerDown = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.onPointerUp = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.onPointerDrag = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.onPointerMove = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.onPointerOut = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.onPointerCancel = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.onWheel = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.onKeyDown = function (keyEvent) {
                    // a virtual method
                };
                ChartElement.prototype.onGlobalPointerDown = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.previewDoubleClick = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.previewTripleClick = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.previewRightClick = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.previewClick = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.previewInstantClick = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.previewLongPress = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.previewWheel = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.previewGlobalPointerDown = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.previewPointerDown = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.previewPointerUp = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.previewPointerDrag = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.previewPointerMove = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.previewPointerOut = function (mouseEvent) {
                    // a virtual method
                };
                ChartElement.prototype.previewPointerCancel = function (mouseEvent) {
                    // a virtual method
                };
                /** Determines if the given coordinates are located within one of the panels for this element. */
                ChartElement.prototype.containsCoordinate = function (x, y) {
                    var panels = this.getPanels(false);
                    if (!panels || !panels.length)
                        return false;
                    for (var i = 0; i < panels.length; i++) {
                        var p = panels[i];
                        if (p.left < x && p.right > x && p.top < y && p.bottom > y)
                            return true;
                    }
                    return false;
                };
                return ChartElement;
            }());
            Base.ChartElement = ChartElement;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
"use strict";
var ZoomCharts;
(function (ZoomCharts) {
    /*!
     * @license
     * DVSL Charting library, version <?package_version?>.
     * (c) 2013 - <?current_year?> Data Visualization Software Lab
     *
     * https://zoomcharts.com
     *
     *
     * Embedded 3rd party software libraries:
     *
     *   CssColorParser.js
     *     author : Dean McNamee <dean@gmail.com>, 2012.
     *     license : MIT
     *     github.com/deanm/css-color-parser-js
     *
     *   SHA-256 implementation in JavaScript
     *     author : Chris Veness
     *     license: MIT
     *     github.com/chrisveness/crypto
     *
     *   jsrsasign (RSA-Sign JavaScript Library)
     *     version : 4.7.2
     *     author : Kenji Urushima
     *     license : MIT
     *     kjur.github.io/jsrsasign/
     *
     *   jsbn (RSA and ECC in JavaScript)
     *     version : 1.4
     *     author : Tom Wu
     *     license : BSD (http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE)
     *     www-cs-students.stanford.edu/~tjw/jsbn/
     */
    ZoomCharts.PackageInfo = {
        LibraryName: "<?library_name?>",
        Version: "<?package_version?>",
        Revision: "<?git_revision?>",
        Built: "<?current_date?>"
    };
    // this __extends will be used when the code is compiled using `build.js` as it merges the modules together
    // if the code is compiled through Visual Studio or other compilers, the __extends below will be used instead.
    /* tslint:disable:no-unused-variable */
    /** A custom implementation of default __extends that additionally sets __baseType */
    var __extends = function (d, b) {
        d.__baseType = b;
        for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})(ZoomCharts || (ZoomCharts = {}));
/*#if !FlatNamespaces*/
/* tslint:disable:no-unused-variable */
/** A custom implementation of default __extends that additionally sets __baseType */
var __extends = function (d, b) {
    d.__baseType = b;
    for (var p in b)
        if (b.hasOwnProperty(p))
            d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/* tslint:enable:no-unused-variable */
/*#endif*/ 
/// <reference path="../ZoomCharts.d.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        if (typeof module !== "undefined" && module.exports) {
            module.exports["Internal"] = Internal;
        }
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var hasProp = Object.prototype.hasOwnProperty;
            // create a dummy wrapper for console calls that prevents errors on IE9.
            function noop() { }
            var safeConsole = (typeof console === typeof void 0 ? null : console) || {};
            if (!safeConsole.log)
                safeConsole.log = noop;
            if (!safeConsole.warn)
                safeConsole.warn = noop;
            if (!safeConsole.error)
                safeConsole.error = noop;
            if (!safeConsole.info)
                safeConsole.info = noop;
            Base.overlayConsole = false;
            var Helpers = (function () {
                function Helpers() {
                }
                Helpers.exportSymbol = function (name, constr) {
                    if (typeof window !== "undefined")
                        window[name] = constr;
                    if (typeof module !== "undefined" && module.exports)
                        module.exports[name] = constr;
                };
                /** Copies shallow object values from `style` into `object`. Skips properties with `undefined` values. */
                Helpers.extendStyleTo = function (style, object) {
                    var keys = Object.keys(style);
                    for (var i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        var val = style[key];
                        if (val !== void 0) {
                            object[key] = val;
                        }
                    }
                };
                Helpers.extendDataItem = function (object, other) {
                    var ret = object;
                    var keys = Object.keys(other);
                    for (var i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        var val = other[key];
                        if (key === "style") {
                            if (ret.style) {
                                Helpers.extendDeep(ret.style, val);
                            }
                            else {
                                ret.style = Helpers.realClone(val);
                            }
                        }
                        else {
                            ret[key] = val;
                        }
                    }
                    return ret;
                };
                Helpers.extendDeep = function (object, other) {
                    if (object == null)
                        throw new Error("Target object is not defined.");
                    if (!Helpers.isObjectOrArray(object))
                        throw new Error("Target is not an object.");
                    var keys = Object.keys(other);
                    for (var i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        var val = other[key];
                        var valBefore = object[key];
                        if (valBefore == null && Helpers.isObjectOrArray(val) && !Helpers.isDomObject(val)) {
                            // object[key]=val approach is not suitable here because multiple objects will end up with the same instance references
                            // thus further changes might impact multiple objects.
                            object[key] = this.realClone(val);
                        }
                        else if (Helpers.isObjectOrArray(valBefore) && Helpers.isObjectOrArray(val) && !Helpers.isDomObject(valBefore) && !Helpers.isDomObject(val)) {
                            this.extendDeep(valBefore, val);
                        }
                        else {
                            object[key] = val;
                        }
                    }
                };
                /** Copies values from `other` into `object`. All objects and arrays are cloned instead of being copied as reference.
                @param object - the target object
                @param other - the source object
                @param shouldIgnore - an optional delegate that will receive the name of each property and has to determine if it should be copied.
                @returns - the target object
                */
                Helpers.extendCopy = function (object, other, filter) {
                    if (filter === void 0) { filter = null; }
                    if (!other)
                        return object;
                    var keys = Object.keys(other);
                    for (var i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        var val = other[key];
                        if (filter)
                            val = filter(key, val);
                        if (val === void 0)
                            continue;
                        var valBefore = object[key];
                        if (this.isDomObject(val)) {
                            object[key] = val;
                        }
                        else if (this.isObjectOrArray(valBefore) && this.isObjectOrArray(val)) {
                            this.extendCopy(valBefore, val, filter);
                        }
                        else if (this.isObjectOrArray(val)) {
                            if (Array.isArray(val)) {
                                object[key] = this.extendCopy([], val, filter);
                            }
                            else {
                                object[key] = this.extendCopy({}, val, filter);
                            }
                        }
                        else {
                            object[key] = val;
                        }
                    }
                    return object;
                };
                /** Creates a shallow clone of the given object. If recursive clone is needed, use `realClone` */
                Helpers.clone = function (obj) {
                    if (obj == null)
                        return obj;
                    var r;
                    if (Helpers.isObjectOrArray(obj)) {
                        r = new obj.constructor();
                    }
                    else {
                        r = obj.constructor();
                    }
                    var keys = Object.keys(obj);
                    for (var i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        var val = obj[key];
                        r[key] = val;
                    }
                    return r;
                };
                Helpers.isObjectOrArray = function (source) {
                    return source !== null && typeof source === "object";
                };
                Helpers.isDomObject = function (source) {
                    return source instanceof Element
                        || source instanceof CanvasGradient
                        || source instanceof CanvasPattern;
                };
                Helpers.isFunction = function (source) {
                    return typeof source === "function";
                };
                Helpers.isNumber = function (n) {
                    return !isNaN(n) && (typeof n === "number" || n instanceof Number);
                };
                Helpers.isString = function (source) {
                    return typeof source === "string" || source instanceof String;
                };
                Helpers.tryParseInt = function (value, defaultValue) {
                    if (defaultValue === void 0) { defaultValue = 0; }
                    var r = parseInt(value, 10);
                    if (!isNaN(r))
                        return r;
                    return defaultValue;
                };
                Helpers.tryParseFloat = function (value, defaultValue) {
                    if (defaultValue === void 0) { defaultValue = 0; }
                    var r = parseFloat(value);
                    if (!isNaN(r))
                        return r;
                    return defaultValue;
                };
                Helpers.hasProperty = function (o, prop) {
                    return hasProp.call(o, prop);
                };
                Helpers.hasProperties = function (o) {
                    if (!o)
                        return false;
                    return Object.keys(o).length > 0;
                };
                /** Removes any single property and returns the key/value pair that was removed or `null` if the dictionary was empty.*/
                Helpers.removePropertyValue = function (o) {
                    var keys = Object.keys(o);
                    if (keys.length === 0)
                        return null;
                    var key = keys[0];
                    var val = o[key];
                    delete o[key];
                    return { key: key, value: val };
                };
                Helpers.countProperties = function (o) {
                    return Object.keys(o).length;
                };
                Helpers.realClone = function (source) {
                    if (this.isFunction(source) || this.isDomObject(source)) {
                        return source;
                    }
                    else if (Array.isArray(source)) {
                        var destArray = new Array(source.length);
                        for (var i = 0; i < source.length; i++) {
                            destArray[i] = this.realClone((source)[i]);
                        }
                        return destArray;
                    }
                    else if (this.isObjectOrArray(source)) {
                        var destObject = new source.constructor();
                        var keys = Object.keys(source);
                        for (var i = 0; i < keys.length; i++) {
                            var key = keys[i];
                            destObject[key] = this.realClone(source[key]);
                        }
                        return destObject;
                    }
                    else {
                        return source;
                    }
                };
                Helpers.realCloneSafe = function (source, recursiveCheck) {
                    if (recursiveCheck === void 0) { recursiveCheck = []; }
                    if (this.isFunction(source) || this.isDomObject(source)) {
                        return source;
                    }
                    else if (Array.isArray(source)) {
                        for (var i = 0; i < recursiveCheck.length; i++) {
                            var r = recursiveCheck[i];
                            if (r.from === source)
                                return r.to;
                        }
                        var destArray = new Array(source.length);
                        recursiveCheck.push({ from: source, to: destArray });
                        for (var i = 0; i < source.length; i++) {
                            destArray[i] = this.realCloneSafe(source[i], recursiveCheck);
                        }
                        return destArray;
                    }
                    else if (this.isObjectOrArray(source)) {
                        for (var i = 0; i < recursiveCheck.length; i++) {
                            var r = recursiveCheck[i];
                            if (r.from === source)
                                return r.to;
                        }
                        var destObject = new source.constructor();
                        recursiveCheck.push({ from: source, to: destObject });
                        var keys = Object.keys(source);
                        for (var i = 0; i < keys.length; i++) {
                            var k = keys[i];
                            destObject[k] = this.realCloneSafe(source[k], recursiveCheck);
                        }
                        return destObject;
                    }
                    else {
                        return source;
                    }
                };
                Helpers.removeFromArray = function (arr, item) {
                    var removed = false;
                    var i;
                    while ((i = arr.indexOf(item)) > -1) {
                        arr.splice(i, 1);
                        removed = true;
                    }
                    return removed;
                };
                /** Removes an element from an array in a quicker but less precise way than removeFromArray(). In particular,
                    only the first instance of the element is removed, and the remaining elements are reordered. */
                Helpers.removeFromArrayHasty = function (arr, item) {
                    var idx = arr.indexOf(item);
                    if (idx >= 0) {
                        arr[idx] = arr[arr.length - 1];
                        arr.pop();
                        return true;
                    }
                    return false;
                };
                Helpers.arrayToMap = function (arr, keyProperty) {
                    var dict = {};
                    for (var i = 0; i < arr.length; i++) {
                        var c = arr[i];
                        c.index = i;
                        dict[c[keyProperty]] = c;
                    }
                    return dict;
                };
                Helpers.overlayConsoleMessage = function (type, message, args) {
                    var el = document.getElementById("zoomChartsOverlayConsole");
                    if (!el) {
                        el = document.createElement("div");
                        el.id = "zoomChartsOverlayConsole";
                        Helpers.extendCopy(el.style, {
                            position: "absolute",
                            top: "10px",
                            left: "10px",
                            width: "50%",
                            height: "300px",
                            overflow: "auto",
                            backgroundColor: "rgba(255,255,255,0.75)",
                            border: "1px solid black",
                            zIndex: "99999"
                        });
                        document.body.appendChild(el);
                    }
                    var msg = document.createElement("div");
                    msg.style.color = type === "error" ? "red" : type === "warn" ? "yellow" : "black";
                    msg.innerText = message + args.map(function (x) { return JSON.stringify(x); }).join("");
                    el.appendChild(msg);
                    el.scrollTop = el.scrollHeight;
                };
                Helpers.log = function (message) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    if (Base.overlayConsole) {
                        Helpers.overlayConsoleMessage("log", message, args);
                    }
                    else if (args && args.length) {
                        safeConsole.info.apply(safeConsole, [message].concat(args));
                    }
                    else {
                        safeConsole.info(message);
                    }
                };
                Helpers.warn = function (message, args, preventDuplicates) {
                    if (preventDuplicates === void 0) { preventDuplicates = null; }
                    if (preventDuplicates) {
                        var d = new Date().getTime();
                        if (this._previousConsoleMessages[message] > d)
                            return;
                        if (preventDuplicates === true)
                            preventDuplicates = 5000;
                        this._previousConsoleMessages[message] = d + preventDuplicates;
                    }
                    if (Base.overlayConsole) {
                        Helpers.overlayConsoleMessage("warn", message, args);
                    }
                    else if (args && args.length) {
                        safeConsole.warn.apply(safeConsole, [message].concat(args));
                    }
                    else {
                        safeConsole.warn(message);
                    }
                };
                Helpers.error = function (message) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    if (Base.overlayConsole) {
                        Helpers.overlayConsoleMessage("error", message, args);
                    }
                    else if (args && args.length) {
                        safeConsole.error.apply(safeConsole, [message].concat(args));
                    }
                    else {
                        safeConsole.error(message);
                    }
                };
                Helpers.createDom = function (tagName, cl, innerHtml, container) {
                    if (cl === void 0) { cl = null; }
                    if (innerHtml === void 0) { innerHtml = null; }
                    if (container === void 0) { container = null; }
                    var el = document.createElement(tagName);
                    if (cl !== null)
                        el.className = cl;
                    if (innerHtml !== null)
                        el.innerHTML = innerHtml;
                    if (container !== null)
                        container.appendChild(el);
                    return el;
                };
                Helpers.addClass = function (el, name) {
                    if (el.classList) {
                        el.classList.add(name);
                    }
                    else {
                        var hasClass = (el.className.length > 0) && new RegExp("(^|\s)" + name.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") + "(\s|$)").test(el.className);
                        if (!hasClass) {
                            if (el.className.length > 0)
                                name = " " + name;
                            el.className = name;
                        }
                    }
                };
                Helpers.removeClass = function (el, name) {
                    if (el.classList) {
                        el.classList.remove(name);
                    }
                    else {
                        var replaceFn = function (w, match) {
                            if (match === name) {
                                return "";
                            }
                            else {
                                return w;
                            }
                        };
                        el.className = el.className.replace(/(\S+)\s*/g, replaceFn).trim();
                    }
                };
                /**
                 * Verifies that the given CSS class name has been loaded into the DOM. The class is loaded if the given
                 * property changes values when the class is assigned.
                 *
                 * Note that stylesheet enumeration is not used since CORS prevents reading of individual rules at least
                 * in Chrome even when it is correctly configured.
                 * @param className - the class name to verify (without the dot prefix).
                 * @param styleProperty - the style property that will be verified from the computed style.
                 */
                Helpers.isStyleSheetDefined = function (className, styleProperty) {
                    var elem = document.createElement("a");
                    var body = document.body;
                    body.appendChild(elem);
                    try {
                        var computedStyle = window.getComputedStyle(elem);
                        var valueBefore = computedStyle[styleProperty];
                        elem.className = className;
                        // the following remove/add is required since that seems to force Chrome/Safari to apply the class.
                        // this was noted on zoomcharts.com - it might be that the size of the page prevented the styles from
                        // being applied immediately...
                        body.removeChild(elem);
                        body.appendChild(elem);
                        return valueBefore !== computedStyle[styleProperty];
                    }
                    finally {
                        body.removeChild(elem);
                    }
                };
                Helpers.listen = function (node, eventName, fn) {
                    node.addEventListener(eventName, fn);
                };
                Helpers.unlisten = function (node, eventName, fn) {
                    node.removeEventListener(eventName, fn);
                };
                Helpers.stopPropagation = function (domEvent) {
                    // prior to 1.12 this also called .preventDefault()
                    // this is no longer done since one of the default actions
                    // is to update document.activeElement which should not be
                    // prevented.
                    // however, it is done in MouseEvents.processConsumed for some event types
                    // since it has to prevent Chrome overscroll gesture that acts as back/forward gesture.
                    domEvent.stopPropagation();
                };
                Helpers.canvasScaling = function () {
                    var x;
                    var y;
                    if (window.screen.deviceXDPI) {
                        // using this as the first one since Windows Phone returns some strange
                        // precision number for devicePixelRatio
                        x = window.screen.deviceXDPI / window.screen.logicalXDPI;
                        y = window.screen.deviceYDPI / window.screen.logicalYDPI;
                    }
                    else if (window.devicePixelRatio) {
                        x = y = window.devicePixelRatio;
                    }
                    else {
                        x = y = 1;
                    }
                    return { x: x, y: y };
                };
                /** Calculates the offsetX/offsetY properties for a mouse event that originally did not provide them. */
                Helpers.convertPointFromPageToNode = function (node, pageX, pageY, clientX, clientY) {
                    // the "window" check is there because Chrome returns window as null when the chart runs in iframe and the top
                    // level window event fires.
                    if (window && window.webkitConvertPointFromPageToNode) {
                        // using this method first since it handles CSS transformations
                        // supported on MS Edge and Safari
                        var pos = window.webkitConvertPointFromPageToNode(node, new WebKitPoint(pageX, pageY));
                        if (pos)
                            return pos;
                    }
                    var box = node.getBoundingClientRect();
                    return {
                        x: clientX - box.left,
                        y: clientY - box.top
                    };
                };
                Helpers.elementPos = function (obj) {
                    var box = obj.getBoundingClientRect();
                    var top = box.top + (window.pageYOffset || document.documentElement.scrollTop) - (document.documentElement.clientTop || 0);
                    var left = box.left + (window.pageXOffset || document.documentElement.scrollLeft) - (document.documentElement.clientLeft || 0);
                    return { left: left, top: top };
                };
                /** Returns `true` if the `child` is nested within the `parent`. If the `child` equals the `parent` the method also returns `true`. */
                Helpers.isParentOf = function (parent, child) {
                    while (child) {
                        if (child === parent) {
                            return true;
                        }
                        child = child.parentElement;
                    }
                    return false;
                };
                /** Retrieves the nested property value from the given object. Returns `undefined` if any of the steps are not present.
                @param obj - the source (root) object
                @param route - the path to the property in form `firstLevel.secondLevel.property`
                @param deleteProperty - specifies if the last property will be removed from the object. Defaults to `false`.*/
                Helpers.getProp = function (obj, route, deleteProperty) {
                    if (deleteProperty === void 0) { deleteProperty = false; }
                    for (var partIndex = 0, partSource = route.split("."); partIndex < partSource.length; partIndex++) {
                        var part = partSource[partIndex];
                        if (obj == null || !this.hasProperty(obj, part))
                            return void 0;
                        if (deleteProperty && partIndex === partSource.length - 1) {
                            var temp = obj[part];
                            delete obj[part];
                            obj = temp;
                        }
                        else {
                            obj = obj[part];
                        }
                    }
                    return obj;
                };
                /** Creates an object structure from the given route (in format `prop1.prop2.prop3`) where the value of the last object is the given value. */
                Helpers.wrapValue = function (value, route) {
                    var v = value;
                    var partSource = route.split(".").reverse();
                    for (var partIndex = 0; partIndex < partSource.length; partIndex++) {
                        var part = partSource[partIndex];
                        v = (_a = {}, _a[part] = v, _a);
                    }
                    return v;
                    var _a;
                };
                Helpers.hasProp = function (obj, route) {
                    return Helpers.getProp(obj, route) !== void 0;
                };
                Helpers.sign = function (x) {
                    if (!x) {
                        return 0;
                    }
                    if (x < 0) {
                        return -1;
                    }
                    return 1;
                };
                Helpers.reversePolyline = function (line) {
                    var reversed = [];
                    if (line.length % 2 !== 0) {
                        throw new Error("The length of a given polyline must be dividable by 2");
                    }
                    for (var i = line.length - 1; i >= 0; i += -2) {
                        reversed.push(line[i - 1], line[i]);
                    }
                    return reversed;
                };
                Helpers.toleranceMax = function (v, max, tol) {
                    return (v >= max * tol) ? v : max;
                };
                Helpers.toleranceMin = function (v, min, tol) {
                    return (v * tol <= min) ? v : min;
                };
                Helpers.getIdentifierStr = function () {
                    return Helpers.SeparatorChar + (Helpers.nextIdentifier++).toString();
                };
                Helpers.doPostRequest = function (url, timeout, data, success, fail) {
                    if (!this.isString(data))
                        data = JSON.stringify(data);
                    this.doRequestRaw(url, timeout, "POST", data, success, fail);
                };
                Helpers.doRequest = function (url, timeout, params, success, fail) {
                    if (params && params.length) {
                        if (url.indexOf("?") !== -1) {
                            url += "&";
                        }
                        else {
                            url += "?";
                        }
                        for (var i = 0; i < params.length; i++) {
                            var p = params[i];
                            if (i > 0)
                                url += "&";
                            url += encodeURIComponent(p[0]) + "=" + encodeURIComponent(p[1]);
                        }
                    }
                    this.doRequestRaw(url, timeout, "GET", "", success, fail);
                };
                Helpers.doRequestRaw = function (url, timeout, method, data, success, fail) {
                    var req;
                    if (typeof XMLHttpRequest !== typeof void 0) {
                        req = new XMLHttpRequest();
                    }
                    else {
                        throw new Error("Cannot create XMLHttpRequest. Please verify if the feature is not disabled in the browser configuration.");
                    }
                    req.onreadystatechange = function () {
                        if (req.readyState === 4) {
                            if (req.status === 200) {
                                success(req.responseText);
                            }
                            else {
                                fail(req.responseText);
                            }
                        }
                    };
                    try {
                        // Edge and Chrome will throw on open()
                        req.open(method, url, true);
                        req.timeout = timeout;
                        req.ontimeout = function () {
                            fail("{\"error\": \"Request timeout.\"}");
                        };
                        // Firefox will throw on send()
                        req.send(data);
                    }
                    catch (e) {
                        // this intercepts errors like 
                        // SecurityError: Failed to execute 'open' on 'XMLHttpRequest': Refused to connect to 'https://api.zoomcharts-cloud.com/lc/v1/' 
                        // because it violates the document's Content Security Policy.
                        window.setTimeout(function () { return fail(e); }, 1);
                        return;
                    }
                };
                Helpers.openUrl = function (url, target) {
                    return window.open(url, target || "_blank");
                };
                /**
                 * Converts incoming data from a data source for use in charts. Parses strings to objects and handles basic error cases
                 * like null response/empty string/etc. The result is guaranteed to be a non-null object with possibly the "error" property.
                 * @param text Data to parse.
                 * @param format Format to use for parsing. Currently only JSON is supported (GeoJSON for geochart as well, but it's the same thing anyway)
                 * @param isErrorString For error responses, the string can be a plain text message. If set to true and parsing fails, uses the raw message for the error string.
                 */
                Helpers.parseData = function (text, format, isErrorString) {
                    if (isErrorString === void 0) { isErrorString = false; }
                    var error = null;
                    var data = null;
                    format = format.toLowerCase();
                    if (format === "json" || format === "geojson") {
                        if (Helpers.isString(text)) {
                            try {
                                data = JSON.parse(text);
                            }
                            catch (exception) {
                                error = isErrorString ? text : "Failed to parse JSON response: " + exception + ". Response text: " + text;
                            }
                        }
                        else {
                            // this is object already, no parsing needed, jquery will auto-parse JSON response if the mime type is correct.
                            data = text;
                        }
                    }
                    else {
                        error = "Unsupported data format: " + format;
                    }
                    if (data == null && error == null)
                        error = "NULL response";
                    return error ? { error: error } : data;
                };
                Helpers.numberFormat = function (value, decPlaces, decSeparator, thouSeparator) {
                    if (decPlaces === void 0) { decPlaces = 2; }
                    if (decSeparator === void 0) { decSeparator = "."; }
                    if (thouSeparator === void 0) { thouSeparator = "\u00A0"; }
                    var n = parseFloat(value);
                    if (isNaN(n))
                        return "â€”";
                    var sign;
                    if (n < 0) {
                        sign = "-";
                        n = -n;
                    }
                    else {
                        sign = "";
                    }
                    var int = Math.floor(n);
                    var dec = n - int;
                    var str = decSeparator + dec.toFixed(decPlaces).substr(2);
                    var part;
                    while (1) {
                        part = int % 1000;
                        str = part.toFixed(0) + str;
                        if (int >= 1000) {
                            int = Math.floor(int / 1000);
                            if (part < 10) {
                                str = "00" + str;
                            }
                            else if (part < 100) {
                                str = "0" + str;
                            }
                            str = thouSeparator + str;
                        }
                        else {
                            break;
                        }
                    }
                    return sign + str;
                };
                Helpers.buildImage = function (src, useCors, onLoad, onError) {
                    var _this = this;
                    var image = new Image();
                    var onLoadFunc = function () { return onLoad(image); };
                    var onErrorFunc = function (ev) {
                        if (useCors) {
                            // try again without CORS. this will still prevent the chart export from working however
                            // it will display an error in the console and the chart itself will show the image.
                            _this.buildImage(src, null, onLoad, onError);
                        }
                        else {
                            onError(image);
                        }
                    };
                    if (useCors)
                        image.crossOrigin = useCors;
                    image.src = src;
                    // if image is cached IE (surprise!) may not trigger onload
                    if (image.complete) {
                        if (image.width > 0) {
                            onLoadFunc();
                        }
                        else {
                            setTimeout(onLoadFunc, 0);
                        }
                    }
                    else {
                        image.onload = onLoadFunc;
                        image.onerror = onErrorFunc;
                    }
                    return image;
                };
                Helpers.sort = function (sourceArray, compare) {
                    // nonrecursive in-place merge sort
                    if (!compare) {
                        compare = function (a, b) { return a - b; };
                    }
                    var array = sourceArray;
                    var len = array.length | 0;
                    var v1;
                    var v2;
                    // first sort pairs of 2
                    for (var i = 0; i <= len - 2; i += 2) {
                        v1 = array[i];
                        v2 = array[i + 1];
                        if (compare(v1, v2) > 0) {
                            array[i] = v2;
                            array[i + 1] = v1;
                        }
                    }
                    var array2 = array.slice(0);
                    var step = 2;
                    while (step < len) {
                        var step2 = step << 1;
                        for (var origin = 0; origin <= len - 1; origin += step2) {
                            // merge one block
                            var i1 = origin;
                            var i2 = origin + step;
                            if (i2 >= len) {
                                // just a single block, copy over
                                for (var i = i1; i <= len - 1; i++) {
                                    array2[i] = array[i];
                                }
                            }
                            else {
                                // two blocks, let's merge
                                var l1 = i2;
                                var l2 = Math.min(i2 + step, len);
                                var r = origin;
                                v1 = array[i1];
                                v2 = array[i2];
                                while (true) {
                                    if (compare(v1, v2) <= 0) {
                                        array2[r] = v1;
                                        r = (r + 1) | 0;
                                        i1 = (i1 + 1) | 0;
                                        if (i1 === l1) {
                                            array2[r] = v2;
                                            r = (r + 1) | 0;
                                            i2 = (i2 + 1) | 0;
                                            while (i2 < l2) {
                                                array2[r] = array[i2];
                                                r = (r + 1) | 0;
                                                i2 = (i2 + 1) | 0;
                                            }
                                            break;
                                        }
                                        v1 = array[i1];
                                    }
                                    else {
                                        array2[r] = v2;
                                        r = (r + 1) | 0;
                                        i2 = (i2 + 1) | 0;
                                        if (i2 === l2) {
                                            array2[r] = v1;
                                            r = (r + 1) | 0;
                                            i1 = (i1 + 1) | 0;
                                            while (i1 < l1) {
                                                array2[r] = array[i1];
                                                r = (r + 1) | 0;
                                                i1 = (i1 + 1) | 0;
                                            }
                                            break;
                                        }
                                        v2 = array[i2];
                                    }
                                }
                            }
                        }
                        step = step2;
                        var temp = array2;
                        array2 = array;
                        array = temp;
                    }
                    if (sourceArray !== array) {
                        for (var i = 0; i <= len - 1; i++) {
                            sourceArray[i] = array[i];
                        }
                        array.length = 0;
                    }
                    else {
                        array2.length = 0;
                    }
                    return sourceArray;
                };
                /** Returns index of first item that is >= value */
                Helpers.binSearch = function (data, value) {
                    var i0 = 0;
                    var i1 = data.length - 1;
                    while (i0 < i1) {
                        var ii = ((i1 + i0) / 2) | 0;
                        if (data[ii] < value) {
                            i0 = ii + 1;
                        }
                        else if (data[ii] > value) {
                            i1 = ii;
                        }
                        else {
                            // equals
                            while (ii > 0 && data[ii - 1] === value) {
                                ii -= 1;
                            }
                            return ii;
                        }
                    }
                    if (i0 < data.length && data[i0] < value) {
                        return i0 + 1;
                    }
                    else {
                        return i0;
                    }
                };
                Helpers.listenResize = function (target, fn) {
                    // copped down version from http://www.backalleycoder.com/2013/03/18/cross-browser-event-based-element-resize-detection/
                    var dmode = document.documentMode;
                    if (dmode && dmode < 11) {
                        // fallback for IE9/IE10, they knew what developers need ;)
                        target.onresize = fn;
                    }
                    else {
                        var element = target;
                        var trigger_1 = document.createElement("div");
                        var scrollListener = function (e) {
                            fn();
                            Helpers.updateResizeTriggers(trigger_1);
                        };
                        if (window.getComputedStyle(element).position === "static")
                            element.style.position = "relative";
                        element["__resizeTriggers__"] = trigger_1;
                        trigger_1.className = "DVSL-resize-triggers";
                        trigger_1.innerHTML = "<div class=\"DVSL-expand-trigger\"><div></div></div><div class=\"DVSL-contract-trigger\"></div>";
                        element.insertBefore(trigger_1, element.firstChild);
                        Helpers.updateResize(trigger_1);
                        element["__resizeListener__"] = scrollListener;
                        element.addEventListener("scroll", scrollListener, true);
                    }
                };
                Helpers.updateResize = function (target) {
                    var trigger = target["__resizeTriggers__"];
                    if (trigger)
                        this.updateResizeTriggers(trigger);
                };
                Helpers.updateResizeTriggers = function (trigger) {
                    var expand = trigger.firstElementChild;
                    var contract = trigger.lastElementChild;
                    var expandChild = expand.firstElementChild;
                    contract.scrollLeft = contract.scrollWidth;
                    contract.scrollTop = contract.scrollHeight;
                    expandChild.style.width = (expand.offsetWidth + 1) + "px";
                    expandChild.style.height = (expand.offsetHeight + 1) + "px";
                    expand.scrollLeft = expand.scrollWidth;
                    expand.scrollTop = expand.scrollHeight;
                };
                Helpers.unlistenResize = function (target) {
                    var element = target;
                    var trigger = element["__resizeTriggers__"];
                    if (trigger) {
                        element.removeEventListener("scroll", element["__resizeListener__"], true);
                        if (trigger.parentNode)
                            trigger.parentNode.removeChild(trigger);
                        delete element["__resizeListener__"];
                        delete element["__resizeTriggers__"];
                    }
                    else {
                        delete target.onresize;
                    }
                };
                Helpers.decodeEntities = function (text) {
                    // decode HTML entities
                    if (text.indexOf("&") === -1) {
                        return text;
                    }
                    else {
                        if (!Helpers.decodeTextarea)
                            Helpers.decodeTextarea = document.createElement("textarea");
                        Helpers.decodeTextarea.innerHTML = text;
                        return Helpers.decodeTextarea.value;
                    }
                };
                Helpers.base64Encode = function (data) {
                    /* tslint:disable:no-bitwise-smart */
                    if (window.btoa)
                        return window.btoa(data);
                    // polyfill from https://github.com/davidchambers/Base64.js
                    var map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                    var output = "";
                    var block = 0;
                    for (var idx = 0; 
                    // if the next str index does not exist:
                    //   change the mapping table to "="
                    //   check if d has no fractional digits
                    data.charAt(idx | 0) || (map = "=", idx % 1); 
                    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
                    output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
                        var charCode = data.charCodeAt(idx += 3 / 4);
                        if (charCode > 0xFF) {
                            throw new Error("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
                        }
                        block = block << 8 | charCode;
                    }
                    return output;
                    /* tslint:enable:no-bitwise-smart */
                };
                /**
                 * Compares two version numbers.
                 * @param libraryVersion - the version number that is verified (format: 1.2.3).
                 * @param expectedVersion - the minimum accepted version
                 */
                Helpers.compareVersions = function (libraryVersion, expectedVersion) {
                    var libV = libraryVersion.split(".");
                    var ll = libV.length;
                    var el = expectedVersion.length;
                    for (var i = 0; i < Math.max(ll, el); i++) {
                        var l = i < ll ? parseInt(libV[i], 10) : 0;
                        var e = i < el ? expectedVersion[i] : 0;
                        if (l > e) {
                            return true;
                        }
                        else if (l < e) {
                            return false;
                        }
                    }
                    return true;
                };
                Helpers.aggregate = function (aggrMethod, hasNextFunc, getNextFunc) {
                    var count = 0;
                    var aggregator = this.aggregationCallbacks[aggrMethod];
                    var acc = aggregator.start;
                    while (hasNextFunc()) {
                        var a = getNextFunc();
                        aggregator.increment(acc, a);
                        count += 1;
                    }
                    if (count > 0) {
                        return aggregator.result(acc, count);
                    }
                    else {
                        return null;
                    }
                };
                /** Contains timestamps (milliseconds) for previously displayed console messages. Used to prevent duplicate messages. */
                Helpers._previousConsoleMessages = {};
                Helpers.SeparatorChar = String.fromCharCode(0xf8ff);
                Helpers.nextIdentifier = 0;
                Helpers.decodeTextarea = null;
                Helpers.aggregationCallbacks = {
                    sum: {
                        // initial value
                        start: 0,
                        // increment
                        increment: function (acc, next) { return acc + next; },
                        // result
                        result: function (acc, count) { return acc; }
                    },
                    min: {
                        start: Infinity,
                        increment: function (acc, next) { return Math.min(acc, next); },
                        result: function (acc, count) { return acc; }
                    },
                    max: {
                        start: -Infinity,
                        increment: function (acc, next) { return Math.max(acc, next); },
                        result: function (acc, count) { return acc; }
                    },
                    avg: {
                        start: 0,
                        increment: function (acc, next) { return acc + next; },
                        result: function (acc, count) { return acc / count; }
                    },
                    count: {
                        start: 0,
                        increment: function (acc, next) { return 0; },
                        result: function (acc, count) { return count; }
                    },
                    first: {
                        start: null,
                        increment: function (acc, next) {
                            if (acc !== null && acc !== void 0) {
                                return acc;
                            }
                            else {
                                return next;
                            }
                        },
                        result: function (acc, count) { return acc; }
                    },
                    last: {
                        start: null,
                        increment: function (acc, next) {
                            if (next !== null && next !== void 0) {
                                return next;
                            }
                            else {
                                return acc;
                            }
                        },
                        result: function (acc, count) { return acc; }
                    }
                };
                return Helpers;
            }());
            Base.Helpers = Helpers;
            // check for window - it is not present if the code is loaded from node.js
            if (typeof window !== "undefined") {
                var rafFunc_1 = window.requestAnimationFrame
                    || window.mozRequestAnimationFrame
                    || window.webkitRequestAnimationFrame
                    || window.msRequestAnimationFrame
                    || window.oRequestAnimationFrame;
                var cafFunc_1 = window.cancelAnimationFrame
                    || window.mozCancelAnimationFrame
                    || window.webkitCancelAnimationFrame
                    || window.msCancelRequestAnimationFrame
                    || window.oCancelAnimationFrame;
                if (!rafFunc_1) {
                    var lastTime_1 = 0;
                    rafFunc_1 = function (callback) {
                        var currTime = new Date().getTime();
                        var timeToCall = Math.max(0, 16 - (currTime - lastTime_1));
                        var id = window.setTimeout(function () { return callback(currTime + timeToCall); }, timeToCall);
                        lastTime_1 = currTime + timeToCall;
                        return id;
                    };
                    cafFunc_1 = window.clearTimeout;
                }
                if (!cafFunc_1) {
                    cafFunc_1 = function () { };
                }
                Helpers.requestAnimationFrame = function (callback) { return rafFunc_1.call(window, callback); };
                Helpers.cancelAnimationFrame = function (id) { return cafFunc_1.call(window, id); };
                var nowOffset_1 = new Date().getTime();
                if ("performance" in window === false) {
                    Helpers.performanceNow = function () { return new Date().getTime() - nowOffset_1; };
                }
                else if ("now" in window.performance === false) {
                    if (performance.timing && performance.timing.navigationStart) {
                        nowOffset_1 = performance.timing.navigationStart;
                    }
                    Helpers.performanceNow = function () { return new Date().getTime() - nowOffset_1; };
                }
                else {
                    Helpers.performanceNow = function () { return window.performance.now(); };
                }
                var offs_1 = nowOffset_1 - Helpers.performanceNow();
                Helpers.timeToPerfNow = function (time) { return time - offs_1; };
            }
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../Helpers.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            /**
             * Detects if the code is running on Safari.
             * http://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser
             */
            var isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor") > 0;
            /** Represents a single pointer. On multitouch, separate event for each pointer will be fired. */
            var MouseEvent = (function () {
                function MouseEvent(x, y, timeStamp, identifier) {
                    this.consumed = false; // Event consumed, prevent default.
                    this.defaultPrevented = false;
                    this.x = 0;
                    this.y = 0;
                    this.dx = 0;
                    this.dy = 0;
                    this.wheely = 0;
                    this.wheelx = 0;
                    this.identifier = "0";
                    this.pressed = false;
                    this.touch = false;
                    this.pageX = 0;
                    this.pageY = 0;
                    this.shiftKey = false;
                    this.altKey = false;
                    this.ctrlKey = false;
                    this.target = null;
                    this.isRightMB = false;
                    this._vx = null;
                    this._vy = null;
                    /**@ignore*/
                    this.velocityPointer = null;
                    /** internal - left the area */
                    this._leaving = false;
                    /** only on up event */
                    this.swipeUp = false;
                    /** only on up event */
                    this.swipeDown = false;
                    /** only on up event */
                    this.swipeLeft = false;
                    /** only on up event */
                    this.swipeRight = false;
                    this.swipeSpeed = null;
                    /** Capture the pointer and send all subsequent events to this component only.
                    @ignore */
                    this.capture = false;
                    /** Hover on element. There is a component that will handle a click if one is fired.
                    @ignore */
                    this.hovered = false;
                    this.cursor = null;
                    this.changedPointerCount = 1;
                    this.identifier = identifier;
                    this.timeStamp = timeStamp;
                    this.y = y;
                    this.x = x;
                }
                MouseEvent.prototype.preventDefault = function () {
                    this.defaultPrevented = true;
                };
                Object.defineProperty(MouseEvent.prototype, "vx", {
                    get: function () {
                        if (this._vx === null && this.velocityPointer !== null)
                            this.velocityPointer.calculatePosAndSpeed(this);
                        return this._vx || 0;
                    },
                    set: function (value) {
                        this._vx = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MouseEvent.prototype, "vy", {
                    get: function () {
                        if (this._vy === null && this.velocityPointer !== null)
                            this.velocityPointer.calculatePosAndSpeed(this);
                        return this._vy || 0;
                    },
                    set: function (value) {
                        this._vy = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                MouseEvent.prototype.distance = function (p) {
                    return Math.sqrt((p.x - this.x) * (p.x - this.x) + (p.y - this.y) * (p.y - this.y));
                };
                /** Verifies if the original event described by this instance is within a specified distance of the given position.
                @param current - The mouse event/pointer to which this instance is compered
                @param dist - The distance, in pixels, non-inclusive, below which the method will return positive
                @param maxAge - Time, in milliseconds. If specified, also verifies that the original event did not occur too long ago. */
                MouseEvent.prototype.isWithinDistance = function (current, dist, maxAge) {
                    if (!current) {
                        return false;
                    }
                    var dx = this.pageX - current.pageX;
                    var dy = this.pageY - current.pageY;
                    return (dx * dx + dy * dy < dist * dist) && (maxAge == null || (current.timeStamp + maxAge > this.timeStamp));
                };
                return MouseEvent;
            }());
            Base.MouseEvent = MouseEvent;
            var MousePointer = (function () {
                function MousePointer(event, settings) {
                    this.noClick = false;
                    this.scrolling = false;
                    /** the index of the first entry in the `pts` array */
                    this.ptsIndex = 0;
                    /** the number of valid entries in `pts` array. note that the items loop from the last entry to the first. */
                    this.ptsLength = 3;
                    /** the maximum number of points remembered. Must be a multiple by 3 (e.g. if 20 points must be remembered, this value must be 60)
                    this also impacts the interval which is used to measure the velocity. */
                    this.ptsMax = 72;
                    this.settings = settings;
                    this.identifier = event.identifier;
                    this.touch = false;
                    this.x = event.x;
                    this.y = event.y;
                    this.pageX = event.pageX;
                    this.pageY = event.pageY;
                    this.timeStamp = event.timeStamp;
                    if (typeof Int32Array !== "undefined") {
                        // Int32Array is initialized with zeroes automatically.
                        this.pts = new Int32Array(this.ptsMax);
                    }
                    else {
                        this.pts = new Array(this.ptsMax);
                    }
                    this.pts[0] = this.x | 0;
                    this.pts[1] = this.y | 0;
                    this.pts[2] = 0;
                }
                MousePointer.prototype.moveTo = function (e) {
                    // the index where the new X should be written.
                    var pI = this.ptsIndex + this.ptsLength;
                    var t = (e.timeStamp - this.timeStamp) | 0;
                    var max = this.ptsMax;
                    if (t === this.pts[pI - 1]) {
                        // do not add 2 points with the same time stamp - instead overwrite the last stored point
                        this.ptsLength -= 3;
                        pI -= 3;
                    }
                    if (e.x || e.y) {
                        e.dx = e.x - this.x;
                        e.dy = e.y - this.y;
                        this.x = e.x;
                        this.y = e.y;
                    }
                    else {
                        e.dx = 0;
                        e.dy = 0;
                        e.x = this.x;
                        e.y = this.y;
                    }
                    if (pI === this.ptsMax)
                        pI = 0;
                    this.pts[pI++] = this.x | 0;
                    this.pts[pI++] = this.y | 0;
                    this.pts[pI++] = t | 0;
                    if ((this.ptsLength += 3) > max) {
                        this.ptsLength -= 3;
                        // move past the oldest stored point.
                        if (max === (this.ptsIndex += 3))
                            this.ptsIndex = 0;
                    }
                };
                MousePointer.prototype.getPosAndSpeed = function (e) {
                    // velocity calculation is rather expensive which is not used in most cases so it is delayed until the code requests the values.
                    e.touch = this.touch;
                    e.velocityPointer = this;
                    e.vx = null;
                    e.vy = null;
                };
                /** Performs the actual calculation of the pointer velocity. */
                MousePointer.prototype.calculatePosAndSpeed = function (e) {
                    /* compute vx and vy */
                    // The speed is calculated by taking an event that had been fired ${timeDiff} ms prior to this event,
                    // and then just calculating the difference between these two events
                    var pts = this.pts;
                    var max = this.ptsMax;
                    var timeDiff = max * 10;
                    var minDiff = 50;
                    var usedEventIndex;
                    var usedEventIndexMod;
                    var t = ((e.timeStamp - this.timeStamp) | 0) - timeDiff;
                    for (usedEventIndex = this.ptsIndex; usedEventIndex < this.ptsIndex + this.ptsLength; usedEventIndex += 3) {
                        usedEventIndexMod = usedEventIndex % max;
                        // Find the first event that's after the
                        if (pts[usedEventIndexMod + 2] > t) {
                            break;
                        }
                    }
                    timeDiff = ((e.timeStamp - this.timeStamp) | 0) - pts[usedEventIndexMod + 2];
                    // we need at least 2 points (also if the time difference between the points is too small, the calculated speed would become inaccurate)
                    if (usedEventIndex === this.ptsIndex + this.ptsLength || timeDiff < minDiff) {
                        e.vx = 0;
                        e.vy = 0;
                        return;
                    }
                    e.vx = (this.x - pts[usedEventIndexMod + 0]) / timeDiff;
                    e.vy = (this.y - pts[usedEventIndexMod + 1]) / timeDiff;
                };
                return MousePointer;
            }());
            var MouseEvents = (function () {
                // private keyDownEvent: (ev: Event) => void;
                function MouseEvents(container, settings, additionalContainers) {
                    var _this = this;
                    if (additionalContainers === void 0) { additionalContainers = null; }
                    this.scaleX = 1;
                    this.scaleY = 1;
                    this.nextFakeMouseId = 1;
                    this.doubleClickTimeout = null;
                    this.longPressTimeout = null;
                    /** The mouse-down event that initiated the long press. Used to verify if the long press should be cancelled when the pointer is being dragged. */
                    this.longPressInitiator = null;
                    this.listeners = {};
                    this.downPointers = {};
                    this.inPointers = {};
                    this.containerList = [];
                    this.clickCounter = 1;
                    this.lastClickEvent = null;
                    /** Event handlers that are attached to window.top (used when the current window is in a frame). */
                    this.topWindowEvents = {};
                    this.ID_MOUSE = "mouse";
                    this.settings = settings;
                    this.container = container;
                    // to prevent duplicate events being processed
                    this.lastEvent = null;
                    // hack to work around browsers that fire both mouse and touch events on the same pointer
                    this.lastTouchEvent = null;
                    this.clickEvent = null;
                    this.containerEvents = {
                        "contextmenu": function (ev) { return _this.filterEvent(ev) && _this.handleCMenu(ev); },
                        "wheel": function (ev) { return _this.filterEvent(ev) && _this.handleMouseWheel(ev); },
                        "dragover": function (ev) { return _this.filterEvent(ev) && _this.handleMouseMove(ev); },
                    };
                    // detect pointer type
                    var hasPointerEvent = typeof PointerEvent !== "undefined";
                    var hasMSPointerEvent = !hasPointerEvent && typeof MSPointerEvent !== typeof void 0;
                    if (hasMSPointerEvent) {
                        this.container.style.msTouchAction = "none";
                        // the important difference here is that `MSPointerDown` uses uppercase letters while the standard `pointerdown` does not.
                        this.windowEvents = (_a = {},
                            _a["MSPointerDown"] = function (ev) { return _this.filterEvent(ev) && _this.handlePointerDown(ev); },
                            _a["MSPointerMove"] = function (ev) { return _this.filterEvent(ev) && _this.handlePointerMove(ev); },
                            _a["MSPointerUp"] = function (ev) { return _this.filterEvent(ev) && _this.handlePointerUp(ev); },
                            _a["MSPointerCancel"] = function (ev) { return _this.filterEvent(ev) && _this.handlePointerCancel(ev); },
                            _a
                        );
                    }
                    else if (hasPointerEvent) {
                        this.container.style.touchAction = "none";
                        this.windowEvents = (_b = {},
                            _b["pointerdown"] = function (ev) { return _this.filterEvent(ev) && _this.handlePointerDown(ev); },
                            _b["pointermove"] = function (ev) { return _this.filterEvent(ev) && _this.handlePointerMove(ev); },
                            _b["pointerup"] = function (ev) { return _this.filterEvent(ev) && _this.handlePointerUp(ev); },
                            _b["pointercancel"] = function (ev) { return _this.filterEvent(ev) && _this.handlePointerCancel(ev); },
                            _b
                        );
                    }
                    else {
                        // container events
                        this.windowEvents = {
                            "mousedown": function (ev) { return _this.filterEvent(ev) && _this.handleMouseDown(ev); },
                            "mouseup": function (ev) { return _this.filterEvent(ev) && _this.handleMouseUp(ev); },
                            "mousemove": function (ev) { return _this.filterEvent(ev) && _this.handleMouseMove(ev); },
                            "touchstart": function (ev) { return _this.filterEvent(ev) && _this.handleTouchStart(ev); },
                            "touchend": function (ev) { return _this.filterEvent(ev) && _this.handleTouchEnd(ev); },
                            "touchcancel": function (ev) { return _this.filterEvent(ev) && _this.handleTouchCancel(ev); },
                            "touchmove": function (ev) { return _this.filterEvent(ev) && _this.handleTouchMove(ev); },
                        };
                        this.topWindowEvents = {
                            "mouseup": function (ev) { return _this.filterEvent(ev) && _this.handleMouseUp(ev); },
                            "touchend": function (ev) { return _this.filterEvent(ev) && _this.handleTouchEnd(ev); },
                        };
                    }
                    // this.keyDownEvent = (event) => this.handleKeyDown(event);
                    // "mouseup" event for the top window is fired even if the mouse moves outside the window. Unfortunately this does not work within individual frames.
                    if (!MouseEvents._ignoreWindowTop && window.top) {
                        this.addTopWindowHandlers();
                    }
                    if (isSafari) {
                        this.addSelectPrevention();
                    }
                    for (var ev in this.windowEvents) {
                        Base.Helpers.listen(window, ev, this.windowEvents[ev]);
                    }
                    this.addContainer(container);
                    if (additionalContainers) {
                        for (var i = 0; i < additionalContainers.length; i++) {
                            this.addContainer(additionalContainers[i]);
                        }
                    }
                    var _a, _b;
                }
                MouseEvents.prototype.addSelectPrevention = function () {
                    var _this = this;
                    document.addEventListener("selectstart", function (e) {
                        if (Object.keys(_this.downPointers).length)
                            e.preventDefault();
                    });
                };
                MouseEvents.prototype.addTopWindowHandlers = function () {
                    try {
                        for (var ev in this.topWindowEvents) {
                            Base.Helpers.listen(window.top, ev, this.topWindowEvents[ev]);
                        }
                    }
                    catch (ex) {
                        MouseEvents._ignoreWindowTop = true;
                    }
                };
                MouseEvents.prototype.addContainer = function (container) {
                    this.containerList.push(container);
                    var ev;
                    for (ev in this.containerEvents) {
                        Base.Helpers.listen(container, ev, this.containerEvents[ev]);
                    }
                    for (ev in this.windowEvents) {
                        Base.Helpers.listen(container, ev, this.windowEvents[ev]);
                    }
                    // Helpers.listen(container, "keydown", this.keyDownEvent);
                };
                MouseEvents.prototype.remove = function () {
                    for (var ev in this.windowEvents) {
                        Base.Helpers.unlisten(window, ev, this.windowEvents[ev]);
                    }
                    if (!MouseEvents._ignoreWindowTop) {
                        for (var ev in this.topWindowEvents) {
                            Base.Helpers.unlisten(window.top, ev, this.topWindowEvents[ev]);
                        }
                    }
                    for (var containerIndex = 0; containerIndex < this.containerList.length; containerIndex++) {
                        var container = this.containerList[containerIndex];
                        for (var ev in this.containerEvents) {
                            Base.Helpers.unlisten(container, ev, this.containerEvents[ev]);
                        }
                    }
                };
                /** Simple variant - only one listener per event */
                MouseEvents.prototype.listen = function (eventName, func) {
                    this.listeners[eventName] = func;
                };
                // =================================
                // Internal methods
                // =================================
                MouseEvents.prototype.processConsumed = function (domEvent, consumed, preventDefault) {
                    if (consumed) {
                        Base.Helpers.stopPropagation(domEvent);
                        // this stops browser gestures
                        if (preventDefault)
                            domEvent.preventDefault();
                    }
                };
                /*
                private handleKeyDown(event: DOMMouseEvent) {
                    if (!event.keyCode) {
                        event.keyCode = event.which;
                    }
        
                    this.fireEvent(MouseEvents.EVENT_KEY, event);
                    this.processConsumed(event, event);
                }
                */
                MouseEvents.prototype.capturePointer = function (event) {
                    var elem = event.target;
                    if (elem.setPointerCapture) {
                        elem.setPointerCapture(event.pointerId);
                    }
                    else if (elem.msSetPointerCapture) {
                        elem.msSetPointerCapture(event.pointerId);
                    }
                    else {
                        this.captureMouse(event);
                    }
                };
                MouseEvents.prototype.releasePointer = function (event) {
                    this.releaseMouse(event);
                };
                MouseEvents.prototype.releaseMouse = function (event) {
                    if (document.releaseCapture)
                        document.releaseCapture();
                };
                MouseEvents.prototype.captureMouse = function (event) {
                    var elem = event.target;
                    if (elem.setCapture)
                        elem.setCapture(true);
                };
                MouseEvents.prototype.filterEvent = function (event) {
                    // note that test.js overrides this method for recording and playback.
                    if (event === this.lastEvent)
                        return false;
                    this.lastEvent = event;
                    return true;
                };
                MouseEvents.prototype.handlePointerDown = function (event) {
                    var e = this.buildEvent(event, event.pointerId.toString(), event.timeStamp, event.buttons > 0);
                    // we do not capture pointers that come from the window tag, only those that happen on the chart container
                    // (note that the events might originate anywhere, currentTarget references the element where the event 
                    // handler is attached).
                    // capturing window pointers causes the scrollbar to be non-clickable on IE and also clicks outside the chart
                    // container will never initiate drag operations which are the reason for the pointer capture requirement.
                    //
                    // note that handleMouseDown also has the same workaround.
                    if (event.currentTarget !== window)
                        this.capturePointer(event);
                    this.downHappened(e);
                    this.processConsumed(event, e.consumed);
                };
                MouseEvents.prototype.handlePointerMove = function (event) {
                    var e = this.buildEvent(event, event.pointerId.toString(), event.timeStamp, event.buttons > 0);
                    this.moveHappened(e);
                    this.processConsumed(event, e.consumed, true);
                };
                MouseEvents.prototype.handlePointerUp = function (event) {
                    if (event.buttons !== 0) {
                        return;
                    }
                    var e = this.buildEvent(event, event.pointerId.toString(), event.timeStamp, false);
                    this.releasePointer(event);
                    this.upHappened(e);
                    this.processConsumed(event, e.consumed);
                };
                MouseEvents.prototype.handlePointerCancel = function (event) {
                    var e = this.buildEvent(event, event.pointerId.toString(), event.timeStamp, false);
                    this.cancelHappened(e);
                };
                /** legacy mouse + touch API */
                MouseEvents.prototype.handleMouseDown = function (event) {
                    // check if a touch event was not fired recently
                    if (event.timeStamp < this.lastTouchEvent)
                        return;
                    var e = this.buildEvent(event, this.ID_MOUSE, event.timeStamp, true);
                    // See the big comment on handlePointerDown().
                    if (event.currentTarget !== window)
                        this.captureMouse(event);
                    this.downHappened(e);
                    this.processConsumed(event, e.consumed);
                };
                MouseEvents.prototype.handleCMenu = function (event) {
                    this.processConsumed(event, true, true);
                };
                MouseEvents.prototype.handleMouseWheel = function (event) {
                    if (!this.isTargetOkay(event.target)) {
                        return;
                    }
                    if (this.settings.mouseWheelRequiresFocus && document.activeElement !== this.container) {
                        return;
                    }
                    if (
                    // Firefox raises the wheel event from touch interactions in some cases that are in no way scroll gestures.
                    event.mozInputSource === 5
                        || (event.deltaX === 0 && event.deltaY === 0)) {
                        Base.Helpers.stopPropagation(event);
                        return;
                    }
                    if (event.deltaMode === event.DOM_DELTA_PAGE)
                        return;
                    var e = this.buildEvent(event, this.ID_MOUSE, event.timeStamp, true);
                    var coef = event.deltaMode === event.DOM_DELTA_LINE ? -40 : -1;
                    e.wheely = event.deltaY * coef;
                    e.wheelx = event.deltaX * coef;
                    this.wheelHappened(e);
                    this.processConsumed(event, e.consumed, true);
                };
                MouseEvents.prototype.handleMouseUp = function (event) {
                    // special hack for multitouch testing
                    if (event.shiftKey && event.ctrlKey) {
                        this.ID_MOUSE = "mouse" + this.nextFakeMouseId;
                        this.nextFakeMouseId += 1;
                        return;
                    }
                    var e = this.buildEvent(event, this.ID_MOUSE, event.timeStamp, false);
                    this.releaseMouse(event);
                    this.upHappened(e);
                    this.processConsumed(event, e.consumed);
                };
                MouseEvents.prototype.handleMouseMove = function (event) {
                    // check if a touch event was not fired recently
                    if (event.timeStamp < this.lastTouchEvent)
                        return;
                    var e = this.buildEvent(event, this.ID_MOUSE, event.timeStamp, false);
                    this.moveHappened(e);
                    this.processConsumed(event, e.consumed, true);
                };
                MouseEvents.prototype.handleTouchStart = function (event) {
                    this.lastTouchEvent = event.timeStamp + 2000;
                    this.removeLostTouches(event, event.touches, event.changedTouches);
                    var consumed = false;
                    var list = event.changedTouches || event.touches;
                    var e;
                    for (var tIndex = 0; tIndex < list.length; tIndex++) {
                        var t = list[tIndex];
                        e = this.buildTouchEvent(event, t, true, list.length);
                        this.downHappened(e);
                        consumed = consumed || e.consumed;
                    }
                    this.processConsumed(event, consumed);
                };
                MouseEvents.prototype.handleTouchEnd = function (event) {
                    this.lastTouchEvent = event.timeStamp + 2000;
                    var list = event.changedTouches || event.touches;
                    var consumed = false;
                    for (var tIndex = 0; tIndex < list.length; tIndex++) {
                        var t = list[tIndex];
                        var e = this.buildTouchEvent(event, t, false, list.length);
                        // simulate the event actually leaving the chart. this is important
                        // since some components treat pointerOut as pointerMove.
                        var e2 = this.buildTouchEvent(event, t, false, list.length);
                        e2.x = e2.y = e2.pageX = e2.pageY = -1e9;
                        this.upHappened(e);
                        this.pointerLeave(e2);
                        consumed = consumed || e.consumed || e2.consumed;
                        this.removeLostTouches(event, event.touches);
                    }
                    this.processConsumed(event, consumed);
                };
                MouseEvents.prototype.handleTouchCancel = function (event) {
                    this.lastTouchEvent = event.timeStamp + 2000;
                    var list = event.changedTouches || event.touches;
                    for (var tIndex = 0; tIndex < list.length; tIndex++) {
                        var t = list[tIndex];
                        var e = this.buildTouchEvent(event, t, false, list.length);
                        this.cancelHappened(e);
                    }
                    this.removeLostTouches(event, event.touches);
                };
                MouseEvents.prototype.handleTouchMove = function (event) {
                    this.lastTouchEvent = event.timeStamp + 2000;
                    var consumed = false;
                    this.removeLostTouches(event, event.touches);
                    var list = event.changedTouches || event.touches;
                    var e;
                    for (var tIndex = 0; tIndex < list.length; tIndex++) {
                        var t = list[tIndex];
                        e = this.buildTouchEvent(event, t, true, list.length);
                        this.moveHappened(e);
                        consumed = consumed || e.consumed;
                    }
                    this.processConsumed(event, consumed, true);
                };
                MouseEvents.prototype.removeLostTouches = function (event, touches, freshTouches) {
                    if (freshTouches === void 0) { freshTouches = null; }
                    var presentTouches = Object.create(null);
                    for (var tIndex = 0; tIndex < touches.length; tIndex++) {
                        var t = touches[tIndex];
                        presentTouches[t.identifier] = true;
                    }
                    for (var k in this.downPointers) {
                        var p = this.downPointers[k];
                        if (!this.downPointers.hasOwnProperty(k)) {
                            continue;
                        }
                        if (!presentTouches[k]) {
                            var e = this.rebuildEvent(event, p, false);
                            this.upHappened(e);
                        }
                    }
                    if (freshTouches !== null) {
                        for (var tIndex = 0; tIndex < freshTouches.length; tIndex++) {
                            var t = freshTouches[tIndex];
                            var p = this.downPointers[t.identifier];
                            if (p) {
                                // console.log("Removing fresh touch #{t.identifier}")
                                var e = this.rebuildEvent(event, p, false);
                                this.upHappened(e);
                            }
                        }
                    }
                };
                MouseEvents.prototype.rebuildEvent = function (event, obj, pressed) {
                    // note that test.js overrides this method for recording and playback.
                    var e = new MouseEvent(obj.x, obj.y, event.timeStamp, obj.identifier);
                    e.pageX = obj.pageX;
                    e.pageY = obj.pageY;
                    e.pressed = pressed;
                    e.shiftKey = event.shiftKey;
                    e.altKey = event.altKey;
                    e.ctrlKey = event.ctrlKey;
                    return e;
                };
                MouseEvents.prototype.buildTouchEvent = function (event, touch, pressed, ofHowManyPointers) {
                    // note that clientX is used here in addition to pageX since on Android/Chrome pageX===clientX even if horizontal scroll is created by pinch-zoom.
                    var pos = Base.Helpers.convertPointFromPageToNode(this.container, touch.pageX, touch.pageY, touch.clientX, touch.clientY);
                    var x = pos.x;
                    var y = pos.y;
                    var e = new MouseEvent(Math.round(x * this.scaleX), Math.round(y * this.scaleY), event.timeStamp, "" + touch.identifier);
                    e.target = (touch.target || event.target || event.srcElement);
                    e.pageX = touch.pageX;
                    e.pageY = touch.pageY;
                    e.shiftKey = event.shiftKey;
                    e.altKey = event.altKey;
                    e.ctrlKey = event.ctrlKey;
                    e.pressed = pressed;
                    e.changedPointerCount = ofHowManyPointers;
                    e.touch = true;
                    return e;
                };
                MouseEvents.prototype.buildEvent = function (event, id, timestamp, pressed, ofHowManyPointers) {
                    if (ofHowManyPointers === void 0) { ofHowManyPointers = 1; }
                    // note that test.js overrides this method for recording and playback.
                    var pageX = event.pageX;
                    var pageY = event.pageY;
                    var x;
                    var y;
                    var sourceIsContainer = (!event.currentTarget || event.currentTarget === this.container) && event.target === this.container;
                    if (sourceIsContainer && event.offsetX !== void 0) {
                        x = event.offsetX;
                        y = event.offsetY;
                    }
                    else if (sourceIsContainer && event.layerX !== void 0) {
                        // Firefox does not support offsetX
                        x = event.layerX;
                        y = event.layerY;
                    }
                    else {
                        // final fallback for container. this unfortunately does not support CSS transforms for all browsers (see Helpers.convertPointFromPageToNode)
                        // also this must be used for when the event source is not the container since then the offsetX property is relative to the current target.
                        // additionally this fallback will be used for touch events since they do not expose offsetX property.
                        // note that clientX is used here in addition to pageX since on Android/Chrome pageX===clientX even if horizontal scroll is created by pinch-zoom.
                        var pos = Base.Helpers.convertPointFromPageToNode(this.container, pageX, pageY, event.clientX, event.clientY);
                        x = pos.x;
                        y = pos.y;
                    }
                    var e = new MouseEvent(Math.round(x * this.scaleX), Math.round(y * this.scaleY), timestamp, "" + id);
                    e.target = (event.target || event.srcElement);
                    e.pageX = pageX;
                    e.pageY = pageY;
                    e.shiftKey = event.shiftKey;
                    e.altKey = event.altKey;
                    e.ctrlKey = event.ctrlKey;
                    e.pressed = pressed;
                    e.changedPointerCount = ofHowManyPointers;
                    e.touch = event.pointerType === "touch" || event.pointerType === 2;
                    if (event.which) {
                        e.isRightMB = event.which === 3;
                    }
                    else {
                        e.isRightMB = event.button === 2;
                    }
                    return e;
                };
                MouseEvents.prototype.downHappened = function (e) {
                    e.pressed = true;
                    this.fireEvent(MouseEvents.EVENT_GLOBAL_DOWN, e);
                    if (!this.isTargetOkay(e.target)) {
                        return;
                    }
                    if (this.downPointers[e.identifier]) {
                        return;
                    }
                    this.click_Hold();
                    var p = new MousePointer(e, this.settings);
                    this.downPointers[e.identifier] = p;
                    p.touch = e.touch;
                    this.inPointers[e.identifier] = true;
                    this.fireEvent(MouseEvents.EVENT_DOWN, e);
                    this.startLongPress(e);
                };
                MouseEvents.prototype.upHappened = function (e) {
                    var p = this.downPointers[e.identifier];
                    // clear container position cache
                    if (!p) {
                        return;
                    }
                    this.cancelLongPress();
                    p.moveTo(e);
                    p.getPosAndSpeed(e);
                    delete this.downPointers[e.identifier];
                    // detect swipe
                    var vx = e.vx;
                    var vy = e.vy;
                    var vxAbs = Math.abs(vx);
                    var vyAbs = Math.abs(vy);
                    if (vxAbs > vyAbs * 2) {
                        e.swipeSpeed = vxAbs;
                        if (vx > 0) {
                            e.swipeLeft = true;
                        }
                        else {
                            e.swipeRight = true;
                        }
                    }
                    else if (vyAbs > vxAbs * 2) {
                        e.swipeSpeed = vyAbs;
                        if (vy < 0) {
                            e.swipeUp = true;
                        }
                        else {
                            e.swipeDown = true;
                        }
                    }
                    this.fireEvent(MouseEvents.EVENT_UP, e);
                    // the click sensitivity is important on touch devices (Android is more sensitive than iOS) because the pointer will
                    // move around under the finger even for a very quick tap.
                    if (p.noClick || !e.isWithinDistance(p, this.settings.clickSensitivity, this.settings.doubleClickTimeout))
                        return;
                    this.click_Next(e);
                };
                MouseEvents.prototype.cancelHappened = function (e) {
                    // clear container position cache
                    if (!this.downPointers[e.identifier]) {
                        return;
                    }
                    this.cancelLongPress();
                    delete this.downPointers[e.identifier];
                    this.fireEvent(MouseEvents.EVENT_CANCEL, e);
                };
                MouseEvents.prototype.moveHappened = function (e) {
                    var p = this.downPointers[e.identifier];
                    e.pressed = (p !== void 0 && p !== null);
                    // drag
                    if (p !== void 0 && p !== null) {
                        this.cancelLongPress(e);
                        p.scrolling = true;
                        p.moveTo(e);
                        p.getPosAndSpeed(e);
                        this.fireEvent(MouseEvents.EVENT_DRAG, e);
                        this.click_Cancel(e);
                    }
                    else if (this.click_OnMove(e)) {
                    }
                    else if (this.isTargetOkay(e.target)) {
                        this.inPointers[e.identifier] = true;
                        this.fireEvent(MouseEvents.EVENT_MOVE, e);
                    }
                    else {
                        this.pointerLeave(e);
                    }
                };
                MouseEvents.prototype.wheelHappened = function (e) {
                    this.fireEvent(MouseEvents.EVENT_WHEEL, e);
                };
                MouseEvents.prototype.pointerLeave = function (e) {
                    if (!this.inPointers.hasOwnProperty(e.identifier)) {
                        return;
                    }
                    if (!this.click_Cancel(e)) {
                        this.fireEvent(MouseEvents.EVENT_LEAVE, e);
                    }
                    delete this.inPointers[e.identifier];
                };
                // ==================
                // Click related functions
                // =================
                MouseEvents.prototype.click_Next = function (e) {
                    var _this = this;
                    // Right mouse button clicks are special. They fire immediately and there are no double/triple clicks for those.
                    if (e.isRightMB) {
                        this.fireEvent(MouseEvents.EVENT_RCLICK, e);
                        return;
                    }
                    if (this.settings.scrollIntoView) {
                        this.container.scrollIntoView();
                    }
                    var fireEvent;
                    switch (this.clickCounter) {
                        case 1:
                            fireEvent = MouseEvents.EVENT_CLICK;
                            break;
                        case 2:
                            fireEvent = MouseEvents.EVENT_DBLCLICK;
                            break;
                        default:
                        case 3:
                            fireEvent = MouseEvents.EVENT_TPLCLICK;
                            break;
                    }
                    var nextClickValid = this.clickEvent !== null
                        && this.clickEvent.timeStamp + this.settings.doubleClickTimeout >= e.timeStamp
                        && this.clickEvent.distance(e) < this.settings.doubleClickSensitivity;
                    if (nextClickValid) {
                        clearTimeout(this.doubleClickTimeout);
                    }
                    if (nextClickValid || this.clickCounter === 1) {
                        if (this.settings.noClickOnDoubleClick) {
                            this.doubleClickTimeout = setTimeout((function () { return _this.fireClick(fireEvent); }), this.settings.doubleClickTimeout);
                        }
                        if (!this.settings.noClickOnDoubleClick) {
                            this.fireEvent(fireEvent, e);
                        }
                        this.lastClickEvent = fireEvent;
                    }
                    this.fireEvent(MouseEvents.EVENT_INSTACLICK, e);
                    this.clickEvent = e;
                    this.clickCounter++;
                    if (!this.settings.noClickOnDoubleClick) {
                        setTimeout((function () {
                            _this.clickEvent = _this.lastClickEvent = null;
                            _this.clickCounter = 1;
                        }), this.settings.doubleClickTimeout);
                    }
                };
                MouseEvents.prototype.click_Cancel = function (e) {
                    if (this.clickEvent && this.clickEvent.identifier === e.identifier) {
                        this.clickEvent._leaving = true;
                        return true;
                    }
                    return false;
                };
                MouseEvents.prototype.click_Hold = function () {
                    if (this.doubleClickTimeout !== void 0 && this.doubleClickTimeout !== null) {
                        clearTimeout(this.doubleClickTimeout);
                        this.doubleClickTimeout = null;
                    }
                };
                MouseEvents.prototype.click_OnMove = function (e) {
                    // returns true to prevent move event from being fired
                    if (!(this.clickEvent && this.settings.noClickOnDoubleClick)) {
                        return false;
                    }
                    if (this.clickEvent.distance(e) < this.settings.doubleClickSensitivity) {
                        return true;
                    }
                    else {
                        // too far away, fire the click and back to business as usual
                        this.fireEvent(this.lastClickEvent, this.clickEvent);
                        this.clickEvent = this.lastClickEvent = null;
                        this.clickCounter = 1;
                        return false;
                    }
                };
                MouseEvents.prototype.fireClick = function (eName) {
                    if (!this.clickEvent) {
                        return;
                    }
                    this.fireEvent(eName, this.clickEvent);
                    if (this.clickEvent._leaving) {
                        this.fireEvent(MouseEvents.EVENT_LEAVE, this.clickEvent);
                    }
                    this.clickEvent = null;
                    this.clickCounter = 1;
                };
                MouseEvents.prototype.startLongPress = function (e) {
                    var _this = this;
                    if (e.isRightMB)
                        return;
                    var fireLongPress = function () {
                        _this.longPressTimeout = null;
                        e.consumed = false;
                        _this.downPointers[e.identifier].noClick = true;
                        _this.fireEvent(MouseEvents.EVENT_LONGPRESS, e);
                        if (!e.consumed) {
                            if (e.touch)
                                _this.cancelHappened(e);
                            _this.fireEvent(MouseEvents.EVENT_RCLICK, e);
                        }
                    };
                    this.cancelLongPress();
                    this.longPressTimeout = setTimeout(fireLongPress, this.settings.longPressTimeout);
                    this.longPressInitiator = e;
                };
                MouseEvents.prototype.cancelLongPress = function (dragEvent) {
                    if (this.longPressTimeout !== null) {
                        if (dragEvent) {
                            // verify the drag distance and cancel only if it exceeds the limit
                            if (dragEvent.isWithinDistance(this.longPressInitiator, this.settings.longPressSensitivity))
                                return;
                        }
                        clearTimeout(this.longPressTimeout);
                        this.longPressTimeout = null;
                    }
                };
                // =================
                // Utilities
                // =================
                MouseEvents.prototype.fireEvent = function (name, event) {
                    if (this.listeners[name]) {
                        this.listeners[name].call(this, event);
                    }
                };
                MouseEvents.prototype.isTargetOkay = function (target) {
                    return this.containerList.indexOf(target) !== -1
                        || Base.Helpers.isParentOf(this.container, target);
                };
                /** Events on window.top will not be possible in cross-origin scenarios. To avoid throw/catch each time, store the fact if an error was thrown. */
                MouseEvents._ignoreWindowTop = false;
                /** mouse move without buttons pressed */
                MouseEvents.EVENT_MOVE = "move";
                /** mouse pressed, touch down */
                MouseEvents.EVENT_DOWN = "down";
                /** mouse pressed, touch down anywhere in pc */
                MouseEvents.EVENT_GLOBAL_DOWN = "gdown";
                /** pointer dragged */
                MouseEvents.EVENT_DRAG = "drag";
                /** touch cancel */
                MouseEvents.EVENT_CANCEL = "cancel";
                /** mouse released, touch up */
                MouseEvents.EVENT_UP = "up";
                MouseEvents.EVENT_LEAVE = "leave";
                MouseEvents.EVENT_CLICK = "click";
                MouseEvents.EVENT_RCLICK = "rclick";
                MouseEvents.EVENT_DBLCLICK = "dblclick";
                MouseEvents.EVENT_INSTACLICK = "instaclick";
                MouseEvents.EVENT_LONGPRESS = "longpress";
                /** triple click */
                MouseEvents.EVENT_TPLCLICK = "tplclick";
                MouseEvents.EVENT_WHEEL = "mwheel";
                MouseEvents.EVENT_KEY = "key";
                return MouseEvents;
            }());
            Base.MouseEvents = MouseEvents;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="MouseEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var UpdateEvent = (function () {
                function UpdateEvent() {
                    this.timeStamp = 0;
                    this.dtime = 0;
                    this.animating = false;
                    this.isExport = false;
                    this.context = null;
                    /**canvas scale X, how many physical pixels are in 1 canvas pixel*/
                    this.scaleX = 1;
                    /**canvas scale Y, how many physical pixels are in 1 canvas pixel*/
                    this.scaleY = 1;
                    this.labelRenderer = null;
                    this.changes = {};
                }
                return UpdateEvent;
            }());
            Base.UpdateEvent = UpdateEvent;
            var KeyEvent = (function () {
                function KeyEvent() {
                    this.keyCode = null;
                    this.capture = false;
                    this.consumed = false;
                    this.noDefault = false;
                    this.cursor = null;
                    this.target = null;
                }
                return KeyEvent;
            }());
            Base.KeyEvent = KeyEvent;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var SettingsChartPanel = (function () {
                function SettingsChartPanel(side, align, margin, packingOrder) {
                    /** Panel side
                     @type enum
                     @value top
                     @value bottom
                     @value left
                     @value right */
                    this.side = "top";
                    /** Panel alignment
                     @type enum
                     @value left
                     @value right
                     @value top
                     @value bottom
                     @value center
                     @value fill */
                    this.align = "fill";
                    /** Whether allow packing over other panels */
                    this.floating = false;
                    /** Margin around the panel
                     @type float
                     @units pixels */
                    this.margin = 0;
                    /** The location of the panel
            @type enum
            @value outside - The panel is located outside of the chart area, which is achieved by reducing the size of the chart area.
            @value inside - The panel is located inside the chart area, possibly overlapping the chart
            @value external - The panel is located outside of the chart area. This option is only available for panels that use HTML elements instead of being drawn on the canvas.*/
                    this.location = "outside";
                    /**@ignore*/
                    this.packingOrder = void 0;
                    if (side !== void 0)
                        this.side = side;
                    if (align !== void 0)
                        this.align = align;
                    if (margin !== void 0)
                        this.margin = margin;
                    if (packingOrder !== void 0)
                        this.packingOrder = packingOrder;
                }
                return SettingsChartPanel;
            }());
            Base.SettingsChartPanel = SettingsChartPanel;
            var ChartPanel = (function () {
                function ChartPanel() {
                    /** lower value means will be packed first. */
                    this.packingOrder = 0;
                    this.location = "outside";
                    this.side = "top";
                    this.align = "fill";
                    /** Specifies if `outside` panels align to the edge of the chart as opposed to the edge of the main chart area. */
                    this.outsideEdge = false;
                    /** if floating, can be packed over other panels */
                    this.floating = false;
                    this.desiredWidth = 0;
                    this.desiredHeight = 0;
                    /** margin around the panel */
                    this.margin = 0;
                    /** computed position */
                    this.left = 0;
                    this.top = 0;
                    this.right = 0;
                    this.bottom = 0;
                    this.visible = false;
                    this.enableClipping = false;
                    this._tempData = null;
                }
                ChartPanel.prototype.pushClip = function (event) {
                    if (this.enableClipping)
                        Base.Graphics.pushClip(event, this.left, this.top, this.right - this.left, this.bottom - this.top);
                };
                ChartPanel.prototype.popClip = function (event) {
                    if (this.enableClipping)
                        Base.Graphics.popClip(event);
                };
                /** override this for custom size */
                ChartPanel.prototype.computeSize = function (availableWidth, availableHeight, context, labelRenderer) {
                    return {
                        width: this.desiredWidth,
                        height: this.desiredHeight
                    };
                };
                /** override this to do something else */
                ChartPanel.prototype.placePanel = function (left, top, right, bottom) {
                    this.bottom = bottom;
                    this.right = right;
                    this.top = top;
                    this.left = left;
                };
                return ChartPanel;
            }());
            Base.ChartPanel = ChartPanel;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var Profiler = (function () {
                function Profiler(shell) {
                    this.framesCount = 0;
                    this.shell = shell;
                    this.measureFpsIters = 0;
                    this.measureFpsT0 = 0;
                    this.measureFpsIter = 0;
                    this.measureFpsCallback = null;
                }
                Profiler.prototype.hasPendingRequests = function () {
                    return this.shell.chart.hasPendingRequests();
                };
                Profiler.prototype.measureFps = function (measureFpsIters, measureFpsCallback) {
                    var _this = this;
                    this.measureFpsCallback = measureFpsCallback;
                    this.measureFpsIters = measureFpsIters;
                    var currentSetting = this.shell.settings.advanced.useAnimationFrame;
                    if (currentSetting) {
                        // in order to properly test the FPS, setTimeout should be used instead of requestAnimationFrame
                        this.shell.chart.updateSettings({
                            advanced: { useAnimationFrame: false }
                        });
                        var origMeasureFpsCallback_1 = this.measureFpsCallback;
                        this.measureFpsCallback = function (a, b, c) {
                            _this.shell.chart.updateSettings({
                                advanced: { useAnimationFrame: true }
                            });
                            if (origMeasureFpsCallback_1) {
                                origMeasureFpsCallback_1.call(window, a, b, c);
                            }
                        };
                    }
                    this.measureFpsIter = 0;
                    this.measureFpsT0 = new Date().getTime();
                    this.shell.events.notifySceneChanges({ requestPaint: true });
                    return true;
                };
                /**@ignore*/
                Profiler.prototype.paintDone = function () {
                    this.framesCount += 1;
                    if (!this.measureFpsIters) {
                        return;
                    }
                    this.measureFpsIter += 1;
                    var time = new Date().getTime() - this.measureFpsT0;
                    // reach iters or max 10 seconds
                    if ((this.measureFpsIter >= this.measureFpsIters && time > 4000)
                        || (time > 10000 && this.measureFpsIter >= 5)) {
                        var fps = this.measureFpsIter * 1000 / Math.max(0.0001, time);
                        this.measureFpsCallback(fps, this.measureFpsIter, time);
                        this.measureFpsCallback = null;
                        this.measureFpsIters = 0;
                    }
                    else {
                        this.shell.events.notifySceneChanges({ requestPaint: true });
                    }
                };
                return Profiler;
            }());
            Base.Profiler = Profiler;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="SceneChanges.ts" />
/// <reference path="ChartElement.ts" />
/// <reference path="ChartPanel.ts" />
/// <reference path="Profiler.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var PointerState = (function () {
                function PointerState() {
                    this.subchart = null;
                    this.element = null;
                }
                return PointerState;
            }());
            var ChartEvents = (function () {
                function ChartEvents(chart, shell) {
                    this.sceneChanges = {};
                    this.forceFloating = false;
                    this._paintSuspended = 0;
                    this.pointerState = {}; // map for pointer iD to ChartElement
                    this.animationOrder = [];
                    this.updateOrder = [];
                    this.paintOrder = [];
                    this.subcharts = [];
                    /** Holds the number of panels during the last layout iteration. Used to improve performance during
                    layout panel collection.
                    
                    The array contains [inside, outside, external] counts.*/
                    this._lastPanelCount = [0, 0, 0];
                    this.chartBounds = new Base.Rect(0, 0, 1, 1);
                    this.chartOuterBounds = new Base.Rect(0, 0, 1, 1);
                    this.chartBoundsIsOuter = true;
                    this.chart = chart;
                    this.shell = shell;
                    this.scene = chart.scene;
                }
                ChartEvents.panelSortCallback = function (a, b) {
                    return a.packingOrder - b.packingOrder;
                };
                ChartEvents.prototype.addElement = function (element) {
                    if (!element)
                        throw new Error("`element` must be defined.");
                    this.paintOrder.push(element);
                    this.updateOrder.push(element);
                    this.animationOrder.push(element);
                    this.refreshElementOrder();
                    return element;
                };
                /**
                 * Notifies that some elements had one of their order properties changed so this instance has to update the cached ordering.
                 */
                ChartEvents.prototype.refreshElementOrder = function () {
                    this.animationOrder.sort(function (a, b) { return a.animationOrder - b.animationOrder; });
                    this.paintOrder.sort(function (a, b) { return a.paintOrder - b.paintOrder; });
                    this.updateOrder.sort(function (a, b) { return a.updateOrder - b.updateOrder; });
                };
                ChartEvents.prototype.removeElement = function (element) {
                    Base.Helpers.removeFromArray(this.paintOrder, element);
                    Base.Helpers.removeFromArray(this.animationOrder, element);
                    Base.Helpers.removeFromArray(this.updateOrder, element);
                };
                ChartEvents.prototype.addSubchart = function (chart) {
                    this.subcharts.push(chart);
                };
                ChartEvents.prototype.removeSubchart = function (chart) {
                    Base.Helpers.removeFromArray(this.subcharts, chart);
                    // Remove references in pointerState
                    for (var pi in this.pointerState) {
                        var ps = this.pointerState[pi];
                        if (ps.subchart === chart) {
                            ps.subchart = null;
                        }
                    }
                };
                ChartEvents.prototype.suspendPaint = function () {
                    this._paintSuspended++;
                };
                ChartEvents.prototype.resumePaint = function () {
                    this._paintSuspended--;
                    if (this._paintSuspended <= 0) {
                        this._paintSuspended = 0;
                        this.requestPaint();
                    }
                };
                /** Remembers the changes and requests a repaint which does the brunt of work.
                    The repaint is fully asynchronous (setTimeout/requestAnimationFrame) and will only happen after the current method has finished.  */
                ChartEvents.prototype.notifySceneChanges = function (changes) {
                    if (!Base.Helpers.hasProperties(changes)) {
                        return;
                    }
                    var settingsChanges = changes.settingsChanges;
                    if (settingsChanges !== void 0 && settingsChanges instanceof Base.Settings) {
                        // special handling for settings to make sure that settings classes are not moved into settingsChanges, instead just the values are copied.
                        // case for keys starting with '_' is there because computed objects can contain circular references that would cause stack overflow.
                        this.sceneChanges.settingsChanges = Base.Helpers.extendCopy(this.sceneChanges.settingsChanges || {}, settingsChanges, function (k, v) { return k[0] === "_" ? true : v; });
                        delete changes.settingsChanges;
                        Base.Helpers.extendDeep(this.sceneChanges, changes);
                        changes.settingsChanges = settingsChanges;
                    }
                    else {
                        Base.Helpers.extendDeep(this.sceneChanges, changes);
                    }
                    this.requestPaint();
                };
                /** Schedules a new animation frame. Note that this method checks if the animation has not been suspended. */
                ChartEvents.prototype.requestPaint = function () {
                    if (this._paintSuspended <= 0)
                        this.shell.requestPaint();
                };
                ChartEvents.prototype.paintNow = function (force) {
                    if (force === void 0) { force = false; }
                    this.shell.paintNow(force = false);
                };
                ChartEvents.prototype.clearSceneChanges = function (changes) {
                    for (var k in changes) {
                        delete this.sceneChanges[k];
                    }
                };
                ChartEvents.prototype.onMouseEvent = function (event, config) {
                    var name = config.name;
                    event.changes = {};
                    event.capture = false;
                    var capturedByElement = null;
                    var capturedBySubchart = null;
                    var firstCursor = void 0;
                    var oldElement;
                    var element;
                    var id = event.identifier;
                    var state = this.pointerState[id];
                    if (!state) {
                        state = new PointerState();
                        state.identifier = id;
                        this.pointerState[id] = state;
                    }
                    // preview first
                    for (var elementIndex = 0; elementIndex < this.updateOrder.length; elementIndex++) {
                        element = this.updateOrder[elementIndex];
                        element.previewMouseEvent(name, event);
                    }
                    // real firing - captured first
                    if (state.subchart) {
                        var subchartEvents = state.subchart.events;
                        subchartEvents.onMouseEvent(event, config);
                        if (event.consumed || event.hovered || event.capture) {
                            capturedBySubchart = state.subchart;
                            event.capture = true;
                            firstCursor = event.cursor;
                        }
                        else {
                            subchartEvents.onMouseEvent(event, { ev: Base.MouseEvents.EVENT_LEAVE, name: "PointerOut" });
                        }
                    }
                    oldElement = element = state.element;
                    if (element) {
                        element.onMouseEvent(name, event);
                        if ((event.consumed || event.capture || (config.captures && config.needsCapture)) && !config.releasesCapture) {
                            capturedByElement = element;
                            event.capture = true;
                            firstCursor = event.cursor;
                        }
                    }
                    // real firing - try find a new handler
                    // Subcharts
                    if (!event.capture && !config.needsCapture) {
                        // Iterate backwards to match paint stacking order.
                        for (var i = this.subcharts.length - 1; i >= 0; i -= 1) {
                            var subchart = this.subcharts[i];
                            var subchartEvents = subchart.events;
                            if (subchartEvents.chartOuterBounds.containsPoint(event.x, event.y)) {
                                subchartEvents.onMouseEvent(event, config);
                                if (event.consumed || event.hovered || event.capture) {
                                    capturedBySubchart = subchart;
                                    event.capture = true;
                                    break;
                                }
                                else {
                                    subchartEvents.onMouseEvent(event, { ev: Base.MouseEvents.EVENT_LEAVE, name: "PointerOut" });
                                }
                            }
                        }
                    }
                    // Elements
                    if (!event.capture && !config.needsCapture) {
                        for (var elementIndex = 0; elementIndex < this.updateOrder.length; elementIndex++) {
                            element = this.updateOrder[elementIndex];
                            if (element !== oldElement) {
                                element.onMouseEvent(name, event);
                                if (event.consumed || event.capture) {
                                    firstCursor = event.cursor;
                                    capturedByElement = element;
                                    event.capture = true;
                                    break;
                                }
                            }
                        }
                    }
                    if (firstCursor !== void 0)
                        event.cursor = firstCursor;
                    // change capture
                    if (config.releasesCapture || config.captures) {
                        state.element = config.captures ? capturedByElement : null;
                        state.subchart = config.captures ? capturedBySubchart : null;
                    }
                    this.notifySceneChanges(event.changes);
                };
                /*
                public onKeyEvent(event: KeyEvent) {
                    event.changes = {};
                    event.consumed = false;
                    event.cursor = null;
        
                    // real firing
                    let funcName = "on" + event.name;
        
                    for (let elementIndex = 0; elementIndex < this.updateOrder.length; elementIndex++) {
                        let element = this.updateOrder[elementIndex];
                        if (element[funcName]) {
                            element[funcName].call(element, event);
                            if (event.consumed) { break; }
                        }
                    }
        
                    this.notifySceneChanges(event.changes);
                }
                */
                ChartEvents.prototype.setNewSize = function (bounds, isOuterBounds, force) {
                    if (!force && this.chartBounds.equals(bounds) && isOuterBounds === this.chartBoundsIsOuter)
                        return;
                    this.chartBounds = bounds.clone();
                    this.chartBoundsIsOuter = isOuterBounds;
                    this.notifySceneChanges({ bounds: true });
                };
                /** Recalculate size for chart area and panels.
                 Save new size in scene.
                 @returns outer bounds
                  */
                ChartEvents.prototype.updateLayout = function (event) {
                    var scene = this.scene;
                    // collect all panels
                    var insidePanels = new Array(this._lastPanelCount[0]);
                    var outsidePanels = new Array(this._lastPanelCount[1]);
                    var externalPanels = new Array(this._lastPanelCount[2]);
                    var insidePanelCount = 0;
                    var outsidePanelCount = 0;
                    var externalPanelCount = 0;
                    for (var eIndex = 0; eIndex < this.paintOrder.length; eIndex++) {
                        var e = this.paintOrder[eIndex];
                        var panels = e.getPanels(event.isExport);
                        for (var i = 0; i < panels.length; i++) {
                            var p = panels[i];
                            var loc = p.location;
                            if (loc === "external") {
                                externalPanels[externalPanelCount++] = p;
                            }
                            else if (loc === "outside") {
                                outsidePanels[outsidePanelCount++] = p;
                            }
                            else if (loc === "inside") {
                                insidePanels[insidePanelCount++] = p;
                            }
                        }
                    }
                    this._lastPanelCount = [insidePanelCount, outsidePanelCount, externalPanelCount];
                    insidePanels.length = insidePanelCount;
                    outsidePanels.length = outsidePanelCount;
                    externalPanels.length = externalPanelCount;
                    Base.Helpers.sort(insidePanels, ChartEvents.panelSortCallback);
                    Base.Helpers.sort(outsidePanels, ChartEvents.panelSortCallback);
                    Base.Helpers.sort(externalPanels, ChartEvents.panelSortCallback);
                    var extBounds; // chart and "external" stuff - for export
                    var outerBounds; // normal chart occupied area
                    var innerBounds; // chart paint area
                    if (this.chartBoundsIsOuter) {
                        // outer bounds specified
                        // first place external panels
                        extBounds = this.chartBounds.clone();
                        for (var pIndex = 0; pIndex < externalPanelCount; pIndex++) {
                            this._placePanel(externalPanels[pIndex], extBounds, true, event);
                        }
                        // then place outside panels and compute inner bounds
                        outerBounds = this.chartBounds.clone();
                        innerBounds = this.chartBounds.clone();
                        for (var pIndex = 0; pIndex < outsidePanelCount; pIndex++) {
                            this._placePanel(outsidePanels[pIndex], innerBounds, false, event);
                        }
                    }
                    else {
                        innerBounds = this.chartBounds.clone();
                        // first place outside panels and conpute outerBounds, set as external to place outside of given bounds
                        outerBounds = this.chartBounds.clone();
                        for (var pIndex = 0; pIndex < outsidePanelCount; pIndex++) {
                            this._placePanel(outsidePanels[pIndex], outerBounds, true, event);
                        }
                        // then place external panels
                        extBounds = outerBounds.clone();
                        for (var pIndex = 0; pIndex < externalPanelCount; pIndex++) {
                            this._placePanel(externalPanels[pIndex], extBounds, true, event);
                        }
                    }
                    // save chart dimensions that are already known
                    this.chartOuterBounds = outerBounds;
                    scene.chartLeft = outerBounds.x0;
                    scene.chartTop = outerBounds.y0;
                    scene.chartHeight = outerBounds.h();
                    scene.chartWidth = outerBounds.w();
                    // finalize all external and outside panels
                    for (var pIndex = 0; pIndex < externalPanelCount; pIndex++) {
                        this._placePanelFinal(externalPanels[pIndex], innerBounds);
                    }
                    for (var pIndex = 0; pIndex < outsidePanelCount; pIndex++) {
                        var p = outsidePanels[pIndex];
                        this._placePanelFinal(p, p.outsideEdge ? outerBounds : innerBounds);
                    }
                    // if scene coordinates were changed, invoke the next frame because some component might require these values in `onSceneChanges`
                    if (scene.x0 !== innerBounds.x0 || scene.y0 !== innerBounds.y0 || scene.width !== innerBounds.w() || scene.height !== innerBounds.h())
                        this.chart.events.notifySceneChanges({ bounds: true });
                    // save chart dimensions that are impacted by outside panels
                    scene.x0 = innerBounds.x0;
                    scene.y0 = innerBounds.y0;
                    scene.width = innerBounds.w();
                    scene.height = innerBounds.h();
                    scene.leftMargin = innerBounds.x0 - outerBounds.x0;
                    scene.rightMargin = outerBounds.x1 - innerBounds.x1;
                    scene.topMargin = innerBounds.y0 - outerBounds.y0;
                    scene.bottomMargin = outerBounds.y1 - innerBounds.y1;
                    // finally place inside panels
                    for (var pIndex = 0; pIndex < insidePanelCount; pIndex++) {
                        var p = insidePanels[pIndex];
                        this._placePanel(p, innerBounds, false, event);
                        this._placePanelFinal(p, innerBounds);
                    }
                    return extBounds;
                };
                /** Place panel within bounds, update bounds for next placement.
                 External: true - place outside of existing bounds, extend bounds
                 External: false - place inside existing bounds, shrink bounds */
                ChartEvents.prototype._placePanel = function (panel, bounds, external, event) {
                    var left = bounds.x0;
                    var top = bounds.y0;
                    var right = bounds.x1;
                    var bottom = bounds.y1;
                    var margin = panel.margin || 0;
                    var computeSizeResult = panel.computeSize(bounds.x1 - bounds.x0, bounds.y1 - bounds.y0, event.context, event.labelRenderer);
                    var desiredWidth = computeSizeResult.width || 0;
                    var desiredHeight = computeSizeResult.height || 0;
                    desiredWidth += margin * 2;
                    desiredHeight += margin * 2;
                    // process side and floating
                    if (external) {
                        if (panel.side === "top") {
                            bottom = top;
                            top = bottom - desiredHeight;
                            if (!panel.floating && !this.forceFloating) {
                                bounds.y0 = top;
                            }
                        }
                        else if (panel.side === "bottom") {
                            top = bottom;
                            bottom = top + desiredHeight;
                            if (!panel.floating && !this.forceFloating) {
                                bounds.y1 = bottom;
                            }
                        }
                        else if (panel.side === "left") {
                            right = left;
                            left = right - desiredWidth;
                            if (!panel.floating && !this.forceFloating) {
                                bounds.x0 = left;
                            }
                        }
                        else if (panel.side === "right") {
                            left = right;
                            right = left + desiredWidth;
                            if (!panel.floating && !this.forceFloating) {
                                bounds.x1 = right;
                            }
                        }
                    }
                    else {
                        if (panel.side === "top") {
                            bottom = Math.min(bottom, top + desiredHeight);
                            if (!panel.floating && !this.forceFloating) {
                                bounds.y0 = bottom;
                            }
                        }
                        else if (panel.side === "bottom") {
                            top = Math.max(top, bottom - desiredHeight);
                            if (!panel.floating && !this.forceFloating) {
                                bounds.y1 = top;
                            }
                        }
                        else if (panel.side === "left") {
                            right = Math.min(right, left + desiredWidth);
                            if (!panel.floating && !this.forceFloating) {
                                bounds.x0 = right;
                            }
                        }
                        else if (panel.side === "right") {
                            left = Math.max(left, right - desiredWidth);
                            if (!panel.floating && !this.forceFloating) {
                                bounds.x1 = left;
                            }
                        }
                    }
                    panel._tempData = {
                        left: left,
                        right: right,
                        top: top,
                        bottom: bottom,
                        desiredWidth: desiredWidth,
                        desiredHeight: desiredHeight
                    };
                    return;
                    // call placePanelFinal after bounds is finalized...
                };
                ChartEvents.prototype._placePanelFinal = function (panel, chartBounds) {
                    var left = panel._tempData.left;
                    var right = panel._tempData.right;
                    var top = panel._tempData.top;
                    var bottom = panel._tempData.bottom;
                    var desiredWidth = panel._tempData.desiredWidth;
                    var desiredHeight = panel._tempData.desiredHeight;
                    // clip to chart area
                    if (panel.location === "outside") {
                        if (panel.side === "top" || panel.side === "bottom") {
                            left = Math.max(left, chartBounds.x0);
                            right = Math.min(right, chartBounds.x1);
                        }
                        else {
                            top = Math.max(top, chartBounds.y0);
                            bottom = Math.min(bottom, chartBounds.y1);
                        }
                    }
                    // process align
                    if (panel.align === "left") {
                        right = Math.min(right, left + desiredWidth);
                    }
                    else if (panel.align === "right") {
                        left = Math.max(left, right - desiredWidth);
                    }
                    else if (panel.align === "top") {
                        bottom = Math.min(bottom, top + desiredHeight);
                    }
                    else if (panel.align === "bottom") {
                        top = Math.max(top, bottom - desiredHeight);
                    }
                    else if (panel.align === "center") {
                        var xsub = Math.max(0, right - left - desiredWidth) / 2;
                        var ysub = Math.max(0, bottom - top - desiredHeight) / 2;
                        left += xsub;
                        right -= xsub;
                        top += ysub;
                        bottom -= ysub;
                    }
                    else {
                    }
                    var margin = panel.margin;
                    panel.placePanel(left + margin, top + margin, right - margin, bottom - margin);
                };
                ChartEvents.prototype.animateFrame = function (event) {
                    this.shell.prepareContext(event);
                    event.changes = this.sceneChanges;
                    // clear changes for next frame
                    this.sceneChanges = {};
                    // notify scene changes
                    for (var elIndex = 0; elIndex < this.updateOrder.length; elIndex++) {
                        var el = this.updateOrder[elIndex];
                        el.onSceneChange(event);
                    }
                    // update size if a chart component needs that
                    if (event.changes.bounds) {
                        this.updateLayout(event);
                    }
                    for (var aIndex = 0; aIndex < this.animationOrder.length; aIndex++) {
                        var ae = this.animationOrder[aIndex];
                        ae.doAnimations(event);
                    }
                    for (var pIndex = 0; pIndex < this.paintOrder.length; pIndex++) {
                        var pe = this.paintOrder[pIndex];
                        pe.paintScene(event);
                    }
                    if (event.changes.position) {
                        this.chart.notifyPositionChange(this.chart.createEventArguments(null, "api"));
                    }
                    event.changes = null;
                    var activeSubcharts = [];
                    for (var id in this.pointerState) {
                        var state = this.pointerState[id];
                        if (state.subchart) {
                            activeSubcharts.push(state.subchart);
                        }
                    }
                    // process subcharts
                    for (var i = 0; i < this.subcharts.length; i += 1) {
                        var subchart = this.subcharts[i];
                        if (activeSubcharts.indexOf(subchart) > -1)
                            continue;
                        var subchartEvents = subchart.events;
                        if (subchartEvents.sceneChanges.bounds || subchartEvents.chartOuterBounds.overlaps(this.chartOuterBounds)) {
                            subchartEvents.animateFrame(event);
                        }
                    }
                    // process active subcharts
                    for (var i = 0; i < activeSubcharts.length; i += 1) {
                        var subchart = activeSubcharts[i];
                        subchart.events.animateFrame(event);
                    }
                    this.shell.finalizeContext(event);
                };
                ChartEvents.prototype.doPaint = function (event) {
                    for (var eIndex = 0; eIndex < this.paintOrder.length; eIndex++) {
                        var e = this.paintOrder[eIndex];
                        e.paintScene(event);
                    }
                    // process subcharts
                    for (var i = 0; i < this.subcharts.length; i += 1) {
                        var subchart = this.subcharts[i];
                        var subchartEvents = subchart.events;
                        if (subchartEvents.chartOuterBounds.overlaps(this.chartOuterBounds)) {
                            subchartEvents.doPaint(event);
                        }
                    }
                };
                return ChartEvents;
            }());
            Base.ChartEvents = ChartEvents;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="core/ChartShell.ts" />
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var DomLayer = (function (_super) {
                __extends(DomLayer, _super);
                function DomLayer(chart) {
                    _super.call(this);
                    this.animationOrder = 500;
                    this.paintOrder = 35;
                    this.updateOrder = 600;
                    this.container = null;
                    this.backgroundContainer = null;
                    this.background = null;
                    this.canvas = null;
                    this.interactionContainer = null;
                    this.menuContainer = null;
                    this.outerBorder = null;
                    this.scene = null;
                    this.curThemeClass = null;
                    this.chart = chart;
                    this.scene = chart.scene;
                }
                DomLayer.setContainerStyle = function (c) {
                    c.style.position = "absolute";
                    c.style.left = "0px";
                    c.style.right = "0px";
                    c.style.top = "0px";
                    c.style.bottom = "0px";
                };
                DomLayer.prototype.createDom = function (shell) {
                    this.shell = shell;
                    this.container = Base.Helpers.createDom("div", "DVSL-container DVSL-" + shell.chart.api.typeName);
                    this.container.style.position = "relative";
                    this.container.style.width = "100%";
                    // note that the initial height is not set - it will be set by ChartOuterShell.updateSize() method.
                    // use border box layout to fill 100% correctly
                    this.backgroundContainer = Base.Helpers.createDom("div", "DVSL-background-container", null, this.container);
                    DomLayer.setContainerStyle(this.backgroundContainer);
                    this.background = Base.Helpers.createDom("div", "DVSL-background", null, this.backgroundContainer);
                    DomLayer.setContainerStyle(this.background);
                    this.backgroundImage = Base.Helpers.createDom("div", "DVSL-background-image", null, this.background);
                    this.canvas = Base.Helpers.createDom("canvas", "DVSL-canvas", null, this.container);
                    DomLayer.setContainerStyle(this.canvas);
                    this.outerBorder = Base.Helpers.createDom("div", "DVSL-border", null, this.container);
                    DomLayer.setContainerStyle(this.outerBorder);
                    this.interactionContainer = Base.Helpers.createDom("div", "DVSL-interaction", null, this.container);
                    DomLayer.setContainerStyle(this.interactionContainer);
                    this.menuContainer = Base.Helpers.createDom("div", "DVSL-menu-container DVSL-menu-workaround", null, this.container);
                    DomLayer.setContainerStyle(this.menuContainer);
                    // creating the empty span element works around an issue with IE11 where an completely empty menuContainer
                    // would break CSS animations due to some strange side effect of CSS box-shadow: none (which in turn is required
                    // for IE9/10.
                    Base.Helpers.createDom("span", "DVSL-empty", " ", this.menuContainer);
                    this.updateSettings(this.scene.settings);
                    // needed to capture keys
                    this.interactionContainer.tabIndex = 0;
                };
                DomLayer.prototype.updateSettings = function (changes) {
                    if (Base.Helpers.hasProp(changes, "area.style.image")) {
                        var image = changes.area.style.image;
                        this.backgroundImage.style.backgroundImage = image ? "url(" + image + ")" : "";
                    }
                    var curThemeClass = this.curThemeClass;
                    var newThemeClass = this.scene.settings.advanced.themeCSSClass;
                    if (newThemeClass !== curThemeClass) {
                        if (curThemeClass) {
                            Base.Helpers.removeClass(this.container, curThemeClass);
                        }
                        this.curThemeClass = newThemeClass;
                        Base.Helpers.addClass(this.container, newThemeClass);
                    }
                };
                DomLayer.prototype.doAnimations = function (event) {
                    if (event.changes.bounds) {
                        this.backgroundImage.style.bottom = this.scene.bottomMargin + "px";
                        this.backgroundImage.style.top = this.scene.topMargin + "px";
                    }
                };
                return DomLayer;
            }(Base.ChartElement));
            Base.DomLayer = DomLayer;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Resources;
        (function (Resources) {
            /* tslint:disable:max-line-length */
            /** An image that is displayed in the banner for free licenses. */
            Resources.LicenseBannerSupportedBy = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAAA/CAMAAACSEXcNAAACc1BMVEVMaXEAmcwAmcwyMjIzMzMAmcwzMzMzMzMzMzMzMzMAmcwzMzMzMzMzMjIAmcwzMzMzMzMAmcwzMzMzMzMAmcxEREQZGRkzMzM3NzczMzMAmcwzMzMzMzMzMzP///8AmcwAms4AmcwAm9AAAAAzMzMAms0zMjIzMjIzMzMAmc0DmMsAmcwAmcwAms0zMzMAmcwzMzMyMjIjIyP///8AmcwAmcwCmcsAms0zMzMzMzM0NDQzMjIAmcwzMzMAmcwzMzMyMjEAmcwAmcwAmcwAmcwAmcwzMzMzMzMAmc0zMzMzMjL////MMzMAAAAFBQUDAwNVVVUAmcwzMzMzMzMAmcwzMjIAmcwzMzMAms0zMzMzMzMEBAREREQAAAAAmcwzMzMAmcwAmc0Ams3///8zMzMzMzMAms7MMzP////KysoAmcwzMzMzMzMAms0zMzMAms0zMzPMMzMAm88AAAAxMTEzMjIxMTH///////9aWlr///9iYmIAmcwAmcwzMzMAms0zMzMzMzMREREzMzP///81NTUfHx8FBQUAAAA5OTn///8MDAwAAAAAmcwhISEAAAD///8DAwMyLi23t7cAAAD///9dXV0zMzMzMzMzMzMzMzPOMjL///9VVVVtbW0QEBCIiIhRUVEdHR0AmcwzMzMzMzPVLiyOjo5QUFBubm6VlZWIiIh9fX0AAACfn5+zs7PTLy3WLizXLSrQMTD///8cHBxiYmIiIiLj4+Pc3Nxubm4AAACIiIgzMzPMMzMAmczMMzM2LivXLSrULiytra1AQEAhISFaWlpgYGAyMC8JCQkCAgIzMzMAmcwAAADMMzMAms0q0h8SAAAAyXRSTlMA51rQTWX71QT0MRwKFwIN4fkp+NGe5+S+QrxUATBZIVDMVCIQl9wG6M0D4hYOY/3svBEMxvYIQ/FoqGDWW/EjhBqPJ6+GVyHcbUBTCIjy8GnufDUSm6mANMGVVcYzSrnKesEv/gI44R5vHUSOX4m3UHiA73PKqjgqQBiycqJLa0ew5D0SJul4u9MG9Kor2URN3uFEZiSuOtgeoCdHvaXSiaahLrG2epC6jXlumZlieNRJre5B6JzHZFN2zDezCzBruLY5cZyQlizU6ioiAAAJa0lEQVR42u2Y6V8TSRqA3xDOxQiYrIiQgIZLIOEyBMJ9X7oRkBsQEVgukQUEV0VRQXHAE+/bGdXRHXXnnt2Zvc8PSe38SVtvdSfdnUhsh98PZJfnQzpVXU3XU/XWWxVgnQ+Pc2OEzOlhGSxcAYTshtVkN3nU36+0poFcriyAC1s2cyI/h9XEeqwvPf135BzIZfOWD1PkawsAfPTdIgsN9rHwao6QV/j93BUy1goArWNkbDe9kGtjc4TSTidyjHxPL3idc4hYvsfml8glAD2OzMryiMy1U5OP2Iiyjy3kcf9naEWsL/vbSDsVuEErzsEecvrRa93ZNt0MvLK+wXhkt14QXoS87P+UtB89+zHAOFmEFabvzUVCFvQgEjl7IP36fSsAuXE0fXL+Y3h4nlYcs1KRv/fNsNDSk89++Pdr0srdauNFjtHm1OLGaYBvz6fDSjNz77vnm61pIhHs1++JnqtouwjkMato30N+za+RbMLYA/OPpWsEmy/SSSQvYIVJ09O46sPFLhXBTmMFlvCKFQ4RLLzRUfqcTRDH9/Tz/2wl12GFmSWXcLGf/QfAvFikhcxwPdvcBle/xYr5GUHkB1IAjKupLiIX2wBenJ64DytNepu1Va9fIK8BPrW26+dQhFzTXyK0K4RW7Ca/gUes4gFwIhc36+lT5JK+fQHgG3rrmnOxt7LmcH3+F/RzpZl8YCXkYv8MwOJ5Yv3mLC72CULOTwKQtofE+uAo9D23EuuxI7zIy3mih8ljtOpfAEfo9eF9x2I/zZrTIfkaP1eaI9U63b10jK+vdNVHLh+gkTKp032FPXt8j9ZgZqvWVR+gFx3VhaPVOtr6QDXeYtd7k5cB0R24zNXB6Ruw6vAhv5ytOm03WfyfELlifZ4OHwIYKXyswE/hcnUfrLPOOv/f9DTW19drYe3jH2yz2UZgdUnaXlSys6thf2/CMkT8qIg3/CTyh4eHa+NguUQWKew8Gp+E1RCZpo+mBMEy8amxi9j5ySqIhNFHgzfA8ijiDUwm7lrTsTZFSu1I18mmgYGmk13MqHctimy3UxKjgCeqAotJKy1StWyRJFzmOwbAycA2WhEDlIzC4gvFhc61b4gsvhBpABeCbueXq+IEkWmAHlV5fqBrp6ID8/OxnQs90YHlPfR6BkX8QUQE/hXnA6NbpZTsBQcbkyIjCzNgP+22Aj0Ek0S7PeRPTaOHKvKS7cl5OTG9tM4rplNhovWKQz4il9na5vgAX3VK7JNxrT8nYsy2+KWofQOCJ8IjHF26nX1HGR+gVmfGWnJFgoHeBU/84gPivVNTU5X0UXVzKmWC5S7tkDIFH5gwqgA5ZJeSXMjPg9eUpsZkqqkowQk5CBK8cMGLH5pqyBMVc8zAETccYHPSncuJ+ApVqfnAUMXbBPxO8BZZ+zK5mpRsm5iANACoVTvL8WeAUuIiklfINEoV4sqcBJCQoLF7JCSKC5ZUm5gsFJESXM6JoK9gnOUiF+AuUiuuyAVKQ4gTE8tHKOKVaJcwCi7s59NxYo4mp0YYhJydWzsVLD9HYsCc4gas2WLZ56cWi6hDb8Vyo93szzpNWx22tAzVp8YzkyoAuM0PeWbs4VPTSqUyFp9TIs1BoGXTGrvPMnE4xWYrY2Mf6WCARVlDgrBthCgqFCH4xW3b6GBNzQOGjZCQFJWDpYqiDrbs9/qY+FyQy16Wm8aWbLmx2ciJxA55lwf5x6lyscB1Iq1xEFuh0jj2/zDVCwygRhZjHa5/t6xVjwEXzu6ovCdGQIJPMgaRASCGG+0Gr2JDhiFy+5TJ7rZrNGELL+fix1nYL5muRAPEYUeVKnCywSX9pmFpH7iQhXpVnIhvoFv6FbJfpZDYQEyvCXvfBDDKPEqEY0hxgxlc6MUmPsDD1EvAQSEu/Cb2Zt+b7vvICXCQjeMa7Zpusc0wL7Lp7RtiEEbgTXgreyv4vplxYpKPg5gMtz1SKuKDBzAhFWCoRUEBxojHDTEfw6gOXBiilU89i2wIpoWWCHCHz14xtM8sIR2Uc/jykaTjbcL+s4MWt8Nf6MuGPIpEx4snKGj25rT39BltIw6AZxHYxxJFmTCb0jS0zYCDSykFzxgUHkU0TITFsUeRoFBaDOecsk+F+nLJF6dJ2eNZxNvGCLWUqUACi6eaYoAEHE1NhoxTpGeRH6PgKmZ4mSK5sTYBGSIwbONJuSOOzcJERxa6kCwjsMwhskS6u7vD5YlgNCG+AQG+8kSg0rlfqseF1bnVTikCykk8WBnAIx01drkzUiZLpIzbG2sHZ2+Xb6prkSUCKuMfMh1HBkmkdLF4muITqTvmYmAMFCXbZYlgtBjliLANJ3RQSMqyRNAl3BLA5mQWGFF2iiISkK381ubOflPJcS+v4w1sOqY6373YD9NXNMoR0XbTLlcJO6JcEWQTOwYNAxJZIzqFSDsIu/7I2LVrF906BIo2dr1bBI8RT+SIjOC5xV++iJRUjEq22e0UHws7pWv9z7/k+QLnjUcTBbDz3SIYIpkquSJxwjJGkQjZIrlYzx0vKIeABw+Ool39V//h+SumAURR4pUBskRUuBZb5IaWkEQn3r6zn8GDtCAimUA/ej3ITq5J4lPT1FtEnuEdTYf5AmY0eSLQYqMUbHD0uqxqCRF/Je7l+cBhxARc6S6C55nuEUAioG5oFjjKb9HmdwBAwYa5cwePArUy3EXugob/nS5bhP9p5FdQFhYWPm4JtlUuIQJGbJdZb5yuOlHJDh/xae4iPUpsVOAdltuSBlU2dWpj2WBY2RB7RxgTcafDTeQL6KVJN+r9RGBaLf2FuJSI/1OblGxwE8G0zKOOpiJi7sASIl2uIl/ehUO4UXoS2eEuAoPBNoGlZwSiWRKVbNXuIhH1NoSd/G+K2z8N4kXcOSkV+fJztpRK4X1FQFUQ6zh93GqZ9XBoHHnq2KZD67UgEREwKrkW0eB/4lQK3/7WuD8gF34mpQkTsMksFvnt36A3j05IEggU06Z7wcFeWiqW3nTM3oa67NqCxsqRTXE4qJu0Wm20EPbiYuCJysaCWuMZR9lfS4kDCT11WQW1ueURbIwGs7B9XRwsQROeCPP45fCMajzbBWbuX0JrjON2SnIpG/+7n98FyBhFtxhYc5TakcTSJgyPhE9GK/j/rqw9jifzu3hn1w7Fj+xrTAKsRcwau4TEg7BGyTipEWmw9bJmVcylW3MUioquoigDrLPO+/JfZ6Pep8PFvkUAAAAASUVORK5CYII=";
            /** An image that is displayed in the banner for development and QA licenses. */
            Resources.LicenseBannerDevelopment = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAAA/CAMAAACSEXcNAAACu1BMVEVMaXEzMzMCmMszMzMzMzMzMzMzMzNbW1tERET///8AAAAAmcwzMzMZGRkzMzMAAAAAmcwAmc0AmcwzMzMAmcwzMzP///8zMzMAmcwzMzMzMzMzMzMAAAAzMjIAmcw3NzczMzMvLy8Amcz///8Am88Amc0BmcwzMjIAmcwzMzP///////8AmcwzMzMAmcwzMzMzMzMzMzMAAAAyMjL///8zMzMAmcwAms4NDQ0zMzMAAABiYmKOjo4AmcwAmcwAms0zMzMAmc0fHx8zMzIAAAAzMzMAmcwzMzMzMjJSUlIzMzMzMjIAms7MMzMQEBAAAAD///////8CAgIAAAA4ODj///9dXV0AmcwAmcwAmcwBAQEAmc0AmcwzMzMAms4zMzMyMjL///+zs7MAAAAvLS0AmcwAmcwzMzMzMzMzMjIAmc0AmcwAms0zMzMzMzMAms0zMzMAAAAfHx8AmcwAms0zMzMAms0zMzMAms0zMzMzMzMzMzMzMzMzMzMzMzMzMzPMMzP///8zMzMICAgzMzMAms0Ams3MMzMKCgozMjJ+fn4yMjL///+UlJT///8DAwP///8FBQUzMzMAmcwzMzMAmcwzMjEzMzNHR0cZGRkAAAAlJSX////KysppaWkAmcwAmcwAmcwzMzNAQEAhISGrq6t+fn5RUVEzMzMzMzMAmcwzMzPS0tLOMjKhoaFLS0tubm5vb2+NjY1CQkImJibVLizXLSp0dHRERETd3d0dHR2RkZEgICBxcXF9fX3GxsYQEBBWVlaHh4czMzMAmczPMTHTLy3WLSvFxcXKysokJCQcHBxPT09oaGikpKQSEhLQMTDPMjGpqam4uLhLS0sYGBiLi4sODg6dnZ2UlJTh4eE1NTVWVlbj4+OFhYUsKScCAgIkISAvLy8DAwMzMzMAmcwAAADMMzMAms3Q4KV9AAAA3nRSTlMATQL01gTiQZ5ZIs0c5/szZVvR0DFCEij5ClQMiAa8vgGDFS9VDwfdIegeDOdh8CT4/u+8BhX9gvQREbKQxvaU8eXpXbvt65AZu2tAUQnjVVNNq2bSJK4dJoze4KswNKuZGHjN3xmlDnG4e9bKsCFCwUSPR016bDzB+aaAWokuAuE1V/JHObd4ecqbN0FaO/BH8UsrZJqdZ8jVmdsqb6FgsNvTnMZKZ5E0fnS1QSeFoo2mVcS3erAwslWhddhHgGjSqYgeLl7UPTM4behncmfB6vJsVVFqHIuBPF6Wf2TjcLnEAAAL9ElEQVR42u2X91uUxxbHBynKCqywYSEIhhVpS5W6u6wgXZSA9N67SFFEkBKvil4VIxYswRI1GqPRxFTTNTG5yU29vXHvb7tz82fcM2X3fd9d2KzyPFHu4/eXnXJm5nxm5j1nFv262j3a2Nj4Alr8cnYxGAx+6PFq9ZqqS+uG27fsX7IAECcAcUCPpJjx8fHBgAVjhKXlGLm8VoQ8DpAJGJq9cqEcKwBD0LovHwOINwx1WShIFSdITWW/0QOLEoRzDO+sr6io3zlMifYvRpA1RlBNPuLaUUOqq39tkE0E5NkFhatIcHx5hdBQsRwaTpFSSFvlyco2cxgLDjt5MiwYWajjQUxvYoAAMgH5JLE3xs3SKa1bTMyGAOvco3Xr3Q2/QwTEWdwTCLMIA5JXSXVJcGTJ6rCwthC0BdyO5BycJN1o9H2mfsuBmugkY1J0d9p+aPM8tTUyFdojD6wQsfjc6A939IjNDu0ZrHNmINNRI07ZsR6OLg1+gSaXHkSdVoQ77opdH9owJgLc4KDqcQp3DHeIj49XwNDY/nhQA71gdbmK7NhdMGA6kdoeMEqV1MbPwbPdKyc1NfrypXRo9UQSeZIPXjyovVZcvWyKBQHjjgaz1o4xEA+hKT6G2SWGGwQ5nWCNbhu71rOW7CiDWI5a6L2xy1wPH0KgSxYg0W0UoypS3NhtkQSXeBltyjefXZZ4iQMbCYhUob1s5zkvJz5D2wQ4R2uQQXHDGALV+pqVSuMRAfFMlzqWjCy0hYfjmm6v7hxhE7rXrdoaSUth5ML0sA3rbxjpcoo1GM6YQWJdnELZbvc7U6fB6lDDbG5jfDgl2QRtD2L5cYQe6plQKBShUN51RQHq70B1HnQbukYaDmUbDHvp3oeZVEFvWfsSIW34Rtak+5LCDkuQAWo6UBGyBL6k/G4a1tIG6GcfvIJsSBqUMulimVr6yfZO908zkNBch96VzgEbMq9AhTmhHZ3Q8ks2SK7MIcBzcwSikajXIE5YR63ThNCP9iQ6NDhYZO8kcongQz3FdrvWszI4JDhsTXuq0Spr1BvFH04FOZQtkuOqCUYBxGvFBmHQSovwqyUkXchCGwneJgbi4TZn+GXzdAqBDYm1P5V4Xw9xjHLUCs+QyvY+ZKH9xGSFuZoGtUvmWhuZqZ6u7DFknUf4t8yPLFtrGW6JzTgH8Zk7IXaQGzg5T7a4zH3rIweTtFPSGWKVI6UgK8gDTAgF3fQ2qsgdsZkQY8g1eg1ZKBcaX7cN8qwLVGYDkbV49DoFPtOA9DKyrTQpiCdJmQIISZhrUBcslmsTRBsuPqCVPkMTDhNDL4ySDbANAnOD+vey07QOQ8tDYHNZlLKt4EibIGQv8hFxeqNNkJXC/6yOqB4XDxZ8yTEpdtsGcYAKqY+MJSKR+H2KruS76QVANpVs/CWQn/NRK4nwdoJkhhoE2QGCxk2W2afFd7Mt3RSFTibZcbH6fO0CWbt2rZ99IKPcKw9HRw/7QFCnOV/u6hRWXmXkoR/thEJksG2OgWijvSey1y6QvSw3Dk74POj1mZy1CwQlTr+ebXoySG7KMNwnlkNq5z6GSp40qpKMdoGQ2zJtBwhLOC7eiCvKPhDQBr8RR/pQ4GY7jKCcMFpexVObtbak1t5cs+Ymex22r7MJQqPWIVhi1B6QurXg8iZz6xm7QUA+9Bk0zvJdjugVslXiIHreLEgdgqqWDP8iCH1G9NgBQkNQqLP9IFLFk1tJk906ccDdKv3Wv/oN1/so34zhlY+QHSdC83aivSABkjeKItAaZJ5/iJmk3ZzbDiAu8nC8KVj99r9c70MYoIq85BmC7ALZsJ6kX3uvlhBEG+bO7EPkIS2ASA7wCvy+TP8JrRan7PY5QN4jPV4DfSdJRLMPBM0aQCrT2h1jm+YBcb5CcnmM6Vv3IHHIGiQGnvU8nAeiyVxTTy+Z8jQU0uk2r1vORao1IdYgt5EX/59uNwj/a+Sk2uvt7dc54gLezRN+p2lma5ye2HSikz4+wrXWILsV0LFe5eCdOauFB2ls/OiYt/feXLoGiXg5RmvtsAJ5H+2HoJv/cCBoItYg1pn5QJxfN0iViaQgPCxzxRIQsUbQPCDDliB/uI0OCInSbhDkLX55zH8iSNsjtovtRHOBBDbyfnj5D4ntu2gsizTOoZ1SkD9+TV2tQg8LghJVJhQPp9kYG49Gh6713NDldB2SgAiaVjCLDuR8oseU1p06WeQ++YxU9SQApw6IQX73NaqPhpS5GgmqBFOhHgy1Smmn6fSenYwaVI12+vkEkE31qaur6xCuPalqecXtROeoanB6yFR3fgE6A5BEuyc3qm6M9QbSPZrYeAPsJ7mJtep9yUOYfybvAcZ7z6O+HPqmXFxiCSOpiu737a9uQ8pMJmxpaLGJ/9tIT64PJhf+y+QaUq0NQYtPN5N4Ft86vDX9Z1pMA45FqD4vo0TpL6NFqpCdIpSa5NVo8SqkL3lVd3rk5eGqHcHoqZ7qqZ7qyVMxRo8if9Owwjjs/zg99sdyVvggAz2KlvHZ5LhUf03Sw5tBcVkyNK9kLRhn6YT6wTioc/sSfBDNr+ew1JGlrLCnaEEgKvyjOsK6eylOuXDhsDsuQfOpBesP42JRNU8P9oW0clXz0kODgBYE8gqbxxpkWUREWdFZfu7W0uEUddlZd+GC6Peoy4pasY4cFm7G8ocE4TfOPw7H0Zu+rRrHzcBvdXEJNG2jLfTIuVEh8SELWjhINQYJRv54m78/B0GgP+PtzL5FBu6RHjk/pAR8Fenc30FcBa1qBPoTvVPbS5WlHyEu7hsMLCyGeXQUJK4agXALB+F8BOZiczlZZxsubb6IsxBy31egP6zBMiSHlsP7yLgZXN78DnEjC6foP8AM5MMU/MYFVEiNpnQw6/dBQSKQiAy4I3H79G+4Y11EaQFxEn+DqFLwTNy5W4gLMyQlfpdQ3UEf7xM+7XLwrRhmnPpAn4JbqMflWE6cvWgBIscp55VBeRg2OOOI8vxb4L/7d0Xqsn/gb2HhH5VlencZMQpSHm29TwvqPWBNlLAMfxqBCmBYWTP+O4IaQiIQ5O4Op9SsbroHW32HrF5QmsAsrmlw3rEEM8ib/Pc5cFBThpq+YwfHlg1KwfKlOG+PGpzUEY9fxCqEGvHvLUBU+EUo3LoAp58nk8n+jTOJAwh9imfRq/gnuU5dFAFGP0CfwmT9JhauqAyXk92E3YeaFchLmrsy2V3Y6jLNdjD9mDs4pdHs0yFZsZwBLBNAfiotLCx85yqt89XA8aXASpadBI/JWnRPpCD8g02IgOWZvqcg1JumN87RGw5GTNx6mQBC7LjT1iDnkDumAg/zXkIHNU3MoFrzr2a4J5l8AI43g+gwk0wIJjDdKzAjW45+DBexTo7vIAuQ66byXZziSqQWQFDTsf80u2M5GDXTPhhpCXKXg5yzApHhz9G5DDruKNlX2dU81g+HmKBsxsXvapS0nvEJv0jX0UFmn7GdtlznINelINfwX1X4G0uQt7GK5eqIjALWKIBkVaME5Rc4E4zYzOhVat0ggPBhcnDaEqQYLsbn5lCqzNgOdaq/4Xio6zG+yOrlLIPch2tfUM5aqCt82e34bSlIROm7V88mMAf+IgPp6I07iw/K/TFs1hc4S75tpkUE8hlpKcD/JEb+ssIWf9TUiv0LZ7AAwoaVTGluSUBkspJqfFiJbmmmSuQH4whN+fEMJetPyMMz8sL7GP/A6kGteKYQ7PUJcvwq3y8S/Omy4NtZpRQE3XHHn3EHqKpp89G84/j4W3sQUkOcxAWfiUDUemg5dyECjFKO4ynFNQi5pRh/clgA4cNK7yWIQUBTpRfKwOd7YH+8nBBcgwPg2vPWPphXX2o6rmO0ju/rPuJfUZOGpBK27PGUo8gCpAxr1GwLXKmK0FFXMu1m183n6fAiaAOLoiKyG65B4CS0HIugQ8DoCJQSjkBLmSvi8yj5MOjiNToURKxBEUegGERLrrAI1/nNMIv6CB/A63rccmszb9gMG2taNog6w5ZjHiNNHnqCpdZ/nGCfZQncwCeapMkuM1nJVCtYLn59i1s/RP8PKnPlr5v/ATeU1EkHfFh/AAAAAElFTkSuQmCC";
            /** An image that is displayed for certain license types when they expire. */
            Resources.LicenseExpired = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAABaCAMAAADKKOnkAAAB7FBMVEVMaXEzMzMzMzMzMzMzMzMzMzMAAAAAAAAAAAAzMzMzMzMCmMsAmcwzMzMAmcwAmc0AmcwAmcwzMzMzMzMzMzMAAAAzMzMAmcwzMzMAAAABmcwAmcwAmc0AmcwAmcwzMzMAm88zMjIzMzMAmcwzMzMzMzMAmcwAmcwAmcwzMjIzMzMAAAAzMzMAmcwAms4AAAAAAAAAms0AAAAyMjIAAAAAmcwAmc0zMzMzMzMAmc0zMjIAmcwzMzMzMjIzMzMAAAAAms7MMzMAAAAAmcwvLy8zMzMzMzMAmcwzMzMAms4zMzMzMzMAmcwzMzMzMjIAmcwAmcwzMzIAmc0zMzMzMzMAms0zMzMAAAAAmcwAms0zMzMAms0zMzMAmcwzMzMzMzMzMzMAms3MMzMzMjIAAAAzMzMzMzMzMzMzMzMAms0AmcwAms3MMzMAms0zMzMzMzM1NTUAAAAyMjIzMzMAmcwAmcwzMjEzMzMAmcwAmcwzMzMzMzMAmcwzMzMzMzMzMzPOMjIyMjIAmcwvLS3VLizXLSozMzPPMTHTLy3WLSsAAAAAAADPMjHQMTAAAAAAAADMMzMzMzMAmcz///8AAADy1tblp6fTXV3rv7/hmpr56+v89fXafX3QSUnvy8vXbm7os7P14ODejIwAms2gRU9CAAAAkHRSTlMATQz04gS7kHfW+wLNKGVbMdEcQlSZ0LwRZgf5D/Yh6FXdAuftMMbwFQb4ERX9giJElMy87h3gZCTlGetrQP7dUQmqJoMKR4whNAFhGXG41qVde6uwQsGIR016bDyr+aZaweHKM1eQgPHKsLd4OQ6JllU3SyuanWdg29M0dH4etSeZLt96sC5e1D0SYPLqGwwy0eDzAAAKN0lEQVR42u2Yh18bORbHBQYOTIClGWNMNdX03gMbCL23pZejBThqCCmbupfs3u5eWXewKSH7j56epLFmPGBPIIQPWf8+n2BJ8zTSV3p6TxP0dRUcZDKZ4tDtKjetfT17YWBoM/waIGEYJABdSTXb29uTedfGSCmtNzNFR+puA6QNd80MvC5HJMbgyv7pFkBicdeg64K0M4LkZPqbM373QDjHwlRnZWXn1AIh2ryLIGkw9apmoTpRBdXcrw3SCCAPrxWuDHji9yp5Q+U93PAESrqelv2WHncY06fs76fokYe2Xtd0FORxkDaEMgo6amI8J6WNqampk4elDG1MRwb+nQaQYCRSF34L71CUINU6n0h4bkpKjw4N4WkbgIOT1JrNSd91Dm1U5RSaC3P6SzdxW9STNUMybjdsRIpYIl6NparUxsz0kcmsYApS3T0XlmlUq4KG47qEKb3uPtCkqmaNj9KH50WAdQGtI2GpqtSA8vJyDe5qHCvHGiYOlrWiyTTO4g7VBQi0YZaqsIftQ9RAdH1ycs7z9VrcGoUkioIDL+40MCOuPhdiQd62yuTW/XkKouZN5TXUriDVxBX2mDbGNPQ9oi2Z3SaxVFr89NWsu546DebrHiA5PQSj3SBu7PdIguHRZq9KaqbOUm4SqwFApErvoCsPvJz4KWnjcCo5yKS4YR7sZ5LcSibxCECias0SFSEPDbFwXNUf3V/PF6E/O2HNQEop4DAjdMHGhuf6wowm01M3iDEoLJ2u9lgwmTS2WhzeWXlXnkpIGnHbayPbjvTFkTaNRpOOy7MvNFhjWyhLTZahb254MdNkWiZrnyKoknjZQDhPG0mGqtokKEx4gowT0/FKXTg+Sc39JKyVjpNjr4+EBSnFpUEy2KCWHNmO6rFqCpK+EtARGJxXN/gCV+gktKttWuZkk+AyixgvRoWJ5rp/hDghi1oHQBiXR3oEDAd4ZO9CcCI9Qk/oas9Eteh1+pS0gWSzLGt0msUHpxI2ZUiyXVV6lAez1tTxToEe4VcLJH3IQw2A10hB1DGy8MujXy8PbEiszWSYfSeOY4Rjhl9DWgZGkYc2wSTSXS3FtXV3rQfe1ElGVk/L8wg7y2zLMrWe4RZsthlIxMUJcQs8cO+SbPGczW0UNqZwComlk+VIKUgkXMB4KOgn3tgKPuI1IdaAG/2IPLSCG994B3kInwM7XUguiF40y+lIQHqGvKtUChIFKZODQMJMQ314sBWvINpU8QYFRky3BbRN/7wKC+AdBPWRQLFMd1Mehu7pYHFJlPIuvcErCKxFM4JJN3gFCeTfWVvdI0FqGnxhmzQZ3kECcAXqc/MFSCTmTzktbDWjdT5Aisy+QP5sRv+ECK8QZDDdxKUABG0LlpkHYt/sqRWi0H6hAscaTVIEcv/+/ThlIKsmKrVKpVYGgnrd+XK2l4+cYGahH03BxUrvnWM8x6x0R5YVgSzT3DjZFvG6I2JvRxEIKqh+kylcGSSesgD+RHLIzMXb0MKSRnuhWREIeEu1AhCacIJiEVO3IhBQXdycCkCMzGwCZlWfQsoJLLXJNZQ88zIt7SW9HQ5keweBqLWIh1hVApJ1H0+5EQl6qhQEFEGuQds039WLbiFrfIKg793CqYOrPXzBNwhcI0aUgEAISg++CgioHLySJLtsccBdk571X/7O9AE1uzGimxHyvSM0bxcoBcmT3FE0XXKQS74QB6Hdnds2EBNcHF9yq3/8wfQBwgDIsB6lQ4pA6h5B+lXqWjyIDl+c2afhIs1BJBv4Av8+I19CueKUPXAByHt4Ej0+ug8RTRkI2jFhtQpjb803XgIS/AJyeY1w1tUQh+QgNfhaz8J5F9pbEZ50wCsPcKGWLHP2PSaoVunkIG9RNPtOVwzCPo3CWpdjY+N654JMDZeF32qS2d5VtzU+7u2DcqpWDpIB37qPWgNiB3e0+EJqLF+dj41dXiFjQMSrN8s1IQP5gDZx0G3+PBDUZjSJ9fQykOA3JqkGkQwEwjKTEUDEmkOXgCx4gvznLdrgiVIxCIoV3zwu3xGkHRHbGXvRRSBd74RbiRYODFcfiWUG8wWakoL8+1cy1Xb0uSCooFVAUYft1Hi5NAbAfzQQBR1kIQkIV7WGWmyh4McjQloP66WRe/87qTohACePi0H+9SvqzMEpMxdxtWBTXtfjWov0obB7D/e6J1tXe+Mi8mBRI7Kysra420NVyyoxj3tXWyerp4V68M/4YR6SKGOvofXVfEcXWaO2hlfYfo+ZyNWZBBdhdkzeY4z336PRenKnvFuiCaOwnaz321/eIqQrArbSu0XBvzZqizr14PA/FVVBdUaH7p5eFrIsvrawVvsnKZbq0F3UqMf/JNY+Q3dUuikRSlVRLrq70o0WJfTXGp4vtE/okV9+/XX1xzciP4gfxA/yFwOxWWzuNofFckRLJx8tFovtSDBhgordYvkk6XeCWyxOO61AmehYNBRrIh2OLJZDOtL5Cbc/ZeaHFqdoRBe8VDYBG+uhCMThpB0PLwRxivududgslYHAyxwwY2LB7Y8uAKGwchDWwzcINLrwOKdsNG7ChrbzRmb0EXrSp/LNpx34GIf0D7d3nFtcJ1IQG31ol8yRVxwY59g3yBl9w4nF8vEiEDwqb3TSX5flUBkIMDts5BXc/hNMSwrCXyoHgbm5LKc+QcCRz8gw9k8XgZzC+/mOwOaBlIHAFM6h5XogMK5vEDv4sbgrlUN4BpziM+K0n3EQ5sDyM+Jk1SNaVuRax9IJ8Gdwyq4Ngv/ZeD/HITnIDmUgIHbKfB52aP3CIDap85w4LUfiRjs+8S6Hb9fik3eeSEBssvBLdSqbgBjk2mcEDJznuJHrGOKCMhCHy2Kj1nJ7DsJyjt3bGbl21GJLZnObYjmVRi1YSvDGM18gWLBY14paMM9Pl+cRugPu8OvERnbFO3LM8ojNJwj7UZ5HqOzKMzsdkr382MWO8omyzO6EAAXdj5SAnCvO7HIQfoE6v+SuJXi6yNRlBw4FIJCtaXfXmS8QyJ1nl961/Nd4P4gfxA9yR0H88ssvv66kEGuIH8QPcvMgoVarNVQoV1itISWsuWnX+gAXEq3WkhCrNR6JhbvEY9PikiZrRYnoRfH5ks7QvQm3Ft84CFRAdNAHVqIlOhesHwgIVagEhKqM/KXTpOWmfN6ZlFjrjYMkwgxD6eTzYfAlPoNEagEN+U3WMilIWT4qA5NdgsjsS+jO8c7FsEZLYHKzILAJFfiveKQmeErm4kbFzoMdycO1iAleaQYeAqTsdbwzLBE8e3DjIGVix1mKh+LngBRDMZ7yx9Neks4/WKlCvipIcYX1C4Dk3wII9wXEPbvpaiBlXlwLdPOHHVx8KdQ96u6VdkR+2JFw2EPyUX7oTUUtqlAeckkILSGliquAyMMv32VQ4k2DsCRYlkjG362wVuzGWyvyrwICVUh9UhC0iwEr8I749e3rf9Zb0e+///aFQX772y3pv+hb0f8Bf+WgGjFCqjoAAAAASUVORK5CYII=";
            /** 1px*1px transparent image */
            Resources.ErrorImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQIHWP4zwAAAgEBAMVfG14AAAAASUVORK5CYII=";
        })(Resources = Internal.Resources || (Internal.Resources = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var SettingsData = (function () {
                function SettingsData() {
                    /** Data id used for series to reference specific data source. */
                    this.id = "default";
                    /** URL that is used to load data
                    @type url */
                    this.url = null;
                    /** List of extra parameters to pass with data URL. */
                    this.urlParameters = [];
                    /** Delegate that can be used to process data returned by the server for the HTTP request issued by the chart.
                    @returns The data object that will be further processed by the chart. */
                    this.postprocessorFunction = null;
                    /**
                     * Provides the ability to embed chart data directly into the chart configuration.
                     *
                     * This data can be complete or act as the initial data where the rest will be requested dynamically using
                     * `url` or `dataFunction`.
                     * !important @update reference
                     * !important @version 1.12.0 - the value has to be an object, JSON strings are no longer accepted.
                     */
                    this.preloaded = null;
                    /** Data loading format. Currently most charts only support JSON. */
                    this.format = "JSON";
                    /** Timeout in milliseconds for data requests. This timeout only applies to HTTP requests issued by the chart directly.
                    @type integer */
                    this.requestTimeout = 40000;
                    /** Max number of parallel data requests to issue. More requests will result in faster loading, but might put heavy load on server.
                    @type integer */
                    this.numberOfParallelRequests = 3;
                }
                return SettingsData;
            }());
            Base.SettingsData = SettingsData;
            /** retrieving and caching raw data */
            var Data = (function () {
                function Data(chart, dataSettings) {
                    this.removed = false;
                    this.requestScheduled = false;
                    this.requestsRunning = false;
                    this.requestCount = 0;
                    this.dataSettings = dataSettings;
                    this.chart = chart;
                    this.settings = chart.settings;
                }
                /** static do request method, add urlParameters */
                Data.doRequest = function (url, config, params, success, fail) {
                    if (config.urlParameters.length) {
                        params = params.slice(); // create a copy of the array
                        for (var pIndex = 0; pIndex < config.urlParameters.length; pIndex++) {
                            var p = config.urlParameters[pIndex];
                            params.push([p.name, p.value]);
                        }
                    }
                    var resultFunc;
                    if (config.postprocessorFunction) {
                        resultFunc = function (data) { return success(config.postprocessorFunction(data)); };
                    }
                    else {
                        resultFunc = success;
                    }
                    Base.Helpers.doRequest(url, config.requestTimeout, params, resultFunc, fail);
                };
                /** Creates a new data request or returns null if there are no more requests pending */
                Data.prototype.buildRequest = function () { return null; };
                /** verifies data, returns true if data is good to add */
                Data.prototype.verifyData = function (request, data) { return true; };
                /** add data, return scene changes object */
                Data.prototype.addVerifiedData = function (request, data) { return {}; };
                /** on request failed */
                Data.prototype.requestFailedPermanently = function (request) {
                    // a virtual method
                };
                Data.prototype.remove = function () {
                    this.removed = true;
                };
                Data.prototype.hasPendingRequests = function () {
                    if (this.removed)
                        return false;
                    return this.requestCount > 0;
                };
                Data.prototype.addData = function (data) {
                    this._dataArrived(null, data);
                };
                Data.prototype.applyPreloadedData = function () {
                    if (this.dataSettings.preloaded) {
                        this._dataArrived(null, this.dataSettings.preloaded);
                    }
                };
                Data.prototype.scheduleRequests = function (immediately) {
                    var _this = this;
                    if (immediately === void 0) { immediately = false; }
                    if (immediately) {
                        this._runRequests();
                    }
                    else if (!this.requestScheduled) {
                        this.requestScheduled = true;
                        setTimeout(function () { return _this._runRequests(); }, 0);
                    }
                };
                /** private methods */
                Data.prototype._runRequests = function () {
                    var _this = this;
                    if (this.removed || this.requestsRunning)
                        return;
                    this.requestScheduled = false;
                    var r;
                    // add new requests
                    try {
                        this.requestsRunning = true;
                        while (this.requestCount < this.dataSettings.numberOfParallelRequests) {
                            r = this.buildRequest();
                            if (r === null) {
                                break;
                            }
                            // create closure to bind request variable
                            (function (request) {
                                var okFunc = function (data) { return _this._dataArrived(request, data); };
                                var failFunc = function (data) { return _this._dataError(request, data); };
                                _this.requestCount += 1;
                                _this.chart.log("Requesting data for", request);
                                _this.dataFunc(request, okFunc, failFunc);
                            })(r);
                        }
                    }
                    finally {
                        this.requestsRunning = false;
                    }
                };
                Data.prototype._dataError = function (request, rawData) {
                    if (this.removed) {
                        return;
                    }
                    var data = Base.Helpers.parseData(rawData, this.dataSettings.format, true);
                    var error = data.error ? data.error : "Unknown error";
                    if (request) {
                        this.requestCount -= 1;
                        this.chart.error("Data request failed: " + error, request);
                    }
                    else {
                        this.chart.error("Data loading failed: " + error);
                    }
                    this.requestFailedPermanently(request);
                    this._runRequests();
                };
                Data.prototype._dataArrived = function (request, rawData) {
                    if (this.removed)
                        return;
                    var data = Base.Helpers.parseData(rawData, this.dataSettings.format);
                    if (request) {
                        this.requestCount -= 1;
                        if (data.error) {
                            this.chart.error("Data request succeeded, but contained an error: " + data.error, request);
                        }
                        else {
                            this.chart.log("Data arrived for request", request);
                        }
                    }
                    else {
                        if (data.error) {
                            this.chart.error("Loaded data contains error: " + data.error);
                        }
                        else {
                            this.chart.log("Data loaded");
                        }
                    }
                    if (!data.error && this.verifyData(request, data)) {
                        var changes = this.addVerifiedData(request, data);
                        if (!changes.dataArrived)
                            changes.dataArrived = {};
                        changes.dataArrived[this.dataSettings.id] = true;
                        this.chart.events.notifySceneChanges(changes);
                    }
                    else if (request) {
                        this.requestFailedPermanently(request);
                    }
                    this._runRequests();
                };
                return Data;
            }());
            Base.Data = Data;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="core/ChartEvents.ts" />
/// <reference path="Images.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var SettingsCredits = (function () {
                function SettingsCredits() {
                    /** Enable/disable chart credits. Note that it does not affect exported image. */
                    this.enabled = false;
                    /** Whether to render credits on the exported image. Note that it does not affect chart. */
                    this.enabledOnExport = false;
                    /** URL to open on click.
                    @type url */
                    this.url = "http://zoomcharts.com";
                    /** The name of the frame that will be used to open the URL.
                    @version 1.13.1 */
                    this.urlTarget = "_blank";
                    /** URL of credits image.
                    @type imageUrl */
                    this.image = "builtin://logo-supported-by";
                    /** Image scaling. Use to embed higher resolution images.
                    @type float */
                    this.imageScaling = 0.5;
                    /** Specifies the image location
                    @type enum
                    @value inside - the image will be rendered within the chart area (for example, over the TimeChart columns) and to the left of any vertical chart axis.
                    @value outside - the image will be rendered below the chart area and inside any chart axis and to the left of any vertical chart axis. */
                    this.location = "outside";
                    /** The URL of the credits image that will be used for the export. By default the same image is used for both export and displaying on the screen.
                    @type imageUrl*/
                    this.imageExport = null;
                }
                return SettingsCredits;
            }());
            Base.SettingsCredits = SettingsCredits;
            var Credits = (function (_super) {
                __extends(Credits, _super);
                function Credits(chart, settings) {
                    var _this = this;
                    _super.call(this);
                    this.animationOrder = 2000;
                    this.paintOrder = 60;
                    this.updateOrder = 400;
                    this.settings = settings;
                    this.chart = chart;
                    this.scene = chart.scene;
                    if (settings.enabledOnExport || settings.enabled) {
                        // preload image
                        this.chart.assetsLoader.getAssetImage(this.settings.image, function (image) { return _this.imageLoaded(image); });
                        if (this.settings.imageExport && this.settings.image !== this.settings.imageExport) {
                            this.chart.assetsLoader.getAssetImage(this.settings.imageExport, function (image) { return _this.imageLoaded(image); });
                        }
                    }
                    var panel = this.panel = new Base.ChartPanel();
                    // this is first
                    panel.packingOrder = 0;
                    panel.side = "bottom";
                    panel.align = "right";
                    panel.visible = false;
                    panel.margin = 3;
                }
                Credits.prototype.onSceneChange = function (event) {
                    var ch = event.changes;
                    if (ch.settings && ch.settingsChanges.credits) {
                        ch.bounds = true;
                    }
                };
                Credits.prototype.getPanels = function (forExport) {
                    var _this = this;
                    var config = this.settings;
                    var enabled = forExport ? config.enabledOnExport : config.enabled;
                    var panel = this.panel;
                    if (enabled) {
                        panel.location = "outside";
                        panel.outsideEdge = true;
                        if (config.location === "outside") {
                            panel.floating = false;
                            if (forExport && !config.enabled) {
                                // outside and for export only, place external to the chart
                                panel.location = "external";
                            }
                        }
                        else {
                            panel.floating = true;
                        }
                        var i = this.chart.assetsLoader.getAssetImage(config.image, function (image) { return _this.imageLoaded(image); });
                        if (i) {
                            panel.desiredWidth = i.width * config.imageScaling;
                            panel.desiredHeight = i.height * config.imageScaling;
                            panel.visible = true;
                            return [panel];
                        }
                    }
                    // default = no panel
                    panel.visible = false;
                    return [];
                };
                Credits.prototype.paintScene = function (event) {
                    var _this = this;
                    var p = this.panel;
                    if (!p.visible) {
                        return;
                    }
                    var i = this.chart.assetsLoader.getAssetImage(this.settings.image, function (image) { return _this.imageLoaded(image); });
                    var ei = this.settings.imageExport ? (this.chart.assetsLoader.getAssetImage(this.settings.imageExport, function (image) { return _this.imageLoaded(image); })) : i;
                    if (event.isExport) {
                        i = ei;
                    }
                    if (i) {
                        event.context.drawImage(i, 0, 0, i.width, i.height, p.left, p.top, p.right - p.left, p.bottom - p.top);
                    }
                    else {
                        event.animating = true;
                    }
                };
                Credits.prototype.onPointerMove = function (event) {
                    var x = event.x;
                    var y = event.y;
                    var p = this.panel;
                    if (p.visible && x >= p.left && y >= p.top && x <= p.right && y <= p.bottom && this.settings.url) {
                        event.cursor = "pointer";
                    }
                };
                Credits.prototype.onClick = function (event) {
                    var x = event.x;
                    var y = event.y;
                    var p = this.panel;
                    var config = this.settings;
                    if (p.visible && x >= p.left && y >= p.top && x <= p.right && y <= p.bottom && config.url) {
                        Base.Helpers.openUrl(config.url, config.urlTarget);
                        event.consumed = true;
                    }
                };
                Credits.prototype.imageLoaded = function (image) {
                    // to re-update panels list
                    this.chart.updateSize(true);
                    this.chart.events.notifySceneChanges({ settings: true, settingsChanges: { credits: true } });
                };
                return Credits;
            }(Base.ChartElement));
            Base.Credits = Credits;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../License.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var Colors = (function () {
                function Colors() {
                }
                /**
                 * Checks if a color is a light color or a dark color. This can be used to select a contrasting color (white or black).
                 * @param color Color to check
                 */
                Colors.isLight = function (color) {
                    if (color == null)
                        return null;
                    return (color.R * 0.299 + color.G * 0.587 + color.B * 0.114) > 128;
                };
                Colors.format = function (color) {
                    if (color == null)
                        return null;
                    return "rgba(" + (color.R | 0) + "," + (color.G | 0) + "," + (color.B | 0) + "," + color.A.toFixed(3) + ")";
                };
                Colors.areEqual = function (a, b) {
                    if (a == null)
                        return b == null;
                    if (b == null)
                        return false;
                    return a.R === b.R
                        && a.G === b.G
                        && a.B === b.B
                        && a.A === b.A;
                };
                Colors.parse = function (color) {
                    var res = CssColorParser.parseCSSColor(color);
                    if (res == null && color) {
                        Base.Helpers.warn("Color value '" + color + "' could not be parsed.", null, true);
                    }
                    return res;
                };
                Colors.normalize = function (color) {
                    return this.format(CssColorParser.parseCSSColor(color));
                };
                Colors.derive = function (color, lighten, opacity) {
                    var str = typeof color === "string";
                    var c = str ? this.parse(color) : color;
                    var light = (lighten - 1) * 255;
                    var r = {
                        R: Math.round(Math.min(255, Math.max(0, c.R + light))),
                        G: Math.round(Math.min(255, Math.max(0, c.G + light))),
                        B: Math.round(Math.min(255, Math.max(0, c.B + light))),
                        A: Math.min(1, c.A * opacity)
                    };
                    return str ? this.format(r) : r;
                };
                Colors.blend = function (color1, color2, proportion, fast) {
                    if (fast === void 0) { fast = true; }
                    var str = typeof color1 === "string";
                    var c1 = str ? this.parse(color1) : color1;
                    var c2 = str ? this.parse(color2) : color2;
                    var r;
                    if (fast) {
                        var p1 = 1 - proportion;
                        r = {
                            R: Math.round(c2.R * proportion + c1.R * p1),
                            G: Math.round(c2.G * proportion + c1.G * p1),
                            B: Math.round(c2.B * proportion + c1.B * p1),
                            A: c2.A * proportion + c1.A * p1
                        };
                    }
                    else {
                        r = this._blendSlow(c1, c2, proportion);
                    }
                    return str ? this.format(r) : r;
                };
                Colors._blendSlow = function (color1, color2, proportion) {
                    var lab1 = this._rgb2lab(color1);
                    var lab2 = this._rgb2lab(color2);
                    var p1 = 1 - proportion;
                    var l = Math.round(lab2.L * proportion + lab1.L * p1);
                    var a = Math.round(lab2.A * proportion + lab1.A * p1);
                    var b = Math.round(lab2.B * proportion + lab1.B * p1);
                    var r = this._lab2rgb(l, a, b);
                    r.R = Math.max(0, Math.min(255, r.R));
                    r.G = Math.max(0, Math.min(255, r.G));
                    r.B = Math.max(0, Math.min(255, r.B));
                    // this assumes that _lab2rgb creates a new instance every time.
                    // if that is ever changed, this method should create a copy and not modify the source.
                    r.A = color2.A * proportion + color1.A * p1;
                    return r;
                };
                Colors.colorTone = function (color, lighten, opacity) {
                    var cc = this.parse(color);
                    var dC = this.derive(cc, lighten, opacity);
                    return { color: this.format(dC), opacity: cc.A };
                };
                Colors.copyHue = function (hue, brightness) {
                    var str = typeof hue === "string";
                    var hc = str ? this.parse(hue) : hue;
                    var bc = str ? this.parse(brightness) : brightness;
                    var br0 = (hc.R + hc.G + hc.B) / 765;
                    var br1 = (bc.R + bc.G + bc.B) / 765;
                    var r = {
                        R: Math.round(hc.R / br0 * br1),
                        G: Math.round(hc.G / br0 * br1),
                        B: Math.round(hc.B / br0 * br1),
                        A: bc.A
                    };
                    return str ? this.format(r) : r;
                };
                Colors.inverse = function (color) {
                    var str = typeof color === "string";
                    var c = str ? this.parse(color) : color;
                    var r = {
                        R: 255 - c.R,
                        G: 255 - c.G,
                        B: 255 - c.B,
                        A: c.A
                    };
                    return str ? this.format(r) : r;
                };
                /* The following conversion algorithms are from http://www.easyrgb.com/index.php?X=MATH */
                /** converts RGB value (without alpha) to XYZ. Note that the returned values are 0..1 instead of 0..100 */
                Colors._rgb2xyz = function (rgb) {
                    var r = rgb.R / 255;
                    var g = rgb.G / 255;
                    var b = rgb.B / 255;
                    // assume sRGB
                    r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
                    g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
                    b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);
                    return {
                        X: (r * 0.4124) + (g * 0.3576) + (b * 0.1805),
                        Y: (r * 0.2126) + (g * 0.7152) + (b * 0.0722),
                        Z: (r * 0.0193) + (g * 0.1192) + (b * 0.9505)
                    };
                };
                Colors._rgb2lab = function (rgb) {
                    if (rgb._lab)
                        return rgb._lab;
                    var xyz = this._rgb2xyz(rgb);
                    var x = xyz.X / 0.95047;
                    var y = xyz.Y;
                    var z = xyz.Z / 1.08883;
                    x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
                    y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
                    z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);
                    return rgb._lab = {
                        L: (116 * y) - 16,
                        A: 500 * (x - y),
                        B: 200 * (y - z)
                    };
                };
                /** converts XYZ to RGB. Assumes the arguments to be 0..1, not 0..100 */
                Colors._xyz2rgb = function (x, y, z) {
                    var r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
                    var g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
                    var b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);
                    // assume sRGB
                    r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055) : (r * 12.92);
                    g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055) : (g * 12.92);
                    b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055) : (b * 12.92);
                    return { R: Math.round(r * 255), G: Math.round(g * 255), B: Math.round(b * 255), A: 1 };
                };
                Colors._lab2rgb = function (l, a, b) {
                    var var_Y = (l + 16) / 116;
                    var var_X = a / 500 + var_Y;
                    var var_Z = var_Y - b / 200;
                    var_Y = (var_Y > this._lab2rgbConst) ? Math.pow(var_Y, 3) : ((var_Y - 16 / 116) / 7.787);
                    var_X = (var_X > this._lab2rgbConst) ? Math.pow(var_X, 3) : ((var_X - 16 / 116) / 7.787);
                    var_Z = (var_Z > this._lab2rgbConst) ? Math.pow(var_Z, 3) : ((var_Z - 16 / 116) / 7.787);
                    var res = this._xyz2rgb(0.95047 * var_X, var_Y, 1.08883 * var_Z);
                    res._lab = { L: l, A: a, B: b };
                    return res;
                };
                Colors._lab2rgbConst = Math.pow(0.008856, 1 / 3);
                return Colors;
            }());
            Base.Colors = Colors;
            /** (c) Dean McNamee <dean@gmail.com>, 2012.
                
                https://github.com/deanm/css-color-parser-js
                
                Permission is hereby granted, free of charge, to any person obtaining a copy
                of this software and associated documentation files (the "Software"), to
                deal in the Software without restriction, including without limitation the
                rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                sell copies of the Software, and to permit persons to whom the Software is
                furnished to do so, subject to the following conditions:
                
                The above copyright notice and this permission notice shall be included in
                all copies or substantial portions of the Software.
                
                THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
                FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
                IN THE SOFTWARE. */
            var CssColorParser = (function () {
                function CssColorParser() {
                }
                /** http://www.w3.org/TR/css3-color/
                Clamp to integer 0 .. 255. */
                CssColorParser.clamp_css_byte = function (int) {
                    // Seems to be what Chrome does (vs truncation).
                    int = Math.round(int);
                    return ((int < 0) ? 0 : ((int > 255) ? 255 : int));
                };
                /** Clamp to float 0.0 .. 1.0. */
                CssColorParser.clamp_css_float = function (float) {
                    return ((float < 0) ? 0 : ((float > 1) ? 1 : float));
                };
                /** int or percentage. */
                CssColorParser.parse_css_int = function (str) {
                    if (str[str.length - 1] === "%") {
                        return CssColorParser.clamp_css_byte(parseFloat(str) / 100 * 255);
                    }
                    return CssColorParser.clamp_css_byte(parseInt(str, 10));
                };
                /** float or percentage. */
                CssColorParser.parse_css_float = function (str) {
                    if (str[str.length - 1] === "%") {
                        return CssColorParser.clamp_css_float(parseFloat(str) / 100);
                    }
                    return CssColorParser.clamp_css_float(parseFloat(str));
                };
                CssColorParser.css_hue_to_rgb = function (m1, m2, h) {
                    if (h < 0) {
                        h += 1;
                    }
                    else {
                        if (h > 1) {
                            h -= 1;
                        }
                    }
                    if (h * 6 < 1) {
                        return m1 + (m2 - m1) * h * 6;
                    }
                    if (h * 2 < 1) {
                        return m2;
                    }
                    if (h * 3 < 2) {
                        return m1 + (m2 - m1) * (2 / 3 - h) * 6;
                    }
                    return m1;
                };
                /* tslint:disable:no-bitwise-smart */
                CssColorParser.parseCSSColor = function (css_str) {
                    if (css_str == null)
                        return { R: 0, G: 0, B: 0, A: 0 };
                    // Remove all whitespace, not compliant, but should just be more accepting.
                    var str = css_str.replace(RegExp(" ", "g"), "").toLowerCase();
                    // Color keywords (and transparent) lookup.
                    if (str in CssColorParser.kCSSColorTable) {
                        var colorArr = CssColorParser.kCSSColorTable[str];
                        return {
                            R: colorArr[0],
                            G: colorArr[1],
                            B: colorArr[2],
                            A: colorArr[3]
                        };
                    }
                    // #abc and #abc123 syntax.
                    if (str[0] === "#") {
                        if (str.length === 4) {
                            // TODO(deanm): Stricter parsing.
                            var iv = parseInt(str.substr(1), 16);
                            // Covers NaN.
                            if (!(iv >= 0 && iv <= 0xfff)) {
                                return null;
                            }
                            return {
                                R: ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
                                G: (iv & 0xf0) | ((iv & 0xf0) >> 4),
                                B: (iv & 0xf) | ((iv & 0xf) << 4),
                                A: 1
                            };
                        }
                        else if (str.length === 7) {
                            // TODO(deanm): Stricter parsing.
                            var iv = parseInt(str.substr(1), 16);
                            // Covers NaN.
                            if (!(iv >= 0 && iv <= 0xffffff)) {
                                return null;
                            }
                            return {
                                R: (iv & 0xff0000) >> 16,
                                G: (iv & 0xff00) >> 8,
                                B: iv & 0xff,
                                A: 1
                            };
                        }
                        return null;
                    }
                    var op = str.indexOf("(");
                    var ep = str.indexOf(")");
                    if (op !== -1 && ep + 1 === str.length) {
                        var fname = str.substr(0, op);
                        var params = str.substr(op + 1, ep - (op + 1)).split(",");
                        // To allow case fallthrough.
                        var alpha = 1;
                        if (fname === "rgba") {
                            if (params.length !== 4) {
                                return null;
                            }
                            alpha = CssColorParser.parse_css_float(params.pop());
                        }
                        // Fall through.
                        if (fname === "rgba" || fname === "rgb") {
                            if (params.length !== 3) {
                                return null;
                            }
                            return {
                                R: CssColorParser.parse_css_int(params[0]),
                                G: CssColorParser.parse_css_int(params[1]),
                                B: CssColorParser.parse_css_int(params[2]),
                                A: alpha
                            };
                        }
                        if (fname === "hsla") {
                            if (params.length !== 4) {
                                return null;
                            }
                            alpha = CssColorParser.parse_css_float(params.pop());
                        }
                        // Fall through.
                        if (fname === "hsla" || fname === "hsl") {
                            if (params.length !== 3) {
                                return null;
                            }
                            // 0 .. 1
                            var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;
                            /* NOTE(deanm): According to the CSS spec s/l should only be
                            percentages, but we don't bother and let float or percentage. */
                            var s = CssColorParser.parse_css_float(params[1]);
                            var l = CssColorParser.parse_css_float(params[2]);
                            var m2 = ((l <= 0.5) ? (l * (s + 1)) : (l + s - l * s));
                            var m1 = l * 2 - m2;
                            return {
                                R: CssColorParser.clamp_css_byte(CssColorParser.css_hue_to_rgb(m1, m2, h + 1 / 3) * 255),
                                G: CssColorParser.clamp_css_byte(CssColorParser.css_hue_to_rgb(m1, m2, h) * 255),
                                B: CssColorParser.clamp_css_byte(CssColorParser.css_hue_to_rgb(m1, m2, h - 1 / 3) * 255),
                                A: alpha
                            };
                        }
                    }
                    return null;
                };
                /* tslint:enable:no-bitwise-smart */
                CssColorParser.kCSSColorTable = {
                    transparent: [0, 0, 0, 0],
                    aliceblue: [240, 248, 255, 1],
                    antiquewhite: [250, 235, 215, 1],
                    aqua: [0, 255, 255, 1],
                    aquamarine: [127, 255, 212, 1],
                    azure: [240, 255, 255, 1],
                    beige: [245, 245, 220, 1],
                    bisque: [255, 228, 196, 1],
                    black: [0, 0, 0, 1],
                    blanchedalmond: [255, 235, 205, 1],
                    blue: [0, 0, 255, 1],
                    blueviolet: [138, 43, 226, 1],
                    brown: [165, 42, 42, 1],
                    burlywood: [222, 184, 135, 1],
                    cadetblue: [95, 158, 160, 1],
                    chartreuse: [127, 255, 0, 1],
                    chocolate: [210, 105, 30, 1],
                    coral: [255, 127, 80, 1],
                    cornflowerblue: [100, 149, 237, 1],
                    cornsilk: [255, 248, 220, 1],
                    crimson: [220, 20, 60, 1],
                    cyan: [0, 255, 255, 1],
                    darkblue: [0, 0, 139, 1],
                    darkcyan: [0, 139, 139, 1],
                    darkgoldenrod: [184, 134, 11, 1],
                    darkgray: [169, 169, 169, 1],
                    darkgreen: [0, 100, 0, 1],
                    darkgrey: [169, 169, 169, 1],
                    darkkhaki: [189, 183, 107, 1],
                    darkmagenta: [139, 0, 139, 1],
                    darkolivegreen: [85, 107, 47, 1],
                    darkorange: [255, 140, 0, 1],
                    darkorchid: [153, 50, 204, 1],
                    darkred: [139, 0, 0, 1],
                    darksalmon: [233, 150, 122, 1],
                    darkseagreen: [143, 188, 143, 1],
                    darkslateblue: [72, 61, 139, 1],
                    darkslategray: [47, 79, 79, 1],
                    darkslategrey: [47, 79, 79, 1],
                    darkturquoise: [0, 206, 209, 1],
                    darkviolet: [148, 0, 211, 1],
                    deeppink: [255, 20, 147, 1],
                    deepskyblue: [0, 191, 255, 1],
                    dimgray: [105, 105, 105, 1],
                    dimgrey: [105, 105, 105, 1],
                    dodgerblue: [30, 144, 255, 1],
                    firebrick: [178, 34, 34, 1],
                    floralwhite: [255, 250, 240, 1],
                    forestgreen: [34, 139, 34, 1],
                    fuchsia: [255, 0, 255, 1],
                    gainsboro: [220, 220, 220, 1],
                    ghostwhite: [248, 248, 255, 1],
                    gold: [255, 215, 0, 1],
                    goldenrod: [218, 165, 32, 1],
                    gray: [128, 128, 128, 1],
                    green: [0, 128, 0, 1],
                    greenyellow: [173, 255, 47, 1],
                    grey: [128, 128, 128, 1],
                    honeydew: [240, 255, 240, 1],
                    hotpink: [255, 105, 180, 1],
                    indianred: [205, 92, 92, 1],
                    indigo: [75, 0, 130, 1],
                    ivory: [255, 255, 240, 1],
                    khaki: [240, 230, 140, 1],
                    lavender: [230, 230, 250, 1],
                    lavenderblush: [255, 240, 245, 1],
                    lawngreen: [124, 252, 0, 1],
                    lemonchiffon: [255, 250, 205, 1],
                    lightblue: [173, 216, 230, 1],
                    lightcoral: [240, 128, 128, 1],
                    lightcyan: [224, 255, 255, 1],
                    lightgoldenrodyellow: [250, 250, 210, 1],
                    lightgray: [211, 211, 211, 1],
                    lightgreen: [144, 238, 144, 1],
                    lightgrey: [211, 211, 211, 1],
                    lightpink: [255, 182, 193, 1],
                    lightsalmon: [255, 160, 122, 1],
                    lightseagreen: [32, 178, 170, 1],
                    lightskyblue: [135, 206, 250, 1],
                    lightslategray: [119, 136, 153, 1],
                    lightslategrey: [119, 136, 153, 1],
                    lightsteelblue: [176, 196, 222, 1],
                    lightyellow: [255, 255, 224, 1],
                    lime: [0, 255, 0, 1],
                    limegreen: [50, 205, 50, 1],
                    linen: [250, 240, 230, 1],
                    magenta: [255, 0, 255, 1],
                    maroon: [128, 0, 0, 1],
                    mediumaquamarine: [102, 205, 170, 1],
                    mediumblue: [0, 0, 205, 1],
                    mediumorchid: [186, 85, 211, 1],
                    mediumpurple: [147, 112, 219, 1],
                    mediumseagreen: [60, 179, 113, 1],
                    mediumslateblue: [123, 104, 238, 1],
                    mediumspringgreen: [0, 250, 154, 1],
                    mediumturquoise: [72, 209, 204, 1],
                    mediumvioletred: [199, 21, 133, 1],
                    midnightblue: [25, 25, 112, 1],
                    mintcream: [245, 255, 250, 1],
                    mistyrose: [255, 228, 225, 1],
                    moccasin: [255, 228, 181, 1],
                    navajowhite: [255, 222, 173, 1],
                    navy: [0, 0, 128, 1],
                    oldlace: [253, 245, 230, 1],
                    olive: [128, 128, 0, 1],
                    olivedrab: [107, 142, 35, 1],
                    orange: [255, 165, 0, 1],
                    orangered: [255, 69, 0, 1],
                    orchid: [218, 112, 214, 1],
                    palegoldenrod: [238, 232, 170, 1],
                    palegreen: [152, 251, 152, 1],
                    paleturquoise: [175, 238, 238, 1],
                    palevioletred: [219, 112, 147, 1],
                    papayawhip: [255, 239, 213, 1],
                    peachpuff: [255, 218, 185, 1],
                    peru: [205, 133, 63, 1],
                    pink: [255, 192, 203, 1],
                    plum: [221, 160, 221, 1],
                    powderblue: [176, 224, 230, 1],
                    purple: [128, 0, 128, 1],
                    red: [255, 0, 0, 1],
                    rosybrown: [188, 143, 143, 1],
                    royalblue: [65, 105, 225, 1],
                    saddlebrown: [139, 69, 19, 1],
                    salmon: [250, 128, 114, 1],
                    sandybrown: [244, 164, 96, 1],
                    seagreen: [46, 139, 87, 1],
                    seashell: [255, 245, 238, 1],
                    sienna: [160, 82, 45, 1],
                    silver: [192, 192, 192, 1],
                    skyblue: [135, 206, 235, 1],
                    slateblue: [106, 90, 205, 1],
                    slategray: [112, 128, 144, 1],
                    slategrey: [112, 128, 144, 1],
                    snow: [255, 250, 250, 1],
                    springgreen: [0, 255, 127, 1],
                    steelblue: [70, 130, 180, 1],
                    tan: [210, 180, 140, 1],
                    teal: [0, 128, 128, 1],
                    thistle: [216, 191, 216, 1],
                    tomato: [255, 99, 71, 1],
                    turquoise: [64, 224, 208, 1],
                    violet: [238, 130, 238, 1],
                    wheat: [245, 222, 179, 1],
                    white: [255, 255, 255, 1],
                    whitesmoke: [245, 245, 245, 1],
                    yellow: [255, 255, 0, 1],
                    yellowgreen: [154, 205, 50, 1]
                };
                return CssColorParser;
            }());
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Colors.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            /** dashed line implementation backdrop for IE9 and IE10. */
            var GraphicsDashedLineContext = (function () {
                function GraphicsDashedLineContext(g, lineDash, fill) {
                    this.isFilling = fill;
                    this.lineDash = lineDash;
                    this.g = g;
                    this.beginPath();
                }
                GraphicsDashedLineContext.prototype.beginPath = function () {
                    this.remaining = this.lineDash[0];
                    this.dashes = [];
                    this.pos = 0;
                    this.x0 = 0;
                    this.y0 = 0;
                    this.x = 0;
                    this.y = 0;
                    this.hasPos = false;
                };
                GraphicsDashedLineContext.prototype.moveTo = function (x, y) {
                    this.y = y;
                    this.x = x;
                    if (this.isFilling) {
                        this.dashes.push(0, x, y);
                    }
                    this.g.moveTo(x, y);
                    this.x0 = x;
                    this.y0 = y;
                    this.hasPos = true;
                };
                GraphicsDashedLineContext.prototype.rect = function (x, y, w, h) {
                    this.moveTo(x, y);
                    this.lineTo(x + w, h);
                    this.lineTo(x + w, y + h);
                    this.lineTo(x, y + h);
                    this.lineTo(x, y);
                };
                GraphicsDashedLineContext.prototype.lineTo = function (xx, yy) {
                    if (this.isFilling) {
                        this.g.lineTo(xx, yy);
                    }
                    var dx = xx - this.x;
                    var dy = yy - this.y;
                    var x = this.x;
                    var y = this.y;
                    this.x = xx;
                    this.y = yy;
                    var len = Math.sqrt(dx * dx + dy * dy);
                    var invLen = 1 / len;
                    dx *= invLen;
                    dy *= invLen;
                    var dashLen = this.lineDash.length;
                    var dashPos = this.pos;
                    var dashRemaining = this.remaining;
                    while (true) {
                        var dlen = Math.min(len, dashRemaining);
                        x += dx * dlen;
                        y += dy * dlen;
                        if (dashPos % 2 === 0) {
                            if (this.isFilling) {
                                this.dashes.push(1, x, y);
                            }
                            else {
                                this.g.lineTo(x, y);
                            }
                        }
                        else {
                            if (this.isFilling) {
                                this.dashes.push(0, x, y);
                            }
                            else {
                                this.g.moveTo(x, y);
                            }
                        }
                        if (len > dlen) {
                            dashPos = (dashPos + 1) % dashLen;
                            dashRemaining = this.lineDash[dashPos];
                            len -= dlen;
                        }
                        else {
                            dashRemaining -= dlen;
                            break;
                        }
                    }
                    this.pos = dashPos;
                    this.remaining = dashRemaining;
                    this.hasPos = true;
                };
                GraphicsDashedLineContext.prototype.arc = function (centerX, centerY, radius, angleFrom, angleTo, counterClockwise) {
                    var PI2 = Math.PI * 2;
                    var da = Math.min(0.6, 2 / radius);
                    var c = Math.cos(da);
                    var s = Math.sin(da);
                    var y = Math.sin(angleFrom) * radius;
                    var x = Math.cos(angleFrom) * radius;
                    var yt = Math.sin(angleTo) * radius;
                    var xt = Math.cos(angleTo) * radius;
                    if (!this.hasPos) {
                        this.moveTo(centerX + x, centerY + y);
                        this.hasPos = true;
                    }
                    if (counterClockwise) {
                        if (angleFrom < angleTo) {
                            angleFrom += PI2;
                        }
                        var d = (angleFrom - angleTo) / da;
                        for (var i = d; i >= 0; i--) {
                            if (i - 1 <= 0) {
                                // target angle reached
                                this.lineTo(centerX + xt, centerY + yt);
                                break;
                            }
                            this.lineTo(centerX + x, centerY + y);
                            var xp = x * c + y * s;
                            var yp = -x * s + y * c;
                            x = xp;
                            y = yp;
                        }
                    }
                    else {
                        if (angleFrom > angleTo) {
                            angleFrom -= 2 * Math.PI;
                        }
                        var d = (angleTo - angleFrom) / da;
                        for (var i = d; i >= 0; i--) {
                            if (i - 1 <= 0) {
                                this.lineTo(centerX + xt, centerY + yt);
                                break;
                            }
                            this.lineTo(centerX + x, centerY + y);
                            // cc
                            var xp = x * c - y * s;
                            var yp = x * s + y * c;
                            x = xp;
                            y = yp;
                        }
                    }
                };
                GraphicsDashedLineContext.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {
                    // TODO: implement quadratic curve for the dashed line context.
                    this.lineTo(cpx, cpy);
                    this.lineTo(x, y);
                };
                GraphicsDashedLineContext.prototype.bezierCurveTo = function (x0, y0, x1, y1, x2, y2) {
                    throw new Error("Bezier curves in dashed line context haven't been implemented yet");
                };
                GraphicsDashedLineContext.prototype.closePath = function () {
                    this.lineTo(this.x0, this.y0);
                };
                GraphicsDashedLineContext.prototype.strokeDashes = function () {
                    var d = this.dashes;
                    for (var i = 0; i < d.length; i += 3) {
                        var m = d[i];
                        var x = d[i + 1];
                        var y = d[i + 2];
                        if (m === 0) {
                            this.g.moveTo(x, y);
                        }
                        else {
                            this.g.lineTo(x, y);
                        }
                    }
                };
                return GraphicsDashedLineContext;
            }());
            Base.GraphicsDashedLineContext = GraphicsDashedLineContext;
            var Graphics = (function () {
                function Graphics() {
                }
                Graphics.stroke = function (g, st) {
                    if (st.lineWidth === 0 || !st.lineColor)
                        return;
                    g.lineWidth = st.lineWidth || 1;
                    g.strokeStyle = st.lineColor;
                    if (st.lineDash && typeof g.setLineDash !== "undefined") {
                        // IE8-11 and Opera
                        g.setLineDash(st.lineDash);
                        g.stroke();
                        g.setLineDash([]);
                    }
                    else {
                        g.stroke();
                    }
                    if (st.lineWidth) {
                        g.lineWidth = 1;
                    }
                };
                Graphics.strokeWithShadow = function (g, st) {
                    if (st.lineWidth === 0 || !(st.lineColor && !st.shadowColor))
                        return;
                    if (st.shadowColor) {
                        g.shadowOffsetX = st.shadowOffsetX;
                        g.shadowOffsetY = st.shadowOffsetY;
                        g.shadowBlur = st.shadowBlur;
                        g.shadowColor = st.shadowColor;
                    }
                    g.lineWidth = st.lineWidth || 1;
                    g.strokeStyle = st.lineColor;
                    g.stroke();
                    if (st.lineWidth) {
                        g.lineWidth = 1;
                    }
                    if (st.shadowColor) {
                        g.shadowBlur = 0;
                        g.shadowColor = "transparent";
                    }
                };
                Graphics.beginStroke = function (g, style, fill) {
                    if (fill === void 0) { fill = false; }
                    g.beginPath();
                    if (style.lineColor && style.lineDash && style.lineDash.length > 1 && typeof g.setLineDash === "undefined") {
                        if (fill && !style.fillColor) {
                            fill = false;
                        }
                        // use backdrop implementation
                        return new GraphicsDashedLineContext(g, style.lineDash, fill);
                    }
                    else {
                        // everything will be done with regular context
                        return g;
                    }
                };
                Graphics.endStroke = function (g, strokeContext, style, fill) {
                    if (fill === void 0) { fill = false; }
                    if (strokeContext instanceof GraphicsDashedLineContext) {
                        if (strokeContext.isFilling) {
                            Graphics.fill(g, style);
                            // do the stroke from buffer
                            g.beginPath();
                            strokeContext.strokeDashes();
                        }
                        Graphics.strokeWithShadow(g, style);
                    }
                    else if (fill) {
                        Graphics.paint(g, style);
                    }
                    else {
                        Graphics.stroke(g, style);
                    }
                };
                Graphics.beginStrokeAndFill = function (g, style) {
                    return Graphics.beginStroke(g, style, true);
                };
                Graphics.endStrokeAndFill = function (g, strokeContext, style) {
                    return Graphics.endStroke(g, strokeContext, style, true);
                };
                Graphics.fill = function (g, st) {
                    if (!st.fillColor) {
                        return;
                    }
                    g.fillStyle = st.fillColor;
                    if (st.shadowColor) {
                        g.shadowOffsetX = st.shadowOffsetX;
                        g.shadowOffsetY = st.shadowOffsetY;
                        g.shadowBlur = st.shadowBlur;
                        g.shadowColor = st.shadowColor;
                    }
                    g.fill();
                    if (st.shadowColor) {
                        g.shadowBlur = 0;
                        g.shadowColor = "transparent";
                    }
                };
                Graphics.paint = function (g, st) {
                    if (st.shadowColor) {
                        g.shadowOffsetX = st.shadowOffsetX;
                        g.shadowOffsetY = st.shadowOffsetY;
                        g.shadowBlur = st.shadowBlur;
                        g.shadowColor = st.shadowColor;
                    }
                    if (st.fillColor) {
                        g.fillStyle = st.fillColor;
                        g.fill();
                    }
                    if (st.lineWidth !== 0 && st.lineColor) {
                        g.lineWidth = st.lineWidth || 1;
                        g.strokeStyle = st.lineColor;
                        if (st.lineDash && typeof g.setLineDash !== typeof void 0) {
                            g.setLineDash(st.lineDash);
                            g.stroke();
                            g.setLineDash([]);
                        }
                        else {
                            g.stroke();
                        }
                    }
                    if (st.shadowColor) {
                        g.shadowBlur = 0;
                        g.shadowColor = "transparent";
                    }
                };
                Graphics.textStyle = function (g, st) {
                    if (g.__textStyle) {
                        this.resetTextStyle(g);
                    }
                    var fillColor = st.fillColor;
                    if (fillColor === void 0)
                        fillColor = "#000";
                    g.fillStyle = fillColor;
                    g.__font = g.font = st.font || null;
                    if (st.shadowColor) {
                        g.shadowOffsetX = st.shadowOffsetX;
                        g.shadowOffsetY = st.shadowOffsetY;
                        g.shadowBlur = st.shadowBlur;
                        g.shadowColor = st.shadowColor;
                    }
                    if (st.outlineColor) {
                        g.strokeStyle = st.outlineColor;
                        g.lineWidth = (st.outlineWidth || 1) * 2;
                        g.lineJoin = st.outlineJoin || "miter";
                        g.miterLimit = 2;
                    }
                    g.__textStyle = st;
                };
                Graphics.getTextWidth = function (g, st, text) {
                    if (st) {
                        var f = st.font;
                        if (g.__font !== f) {
                            // adding the custom property seems to be approx 2x times faster (Chrome) than retrieving the value of the default property
                            g.__textStyle = null;
                            g.__font = g.font = f || null;
                        }
                    }
                    var res = g.measureText(text).width;
                    if (st.outlineColor) {
                        res += (st.outlineWidth || 1) * 2;
                    }
                    return res;
                };
                Graphics.drawText = function (g, st, text, x, y) {
                    if (g.__textStyle !== st) {
                        this.textStyle(g, st);
                    }
                    if (text == null || !text.length)
                        return;
                    if (st.outlineColor) {
                        g.strokeText(text, x, y);
                    }
                    g.fillText(text, x, y);
                };
                Graphics.resetTextStyle = function (g) {
                    g.__font = null;
                    var st = g.__textStyle;
                    if (st) {
                        if (st.shadowColor) {
                            g.shadowColor = "transparent";
                            g.shadowBlur = 0;
                        }
                        if (st.outlineColor) {
                            g.lineJoin = "miter";
                            g.miterLimit = 10;
                            g.lineWidth = 1;
                        }
                        g.__textStyle = null;
                    }
                };
                /** Calls `.restore()` on the context and also clears any custom caches associated with it. */
                Graphics.restore = function (g) {
                    this.resetTextStyle(g);
                    g.restore();
                };
                /**
                @deprecated - use beginStrokeAndFill() instead.
                */
                Graphics.rectStyle = function (g, st) {
                    if (st.lineColor !== void 0) {
                        g.strokeStyle = st.lineColor;
                    }
                    if (st.fillColor !== void 0) {
                        g.fillStyle = st.fillColor;
                    }
                    if (st.lineWidth !== void 0) {
                        g.lineWidth = st.lineWidth;
                    }
                };
                Graphics.pushClip = function (event, x, y, w, h) {
                    var g = event.context;
                    var sx = event.scaleX;
                    var sy = event.scaleY;
                    if ((sx !== 1 || sy !== 1) && window.screen.deviceXDPI) {
                        // this workaround is required for Windows Phone devices that use scaling on canvas.
                        // without it the draws within the clipped region will result in canvas memory corruption.
                        // note that `deviceXDPI` check will also match desktop IE and Edge
                        g.save();
                        g.setTransform(1, 0, 0, 1, 0, 0);
                        g.beginPath();
                        g.rect((x * sx) | 0, (y * sy) | 0, (w * sx) | 0, (h * sy) | 0);
                        g.clip();
                        g.setTransform(sx, 0, 0, sy, 0, 0);
                    }
                    else {
                        g.save();
                        g.beginPath();
                        g.rect(x, y, w, h);
                        g.clip();
                    }
                };
                Graphics.popClip = function (event) {
                    this.restore(event.context);
                };
                Graphics.arcBetweenTwoPoints = function (g, x, y, r, x0, y0, x1, y1) {
                    // middle point
                    var mx = (x0 + x1) / 2;
                    var my = (y0 + y1) / 2;
                    // orthogonal vector
                    var px = y1 - y0;
                    var py = x0 - x1;
                    // length of both vectors
                    var lenSq = (px * px + py * py);
                    if (lenSq === 0) {
                        return;
                    }
                    var len = Math.sqrt(lenSq);
                    // enlarge radius if needed
                    r = Math.min(Math.max(r, len / 2), len * 3);
                    // distance along p to go form M = sqrt(r*r - lenSq /4)/len
                    var d = Math.sqrt(r * r / lenSq - 0.25);
                    // c1 = m + p * d;
                    var xa = mx + px * d;
                    var ya = my + py * d;
                    // c2 = m - p * d;
                    var xb = mx - px * d;
                    var yb = my - py * d;
                    // get closest to xy
                    var d1 = (xa - x) * (xa - x) + (ya - y) * (ya - y);
                    var d2 = (xb - x) * (xb - x) + (yb - y) * (yb - y);
                    if (d1 > d2) {
                        x = xb;
                        y = yb;
                    }
                    else {
                        x = xa;
                        y = ya;
                    }
                    var a1 = Math.atan2(y0 - y, x0 - x);
                    var a2 = Math.atan2(y1 - y, x1 - x);
                    if (a2 < a1) {
                        a2 += Math.PI * 2;
                    }
                    var counterclockwise = Math.abs(a1 - a2) > Math.PI;
                    g.arc(x, y, r, a1, a2, counterclockwise);
                };
                Graphics.strokeMarker = function (g, shape, x, y, r) {
                    var d2 = r * 1.41421356237;
                    switch (shape) {
                        case "rect":
                        case "square":
                            g.moveTo(x - r, y - r);
                            g.lineTo(x + r, y - r);
                            g.lineTo(x + r, y + r);
                            g.lineTo(x - r, y + r);
                            g.lineTo(x - r, y - r);
                            break;
                        case "romb":
                        case "rhombus":
                            d2 = d2 * .9;
                            g.moveTo(x - d2, y);
                            g.lineTo(x, y - d2);
                            g.lineTo(x + d2, y);
                            g.lineTo(x, y + d2);
                            g.lineTo(x - d2, y);
                            break;
                        case "triangle":
                            var addFromCenter = Graphics.SQRT3D6 * (r * 3);
                            g.moveTo(x - r, y + addFromCenter);
                            g.lineTo(x + r, y + addFromCenter);
                            g.lineTo(x, y - addFromCenter);
                            g.lineTo(x - r, y + addFromCenter);
                            break;
                        case "triangle2":
                            g.moveTo(x - d2, y - d2);
                            g.lineTo(x + d2, y - d2);
                            g.lineTo(x, y + d2);
                            g.lineTo(x - d2, y - d2);
                            break;
                        case "circle":
                            g.moveTo(x + r, y);
                            g.arc(x, y, r, 0, Math.PI * 2, false);
                            break;
                        default:
                            throw new Error("Unknown marker shape " + shape + ". Valid values are `square`, `rhombus`, `triangle`, `triangle2`, `circle`.");
                    }
                };
                Graphics.strokeBalloon = function (g, x0, y0, w, h) {
                    w = Math.max(w, h * 2);
                    var m = 5;
                    var s = 4;
                    var r = (h + s * 2) / 2;
                    var x = x0;
                    var y = y0;
                    g.moveTo(x, y);
                    x += 3;
                    y += m + 1;
                    g.lineTo(x, y);
                    x += w - s;
                    g.lineTo(x, y);
                    g.arc(x, y + r, r, -Math.PI / 2, Math.PI / 2);
                    y += r * 2;
                    x -= w - s;
                    g.lineTo(x, y);
                    g.arc(x, y - r, r, Math.PI * 0.5, Math.PI * 1.3);
                    g.closePath();
                };
                Graphics.strokeBalloon2 = function (g, x0, y0, w, h) {
                    var s = 4;
                    var r = (h + s * 2) / 2;
                    w = Math.max(w, h * 2) / 2 - s;
                    var x = x0 + w;
                    var y = y0 - r;
                    g.moveTo(x, y);
                    g.arc(x, y + r, r, -Math.PI / 2, Math.PI / 2, false);
                    y += r * 2;
                    x -= w * 2;
                    g.lineTo(x, y);
                    g.arc(x, y - r, r, Math.PI * 0.5, Math.PI * 1.5, false);
                    g.closePath();
                };
                Graphics.applyColorToImage = function (image, color, ignoreTransparent) {
                    if (ignoreTransparent === void 0) { ignoreTransparent = true; }
                    var parsedColor = Base.Colors.parse(color);
                    var r = parsedColor.R;
                    var g = parsedColor.G;
                    var b = parsedColor.B;
                    var c = document.createElement("canvas");
                    var w = c.width = image.width;
                    var h = c.height = image.height;
                    var gr = c.getContext("2d");
                    gr.drawImage(image, 0, 0);
                    var cData = gr.getImageData(0, 0, w, h);
                    var data = cData.data;
                    // condition unrolling for peformance
                    if (ignoreTransparent) {
                        for (var i = 0; i <= data.length; i += 4) {
                            // process only fully opaque pixels
                            if (data[i + 3] !== 255) {
                                continue;
                            }
                            data[i] = (data[i] * r) >> 8;
                            data[i + 1] = (data[i + 1] * g) >> 8;
                            data[i + 2] = (data[i + 2] * b) >> 8;
                        }
                    }
                    else {
                        for (var i = 0; i <= data.length; i += 4) {
                            data[i] = (data[i] * r) >> 8;
                            data[i + 1] = (data[i + 1] * g) >> 8;
                            data[i + 2] = (data[i + 2] * b) >> 8;
                        }
                    }
                    gr.putImageData(cData, 0, 0);
                    return c;
                };
                Graphics.cropImageToCircle = function (image, mode) {
                    var minSize = Math.min(image.width, image.height);
                    var maxSize = Math.max(image.width, image.height);
                    var size = Math.min(maxSize, minSize * 2);
                    var canvas = document.createElement("canvas");
                    canvas.width = size;
                    canvas.height = size;
                    var g = canvas.getContext("2d");
                    var w = image.width;
                    var h = image.height;
                    g.fillStyle = "rgba(0,0,0,1)";
                    g.beginPath();
                    g.arc(size / 2, size / 2, size / 2, 0, -Math.PI * 2, false);
                    g.fill();
                    var old = g.globalCompositeOperation;
                    g.globalCompositeOperation = "source-in";
                    if (mode === "crop") {
                        var r = Math.min(w, h) / 2;
                        g.drawImage(image, w / 2 - r, h / 2 - r, r * 2, r * 2, 0, 0, size, size);
                    }
                    else if (mode === "letterbox") {
                        g.fillStyle = "black";
                        g.fillRect(0, 0, size, size);
                        var scale = size / Math.max(w, h);
                        g.drawImage(image, 0, 0, w, h, size / 2 - w / 2 * scale, size / 2 - h / 2 * scale, w * scale, h * scale);
                    }
                    else if (mode === "fit") {
                        g.fillStyle = "black";
                        g.fillRect(0, 0, size, size);
                        var scale = size / Math.sqrt(w * w + h * h);
                        g.drawImage(image, 0, 0, w, h, size / 2 - w / 2 * scale, size / 2 - h / 2 * scale, w * scale, h * scale);
                    }
                    else {
                        // just stretch the image
                        g.drawImage(image, 0, 0, w, h, 0, 0, size, size);
                    }
                    g.globalCompositeOperation = old;
                    return canvas;
                };
                /**
                 * @deprecated - should not be used for new code.
                 */
                Graphics.applyShadow = function (g, style) {
                    if (style.shadowColor) {
                        g.shadowOffsetX = style.shadowOffsetX;
                        g.shadowOffsetY = style.shadowOffsetY;
                        g.shadowBlur = style.shadowBlur;
                        g.shadowColor = style.shadowColor;
                    }
                };
                Graphics.clearShadow = function (g) {
                    g.shadowBlur = 0;
                    g.shadowColor = "transparent";
                };
                Graphics.drawImageInSquare = function (g, im, ix0, iy0, iw, ih, cx, cy, radius) {
                    var scale = radius / Math.max(iw, ih);
                    var iww = iw * scale;
                    var ihh = ih * scale;
                    this.drawImageHighQuality(g, im, ix0, iy0, iw, ih, cx - iww, cy - ihh, iww * 2, ihh * 2);
                };
                Graphics.drawImageHighQuality = function (target, image, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, canvasImageWidth, canvasImageHeight) {
                    if (canvasOffsetX === void 0) {
                        canvasOffsetX = offsetX;
                        canvasOffsetY = offsetY;
                        canvasImageWidth = width;
                        canvasImageHeight = height;
                        width = image.width;
                        height = image.height;
                        offsetX = 0;
                        offsetY = 0;
                    }
                    // if the source canvas is transformed to use scaling, the painted image has to take that into account
                    // since the internal actual drawing will be done on device pixels, not the upscaled pixels.
                    var scaleX = target.__scaleX || 1;
                    var scaleY = target.__scaleY || 1;
                    // do not draw anything that is smaller than 1px.
                    if (canvasImageHeight < 1 / scaleY || canvasImageWidth < 1 / scaleX) {
                        return;
                    }
                    var currentWidth = width;
                    var currentHeight = height;
                    var currentImage = image;
                    var scale = 1;
                    var sliceKey = "__size:" + offsetX + "/" + offsetY + "/" + width + "/" + height + "/";
                    // the whole image is resized even if only a part of it would be drawn. this is done because it is likely that the sprite image
                    // will be used for other nodes as well so the resize would only be done the first time.
                    // note that currently if the aspect ratio of the image is changed very often, the cache this method creates could consume large
                    // amount of memory.
                    while (currentWidth >= canvasImageWidth * scaleX * 2 && currentHeight >= canvasImageHeight * scaleY * 2) {
                        var resizedWidth = Math.round(currentWidth / 2);
                        var resizedHeight = Math.round(currentHeight / 2);
                        scale = scale / 2;
                        var cacheKey = sliceKey + scale;
                        var resizedImage = image[cacheKey];
                        if (!resizedImage) {
                            resizedImage = image[cacheKey] = document.createElement("canvas");
                            resizedImage.width = resizedWidth;
                            resizedImage.height = resizedHeight;
                            var context = resizedImage.getContext("2d");
                            context.drawImage(currentImage, offsetX, offsetY, currentWidth, currentHeight, 0, 0, resizedWidth, resizedHeight);
                        }
                        offsetX = 0;
                        offsetY = 0;
                        currentImage = resizedImage;
                        currentHeight = resizedHeight;
                        currentWidth = resizedWidth;
                    }
                    target.drawImage(currentImage, offsetX, offsetY, currentWidth | 0, currentHeight | 0, canvasOffsetX, canvasOffsetY, canvasImageWidth, canvasImageHeight);
                };
                Graphics.getTextHeight = function (g, font) {
                    var cache = Graphics._heightCache;
                    if (cache.hasOwnProperty(font)) {
                        return cache[font];
                    }
                    var dummy = Graphics._heightElem;
                    if (!dummy) {
                        var container = document.createElement("div");
                        container.className = "DVSL-font-height";
                        Graphics._heightElem = dummy = document.createElement("div");
                        dummy.appendChild(document.createTextNode("Mg9!"));
                        container.appendChild(dummy);
                        document.body.appendChild(container);
                    }
                    dummy.style.font = font;
                    var bounds = dummy.getBoundingClientRect();
                    if (bounds.top >= 0 && bounds.left >= 0) {
                        Base.Helpers.error("getTextHeight called before CSS loaded");
                        return bounds.height;
                    }
                    else {
                        return cache[font] = bounds.height;
                    }
                };
                Graphics.SQRT3D6 = Math.sqrt(3) / 6;
                Graphics._heightElem = null;
                Graphics._heightCache = {};
                return Graphics;
            }());
            Base.Graphics = Graphics;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="core/ChartEvents.ts" />
/// <reference path="Graphics.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var SettingsTitle = (function () {
                function SettingsTitle() {
                    /** Show/hide chart title */
                    this.enabled = true;
                    /** Whether to display title on the exported image. Note that it does not affect chart. */
                    this.enabledOnExport = true;
                    /** Alignment of the title text.
                    @type enum
                    @value center
                    @value left
                    @value right */
                    this.align = "center";
                    /** Margin around title text, in px.
                    @type float
                    @units pixels */
                    this.margin = 25;
                    /** Title style */
                    this.style = {
                        font: "20px Arial",
                        fillColor: "#000"
                    };
                    /** Title text. */
                    this.text = "";
                }
                return SettingsTitle;
            }());
            Base.SettingsTitle = SettingsTitle;
            var Title = (function (_super) {
                __extends(Title, _super);
                function Title(chart) {
                    var _this = this;
                    _super.call(this);
                    this.lineSpacing = 0;
                    this.animationOrder = 2000;
                    this.paintOrder = 55;
                    this.updateOrder = 500;
                    this.chart = chart;
                    this.scene = chart.scene;
                    this.settings = this.scene.settings.title;
                    // right after credits
                    this.panel = new Base.ChartPanel();
                    this.panel.packingOrder = 10;
                    this.panel.side = "top";
                    this.panel.outsideEdge = true;
                    this.panel.align = "fill";
                    this.panel.visible = false;
                    this.panel.computeSize = function (aw, ah, g) { return _this.computePanelSize(aw, ah, g); };
                    this.lines = null;
                }
                Title.prototype.onSceneChange = function (event) {
                    var ch = event.changes;
                    if (ch.settings && ch.settingsChanges.title) {
                        ch.bounds = true;
                    }
                };
                Title.prototype.getPanels = function (forExport) {
                    var config = this.settings;
                    this.panel.visible = !!config.text && (forExport ? config.enabledOnExport : config.enabled);
                    if (this.panel.visible) {
                        this.panel.margin = config.margin;
                        if (forExport && !config.enabled) {
                            // place panel externally
                            this.panel.location = "external";
                        }
                        else {
                            // place normally
                            this.panel.location = "outside";
                        }
                        return [this.panel];
                    }
                    else {
                        return [];
                    }
                };
                Title.prototype.computePanelSize = function (availableWidth, availableHeight, g) {
                    if (!this.chart.assetsLoaded)
                        return { width: 0, height: 0 };
                    this.lines = [];
                    var text = this.settings.text;
                    var style = this.settings.style;
                    g.save();
                    var w = Base.Graphics.getTextWidth(g, style, text);
                    var h = Base.Graphics.getTextHeight(g, style.font);
                    this.lineSpacing = h * 1.15;
                    // split into multiple lines
                    if (w > availableWidth) {
                        // split into lines
                        var width = 0;
                        var words = text.split(" ");
                        var line = words[0];
                        var lineWidth = Base.Graphics.getTextWidth(g, style, line);
                        for (var i = 1; i <= words.length - 1; i++) {
                            var line1 = line + " " + words[i];
                            var line1Width = Base.Graphics.getTextWidth(g, style, line1);
                            if (line1Width <= availableWidth) {
                                line = line1;
                                lineWidth = line1Width;
                            }
                            else {
                                // line too long, start new line
                                this.lines.push(line);
                                w = Math.max(w, lineWidth);
                                line = words[i];
                                lineWidth = Base.Graphics.getTextWidth(g, style, line);
                            }
                        }
                        this.lines.push(line);
                        w = Math.max(width, lineWidth);
                    }
                    else {
                        this.lines.push(text);
                    }
                    Base.Graphics.restore(g);
                    h = (this.lines.length - 1) * this.lineSpacing + h;
                    return { width: w, height: h };
                };
                Title.prototype.paintScene = function (event) {
                    if (!this.panel.visible || !this.lines) {
                        return;
                    }
                    var title = this.settings;
                    var g = event.context;
                    var left = this.panel.left;
                    var right = this.panel.right;
                    var y = this.panel.top;
                    var style = title.style;
                    g.textBaseline = "top";
                    var x;
                    if (title.align === "left") {
                        g.textAlign = "start";
                        x = left;
                    }
                    else if (title.align === "right") {
                        g.textAlign = "end";
                        x = right;
                    }
                    else {
                        g.textAlign = "center";
                        x = (left + right) / 2;
                    }
                    for (var lineIndex = 0; lineIndex < this.lines.length; lineIndex++) {
                        Base.Graphics.drawText(g, style, this.lines[lineIndex], x, y);
                        y += this.lineSpacing;
                    }
                    Base.Graphics.resetTextStyle(g);
                };
                return Title;
            }(Base.ChartElement));
            Base.Title = Title;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Graphics.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var Label = (function () {
                function Label(style, styleByRef) {
                    if (styleByRef === void 0) { styleByRef = false; }
                    /** The style settings used to render this label. */
                    this.style = { textStyle: {} };
                    this._textOverride = void 0;
                    this.visible = true;
                    /**@ignore */ this.allowCache = true;
                    /**@ignore */ this.shouldBeVisible = true;
                    /**@ignore */ this.userPlaced = false;
                    /**@ignore */ this.rows = null;
                    /**@ignore */ this.lineHeight = 0;
                    /** with line spacing
                    @ignore */
                    this.lineHeightM = 0;
                    this.hwidth = null;
                    this.hheight = null;
                    /** The bounds from where the label was last rendered.
                    @ignore */
                    this.currentBounds = null;
                    /** per label specific use
                    @ignore */
                    this.x = null;
                    /** @ignore */
                    this.originX = null;
                    /** per label specific use
                    @ignore */
                    this.y = null;
                    /**@ignore*/
                    this.prop = null;
                    /** If set to true, the image specified for this label is still being loaded. */
                    this._pendingImage = false;
                    this._textCache = null;
                    /** The styles used when measure() was last called on the label. */
                    this._measureStyles = null;
                    if (!style.textStyle)
                        style.textStyle = {};
                    if (style.lineSpacing == null)
                        style.lineSpacing = 0.2;
                    if (styleByRef) {
                        this.style = style;
                    }
                    else {
                        this.style = Base.Helpers.realClone(style);
                    }
                }
                Object.defineProperty(Label.prototype, "text", {
                    /** The text the label renders. This property overrides the text specified in the style settings. */
                    get: function () {
                        var o = this._textOverride;
                        if (o === void 0) {
                            o = this.style.text;
                            if (o != null && typeof o !== "string")
                                o = "" + o;
                        }
                        return o;
                    },
                    set: function (value) {
                        if (value === void 0)
                            value = null;
                        if (value != null && typeof value !== "string")
                            value = "" + value;
                        this._textOverride = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                ;
                /** @ignore */
                Label.prototype.needTextParsing = function () {
                    var cache = this._textCache;
                    return !cache || cache.sourceText !== this.text || cache.sourceFont !== this.style.textStyle.font;
                };
                /** Returns `null` when the measure is needed but the measurement was done through a custom measurement
                method.
                @ignore */
                Label.prototype.needMeasure = function () {
                    var cache = this._measureStyles;
                    var isCustom = cache && cache.customMeasure;
                    if (this._pendingImage)
                        return isCustom ? null : true;
                    var style = this.style;
                    var textStyle = style.textStyle;
                    var result = !cache
                        || cache.align !== style.align
                        || cache.text !== this.text
                        || cache.aspectRatio !== style.aspectRatio
                        || cache.borderRadius !== style.borderRadius
                        || cache.font !== textStyle.font
                        || cache.image !== style.image
                        || cache.imageSlicing !== "" + style.imageSlicing
                        || cache.margin !== style.margin
                        || cache.maxWidth !== style.maxWidth
                        || cache.padding !== style.padding;
                    if (result && isCustom)
                        return null;
                    return result;
                };
                /** @ignore */
                Label.prototype.measureComplete = function (customMeasure) {
                    var style = this.style;
                    var textStyle = style.textStyle;
                    this._measureStyles = {
                        customMeasure: customMeasure,
                        text: this.text,
                        align: style.align,
                        aspectRatio: style.aspectRatio,
                        borderRadius: style.borderRadius,
                        font: textStyle.font,
                        image: style.image,
                        imageSlicing: "" + style.imageSlicing,
                        lineSpacing: style.lineSpacing,
                        margin: style.margin,
                        maxWidth: style.maxWidth,
                        padding: style.padding
                    };
                };
                return Label;
            }());
            Base.Label = Label;
            var LabelRenderer = (function () {
                function LabelRenderer(settings, assetsLoader, chartContainer) {
                    this.cache = {};
                    this.frameLabels = {};
                    this.numPaints = 0;
                    this.numCachedPaints = 0;
                    /** If set to `false`, label cache will not be used even if it is enabled in the settings. */
                    this.allowCache = true;
                    this.chartArea = 0;
                    this.scaleX = 0;
                    this.scaleY = 0;
                    this.settings = settings;
                    this.assetsLoader = assetsLoader;
                    if (!chartContainer)
                        throw new Error("chartContainer must be specified");
                    this.chartContainer = chartContainer;
                }
                LabelRenderer.prototype.startFrame = function (width, height, scaleX, scaleY) {
                    this.chartArea = width * height;
                    this.scaleX = scaleX;
                    this.scaleY = scaleY;
                };
                LabelRenderer.prototype.finishFrame = function () {
                    // compact the cache
                    var cc = Base.Helpers.countProperties(this.cache);
                    // if the cache is small enough, do not do the compaction
                    if (cc < 1000)
                        return;
                    var fc = Base.Helpers.countProperties(this.frameLabels);
                    if (cc > fc * 3) {
                        for (var k in this.cache) {
                            if (!this.frameLabels[k]) {
                                delete this.cache[k];
                            }
                        }
                    }
                    this.frameLabels = {};
                };
                LabelRenderer.prototype.measure = function (g, item) {
                    var needMeasure = item.needMeasure();
                    if (needMeasure !== true) {
                        if (needMeasure === null) {
                            throw new Error("Label.needMeasure assert.");
                        }
                        return;
                    }
                    var style = item.style;
                    var padding = new LabelLayoutBase().totalPadding(style);
                    var w = 0;
                    var h = 0;
                    if (item.text) {
                        var measureTextResult = this.measureText(g, item);
                        var ww = measureTextResult.w;
                        var hh = measureTextResult.h;
                        h = Math.max(h, hh);
                        w += ww;
                    }
                    else {
                        item.rows = {
                            subLines: [],
                            rowWidths: []
                        };
                    }
                    if (style.image) {
                        var slicing = style.imageSlicing;
                        if (slicing) {
                            w += slicing[2];
                            h = Math.max(h, slicing[3]);
                        }
                        else {
                            var i = this.assetsLoader.getAssetImage(style.image, null);
                            if (i && i.width) {
                                w += i.width;
                                h = Math.max(h, i.height);
                            }
                            else {
                                item._pendingImage = true;
                            }
                        }
                    }
                    if (w === 0) {
                        w = 10;
                        h = 10;
                    }
                    // no padding between image and text
                    w += padding * 2;
                    h += padding * 2;
                    if (style.borderRadius > 0 && item.text) {
                        var r = Math.min(style.borderRadius, h / 2);
                        w += r * .45;
                        if (!style.image) {
                            w += r * .45;
                        }
                    }
                    item.hwidth = w / 2;
                    item.hheight = h / 2;
                    item.measureComplete(false);
                };
                LabelRenderer.prototype.measureText = function (g, item) {
                    var style = item.style;
                    var aspect = style.aspectRatio;
                    var maxW = style.maxWidth;
                    var textLayout = new LabelLayoutBase();
                    var w;
                    var h;
                    var parsedTags = textLayout.styleTagParser(g, item);
                    if ((aspect > 0 || maxW > 0) && parsedTags.maxLines > 1) {
                        if (!aspect) {
                            aspect = 1e9;
                        }
                        if (!maxW) {
                            maxW = 1e9;
                        }
                        var locationFromHeight = function (height) {
                            return {
                                x: 0,
                                y: 0,
                                dx: 0,
                                dy: 0,
                                width: Math.min(maxW, height * (aspect + 0.2))
                            };
                        };
                        textLayout.fitLabelInRect(g, item, locationFromHeight, false);
                        w = item.hwidth * 2;
                        h = item.hheight * 2;
                    }
                    else {
                        // just make a simple line. Split on line breaks if necessary.
                        var words = parsedTags.words;
                        var breaks = parsedTags.breaks;
                        for (var i = 0; i < breaks.length; i++) {
                            breaks[i] = breaks[i] - 1;
                        }
                        var sbf = textLayout.stringsByFont(words, breaks);
                        item.lineHeight = h = Base.Graphics.getTextHeight(g, style.textStyle.font);
                        item.rows = sbf;
                        w = sbf.rowWidths.reduce(function (a, b) { return Math.max(a, b); });
                        h = h * (1 + (style.lineSpacing || 0)) * sbf.rowWidths.length;
                    }
                    return { w: w, h: h };
                };
                LabelRenderer.prototype.canCache = function (item, scale) {
                    var config = this.settings.advanced;
                    var style = item.style;
                    if (!this.allowCache || !item.allowCache || !config.labelCache)
                        return false;
                    if (style.angle && !config.labelCacheRotated)
                        return false;
                    var itemArea = 2 * (item.hwidth * item.hheight * scale * scale);
                    if (this.chartArea / itemArea < 10)
                        return false;
                    if (style.image) {
                        var imgExists = this.assetsLoader.getAssetImage(style.image, null);
                        if (!imgExists)
                            return false;
                    }
                    return true;
                };
                /** Determines if the given style requires a canvas to be appended to the document before it can be drawn onto. */
                LabelRenderer.prototype.styleRequiresDocumentCanvas = function (style) {
                    if (style && style.font && /[0-9]+em/.test(style.font))
                        return true;
                    return false;
                };
                LabelRenderer.prototype.realPaint = function (g, x, y, item) {
                    var hw = item.hwidth;
                    var hh = item.hheight;
                    var style = item.style;
                    var background = style.backgroundStyle;
                    var padding = new LabelLayoutBase().totalPadding(style);
                    var borderRadius = Math.min(style.borderRadius || 0, hh);
                    if (background) {
                        var lw = background.lineWidth;
                        if (lw == null && background.lineColor) {
                            lw = 0.5;
                        }
                        else {
                            lw = (lw || 0) / 2;
                        }
                        // canvas line is drawn to both sides of the coordinates but hw/hh contain the total width/height
                        // of the label, including the whole border.
                        hw -= lw;
                        hh -= lw;
                        var gr = Base.Graphics.beginStrokeAndFill(g, background);
                        if (borderRadius >= hh) {
                            var xx = x + hw - hh;
                            gr.moveTo(xx, y - hh);
                            gr.arc(xx, y, hh, -Math.PI / 2, Math.PI / 2, false);
                            xx = x - hw + hh;
                            gr.lineTo(xx, y + hh);
                            gr.arc(xx, y, hh, Math.PI / 2, -Math.PI / 2, false);
                            gr.closePath();
                        }
                        else if (borderRadius > 0) {
                            gr.moveTo(x - hw + borderRadius, y - hh);
                            gr.lineTo(x + hw - borderRadius, y - hh);
                            gr.arc(x + hw - borderRadius, y - hh + borderRadius, borderRadius, -Math.PI / 2, 0, false);
                            gr.lineTo(x + hw, y + hh - borderRadius);
                            gr.arc(x + hw - borderRadius, y + hh - borderRadius, borderRadius, 0, +Math.PI / 2, false);
                            gr.lineTo(x - hw + borderRadius, y + hh);
                            gr.arc(x - hw + borderRadius, y + hh - borderRadius, borderRadius, +Math.PI / 2, Math.PI, false);
                            gr.lineTo(x - hw, y - hh + borderRadius);
                            gr.arc(x - hw + borderRadius, y - hh + borderRadius, borderRadius, Math.PI, Math.PI + Math.PI / 2, false);
                        }
                        else {
                            gr.moveTo(x - hw, y - hh);
                            gr.lineTo(x + hw, y - hh);
                            gr.lineTo(x + hw, y + hh);
                            gr.lineTo(x - hw, y + hh);
                            gr.closePath();
                        }
                        Base.Graphics.endStrokeAndFill(g, gr, background);
                        // restore the previous values
                        hw += lw;
                        hh += lw;
                    }
                    var image = style.image;
                    hw -= padding;
                    hh -= padding;
                    var left = x - hw;
                    var right = x + hw;
                    if (image) {
                        var i = this.assetsLoader.getAssetImage(image);
                        if (i) {
                            var slicing = style.imageSlicing;
                            if (slicing) {
                                Base.Graphics.drawImageHighQuality(g, i, slicing[0], slicing[1], slicing[2], slicing[3], x - hw, y - hh, slicing[2], slicing[3]);
                                left += slicing[2];
                            }
                            else {
                                g.drawImage(i, x - hw, y - hh);
                                left += i.width;
                            }
                        }
                    }
                    // label text
                    var subLines = item.rows.subLines;
                    var rowWidths = item.rows.rowWidths;
                    var count = rowWidths.length;
                    if (subLines.length > 0) {
                        var lineHeight = item.lineHeight * (1 + (style.lineSpacing || 0));
                        var labelAlign = style.align;
                        var align = void 0;
                        var x0 = void 0;
                        g.textBaseline = "bottom";
                        var y0 = y - (((count + 1) * lineHeight) / 2) + item.lineHeight * .58;
                        if (labelAlign === "left") {
                            x0 = left;
                            if (!image) {
                                x0 += borderRadius * .45;
                            }
                            align = "start";
                        }
                        else if (labelAlign === "right") {
                            x0 = right - borderRadius * .45;
                            align = "end";
                        }
                        else {
                            // center
                            x0 = (left + right) / 2;
                            align = "center";
                        }
                        var textStyle = style.textStyle;
                        // text positioning
                        var row = -1;
                        var slWidth = 0;
                        g.textAlign = align;
                        var rowStartPos = void 0;
                        // this will set the initial text style. the font is the only one that
                        // will be overridden for each word. since the same textStyle instance
                        // is then passed to drawText, the styles are not reset after each word.
                        Base.Graphics.textStyle(g, textStyle);
                        var font = textStyle.font;
                        for (var slIndex = 0; slIndex < subLines.length; slIndex++) {
                            var sl = subLines[slIndex];
                            var xpos = slWidth;
                            slWidth += sl.width;
                            if (row !== sl.row) {
                                row = sl.row;
                                y0 += lineHeight;
                                xpos = 0;
                                slWidth = sl.width;
                                var totalWidth = rowWidths[row];
                                if (align === "center") {
                                    rowStartPos = x0 - totalWidth / 2;
                                }
                                else if (align === "start") {
                                    rowStartPos = x0;
                                }
                                else {
                                    // left
                                    rowStartPos = x0 - totalWidth;
                                }
                            }
                            g.textAlign = "left";
                            if (font !== sl.font) {
                                g.font = font = sl.font;
                            }
                            xpos += rowStartPos;
                            Base.Graphics.drawText(g, textStyle, sl.text, xpos, y0);
                        }
                        Base.Graphics.resetTextStyle(g);
                    }
                };
                LabelRenderer.prototype.paint = function (g, x, y, scale, item) {
                    this.measure(g, item);
                    var style = item.style;
                    var angle = (style.angle || 0) / 180 * Math.PI;
                    var scaleX = this.scaleX;
                    var scaleY = this.scaleY;
                    var scaleForAngle = ((style.angle || 0) === 0) ? 1 : 1.7;
                    var effectiveScaleX = scaleX * scale * scaleForAngle;
                    var effectiveScaleY = scaleY * scale * scaleForAngle;
                    var canCache = this.canCache(item, scale);
                    var hw = item.hwidth;
                    var hh = item.hheight;
                    /** The minimum height of the cached image. This is done because rendering the text at very small size
                    will be mostly unreadable either way so this ensures that at least the cache is not filled with rather
                    useless small images. */
                    var minCacheHalfHeight = 3 / scaleY;
                    // store the last rendered coordinates - these are used by hit testing
                    item.currentBounds = new Base.Rect(x - hw * effectiveScaleX, y - hh * effectiveScaleY, x + hw * effectiveScaleX, y + hh * effectiveScaleY);
                    if (!canCache) {
                        // paint directly
                        var shouldTransform = scale !== 1 || angle !== 0;
                        if (shouldTransform) {
                            g.save();
                            g.transform(scale, 0, 0, scale, x, y);
                            if (angle !== 0) {
                                g.rotate(angle);
                            }
                            x = 0;
                            y = 0;
                        }
                        this.realPaint(g, x, y, item);
                        this.numPaints += 1;
                        if (shouldTransform) {
                            Base.Graphics.restore(g);
                        }
                    }
                    else {
                        // paint with cache
                        // if the scale is less than 0.5, the cached image will be stored with scale=0.5 and it will be downscaled when image is painted
                        var cacheScaleX = effectiveScaleX;
                        var cacheScaleY = effectiveScaleY;
                        if (hh * effectiveScaleY < minCacheHalfHeight) {
                            cacheScaleY = minCacheHalfHeight / hh;
                            cacheScaleX = effectiveScaleX / effectiveScaleY * cacheScaleY;
                        }
                        var imageId = item.text
                            + JSON.stringify(item.style)
                            + cacheScaleX.toFixed(2)
                            + "," + cacheScaleY.toFixed(2)
                            + "," + item.hwidth
                            + "," + item.hheight;
                        // check out if style base exists
                        var image = this.cache[imageId] || null;
                        var imWidth = void 0;
                        var imHeight = void 0;
                        var hWidth = void 0;
                        var hHeight = void 0;
                        if (!image) {
                            var bkg = style.backgroundStyle;
                            var externalBkg = (bkg && bkg.lineWidth) ? bkg.lineWidth : 0;
                            imWidth = Math.ceil((2 * hw + externalBkg + 1) * cacheScaleX);
                            imHeight = Math.ceil((2 * hh + externalBkg + 1) * cacheScaleY);
                            image = document.createElement("canvas");
                            // make even
                            imWidth += imWidth % 2;
                            imHeight += imHeight % 2;
                            hWidth = imWidth / 2;
                            hHeight = imHeight / 2;
                            image.width = imWidth;
                            image.height = imHeight;
                            var needsAppend = this.styleRequiresDocumentCanvas(style.textStyle);
                            var container = void 0;
                            if (needsAppend) {
                                container = this.chartContainer;
                                if (!container.ownerDocument) {
                                    Base.Helpers.warn("chartContainer must be appended to the document in order to use `em` when specifying font size.");
                                    container = document.body;
                                }
                                image.style.display = "none";
                                container.appendChild(image);
                            }
                            // draw on scaled canvas
                            var ig = image.getContext("2d");
                            ig.transform(cacheScaleX, 0, 0, cacheScaleY, hWidth, hHeight);
                            this.realPaint(ig, 0, 0, item);
                            if (needsAppend) {
                                container.removeChild(image);
                            }
                            this.cache[imageId] = image;
                            this.numPaints += 1;
                        }
                        else {
                            imWidth = image.width;
                            imHeight = image.height;
                            hWidth = imWidth / 2;
                            hHeight = imHeight / 2;
                            this.numCachedPaints += 1;
                        }
                        // reverting device pixel transform
                        var dw = imWidth / effectiveScaleX * scale;
                        var dh = imHeight / effectiveScaleY * scale;
                        if (cacheScaleX !== effectiveScaleX) {
                            dw = dw / cacheScaleX * effectiveScaleX;
                            dh = dh / cacheScaleY * effectiveScaleY;
                        }
                        // round 
                        dw = Math.round(dw / 2 * 1000) / 1000;
                        dh = Math.round(dh / 2 * 1000) / 1000;
                        var dx = x - dw;
                        var dy = y - dh;
                        if (angle !== 0) {
                            g.save();
                            g.translate(x, y);
                            g.rotate(angle);
                            dx = -dw;
                            dy = -dh;
                        }
                        else if (cacheScaleX === effectiveScaleX) {
                            // round x and y to device pixels to prevent blur
                            dx = Math.round(dx * scaleX) / scaleX;
                            dy = Math.round(dy * scaleY) / scaleY;
                        }
                        Base.Graphics.drawImageHighQuality(g, image, 0, 0, imWidth, imHeight, dx, dy, dw * 2, dh * 2);
                        this.frameLabels[imageId] = 1;
                        if (angle !== 0) {
                            Base.Graphics.restore(g);
                        }
                    }
                };
                return LabelRenderer;
            }());
            Base.LabelRenderer = LabelRenderer;
            var LabelLayoutBase = (function () {
                function LabelLayoutBase() {
                }
                /** Calculates the total padding of the given label that includes the border width. */
                LabelLayoutBase.prototype.totalPadding = function (style) {
                    var padding = (style.padding || 0);
                    var bgstyle = style.backgroundStyle;
                    if (bgstyle) {
                        var lw = bgstyle.lineWidth;
                        padding += ((lw == null && bgstyle.lineColor) ? 1 : (lw || 0));
                    }
                    return padding;
                };
                /** places label
                locationFromHeight(halfHeight) -> [centerX, centerY, directionX, directionY, width] */
                LabelLayoutBase.prototype.fitLabelInRect = function (g, label, locationFromHeight, storePosition) {
                    if (storePosition === void 0) { storePosition = true; }
                    var style = label.style;
                    var margin = style.margin || 0;
                    var padding = this.totalPadding(style);
                    var lineHeight = Base.Graphics.getTextHeight(g, style.textStyle.font);
                    var lineSpacing = style.lineSpacing || 0;
                    var lineHeightM = lineHeight * (lineSpacing + 1);
                    var lineHeightC = -lineHeight * lineSpacing;
                    if (label.needTextParsing()) {
                        this.styleTagParser(g, label);
                    }
                    var words = label._textCache.words;
                    var breaks = label._textCache.breaks;
                    // let totalWidth = label._textCache.totalWidth;
                    var maxLines = label._textCache.maxLines;
                    var bestProp = -Infinity;
                    var bestLineBreaks = null;
                    var bestX = 0;
                    var bestY = 0;
                    var bestDx;
                    var bestDy;
                    var bestWidth = 0;
                    var bestActualWidth = 0;
                    // find best fit
                    for (var lineCount = breaks.length; lineCount <= maxLines; lineCount++) {
                        var height = lineHeightC + lineHeightM * lineCount;
                        var locData = locationFromHeight(height / 2 + margin + padding);
                        /* tslint:disable:no-var-keyword */
                        var availableWidth = locData.width;
                        /* tslint:enable:no-var-keyword */
                        availableWidth -= (margin + padding) * 2;
                        // let lineTargetWidth = totalWidth / lineCount;
                        var splitWordsToLinesResult = this.splitWordsToLines(words, breaks, lineCount, function () { return availableWidth; });
                        var prop = splitWordsToLinesResult.prop;
                        var actualWidth = splitWordsToLinesResult.actualWidthForLines;
                        var positions = splitWordsToLinesResult.positions;
                        if (prop > bestProp) {
                            bestLineBreaks = positions;
                            bestProp = prop;
                            bestDx = locData.dx;
                            bestDy = locData.dy;
                            bestX = locData.x;
                            bestY = locData.y;
                            bestWidth = availableWidth;
                            bestActualWidth = 0;
                            for (var vIndex = 0; vIndex < actualWidth.length; vIndex++) {
                                var v = actualWidth[vIndex];
                                bestActualWidth = Math.max(v, bestActualWidth);
                            }
                        }
                        if (prop >= 1) {
                            break;
                        }
                    }
                    if (bestLineBreaks) {
                        // use align
                        if (!label.userPlaced) {
                            var align = label.style.align;
                            var centerOffset = void 0;
                            if (align === "left") {
                                centerOffset = (bestActualWidth - bestWidth) / 2;
                            }
                            else if (align === "right") {
                                centerOffset = (bestWidth - bestActualWidth) / 2;
                            }
                            else {
                                centerOffset = 0;
                            }
                            bestX = bestX + bestDx * centerOffset;
                            bestY = bestY + bestDy * centerOffset;
                        }
                        if (storePosition) {
                            label.x = bestX;
                            label.y = bestY;
                        }
                        label.rows = this.stringsByFont(words, bestLineBreaks);
                        label.hheight = (lineHeightC + lineHeightM * bestLineBreaks.length) / 2 + padding;
                        label.lineHeight = lineHeight;
                        label.lineHeightM = lineHeightM;
                        label.hwidth = bestActualWidth / 2 + padding;
                        label.visible = true;
                        label.measureComplete(true);
                        if (style.borderRadius > 0) {
                            label.hwidth += 0.45 * Math.min(style.borderRadius, label.hheight);
                        }
                    }
                    else {
                        label.rows = {
                            subLines: [],
                            rowWidths: []
                        };
                        label.visible = false;
                    }
                    return bestProp;
                };
                LabelLayoutBase.prototype.styleTagParser = function (g, label) {
                    if (label.needTextParsing())
                        label._textCache = this.styleTagParser2(g, label.text, label.style.textStyle);
                    return label._textCache;
                };
                LabelLayoutBase.prototype.styleTagParser2 = function (g, text, textStyle) {
                    // this is reset by a call to Graphics.resetTextStyle()
                    var font = textStyle.font;
                    if (font) {
                        // pass font through context to covert to px.
                        g.font = font;
                        font = g.font;
                    }
                    else {
                        // most common case when the font is not set - when the method is used by
                        // facetaxis to remove tags from the text.
                        font = "11px Arial";
                    }
                    var fontMap = LabelLayoutBase._spaceWidth;
                    if (!fontMap[font])
                        fontMap[font] = Base.Graphics.getTextWidth(g, { font: font }, " ");
                    var currentFont = font;
                    var boldCounter = 0;
                    var italicCounter = 0;
                    var lastWasSpace = true;
                    var originalText = text;
                    text = text == null ? "" : "" + text;
                    var pos = 0;
                    var lastPos = 0;
                    var words = [];
                    var breaks = [];
                    var lastBreak = -1;
                    // TODO: unfortunately the first word has to be the dummy placeholder - this should be fixed.
                    words.push({ word: "", width: 0, font: currentFont, spaceWidth: 0 });
                    var lastWord = { word: "", width: 0, font: currentFont, spaceWidth: 0 };
                    words.push(lastWord);
                    var length = text.length;
                    // chartCodeAt() called with out of bounds index might result in V8 deoptimizing the method which reduces performance.
                    var char = length === 0 ? -1 : text.charCodeAt(0);
                    while (pos < length) {
                        switch (char) {
                            case 32:
                                // move past all consecutive spaces
                                // it is important that ++pos is the last in the condition.
                                while (char === 32 && ++pos < length) {
                                    char = text.charCodeAt(pos);
                                }
                                if (!lastWasSpace) {
                                    // add a space at the end of the previous word
                                    lastWord.spaceWidth = fontMap[currentFont];
                                    lastWasSpace = true;
                                }
                                lastPos = pos;
                                break;
                            case 60:
                                if (pos + 4 > length) {
                                    // quickly fail if there will not be enough room for a simple tag.
                                    // -1 is used so that the char is read by the `default` case in the next iteration
                                    char = -1;
                                    break;
                                }
                                var tempPos = pos;
                                var c1 = text.charCodeAt(++pos);
                                var closer = c1 === 47 ? -1 : 1; // 47='/'
                                if (closer < 0)
                                    c1 = text.charCodeAt(++pos);
                                var c2 = text.charCodeAt(++pos);
                                /** The type of the tag that has been parsed: -1: unknown; 0: bold; 1: italic; 2: linebreak */
                                var tag = -1;
                                if (c1 === 98 || c1 === 66) {
                                    if (c2 === 82 || c2 === 114) {
                                        c2 = ++pos === length ? -1 : text.charCodeAt(pos);
                                        tag = 2;
                                    }
                                    else {
                                        tag = 0;
                                    }
                                }
                                else if (c1 === 73 || c1 === 105) {
                                    tag = 1;
                                }
                                if (tag > -1 && c2 === 62) {
                                    // a valid tag has been parsed.
                                    char = ++pos === length ? -1 : text.charCodeAt(pos); // move past the '>'
                                    lastPos = pos;
                                    var needNewWord = false;
                                    var lastWordNonEmpty = lastWord.word || lastWord.spaceWidth > 0;
                                    if (tag === 2) {
                                        // this case handles multiple <br> tags in sequence
                                        if (lastBreak === words.length - 1)
                                            lastWordNonEmpty = true;
                                        // the -1 is for case like `<b>foo</b><br>bar` and is needed because needNewWord would not create a new word when the last is empty
                                        breaks.push(lastBreak = (words.length - (lastWordNonEmpty ? 0 : 1)));
                                        lastWasSpace = true;
                                        needNewWord = true;
                                    }
                                    else {
                                        if (tag === 1) {
                                            italicCounter = Math.max(0, italicCounter + closer);
                                        }
                                        else {
                                            boldCounter = Math.max(0, boldCounter + closer);
                                        }
                                        var newFont = (italicCounter ? "italic " : "") + (boldCounter ? "bold " : "") + font;
                                        if (newFont !== currentFont) {
                                            needNewWord = true;
                                            currentFont = newFont;
                                            if (!fontMap[currentFont]) {
                                                fontMap[currentFont] = Base.Graphics.getTextWidth(g, { font: currentFont }, " ");
                                            }
                                        }
                                    }
                                    if (needNewWord) {
                                        if (lastWordNonEmpty) {
                                            lastWord = { word: "", width: 0, font: currentFont, spaceWidth: 0 };
                                            words.push(lastWord);
                                        }
                                        else {
                                            lastWord.font = currentFont;
                                        }
                                    }
                                }
                                else {
                                    // the tag was not found - move back to before the initial '<' but replace the `char` so that the `default` case is triggered
                                    pos = tempPos;
                                    char = -1;
                                }
                                break;
                            default:
                                var hasAmpersand = false;
                                // move past all non-special symbols
                                // it is important that ++pos is the last in the condition.
                                while (char !== 32 && char !== 60 && ++pos < length) {
                                    hasAmpersand = hasAmpersand || char === 38;
                                    char = text.charCodeAt(pos);
                                }
                                // create a new word
                                var word = text.substring(lastPos, pos);
                                if (hasAmpersand)
                                    word = Base.Helpers.decodeEntities(word);
                                if (lastWord.spaceWidth > 0 || lastWord.font !== currentFont) {
                                    lastWord = { word: word, width: 0, font: currentFont, spaceWidth: 0 };
                                    words.push(lastWord);
                                }
                                else {
                                    lastWord.word += word;
                                }
                                lastWasSpace = false;
                                lastPos = pos;
                                break;
                        }
                    }
                    for (var i = 0; i < words.length; i++) {
                        var w = words[i];
                        if (w.word)
                            w.width = Base.Graphics.getTextWidth(g, { font: w.font }, w.word);
                    }
                    // no return should go before this line
                    Base.Graphics.resetTextStyle(g);
                    var wordCount = words.length;
                    if (breaks[breaks.length - 1] !== wordCount)
                        breaks.push(wordCount);
                    // count the lines as the number of words but removing
                    // empty words from the start and beginning
                    var maxLines = wordCount;
                    if (words[0].width === 0)
                        maxLines--;
                    for (var i = wordCount - 1; i >= 0; i--) {
                        var w = words[i];
                        if (w.width > 0)
                            break;
                        maxLines--;
                    }
                    return {
                        sourceText: originalText,
                        sourceFont: textStyle.font,
                        breaks: breaks,
                        maxLines: maxLines,
                        words: words
                    };
                };
                LabelLayoutBase.prototype.stringsByFont = function (words, bestLineBreaks) {
                    var curFont = words[0].font;
                    var breaks = bestLineBreaks.slice(0);
                    var subLines = [];
                    var rowWidths = [];
                    // row width
                    var rw = 0;
                    // string width
                    var strw = 0;
                    var str = "";
                    var row = 0;
                    var lastSpaceWidth = 0;
                    for (var i = 0; i <= words.length - 1; i++) {
                        var w = words[i];
                        lastSpaceWidth = w.spaceWidth;
                        // note that breaks array is shifted every time.
                        var rowChanges = i === breaks[0];
                        if (w.font !== curFont) {
                            if (!!strw) {
                                subLines.push({
                                    text: str,
                                    width: strw,
                                    font: curFont,
                                    row: row
                                });
                            }
                            curFont = w.font;
                            str = "";
                            strw = 0;
                        }
                        strw += w.width;
                        str += w.word;
                        rw += w.width + w.spaceWidth;
                        if (rowChanges) {
                            subLines.push({
                                text: str,
                                width: strw,
                                font: curFont,
                                row: row
                            });
                            rowWidths.push(rw - w.spaceWidth);
                            str = "";
                            row++;
                            strw = rw = 0;
                            // include cutting w
                            breaks.shift();
                        }
                        // skip space if row changes
                        if (rowChanges) {
                            continue;
                        }
                        if (w.spaceWidth) {
                            strw += w.spaceWidth;
                            str += " ";
                        }
                    }
                    if (!!str) {
                        subLines.push({
                            text: str,
                            width: strw,
                            font: curFont,
                            row: row
                        });
                        rowWidths.push(rw - lastSpaceWidth);
                    }
                    return {
                        subLines: subLines,
                        rowWidths: rowWidths
                    };
                };
                /** places label */
                LabelLayoutBase.prototype.fitLabelInLines = function (g, label, x, y, align, noSpaceAlign, leftRightFromXY) {
                    var style = label.style;
                    var margin = style.margin || 0;
                    var padding = this.totalPadding(style);
                    var lineHeight = Base.Graphics.getTextHeight(g, style.textStyle.font);
                    var lineSpacing = style.lineSpacing || 0;
                    var lineHeightM = lineHeight * (lineSpacing + 1);
                    var lineHeightC = -lineHeight * lineSpacing;
                    this.styleTagParser(g, label);
                    var words = label._textCache.words;
                    var breaks = label._textCache.breaks;
                    // let totalWidth = label._textCache.totalWidth;
                    var maxLines = label._textCache.maxLines;
                    var bestProp = -Infinity;
                    var bestLineBreaks = null;
                    var bestLinesActualWidth = null;
                    var bestLinesAvailableWidth = null;
                    var bestY0 = 0;
                    var oddLinesAvailableSize = [];
                    var evenLinesAvailableSize = [];
                    // build initial lines
                    evenLinesAvailableSize.push(leftRightFromXY(x, y));
                    for (var lineCount = 1; lineCount <= breaks.length - 1; lineCount++) {
                        var height = lineHeightC + lineHeightM * lineCount;
                        var availableLines_1 = void 0;
                        if (lineCount % 2 === 1) {
                            availableLines_1 = oddLinesAvailableSize;
                        }
                        else {
                            availableLines_1 = evenLinesAvailableSize;
                        }
                        // add extra line at top and bottom
                        var a = leftRightFromXY(x, y - height / 2 - margin);
                        availableLines_1.unshift([a[0] - margin, a[1] - margin]);
                        a = leftRightFromXY(x, y + height / 2 + margin);
                        availableLines_1.push([a[0] - margin, a[1] - margin]);
                    }
                    // find best fit
                    for (var lineCount = breaks.length; lineCount <= maxLines; lineCount++) {
                        var height = lineHeightC + lineHeightM * lineCount;
                        /* tslint:disable:no-var-keyword */
                        var availableLines;
                        /* tslint:enable:no-var-keyword */
                        if (lineCount % 2 === 1) {
                            availableLines = oddLinesAvailableSize;
                        }
                        else {
                            availableLines = evenLinesAvailableSize;
                        }
                        // add extra line at top and bottom
                        var a = leftRightFromXY(x, y - height / 2 - margin);
                        availableLines.unshift([a[0] - margin, a[1] - margin]);
                        a = leftRightFromXY(x, y + height / 2 + margin);
                        availableLines.push([a[0] - margin, a[1] - margin]);
                        var availableWidthFunc = function (linePos) {
                            return Math.min(availableLines[linePos][0] + availableLines[linePos][1], availableLines[linePos + 1][0] + availableLines[linePos + 1][1]);
                        };
                        var splitWordsToLinesResult = this.splitWordsToLines(words, breaks, lineCount, availableWidthFunc);
                        var prop = splitWordsToLinesResult.prop;
                        var linesWidth = splitWordsToLinesResult.actualWidthForLines;
                        var positions = splitWordsToLinesResult.positions;
                        if (prop > bestProp) {
                            bestY0 = y - height / 2;
                            bestLineBreaks = positions;
                            bestProp = prop;
                            bestLinesActualWidth = linesWidth;
                            bestLinesAvailableWidth = availableLines.slice(0);
                            if (positions.length + 1 > availableLines.length) {
                                throw new Error("Internal error");
                            }
                        }
                        if (prop >= 1) {
                            break;
                        }
                    }
                    if (bestLineBreaks) {
                        // fit in available lines
                        var missingSpaceLeft = 0;
                        var missingSpaceRight = 0;
                        var x0 = void 0;
                        var x1 = void 0;
                        if (align === "left") {
                            var left = 1e30;
                            for (var i = 0; i <= bestLineBreaks.length; i++) {
                                left = Math.min(bestLinesAvailableWidth[i][0]);
                            }
                            var leftAnchor = -left;
                            x0 = leftAnchor;
                            x1 = leftAnchor;
                            for (var i = 0; i <= bestLineBreaks.length - 1; i++) {
                                var width = bestLinesActualWidth[i];
                                var right = Math.min(bestLinesAvailableWidth[i][1], bestLinesAvailableWidth[i + 1][1]);
                                x1 = Math.max(leftAnchor + width);
                                missingSpaceRight = Math.max(missingSpaceRight, width - (right - leftAnchor));
                            }
                        }
                        else if (align === "right") {
                            var right = 1e30;
                            for (var i = 0; i <= bestLineBreaks.length; i++) {
                                right = Math.min(bestLinesAvailableWidth[i][1]);
                            }
                            var rightAnchor = right;
                            x0 = rightAnchor;
                            x1 = rightAnchor;
                            for (var i = 0; i <= bestLineBreaks.length - 1; i++) {
                                var width = bestLinesActualWidth[i];
                                // left = Math.min(bestLinesAvailableWidth[i][0], bestLinesAvailableWidth[i + 1][0]);
                                x0 = Math.min(rightAnchor - width);
                                missingSpaceLeft = Math.max(missingSpaceLeft, width - (right + rightAnchor));
                            }
                        }
                        else if (align === "center") {
                            var left = 1e30;
                            var right = 1e30;
                            for (var i = 0; i <= bestLineBreaks.length - 1; i++) {
                                var width = bestLinesActualWidth[i] / 2;
                                left = Math.min(bestLinesAvailableWidth[i][0] - width, Math.min(bestLinesAvailableWidth[i + 1][0] - width, left));
                                right = Math.min(bestLinesAvailableWidth[i][1] - width, Math.min(bestLinesAvailableWidth[i + 1][1] - width, right));
                            }
                            var center = void 0;
                            if (left > 0 && right > 0) {
                                center = 0;
                            }
                            else if (left > -right) {
                                center = right;
                            }
                            else if (right > -left) {
                                center = -left;
                            }
                            else {
                                center = (right - left) / 2;
                            }
                            x0 = center;
                            x1 = center;
                            for (var i = 0; i <= bestLineBreaks.length - 1; i++) {
                                var width = bestLinesActualWidth[i];
                                left = Math.min(bestLinesAvailableWidth[i][0], bestLinesAvailableWidth[i + 1][0]);
                                right = Math.min(bestLinesAvailableWidth[i][1], bestLinesAvailableWidth[i + 1][1]);
                                x0 = Math.min(x0, center - width / 2);
                                x1 = Math.max(x1, center + width / 2);
                                missingSpaceLeft = Math.max(missingSpaceLeft, width / 2 - left - center);
                                missingSpaceRight = Math.max(missingSpaceRight, width / 2 - right + center);
                            }
                        }
                        // assign noSpace
                        if (noSpaceAlign === "left" && missingSpaceLeft > 0) {
                            x0 += missingSpaceLeft;
                            x1 += missingSpaceLeft;
                        }
                        else if (noSpaceAlign === "right" && missingSpaceRight > 0) {
                            x0 -= missingSpaceRight;
                            x1 -= missingSpaceRight;
                        }
                        else if (noSpaceAlign === "center") {
                            var diff = (missingSpaceLeft - missingSpaceRight) / 2;
                            x0 += diff;
                            x1 += diff;
                        }
                        label.rows = this.stringsByFont(words, bestLineBreaks);
                        label.hwidth = (x1 - x0) / 2 + padding;
                        label.hheight = (lineHeightC + lineHeightM * bestLineBreaks.length) / 2 + padding;
                        label.lineHeight = lineHeight;
                        label.lineHeightM = lineHeightM;
                        label.visible = true;
                        label.measureComplete(true);
                        if (style.borderRadius > 0) {
                            label.hwidth += 0.45 * Math.min(style.borderRadius, label.hheight);
                        }
                        if (!label.userPlaced) {
                            label.x = x + (x0 + x1) / 2;
                            label.y = bestY0 + label.hheight;
                        }
                    }
                    else {
                        label.rows = {
                            subLines: [],
                            rowWidths: []
                        };
                        label.visible = false;
                    }
                    return bestProp;
                };
                /* Splits words to lines using specified constraints.
                Params:
                * words: array of words generated by styleTagParser, first word is special denoting whitespace before first real word.
                * breaks: indices in words array where mandatory line breaks after word are needed.
                * lineCount: number of lines to build
                * availableWidthFunc: function(lineNo) -> maxLineWidth
                Returns:
                * prop: proportion of available width filled. >1 is good, <1 is not enough space
                * actualWidthForLines: array if used widths for each line
                * positions: line break positions in words array */
                LabelLayoutBase.prototype.splitWordsToLines = function (words, breaks, lineCount, availableWidthFunc) {
                    var prop = 100;
                    // build lines to fit that width
                    var actualWidthForLines = [];
                    // line break positions
                    var positions = [];
                    var nextBreakIndex = 0;
                    var nextBrPos = breaks[nextBreakIndex];
                    var availableBreaks = lineCount - breaks.length;
                    var prevWord = words[0];
                    var lineWidth = 0;
                    var availableWidth = availableWidthFunc(0);
                    var lineNo = 0;
                    // add by 1 word and split when too long
                    for (var pos = 1; pos <= words.length - 1; pos++) {
                        // advance to next word
                        var word = words[pos];
                        var longerLineWidth = lineWidth + (prevWord.spaceWidth + word.width);
                        if (nextBrPos === pos || (prevWord.spaceWidth > 0 && longerLineWidth > availableWidth && availableBreaks > 0)) {
                            // line too long, start new line with `word` being the first word in it
                            positions.push(pos - 1);
                            actualWidthForLines.push(lineWidth);
                            prop = Math.min(prop, availableWidth / lineWidth);
                            lineWidth = word.width;
                            lineNo += 1;
                            availableWidth = availableWidthFunc(lineNo);
                            if (nextBrPos !== pos) {
                                availableBreaks -= 1;
                            }
                            else {
                                nextBreakIndex += 1;
                                nextBrPos = breaks[nextBreakIndex];
                            }
                        }
                        else {
                            // line fits after adding word or this is the last word
                            lineWidth = longerLineWidth;
                        }
                        prevWord = word;
                    }
                    // finalize last line
                    positions.push(words.length);
                    actualWidthForLines.push(lineWidth);
                    prop = Math.min(prop, availableWidth / lineWidth);
                    return {
                        prop: prop,
                        actualWidthForLines: actualWidthForLines,
                        positions: positions
                    };
                };
                /**
                   Format full or partial multi line label text based on available space. It will add
                   elipsis to any row if it does not fit in available space. Non-ortogonal rotated labels
                   will be formated as one line with or without ellipsis.
                 */
                LabelLayoutBase.prototype.getFormatedText = function (g, label, availableWidth, availableHeight, locationFromHeight) {
                    var style = label.style;
                    var textStyle = style.textStyle;
                    var lineHeight = Base.Graphics.getTextHeight(g, style.textStyle.font);
                    var lineSpacing = style.lineSpacing || 0;
                    var lineHeightM = lineHeight * (lineSpacing + 1);
                    var margin = style.margin || 0;
                    var padding = this.totalPadding(style);
                    var horizontal = !style.angle || style.angle === 0;
                    var vertical = style.angle === 90 || style.angle === -90;
                    var ortogonal = horizontal || vertical;
                    var width;
                    if (vertical) {
                        width = availableHeight - (margin * 2);
                        availableHeight = availableWidth - margin;
                    }
                    else {
                        availableHeight -= margin;
                        var locData = locationFromHeight(lineHeight / 2 + padding, availableWidth - margin * 2, availableHeight - margin);
                        width = locData.width;
                    }
                    var line = this.getIncludingPart(g, textStyle, label.text, "", width, 0);
                    var text = label.text; // remaining processing text
                    var finalWidth = null;
                    var addEllipsis = false;
                    var ellipsisWidth = Base.Graphics.getTextWidth(g, label.style.textStyle, "\u2026");
                    if (ortogonal) {
                        var rows = Math.floor(availableHeight / lineHeight) - 2;
                        var r = 0;
                        while (r <= rows) {
                            text = text.replace(/\s+$/g, "");
                            line = this.getIncludingPart(g, textStyle, text, "", width, 0);
                            if (line === text) {
                                // everything fits in - ellipsis should not be applied
                                this.addLine(g, label, line, r, addEllipsis);
                                break;
                            }
                            else {
                                addEllipsis = true;
                                if (line.length <= 1) {
                                    line = text.slice(0, 1);
                                    addEllipsis = label.text !== line;
                                    this.addLine(g, label, line, r, addEllipsis);
                                    finalWidth = label.rows.rowWidths[0];
                                    break;
                                }
                                if (r === rows) {
                                    // last row - does not fit remaining text. Ellipsis should not be applied
                                    line = this.getIncludingPart(g, textStyle, text, "", width - ellipsisWidth, 0);
                                }
                                else {
                                    // lines between first and last one. Check out remaining text to slice by whole word or part of last that fits
                                    var lastSpace = line.lastIndexOf(" ");
                                    var firstSpace = void 0;
                                    if (lastSpace === -1) {
                                        firstSpace = text.indexOf(" ");
                                        var firstWord = (firstSpace === -1) ? text : text.substring(0, firstSpace);
                                        addEllipsis = line !== firstWord;
                                        if (addEllipsis) {
                                            line = this.getIncludingPart(g, textStyle, text, "", width - ellipsisWidth, 0).replace(/\s+$/g, "");
                                            firstSpace = text.indexOf(" ");
                                            firstWord = (firstSpace === -1) ? text : text.substring(0, firstSpace);
                                        }
                                        text = text.substr(line.length);
                                        firstSpace = text.indexOf(" ");
                                        text = (firstSpace === -1) ? "" : text.substr(firstSpace + 1);
                                    }
                                    else {
                                        line = line.substr(0, lastSpace);
                                        text = text.substr(lastSpace + 1);
                                        addEllipsis = false;
                                    }
                                }
                                if (line.length <= 1) {
                                    // last row fixes
                                    if (r !== 0)
                                        break;
                                    line = label.text.slice(0, 1);
                                }
                            }
                            // reset
                            this.addLine(g, label, line, r, addEllipsis);
                            if (text === "")
                                break;
                            text = text.trim();
                            addEllipsis = false;
                            r++;
                        }
                    }
                    else {
                        addEllipsis = line !== text;
                        if (addEllipsis) {
                            line = this.getIncludingPart(g, textStyle, text, "", width - ellipsisWidth, 0).replace(/\s+$/g, "");
                        }
                        this.addLine(g, label, line, 0, addEllipsis);
                    }
                    if (!label.rows) {
                        this.addLine(g, label, "", 0, false);
                    }
                    // adjust x, y position based on alignment
                    var finalHeight = ((lineHeightM * label.rows.subLines.length - lineHeight * lineSpacing) / 2);
                    var offset = 0;
                    if (style.align === "left" || style.align === "right") {
                        var longest = Math.max.apply(Math, label.rows.rowWidths);
                        var diff = (width - longest) / 2;
                        offset = (style.align === "right") ? diff : -diff;
                    }
                    if (style.angle) {
                        finalWidth = Math.max.apply(Math, label.rows.rowWidths);
                    }
                    var location = locationFromHeight(finalHeight, finalWidth || availableWidth, availableHeight);
                    label.x = location.x + location.dx * offset;
                    label.y = margin + location.y;
                    label.hheight = finalHeight + padding;
                    label.hwidth = Math.max.apply(Math, label.rows.rowWidths) / 2 + padding;
                    label.lineHeight = lineHeight;
                    label.lineHeightM = lineHeightM;
                    label.visible = true;
                    label.measureComplete(true);
                    if (style.borderRadius > 0) {
                        label.hwidth += 0.45 * Math.min(style.borderRadius, label.hheight);
                    }
                };
                /**
                 *  Add rows, recalculate offsets, add ellipsis if necessary
                 */
                LabelLayoutBase.prototype.addLine = function (g, label, line, row, addEllipsis) {
                    if (addEllipsis)
                        line = line.replace(/\s+$/g, "") + "\u2026";
                    var textStyle = label.style.textStyle;
                    var width = Base.Graphics.getTextWidth(g, textStyle, line);
                    if (label.rows == null) {
                        label.rows = { rowWidths: [], subLines: [] };
                    }
                    label.rows.rowWidths.push(width);
                    label.rows.subLines.push({
                        font: textStyle.font,
                        row: row,
                        text: line,
                        width: width
                    });
                };
                /**
                 * Binary split words and measure whether it exceeds available width.
                 * @returns word part or full word that fits in available width.
                 */
                LabelLayoutBase.prototype.getIncludingPart = function (g, textStyle, t, subText, availableWidth, subWidth) {
                    if (t.length <= 1) {
                        var w = Base.Graphics.getTextWidth(g, textStyle, t);
                        if (subWidth + w <= availableWidth) {
                            subText += t;
                        }
                        return subText;
                    }
                    var l = t.slice(0, t.length / 2);
                    var lw = Base.Graphics.getTextWidth(g, textStyle, l);
                    if (subWidth + lw <= availableWidth) {
                        subText += l;
                    }
                    if (subWidth + lw === availableWidth) {
                        return subText;
                    }
                    else if (subWidth + lw < availableWidth) {
                        var r = t.slice(t.length / 2, t.length);
                        subWidth += lw;
                        return this.getIncludingPart(g, textStyle, r, subText, availableWidth, subWidth);
                    }
                    else {
                        return this.getIncludingPart(g, textStyle, l, subText, availableWidth, subWidth);
                    }
                };
                /** The width of space characters for different fonts. */
                LabelLayoutBase._spaceWidth = {};
                return LabelLayoutBase;
            }());
            Base.LabelLayoutBase = LabelLayoutBase;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Graphics.ts" />
/// <reference path="Label.ts" />
/// <reference path="core/ChartEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var LegendEntry = (function () {
                function LegendEntry(label, textColorEnabled, textColorDisabled, groupId) {
                    /** Cached label that will be painted when the item is enabled. */
                    this.labelEnabled = null;
                    /** Cached label that will be painted when the item is disabled. */
                    this.labelDisabled = null;
                    /** Group identifier, used for enabling/disabling logic. */
                    this.groupId = null;
                    /** Count of pointers hovering over the legend item */
                    this.hoverCount = 0;
                    /** Whether the item is enabled */
                    this.enabled = true;
                    this.labelText = label;
                    this.textColorEnabled = textColorEnabled;
                    this.textColorDisabled = textColorDisabled;
                    this.groupId = groupId;
                }
                /**
                 * Determines if the item is hovered. Override if the item is also considered hovered depending on some external circumstance.
                 */
                LegendEntry.prototype.isHovered = function () {
                    return this.hoverCount > 0;
                };
                /**
                 * Determines if the item is enabled. Override if the item is also considered enabled/disabled depending on some external circumstance.
                 */
                LegendEntry.prototype.isEnabled = function () {
                    return this.enabled;
                };
                return LegendEntry;
            }());
            Base.LegendEntry = LegendEntry;
            var SettingsLegend = (function () {
                function SettingsLegend() {
                    /** Show/hide chart legend. */
                    this.enabled = false;
                    /** Maximum width of the legend. If null, all available horizontal space of chart will be consumed to set as much entries as possible.
                    It coincides with the chart width if legend panel side is on a top or bottom.
                    @type float
                    @units pixels */
                    this.width = null;
                    /** Maximum height of the legend. If null, all available vertical space of chart will be consumed to set as much entries as possible.
                    It coincides with the chart height if legend panel side is on a left or right.
                    @type float
                    @units pixels */
                    this.height = null;
                    /** Max number of rows. Use in conjunction with side parameter under the legend panel that should be set as bottom or top in order to arrange entries by rows.
                    @type integer
                    @units rows */
                    this.numberOfRows = null;
                    /** Max number of columns. Use in conjunction with side parameter under the legend panel should be right or left in order to arrange entries by columns.
                    @type integer
                    @units columns */
                    this.numberOfColumns = null;
                    /** Margin around each legend entry.
                    @type float
                    @units pixels */
                    this.margin = 1;
                    /** Padding around each entry text and marker.
                    @type float
                    @units pixels */
                    this.padding = 5;
                    /** Max number of symbols used in one line of text that applies to any legend entry.
                    @type integer
                    @units symbols */
                    this.maxLineSymbols = 15;
                    /** Vertical space between the lines of text.
                    @type float
                    @units scale */
                    this.lineSpacing = 0.2;
                    /** Text settings displaying in legend entries. */
                    this.text = {
                        font: "12px Arial",
                        fillColor: "#000"
                    };
                    /** Visual element of legend entry with appropriate style to a slice color it corresponds. The content of each legend marker is the
                    same as info popup appearing while hovering on slice. */
                    this.marker = new SettingsLegendMarker();
                    /** Whether to order entries to get possibly equal number of items into columns or rows. If false, once the row or column is full of entries,
                    the next element will be first in the new row or column/rows. */
                    this.equalizeRowsColumns = true;
                    /** Legend enclosing panel settings. */
                    this.panel = new SettingsLegendPanel("left", "fill", 1);
                    /** Advanced settings which may change in the future. */
                    this.advanced = new SettingsLegendAdvanced();
                    /** Settings related to the user interaction with the legend.
                    @version 1.14.0 */
                    this.interaction = new SettingsLegendInteraction();
                }
                return SettingsLegend;
            }());
            Base.SettingsLegend = SettingsLegend;
            var SettingsLegendInteraction = (function () {
                function SettingsLegendInteraction() {
                    /** Specifies if the legend can be interacted with by clicking each entry to select the particular item.
                    @version 1.14.0 */
                    this.click = true;
                }
                return SettingsLegendInteraction;
            }());
            Base.SettingsLegendInteraction = SettingsLegendInteraction;
            var SettingsLegendAdvanced = (function () {
                function SettingsLegendAdvanced() {
                    /** Background color for selected legend entry.
                    @type color */
                    this.selectedBackground = "rgba(208,233,255,0.3)";
                    /** Border color for selected legend entry.
                    @type color */
                    this.selectedBorder = "rgba(208,233,255,0.3)";
                }
                return SettingsLegendAdvanced;
            }());
            Base.SettingsLegendAdvanced = SettingsLegendAdvanced;
            var SettingsLegendPanel = (function (_super) {
                __extends(SettingsLegendPanel, _super);
                function SettingsLegendPanel(side, align, margin, packingOrder, padding) {
                    _super.call(this, side, align, margin, packingOrder);
                    this.padding = 0;
                    if (padding !== void 0)
                        this.padding = padding;
                }
                return SettingsLegendPanel;
            }(Base.SettingsChartPanel));
            Base.SettingsLegendPanel = SettingsLegendPanel;
            var SettingsLegendMarker = (function () {
                function SettingsLegendMarker() {
                    /** Marker size.
                    @type float
                    @units pixels */
                    this.size = 20;
                    /** Marker position relative to text
                    @type enum
                    @value left
                    @value right */
                    this.alignment = "left";
                    /** Line color around marker shape
                    @type color */
                    this.lineColor = "#fff";
                }
                return SettingsLegendMarker;
            }());
            Base.SettingsLegendMarker = SettingsLegendMarker;
            var Legend = (function (_super) {
                __extends(Legend, _super);
                function Legend(chart) {
                    var _this = this;
                    _super.call(this);
                    this.animationOrder = 300;
                    this.entries = [];
                    this.hoverPointers = {};
                    this.hoverOrder = [];
                    /** including text, marker and markers's margin */
                    this.entryWidth = 0;
                    this.textHeight = 0;
                    this.columns = null;
                    this.rows = null;
                    this.contentWidth = 0;
                    this.contentHeight = 0;
                    this.markerSize = 0;
                    this.drawingEntries = 0;
                    /** indicates that the last entry should be ... and no item to return */
                    this.lastInsensitive = false;
                    this.needsMeasure = false;
                    this.chart = chart;
                    this.settings = chart.settings.legend;
                    this.panel = new Base.ChartPanel();
                    // right after Toolbar panel
                    this.panel.packingOrder = 50;
                    this.panel.location = "outside";
                    this.panel.computeSize = function (aw, ah, g, lr) { return _this.computePanelSize(aw, ah, g, lr); };
                    Base.Helpers.extendDeep(this.panel, this.settings.panel);
                    this.orientation = (this.settings.panel.side === "left" || this.settings.panel.side === "right") ? "vertical" : "horizontal";
                }
                Legend.prototype.onSceneChange = function (event) {
                    var ch = event.changes;
                    if (ch.settings && ch.settingsChanges.legend) {
                        ch.bounds = true;
                        if (!this.settings.enabled) {
                            this.entries = [];
                        }
                        Base.Helpers.extendDeep(this.panel, this.settings.panel);
                    }
                };
                Legend.prototype.getPanels = function () {
                    return this.settings.enabled ? ([this.panel]) : ([]);
                };
                Legend.prototype.computePanelSize = function (availableWidth, availableHeight, g, labelRenderer) {
                    this.needsMeasure = false;
                    if (this.entries.length === 0 || !this.chart.assetsLoaded) {
                        return { width: 0, height: 0 };
                    }
                    var textWidth = Base.Graphics.getTextWidth(g, this.settings.text, "M") * this.settings.maxLineSymbols;
                    var maxHeight = 0;
                    var numberOfRows = this.settings.numberOfRows;
                    var numberOfColumns = this.settings.numberOfColumns;
                    var spaceE = 2 * (this.settings.margin + this.settings.padding);
                    var space = 2 * (this.settings.panel.margin + this.settings.panel.padding);
                    // get the max label height
                    for (var eIndex = 0; eIndex < this.entries.length; eIndex++) {
                        var e = this.entries[eIndex];
                        var labelParams = {
                            lineSpacing: this.settings.lineSpacing,
                            textStyle: this.settings.text,
                            text: e.labelText,
                            maxWidth: textWidth,
                            align: "left",
                            padding: 0,
                            aspectRatio: null
                        };
                        e.labelEnabled = new Base.Label(labelParams);
                        e.labelEnabled.style.textStyle.fillColor = e.textColorEnabled;
                        e.labelDisabled = new Base.Label(labelParams);
                        e.labelDisabled.style.textStyle.fillColor = e.textColorDisabled;
                        labelRenderer.measure(g, e.labelEnabled);
                        labelRenderer.measure(g, e.labelDisabled);
                        maxHeight = Math.max(maxHeight, e.labelEnabled.hheight * 2, e.labelDisabled.hheight * 2);
                    }
                    this.textHeight = this.entries[0].labelEnabled.lineHeight;
                    this.markerSize = this.settings.marker.size || this.textHeight;
                    maxHeight = Math.max(maxHeight, this.markerSize);
                    this.entryHeight = Math.max(maxHeight, this.markerSize) + spaceE;
                    this.entryWidth = textWidth + this.markerSize + this.settings.padding + spaceE;
                    // set legend dimensions based on predefined w or h or available space if definition exceeds available spece
                    var contAproxW = (this.settings.width > 0 ? Math.min(availableWidth, Math.max(this.settings.width, this.entryWidth) + space) : availableWidth) - space;
                    var contAproxH = (this.settings.height > 0 ? Math.min(availableHeight, Math.max(this.settings.height, this.entryHeight) + space) : availableHeight) - space;
                    var h;
                    var w;
                    if (this.orientation === "vertical") {
                        this.rows = Math.floor(contAproxH / this.entryHeight);
                        var calcColumns = Math.min(Math.ceil(this.entries.length / this.rows), Math.max(1, Math.floor(contAproxW / this.entryWidth)));
                        this.columns = (numberOfColumns > 0) ? (Math.min(numberOfColumns, calcColumns)) : calcColumns;
                        this.drawingEntries = Math.min(Math.floor(contAproxH / this.entryHeight) * this.columns, this.entries.length);
                        w = this.columns * this.entryWidth;
                        if (this.drawingEntries > this.rows) {
                            // we have more than 1 row or column
                            if (this.settings.equalizeRowsColumns) {
                                this.rows = Math.ceil(this.drawingEntries / this.columns);
                            }
                            h = this.rows * this.entryHeight;
                        }
                        else {
                            // all entries fit into one column
                            h = this.drawingEntries * this.entryHeight;
                        }
                    }
                    if (this.orientation === "horizontal") {
                        this.columns = Math.floor(contAproxW / this.entryWidth);
                        var calcRows = Math.min(Math.ceil(this.entries.length / this.columns), Math.max(1, Math.floor(contAproxH / this.entryHeight)));
                        this.rows = (numberOfRows > 0) ? (Math.min(numberOfRows, calcRows)) : calcRows;
                        this.drawingEntries = Math.min(Math.floor(contAproxW / this.entryWidth) * this.rows, this.entries.length);
                        h = this.rows * this.entryHeight;
                        if (this.drawingEntries > this.columns) {
                            if (this.settings.equalizeRowsColumns) {
                                this.columns = Math.ceil(this.drawingEntries / this.rows);
                            }
                            w = this.columns * this.entryWidth;
                        }
                        else {
                            w = this.drawingEntries * this.entryWidth;
                        }
                    }
                    if (w <= 0 || h <= 0) {
                        return { width: 0, height: 0 };
                    }
                    this.contentHeight = h;
                    this.contentWidth = w;
                    var pad = this.settings.panel.padding;
                    this.resetHovers();
                    return {
                        width: w + pad * 2,
                        height: h + pad * 2
                    };
                };
                Legend.prototype.paintScene = function (event) {
                    if (this.needsMeasure || !this.settings.enabled || this.entries.length < 1 || this.drawingEntries < 1)
                        return;
                    this.lastInsensitive = false;
                    var g = event.context;
                    var labelRenderer = event.labelRenderer;
                    var top = this.panel.top;
                    var left = this.panel.left;
                    // E - entry
                    var marginE = this.settings.margin;
                    var paddingE = this.settings.padding;
                    // P - panel
                    var paddingP = this.settings.panel.padding;
                    var col = 0;
                    var block = 0;
                    /* legend
                    @shape(g,left, top, @panel.right-left, @panel.bottom-top, "red") #debug: paint outline
                    @shape(g,left + paddingP, top + paddingP, @panel.right-left - 2*paddingP, @panel.bottom-top - 2*paddingP, "blue") #debug: paint outline */
                    for (var entr = 0; entr < this.drawingEntries; entr++) {
                        var whiteSpace = paddingP + marginE;
                        var x = left + whiteSpace + col * this.entryWidth;
                        var y = top + whiteSpace + block * this.entryHeight;
                        // @shape(g,x, y, @entryWidth - 2*marginE, @entryHeight - 2*marginE)   #debug - paint outline
                        var entry = this.entries[entr];
                        var label = entry.isEnabled() ? entry.labelEnabled : entry.labelDisabled;
                        var xtPos = void 0;
                        var xmPos = void 0;
                        if (this.settings.marker.alignment === "right") {
                            xtPos = x + paddingE + label.hwidth;
                            xmPos = x + this.entryWidth - 2 * (marginE + paddingE) - this.markerSize / 2;
                        }
                        else {
                            xtPos = x + this.markerSize + 2 * paddingE + label.hwidth;
                            xmPos = x + paddingE + this.markerSize / 2;
                        }
                        // marker && text
                        var alignToMarker = (label.hheight > this.markerSize / 2) ? 0 : (this.markerSize / 2 - this.textHeight / 2);
                        var ymPos = y + paddingE + this.markerSize / 2;
                        var ytPos = y + alignToMarker + paddingE + label.hheight;
                        // handle multi symbol
                        if (this.drawingEntries < this.entries.length && entr + 1 === this.drawingEntries) {
                            this.lastInsensitive = true;
                            Base.Graphics.resetTextStyle(g);
                            g.fillStyle = "#000";
                            g.textAlign = "left";
                            g.font = "bold 12px Arial";
                            g.fillText(". . .", xtPos - label.hwidth, ytPos);
                            break;
                        }
                        if (entry.isHovered()) {
                            this.rect(g, x, y, this.settings.advanced.selectedBorder, this.settings.advanced.selectedBackground, this.entryWidth - 2 * marginE, this.entryHeight - 2 * marginE);
                        }
                        labelRenderer.paint(g, xtPos, ytPos, 1, label);
                        this.paintMarker(event, xmPos, ymPos, this.markerSize / 2, entry);
                        if (this.orientation === "vertical") {
                            block += 1;
                            if (block === this.rows) {
                                block = 0;
                                col += 1;
                            }
                            if (col === this.columns) {
                                break;
                            }
                        }
                        else {
                            col += 1;
                            if (col === this.columns) {
                                col = 0;
                                block += 1;
                            }
                            if (block === this.rows) {
                                break;
                            }
                        }
                    }
                };
                Legend.prototype.findItemAt = function (x, y) {
                    if (this.entries.length === 0) {
                        return null;
                    }
                    var top = this.panel.top + this.settings.panel.padding;
                    var left = this.panel.left + this.settings.panel.padding;
                    var pointerApart = (x < left || x > left + this.contentWidth) || (y < top || y > top + this.contentHeight);
                    if (pointerApart) {
                        return null;
                    }
                    var entriesInSet = (this.orientation === "vertical") ? (Math.abs(this.contentHeight / this.entryHeight)) : (Math.abs(this.contentWidth / this.entryWidth));
                    // get the focused cell
                    var c;
                    var r;
                    if (this.orientation === "vertical") {
                        c = Math.floor((x - left) / this.entryWidth);
                        r = Math.floor((y - top) / this.entryHeight);
                    }
                    else {
                        c = Math.floor((y - top) / this.entryHeight);
                        r = Math.floor((x - left) / this.entryWidth);
                    }
                    var focusEntry = Math.floor(entriesInSet * c + r);
                    if (focusEntry > this.drawingEntries - 1) {
                        return null;
                    }
                    else {
                        if (this.lastInsensitive && focusEntry === this.drawingEntries - 1) {
                            return null;
                        }
                        return this.entries[focusEntry];
                    }
                };
                Legend.prototype.rect = function (g, x, y, strokeColor, fillColor, width, height) {
                    g.beginPath();
                    g.rect(x, y, width, height);
                    g.fillStyle = fillColor;
                    g.fill();
                    g.lineWidth = 1;
                    g.strokeStyle = strokeColor;
                    g.stroke();
                };
                Legend.prototype.resetEntries = function (entries) {
                    this.entries = entries;
                    this.needsMeasure = true;
                };
                Legend.prototype.getLastHoveredEntry = function () {
                    if (this.hoverOrder.length < 1)
                        return null;
                    return this.hoverOrder[this.hoverOrder.length - 1].entry;
                };
                Legend.prototype.resetHovers = function () {
                    for (var i = this.hoverOrder.length - 1; i >= 0; i--) {
                        var hoverPointer = this.hoverOrder[i];
                        var hoverEntry = this.findItemAt(hoverPointer.lastX, hoverPointer.lastY);
                        if (hoverPointer.entry === hoverEntry)
                            continue;
                        if (!hoverEntry) {
                            this.itemUnhovered(null, hoverPointer.entry);
                            delete this.hoverPointers[hoverPointer.id];
                            this.hoverOrder.splice(i, 1);
                        }
                        else {
                            this.itemUnhovered(null, hoverPointer.entry);
                            hoverPointer.entry = hoverEntry;
                            this.itemHovered(null, hoverEntry);
                        }
                    }
                };
                Legend.prototype.pointerHoverIn = function (event) {
                    var hoverPointer = this.hoverPointers[event.identifier];
                    var hoverEntry = this.findItemAt(event.x, event.y);
                    if (!hoverEntry) {
                        if (hoverPointer) {
                            this.itemUnhovered(event, hoverPointer.entry);
                            delete this.hoverPointers[event.identifier];
                            this.hoverOrder.splice(this.hoverOrder.indexOf(hoverPointer), 1);
                        }
                        return;
                    }
                    if (this.settings.interaction.click)
                        event.cursor = "pointer";
                    if (hoverPointer) {
                        hoverPointer.lastX = event.x;
                        hoverPointer.lastY = event.y;
                        if (hoverPointer.entry !== hoverEntry) {
                            this.itemUnhovered(event, hoverPointer.entry);
                            hoverPointer.entry = hoverEntry;
                            this.hoverOrder.splice(this.hoverOrder.indexOf(hoverPointer), 1);
                            this.hoverOrder.push(hoverPointer);
                            this.itemHovered(event, hoverEntry);
                        }
                    }
                    else {
                        hoverPointer = {
                            id: event.identifier,
                            lastX: event.x,
                            lastY: event.y,
                            entry: hoverEntry
                        };
                        this.hoverPointers[event.identifier] = hoverPointer;
                        this.hoverOrder.push(hoverPointer);
                        this.itemHovered(event, hoverEntry);
                    }
                };
                Legend.prototype.pointerHoverOut = function (event) {
                    var hoverPointer = this.hoverPointers[event.identifier];
                    if (!hoverPointer)
                        return;
                    this.itemUnhovered(event, hoverPointer.entry);
                    delete this.hoverPointers[event.identifier];
                    this.hoverOrder.splice(this.hoverOrder.indexOf(hoverPointer), 1);
                };
                /**
                 * Override to provide custom logic for when item is hovered by a pointer. Called once when the item becomes hovered.
                 * @param item The item that was hovered
                 */
                Legend.prototype.itemHovered = function (event, item) {
                    item.hoverCount++;
                    if (item.hoverCount === 1)
                        this.chart.events.notifySceneChanges({ hover: true });
                };
                /**
                 * Override to provide custom logic for when item is unhovered by a pointer. Called once when the item becomes unhovered.
                 * @param item The item that was unhovered
                 */
                Legend.prototype.itemUnhovered = function (event, item) {
                    item.hoverCount--;
                    if (item.hoverCount === 0) {
                        this.chart.events.notifySceneChanges({ hover: true });
                    }
                };
                /**
                 * Override to provide custom logic for when item is clicked by a pointer.
                 * @param item The item that was clicked.
                 */
                Legend.prototype.itemClicked = function (event, item) {
                    this.chart.events.requestPaint();
                    this.chart.notifyChartUpdate("user", true);
                    event.consumed = true;
                    event.preventDefault();
                    if (item.groupId == null || !item.enabled) {
                        item.enabled = !item.enabled;
                        return;
                    }
                    var group = this.entries.filter(function (x) { return x.groupId === item.groupId; });
                    if (group.length < 2) {
                        item.enabled = !item.enabled;
                        return;
                    }
                    var hasEnabled = false; // Is there an enabled item other than the clicked one?
                    var hasDisabled = false; // Is there a disabled item?
                    for (var i = 0; i < group.length; i++) {
                        if (group[i] !== item) {
                            if (group[i].enabled) {
                                hasEnabled = true;
                                if (hasDisabled)
                                    break;
                            }
                            else {
                                hasDisabled = true;
                                if (hasEnabled)
                                    break;
                            }
                        }
                    }
                    if (!hasEnabled) {
                        for (var i = 0; i < group.length; i++)
                            group[i].enabled = true;
                    }
                    else if (!hasDisabled) {
                        for (var i = 0; i < group.length; i++)
                            if (group[i] !== item)
                                group[i].enabled = false;
                    }
                    else {
                        item.enabled = !item.enabled;
                    }
                };
                Legend.prototype.previewPointerMove = function (event) {
                    this.pointerHoverIn(event);
                };
                Legend.prototype.previewPointerCancel = function (event) {
                    this.pointerHoverOut(event);
                };
                Legend.prototype.previewPointerOut = function (event) {
                    this.pointerHoverOut(event);
                };
                Legend.prototype.previewPointerUp = function (event) {
                    if (event.touch) {
                        this.pointerHoverOut(event);
                    }
                    else {
                        this.pointerHoverIn(event);
                    }
                };
                Legend.prototype.previewPointerDown = function (event) {
                    this.pointerHoverIn(event);
                    if (this.settings.interaction.click && this.hoverPointers[event.identifier])
                        event.consumed = true;
                };
                Legend.prototype.previewInstantClick = function (event) {
                    if (!this.settings.interaction.click)
                        return;
                    var item = this.findItemAt(event.x, event.y);
                    if (item) {
                        this.itemClicked(event, item);
                    }
                };
                return Legend;
            }(Base.ChartElement));
            Base.Legend = Legend;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../Helpers.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var Bar;
            (function (Bar) {
                var Item = (function () {
                    function Item(chart, options) {
                        this.chart = chart;
                        this.domElement = null;
                        if (options instanceof Base.SettingsToolbarItem) {
                            this.options = options;
                        }
                        else {
                            this.options = new Base.SettingsToolbarItem();
                            Base.SettingsHelper.updateRecursive(this.options, options, Base.SettingsMapping.BaseSettingsToolbarItem, {});
                        }
                    }
                    Item.prototype.onSceneChange = function (changes) {
                        // stub to override
                    };
                    Item.prototype.doAnimations = function (event) {
                        // stub to override
                    };
                    Item.prototype.previewPointerDown = function (event) {
                        // stub to override
                    };
                    return Item;
                }());
                Bar.Item = Item;
                var Button = (function (_super) {
                    __extends(Button, _super);
                    function Button(chart, options, skipParagraph, captureClick) {
                        var _this = this;
                        if (captureClick === void 0) { captureClick = true; }
                        _super.call(this, chart, options);
                        this.captureClick = captureClick;
                        this.onClickProxy = function (ev) { return _this.onClick(ev); };
                        this.createButton(skipParagraph);
                    }
                    Button.prototype.createButton = function (skipParagraph) {
                        this.domElement = Base.Helpers.createDom("li", null, null, null);
                        this.a = Base.Helpers.createDom("a", null, null, this.domElement);
                        this.p = skipParagraph ? this.a : Base.Helpers.createDom("p", null, null, this.a);
                        Base.Helpers.listen(this.a, "click", this.onClickProxy);
                        this.updateSettings();
                    };
                    Button.prototype.updateSettings = function () {
                        var opt = this.options;
                        var title = opt.title || opt.label || "";
                        var img = opt.image;
                        this.a.title = title;
                        var css = "DVSL-bar-btn " + (opt.cssClass ? opt.cssClass : (img ? "DVSL-bar-btn-image" : "DVSL-bar-btn-none"));
                        if (!opt.enabled)
                            css += " DVSL-bar-disabled";
                        this.a.className = css;
                        this.p.innerHTML = (opt.showLabel !== false && opt.label) || "";
                        this.p.style.backgroundImage = img ? "url(\"" + encodeURI(img) + "\")" : null;
                    };
                    Button.prototype.remove = function () {
                        Base.Helpers.unlisten(this.a, "click", this.onClickProxy);
                    };
                    Button.prototype.onClick = function (event) {
                        var opt = this.options;
                        if (opt.enabled && opt.onClick) {
                            opt.onClick(event, this.chart.api);
                            if (this.captureClick)
                                Base.Helpers.stopPropagation(event);
                        }
                    };
                    return Button;
                }(Item));
                Bar.Button = Button;
            })(Bar = Base.Bar || (Base.Bar = {}));
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Button.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var Bar;
            (function (Bar) {
                var DropdownBase = (function (_super) {
                    __extends(DropdownBase, _super);
                    function DropdownBase(chart, options) {
                        _super.call(this, chart, options);
                    }
                    DropdownBase.prototype.createButton = function () {
                        _super.prototype.createButton.call(this);
                        Base.Helpers.createDom("span", null, null, this.a);
                        Base.Helpers.addClass(this.a, "DVSL-bar-show-more");
                    };
                    DropdownBase.prototype.buildDropdownList = function () { return []; };
                    DropdownBase.prototype.onHideDropdown = function () {
                        // stub to override
                    };
                    DropdownBase.prototype.onClick = function (ev) {
                        if (this.dropdown) {
                            this.hideDropdown();
                        }
                        else {
                            this.showDropdown();
                        }
                        _super.prototype.onClick.call(this, ev);
                        Base.Helpers.stopPropagation(ev);
                    };
                    DropdownBase.prototype.showDropdown = function () {
                        var dropdown = this.dropdown = Base.Helpers.createDom("div", "DVSL-bar-dropdown", null, this.domElement);
                        dropdown.style.display = "block";
                        var ul = Base.Helpers.createDom("ul", null, null, dropdown);
                        var itemSource = this.buildDropdownList();
                        for (var itemIndex = 0; itemIndex < itemSource.length; itemIndex++) {
                            var item = itemSource[itemIndex];
                            ul.appendChild(item);
                        }
                        // position the popup so that it is (if possible) within the visible window bounds
                        var bounds = dropdown.getBoundingClientRect();
                        if (bounds.top < 0) {
                            // move the popup downwards
                            dropdown.style.marginBottom = (bounds.top | 0) + "px";
                            dropdown.className += " DVSL-no-triangle";
                        }
                        else {
                            // first part checks if the popup moves past the end of the window, the second makes sure
                            // it is not moved above the current viewport.
                            var deltaY = Math.max(window.innerHeight - bounds.bottom, -bounds.top);
                            // if the popup is not above the viewport, it is never moved down.
                            if (deltaY < 0) {
                                dropdown.style.marginTop = (deltaY | 0) + "px";
                                dropdown.className += " DVSL-no-triangle";
                            }
                        }
                    };
                    DropdownBase.prototype.hideDropdown = function () {
                        this.onHideDropdown();
                        this.dropdown.parentNode.removeChild(this.dropdown);
                        this.dropdown = null;
                        this.chart.shell.forceChromeRedraw();
                    };
                    DropdownBase.prototype.previewPointerDown = function (ev) {
                        // if click is outside the element, hide dropdown
                        var isInside = Base.Helpers.isParentOf(this.domElement, ev.target);
                        if (this.dropdown && !isInside) {
                            var elementPosResult = Base.Helpers.elementPos(this.chart.shell.interactiveContainer);
                            var cleft = elementPosResult.left;
                            var ctop = elementPosResult.top;
                            elementPosResult = Base.Helpers.elementPos(this.dropdown);
                            var left = elementPosResult.left;
                            var top = elementPosResult.top;
                            left -= cleft;
                            top -= ctop;
                            var right = left + this.dropdown.offsetWidth;
                            var bottom = top + this.dropdown.offsetHeight;
                            if (left > ev.x || top > ev.y || bottom < ev.y || right < ev.x) {
                                this.hideDropdown();
                            }
                        }
                    };
                    return DropdownBase;
                }(Bar.Button));
                Bar.DropdownBase = DropdownBase;
            })(Bar = Base.Bar || (Base.Bar = {}));
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="DropdownBase.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var Bar;
            (function (Bar) {
                var Dropdown = (function (_super) {
                    __extends(Dropdown, _super);
                    function Dropdown(chart, options) {
                        var _this = this;
                        _super.call(this, chart, options);
                        this.htmlItems = [];
                        this.clickProxy = function () { _this.hideDropdown(); };
                        var src = options.dropDownItems;
                        this.items = new Array(src.length);
                        for (var i = 0; i < src.length; i++) {
                            this.items[i] = new Bar.Button(chart, src[i], true, false);
                        }
                    }
                    Dropdown.prototype.buildDropdownList = function () {
                        this.htmlItems = new Array(this.items.length);
                        for (var i = 0; i < this.items.length; i++) {
                            var item = this.items[i];
                            Base.Helpers.listen(item.domElement, "click", this.clickProxy);
                            this.htmlItems[i] = item.domElement;
                        }
                        return this.htmlItems;
                    };
                    Dropdown.prototype.onHideDropdown = function () {
                        if (this.htmlItems) {
                            for (var i = 0; i < this.htmlItems.length; i++) {
                                var item = this.htmlItems[i];
                                item.parentNode.removeChild(item);
                                Base.Helpers.unlisten(item, "click", this.clickProxy);
                            }
                            this.htmlItems = null;
                        }
                    };
                    return Dropdown;
                }(Bar.DropdownBase));
                Bar.Dropdown = Dropdown;
            })(Bar = Base.Bar || (Base.Bar = {}));
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="DropdownBase.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var Bar;
            (function (Bar) {
                var Combobox = (function (_super) {
                    __extends(Combobox, _super);
                    /** Combobox options, similar to user button with added items array */
                    function Combobox(chart, options) {
                        // @options.items is array with items: {name: string, disabled: bool, selected: bool}
                        _super.call(this, chart, options);
                        this._lastLabel = "";
                    }
                    Combobox.prototype.buildDropdownList = function () {
                        var _this = this;
                        var items = [];
                        for (var itemIndex = 0, itemSource = this.getItems(); itemIndex < itemSource.length; itemIndex++) {
                            var item = itemSource[itemIndex];
                            var li = Base.Helpers.createDom("li", null, null, null);
                            var a = Base.Helpers.createDom("a", null, item.name, li);
                            if (item.selected) {
                                a.className = "DVSL-bar-dropdown-active";
                            }
                            if (item.disabled) {
                                a.className = "DVSL-bar-dropdown-disabled";
                            }
                            else {
                                // create closure to bind request variable
                                (function (a, item) {
                                    return Base.Helpers.listen(a, "click", function () { return _this.userSelected(item); });
                                })(a, item);
                            }
                            items.push(li);
                        }
                        return items;
                    };
                    Combobox.prototype.userSelected = function (item) {
                        this.hideDropdown();
                        this.setSelectedItem(item);
                        this.onSelectionChange(item);
                    };
                    /** sets selected item text */
                    Combobox.prototype.setSelectedItem = function (item) {
                        var s = item.name || "";
                        if (this.options.showLabel && this._lastLabel !== s) {
                            this.p.innerHTML = this._lastLabel = s;
                        }
                    };
                    return Combobox;
                }(Bar.DropdownBase));
                Bar.Combobox = Combobox;
            })(Bar = Base.Bar || (Base.Bar = {}));
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Button.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var Bar;
            (function (Bar) {
                var ToggleButton = (function (_super) {
                    __extends(ToggleButton, _super);
                    function ToggleButton(chart, options, additionalOptions) {
                        _super.call(this, chart, options);
                        this.additionalOptions = additionalOptions;
                        this.curState = null;
                        this.onSceneChange({});
                    }
                    ToggleButton.prototype.onSceneChange = function (changes) {
                        var newState = this.additionalOptions.getChartState();
                        if (newState !== this.curState) {
                            var opt = this.options;
                            var topt = this.additionalOptions;
                            this.curState = newState;
                            opt.cssClass = (newState && topt.cssClassEnabled) || topt.cssClassDisabled;
                            opt.label = (newState && topt.labelEnabled) || topt.labelDisabled;
                            opt.title = (newState && topt.titleEnabled) || topt.titleDisabled;
                            this.updateSettings();
                        }
                    };
                    ToggleButton.prototype.onClick = function (ev) {
                        if (this.options.enabled) {
                            if (this.curState) {
                                this.additionalOptions.onDisable();
                            }
                            else {
                                this.additionalOptions.onEnable();
                            }
                        }
                        this.onSceneChange(null);
                        _super.prototype.onClick.call(this, ev);
                        Base.Helpers.stopPropagation(ev);
                    };
                    return ToggleButton;
                }(Bar.Button));
                Bar.ToggleButton = ToggleButton;
            })(Bar = Base.Bar || (Base.Bar = {}));
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../core/ChartEvents.ts" />
/// <reference path="Button.ts" />
/// <reference path="Dropdown.ts" />
/// <reference path="Combobox.ts" />
/// <reference path="ToggleButton.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var Bar;
            (function (Bar) {
                // Base toolbar items
                Bar.ToolbarItemNames = {};
            })(Bar = Base.Bar || (Base.Bar = {}));
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var SettingsToolbar = (function () {
                function SettingsToolbar(enabled, items, side, align, showLabels) {
                    if (enabled === void 0) { enabled = false; }
                    /** Show/hide toolbar. */
                    this.enabled = false;
                    /** Toolbar location inside chart.
                    @type enum
                    @value inside - Inside chart area
                    @value outside - Outside of chart area */
                    this.location = "inside";
                    /** Toolbar placement side. Note that it can be overridden for individual items using item.side.
                    @type enum
                    @value left
                    @value right
                    @value top
                    @value bottom */
                    this.side = "top";
                    /** Toolbar align. Note that it can be overridden for individual items using item.align. Also Use 'top' or 'bottom'
                    sides in conjunction with 'left', 'right' align or use 'left', 'right' sides with 'top', 'bottom'.
                    @type enum
                    @value left
                    @value right
                    @value top
                    @value bottom */
                    this.align = "right";
                    /** Whether to show or hide labels next to toolbar items by default. Note that it can be overridden for individual items using item.showLabels. */
                    this.showLabels = true;
                    /** CSS class name for the toolbar HTML panel.
                    @version 1.11.6 */
                    this.cssClass = null;
                    /** A list of toolbar items. If this is specified, it overrides all the default buttons.
            
                    Use `extraItems` to specify items that should be displayed in addition to the defaults.
                    
                    @see Example: [custom toolbar items](time-chart/examples/toolbar/custom-items.html) */
                    this.items = [];
                    /** A list of user defined items to show in toolbar. These are displayed in addition to the
                    `items` collection (which includes the default buttons).
            
                    @see Example: [custom toolbar items](time-chart/examples/toolbar/custom-items.html) */
                    this.extraItems = [];
                    /** Whether to show back button in toolbar. */
                    this.back = true;
                    /** Whether to show export dropdown in toolbar. */
                    this.export = true;
                    /** Specifies what options will be provided for the user in the Export dropdown. Specifying `null` here
                    will enable all options.
            
                    Note that some charts do not support `XLSX` or `CSV` option so enabling it here will not have any effect.
            
                    Currently the order of the types given in this array are ignored.
                    @version 1.15.6 */
                    this.exportOptions = null;
                    /** Whether to show the zoom out button. */
                    this.zoomOut = false;
                    this.enabled = enabled;
                    if (items !== void 0)
                        this.items = items;
                    if (side !== void 0)
                        this.side = side;
                    if (align !== void 0)
                        this.align = align;
                    if (showLabels !== void 0)
                        this.showLabels = showLabels;
                }
                return SettingsToolbar;
            }());
            Base.SettingsToolbar = SettingsToolbar;
            var SettingsToolbarItemBase = (function () {
                function SettingsToolbarItemBase() {
                    /** Item label */
                    this.label = null;
                    /** Item title, shown on hover. */
                    this.title = null;
                    /** Item image, URL to image.
                    @type imageUrl */
                    this.image = null;
                    /** Determines if the toolbar item is rendered as disabled. Disabled item do not fire the `onClick` handler
                    when clicked.
                    @version 1.15.0 */
                    this.enabled = true;
                    /** Function to execute on item click. */
                    this.onClick = null;
                    /** CSS class name. */
                    this.cssClass = null;
                }
                return SettingsToolbarItemBase;
            }());
            Base.SettingsToolbarItemBase = SettingsToolbarItemBase;
            var SettingsToolbarItem = (function (_super) {
                __extends(SettingsToolbarItem, _super);
                function SettingsToolbarItem(item, align, side, location) {
                    _super.call(this);
                    /** Item location
                    @type enum
                    @value inside - Inside chart area
                    @value outside - Outside of chart area */
                    this.location = void 0;
                    /** Item side.
                    @type enum
                    @value left
                    @value right
                    @value top
                    @value bottom */
                    this.side = void 0;
                    /** Item align.
                    @type enum
                    @value left
                    @value right
                    @value top
                    @value bottom */
                    this.align = void 0;
                    /** Whether to show button label. */
                    this.showLabel = void 0;
                    /** Built in toolbar item name. Note that not all buttons are available for all charts.
                    @type enum
                    @value back - Back button used in all charts
                    @value displayPeriod - Display period dropdown used in time chart
                    @value displayUnit - Display unit dropdown used in time chart
                    @value export - Export dropdown list used in all charts except net chart
                    @value fit - Fit to screen button used in net chart
                    @value freeze - Freeze chart used in net chart
                    @value fullScreen - Togggle fullscreen mode used in net chart
                    @value logScale - Log scale button used in time chart and facet chart
                    @value rearrange - Rearrange elements in net chart
                    @value zoomOut - Zoom out button used in facet chart, time chart and pie chart
                    @value zoomControl - Zoom control to manage zoom used in net chart */
                    this.item = null;
                    /** An array of nested items. Setting this will display a dropdown item instead of a simple button.
                    
                    Note that nested dropdowns are not supported.
            
                    @version 1.12.0 */
                    this.dropDownItems = null;
                    if (item !== void 0)
                        this.item = item;
                    if (align !== void 0)
                        this.align = align;
                    if (side !== void 0)
                        this.side = side;
                    if (location !== void 0)
                        this.location = location;
                }
                return SettingsToolbarItem;
            }(SettingsToolbarItemBase));
            Base.SettingsToolbarItem = SettingsToolbarItem;
            /** Toolbar implementation */
            var Toolbar = (function (_super) {
                __extends(Toolbar, _super);
                function Toolbar(chart, options) {
                    _super.call(this);
                    this.panels = {};
                    this.panelList = [];
                    this.items = [];
                    this.animationOrder = 2000;
                    this.options = options;
                    this.chart = chart;
                    this.scene = this.chart.scene;
                    this.addItems();
                    this.chart.events.addElement(this);
                    this.chart.events.notifySceneChanges({ bounds: true });
                }
                Toolbar.prototype.rebuildItems = function () {
                    this.removeItems();
                    this.addItems();
                };
                Toolbar.prototype.addItems = function () {
                    if (this.options.enabled) {
                        for (var itemIndex = 0; itemIndex < this.options.items.length; itemIndex++) {
                            var item = this.options.items[itemIndex];
                            this.addItem(item);
                        }
                        for (var itemIndex = 0; itemIndex < this.options.extraItems.length; itemIndex++) {
                            var item = this.options.extraItems[itemIndex];
                            this.addItem(item);
                        }
                    }
                };
                Toolbar.prototype.removeItems = function () {
                    for (var itemIndex = 0; itemIndex < this.items.length; itemIndex++) {
                        var item = this.items[itemIndex];
                        item.remove();
                    }
                    for (var panelIndex = 0; panelIndex < this.panelList.length; panelIndex++) {
                        var panel = this.panelList[panelIndex];
                        // we do not want to remove panels, as they have "cached" content width
                        panel.clear();
                    }
                    this.items = [];
                };
                Toolbar.prototype.remove = function () {
                    this.removeItems();
                    for (var panelIndex = 0; panelIndex < this.panelList.length; panelIndex++) {
                        var panel = this.panelList[panelIndex];
                        panel.remove();
                    }
                    this.chart.events.removeElement(this);
                };
                Toolbar.prototype.addItem = function (itemOptionsOrName) {
                    var itemOptions;
                    var myOptions = this.options;
                    // create item
                    if (Base.Helpers.isString(itemOptionsOrName)) {
                        itemOptions = new SettingsToolbarItem(itemOptionsOrName, myOptions.align, myOptions.side, myOptions.location);
                    }
                    else {
                        itemOptions = Base.Helpers.clone(itemOptionsOrName);
                        itemOptions.align = itemOptions.align || this.options.align;
                        itemOptions.side = itemOptions.side || this.options.side;
                        itemOptions.location = itemOptions.location || this.options.location;
                    }
                    // find / create the panel
                    var panelStr = itemOptions.location + itemOptions.side;
                    var panel;
                    if (!this.panels.hasOwnProperty(panelStr)) {
                        panel = new ToolbarPanel(this, itemOptions.location, itemOptions.side, this.chart);
                        this.panelList.push(panel);
                        this.panels[panelStr] = panel;
                    }
                    else {
                        panel = this.panels[panelStr];
                    }
                    itemOptions.showLabel = ((itemOptions.showLabel != null) ? itemOptions.showLabel : myOptions.showLabels) && !panel.hideLabels;
                    var item;
                    if (itemOptions.item != null) {
                        var name = itemOptions.item;
                        // do not add if the item has been disabled
                        if (this.options[name] === false) {
                            return;
                        }
                        if (Base.Bar.ToolbarItemNames.hasOwnProperty(name)) {
                            item = Base.Bar.ToolbarItemNames[name](this.chart, itemOptions);
                        }
                        else {
                            this.chart.error("Toolbar item name '" + name + "' not recognized.");
                            return;
                        }
                    }
                    else if (itemOptions.dropDownItems) {
                        item = new Base.Bar.Dropdown(this.chart, itemOptions);
                    }
                    else {
                        item = new Base.Bar.Button(this.chart, itemOptions);
                    }
                    panel.addItem(item, itemOptions.align);
                    this.items.push(item);
                };
                Toolbar.prototype.getPanels = function () {
                    return this.panelList;
                };
                Toolbar.prototype.onSceneChange = function (event) {
                    for (var itemIndex = 0; itemIndex < this.items.length; itemIndex++) {
                        var item = this.items[itemIndex];
                        item.onSceneChange(event.changes);
                    }
                };
                Toolbar.prototype.doAnimations = function (event) {
                    for (var itemIndex = 0; itemIndex < this.items.length; itemIndex++) {
                        var item = this.items[itemIndex];
                        item.doAnimations(event);
                    }
                };
                Toolbar.prototype.previewGlobalPointerDown = function (event) {
                    for (var itemIndex = 0; itemIndex < this.items.length; itemIndex++) {
                        this.items[itemIndex].previewPointerDown(event);
                    }
                };
                return Toolbar;
            }(Base.ChartElement));
            Base.Toolbar = Toolbar;
            var ToolbarPanel = (function (_super) {
                __extends(ToolbarPanel, _super);
                function ToolbarPanel(toolbar, location, side, chart) {
                    _super.call(this);
                    this.chart = chart;
                    this.side = side;
                    this.location = location;
                    this.toolbar = toolbar;
                    this.packingOrder = (location === "inside") ? 1000 : 15;
                    this.container = this.toolbar.chart.shell.menuContainer;
                    this.floating = false;
                    this.align = "fill";
                    var customCssClass = (toolbar.options.cssClass) ? toolbar.options.cssClass + " " : "";
                    if (this.side === "top") {
                        this.vertical = false;
                        this.leftPanel = Base.Helpers.createDom("ul", customCssClass + "DVSL-bar-left DVSL-bar-top DVSL-bar-horizontal", null, this.container);
                        this.rightPanel = Base.Helpers.createDom("ul", customCssClass + "DVSL-bar-right DVSL-bar-top DVSL-bar-horizontal", null, this.container);
                    }
                    else if (this.side === "bottom") {
                        this.vertical = false;
                        this.leftPanel = Base.Helpers.createDom("ul", customCssClass + "DVSL-bar-left DVSL-bar-bottom DVSL-bar-horizontal", null, this.container);
                        this.rightPanel = Base.Helpers.createDom("ul", customCssClass + "DVSL-bar-right DVSL-bar-bottom DVSL-bar-horizontal", null, this.container);
                    }
                    else if (this.side === "left") {
                        this.vertical = true;
                        this.leftPanel = Base.Helpers.createDom("ul", customCssClass + "DVSL-bar-left DVSL-bar-top DVSL-bar-vertical", null, this.container);
                        this.rightPanel = Base.Helpers.createDom("ul", customCssClass + "DVSL-bar-left DVSL-bar-bottom DVSL-bar-vertical", null, this.container);
                    }
                    else if (this.side === "right") {
                        this.vertical = true;
                        this.leftPanel = Base.Helpers.createDom("ul", customCssClass + "DVSL-bar-right DVSL-bar-top DVSL-bar-vertical", null, this.container);
                        this.rightPanel = Base.Helpers.createDom("ul", customCssClass + "DVSL-bar-right DVSL-bar-bottom DVSL-bar-vertical", null, this.container);
                    }
                    else {
                        this.chart.error("Unrecognized side: '" + this.side + "'");
                    }
                    // hide until the placement is known
                    this.leftPanel.style.visibility = "hidden";
                    this.rightPanel.style.visibility = "hidden";
                }
                ToolbarPanel.prototype.addItem = function (item, align) {
                    if (align === "left" || align === "top") {
                        this.leftPanel.appendChild(item.domElement);
                    }
                    else if (align === "right" || align === "bottom") {
                        this.rightPanel.appendChild(item.domElement);
                    }
                    else {
                        this.chart.error("Unrecognized align: '" + align + "'");
                    }
                };
                ToolbarPanel.prototype.clear = function () {
                    this.leftPanel.innerHTML = "";
                    this.rightPanel.innerHTML = "";
                };
                ToolbarPanel.prototype.computeSize = function (availableWidth, availableHeight, context) {
                    // check if we need to hide/show labels, in vertical mode only
                    if (!this.vertical) {
                        if (!this.hideLabels) {
                            // save width with labels for later  use
                            this.contentWidthWithLabels = this.leftPanel.offsetWidth + this.rightPanel.offsetWidth;
                        }
                        var hideLabels = this.contentWidthWithLabels > 0 && this.contentWidthWithLabels > availableWidth;
                        if (hideLabels !== this.hideLabels) {
                            this.hideLabels = hideLabels;
                            this.toolbar.rebuildItems();
                        }
                    }
                    // toolbar fills in one dimension, compute the other dimension
                    if (this.vertical) {
                        return {
                            width: Math.max(this.leftPanel.offsetWidth, this.rightPanel.offsetWidth),
                            height: 0
                        };
                    }
                    else {
                        return {
                            width: 0,
                            height: Math.max(this.leftPanel.offsetHeight, this.rightPanel.offsetHeight)
                        };
                    }
                };
                ToolbarPanel.prototype.placePanel = function (left, top, right, bottom) {
                    var leftPanel = this.leftPanel.style;
                    var rightPanel = this.rightPanel.style;
                    var px = "px";
                    var scene = this.toolbar.scene;
                    if (this.vertical) {
                        leftPanel.top = top + px;
                        rightPanel.bottom = (scene.chartHeight - bottom) + px;
                        if (this.side === "left") {
                            leftPanel.left = left + px;
                            rightPanel.left = left + px;
                        }
                        else {
                            // right
                            leftPanel.right = (scene.chartWidth - right) + px;
                            rightPanel.right = (scene.chartWidth - right) + px;
                        }
                    }
                    else {
                        leftPanel.left = left + px;
                        rightPanel.right = (scene.chartWidth - right) + px;
                        if (this.side === "top") {
                            leftPanel.top = top + px;
                            rightPanel.top = top + px;
                        }
                        else {
                            // bottom
                            leftPanel.bottom = (scene.chartHeight - bottom) + px;
                            rightPanel.bottom = (scene.chartHeight - bottom) + px;
                        }
                        // try to make sure that the left and right toolbars do not overlap.
                        if (this.hideLabels)
                            rightPanel.marginLeft = this.leftPanel.offsetLeft + this.leftPanel.offsetWidth + "px";
                    }
                    // the offsetWidth check is to handle the situations when the whole chart container has display:none and as such
                    // the size calculations most probably are not correct.
                    if (this.leftPanel.offsetWidth > 0)
                        leftPanel.visibility = "visible";
                    if (this.rightPanel.offsetWidth > 0)
                        rightPanel.visibility = "visible";
                };
                ToolbarPanel.prototype.remove = function () {
                    this.container.removeChild(this.leftPanel);
                    this.container.removeChild(this.rightPanel);
                };
                return ToolbarPanel;
            }(Base.ChartPanel));
            Base.ToolbarPanel = ToolbarPanel;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="core/ChartEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var SettingsResizer = (function () {
                function SettingsResizer() {
                    /** Enable/disable chart resizing. */
                    this.enabled = true;
                    /** Whether to fix chart aspect ratio while resizing. */
                    this.fixedAspect = false;
                    /** Max pointer distance from chart edge when resize handle appears.
                    @type float
                    @units pixels */
                    this.visibilityDistance = 45;
                    /** Distance from chart edge that will be used for resizing.
                    @type float
                    @units pixels */
                    this.grabDistance = 10;
                }
                return SettingsResizer;
            }());
            Base.SettingsResizer = SettingsResizer;
            var Resizer = (function (_super) {
                __extends(Resizer, _super);
                function Resizer(chart) {
                    _super.call(this);
                    this.animationOrder = 2000;
                    this.paintOrder = 65;
                    this.updateOrder = 300;
                    this.oh = 0;
                    this.sy = 0;
                    this.barVisible = false;
                    this.resizing = false;
                    this.aspect = null;
                    this.chart = chart;
                    this.scene = this.chart.scene;
                    this.options = this.scene.settings.interaction.resizing;
                    this.resizerBar = Base.Helpers.createDom("div", "DVSL-resizer", null, this.chart.shell.interactiveContainer);
                }
                Resizer.prototype.onSceneChange = function (ev) {
                    if (!this.options.enabled) {
                        this.hideUI();
                    }
                };
                Resizer.prototype.doAnimations = function (event) {
                    if (event.changes.bounds && this.resizerBar) {
                        this.resizerBar.style.width = this.scene.chartWidth + "px";
                    }
                };
                Resizer.prototype.onPointerOut = function (ev) {
                    if (!this.options.enabled) {
                        return;
                    }
                    this.hideUI();
                };
                Resizer.prototype.onPointerMove = function (ev) {
                    if (!this.options.enabled) {
                        return;
                    }
                    var dy = this.scene.chartHeight - ev.y;
                    if (dy < this.options.visibilityDistance) {
                        if (!this.barVisible) {
                            this.showUI();
                        }
                        if (dy < this.options.grabDistance) {
                            ev.consumed = true;
                            ev.cursor = "ns-resize";
                        }
                    }
                    else {
                        if (this.barVisible) {
                            this.hideUI();
                        }
                    }
                };
                Resizer.prototype.onPointerDown = function (ev) {
                    if (!this.options.enabled) {
                        return;
                    }
                    this.sy = ev.y;
                    var dy = this.scene.chartHeight - ev.y;
                    this.resizing = dy < this.options.grabDistance && ev.y <= this.scene.chartHeight;
                    if (this.resizing) {
                        if (this.options.fixedAspect) {
                            this.aspect = Math.max(1, this.chart.scene.chartWidth) / Math.max(1, this.chart.scene.chartHeight);
                        }
                        else {
                            this.aspect = 0;
                        }
                        this.oh = this.scene.chartHeight;
                        this.showUI();
                        ev.cursor = "ns-resize";
                        ev.consumed = true; // this also sets ev.capture=true in the core
                    }
                };
                Resizer.prototype.onDoubleClick = function (ev) {
                    if (this.resizing) {
                        // toggle fullscreen.
                        this.chart.setFullscreen(!this.chart.isFullscreen());
                    }
                };
                Resizer.prototype.onPointerDrag = function (ev) {
                    if (!this.options.enabled) {
                        return;
                    }
                    if (this.chart.isFullscreen()) {
                        this.chart.setFullscreen(false);
                        this.hideUI();
                        ev.consumed = true;
                    }
                    else if (this.resizing) {
                        var areaSettings = this.scene.settings.area;
                        ev.consumed = true;
                        this.wasMaximized = false;
                        areaSettings.height = Math.min(areaSettings.maxHeight, Math.max(areaSettings.minHeight, this.oh + (ev.y - this.sy)));
                        if (this.aspect) {
                            areaSettings.width = areaSettings.height * this.aspect;
                        }
                        this.chart.updateSize(true);
                    }
                };
                Resizer.prototype.showUI = function () {
                    if (this.barVisible) {
                        return;
                    }
                    this.barVisible = true;
                    this.resizerBar.style.display = "block";
                };
                Resizer.prototype.hideUI = function () {
                    if (!this.barVisible) {
                        return;
                    }
                    this.barVisible = false;
                    this.resizing = false;
                    this.resizerBar.style.display = "none";
                };
                return Resizer;
            }(Base.ChartElement));
            Base.Resizer = Resizer;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            /* tslint:disable */
            var SettingsMapping = (function () {
                function SettingsMapping() {
                }
                /*#if Base*/
                SettingsMapping.BaseIChartErrorEventArguments = {};
                SettingsMapping.BaseIChartEventArguments = {};
                SettingsMapping.BaseIChartSettingsChangeEventArguments = {};
                SettingsMapping.BaseIDataErrorResponse = {
                    error: { t: 0 /* string */ },
                };
                SettingsMapping.BaseIDataObjectBase = {
                    extra: { t: 10 /* any */ },
                };
                SettingsMapping.BaseISettingsClassMap = {};
                SettingsMapping.BaseSettings = {
                    advanced: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsAdvanced; }, x: function () { return Internal.Base.SettingsAdvanced; } },
                    area: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsArea; }, x: function () { return Internal.Base.SettingsArea; } },
                    assetsUrlBase: { t: 0 /* string */ },
                    container: { t: 3 /* HTMLElement */ },
                    credits: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsCredits; }, x: function () { return Internal.Base.SettingsCredits; } },
                    data: { t: 6 /* array */, u: 4 /* mergeByID */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsData; }, x: function () { return Internal.Base.SettingsData; } }] },
                    events: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsEvents(SettingsMapping.BaseIChartEventArguments, SettingsMapping.BaseIChartEventArguments); }, x: function () { return Internal.Base.SettingsEvents; } },
                    interaction: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsInteraction; }, x: function () { return Internal.Base.SettingsInteraction; } },
                    legend: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLegend; }, x: function () { return Internal.Base.SettingsLegend; } },
                    localization: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLocalization; }, x: function () { return Internal.Base.SettingsLocalization; } },
                    parentChart: { t: 5 /* object */ },
                    theme: { t: 5 /* object */, c: function () { return SettingsMapping.BaseSettings; }, x: function () { return Internal.Base.Settings; }, y: true },
                    title: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsTitle; }, x: function () { return Internal.Base.SettingsTitle; } },
                    toolbar: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsToolbar; }, x: function () { return Internal.Base.SettingsToolbar; } },
                };
                SettingsMapping.BaseSettingsAdvanced = {
                    assets: { t: 6 /* array */, u: 3 /* concat */, b: [{ t: 7 /* union */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }, { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                                            url: { t: 0 /* string */ },
                                            required: { t: 4 /* delegate */ },
                                        }; } }] }] },
                    crossOriginHeader: { t: 7 /* union */, b: [{ t: 0 /* string */ }] },
                    exportPdfSize: { t: 12 /* tuple */, b: [{ t: 1 /* number */ }, { t: 1 /* number */ }] },
                    exportProxyURL: { t: 0 /* string */, d: 5 /* url */ },
                    highDPI: { t: 7 /* union */, b: [{ t: 9 /* boolean */ }, { t: 1 /* number */ }] },
                    labelCache: { t: 9 /* boolean */ },
                    labelCacheRotated: { t: 9 /* boolean */ },
                    logging: { t: 9 /* boolean */ },
                    maxCanvasHeight: { t: 1 /* number */, d: 0 /* integer */ },
                    maxCanvasWidth: { t: 1 /* number */, d: 0 /* integer */ },
                    pointer: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsAdvancedPointer; }, x: function () { return Internal.Base.SettingsAdvancedPointer; } },
                    showFPS: { t: 9 /* boolean */ },
                    showTimestamp: { t: 9 /* boolean */ },
                    showTouchTrail: { t: 9 /* boolean */ },
                    showTouches: { t: 9 /* boolean */ },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsAdvancedStyle; }, x: function () { return Internal.Base.SettingsAdvancedStyle; } },
                    themeCSSClass: { t: 0 /* string */ },
                    useAnimationFrame: { t: 9 /* boolean */ },
                };
                SettingsMapping.BaseSettingsAdvancedPointer = {
                    clickSensitivity: { t: 1 /* number */ },
                    doubleClickSensitivity: { t: 1 /* number */ },
                    doubleClickTimeout: { t: 1 /* number */, d: 0 /* integer */ },
                    longPressSensitivity: { t: 1 /* number */, d: 0 /* integer */ },
                    longPressTimeout: { t: 1 /* number */, d: 0 /* integer */ },
                    mouseWheelRequiresFocus: { t: 9 /* boolean */ },
                    noClickOnDoubleClick: { t: 9 /* boolean */ },
                    scrollIntoView: { t: 9 /* boolean */ },
                    speedAveragingPeriod: { t: 1 /* number */, d: 0 /* integer */ },
                };
                SettingsMapping.BaseSettingsAdvancedStyle = {
                    loadingArcStyle: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            lineColor: { t: 0 /* string */ },
                            lineWidth: { t: 1 /* number */ },
                            location: { t: 0 /* string */, d: 6 /* enum */ },
                            r: { t: 1 /* number */ },
                        }; } },
                    messageBackgroundStyle: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsAdvancedStyleMessageBackground; } },
                    messageTextStyle: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsTextStyle; } },
                };
                SettingsMapping.BaseSettingsAdvancedStyleMessageBackground = {
                    padding: { t: 1 /* number */ },
                };
                SettingsMapping.BaseSettingsArea = {
                    height: { t: 1 /* number */ },
                    left: { t: 1 /* number */ },
                    maxHeight: { t: 1 /* number */ },
                    maxWidth: { t: 1 /* number */ },
                    minHeight: { t: 1 /* number */ },
                    minWidth: { t: 1 /* number */ },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsAreaStyle; }, x: function () { return Internal.Base.SettingsAreaStyle; } },
                    top: { t: 1 /* number */ },
                    width: { t: 1 /* number */ },
                };
                SettingsMapping.BaseSettingsAreaStyle = {
                    fillColor: { t: 0 /* string */, d: 3 /* color */ },
                    image: { t: 0 /* string */, d: 4 /* imageUrl */ },
                    overlayColor: { t: 0 /* string */, d: 3 /* color */ },
                };
                SettingsMapping.BaseSettingsBackgroundStyle = {
                    fillColor: { t: 7 /* union */, b: [{ t: 0 /* string */ }, { t: 14 /* CanvasGradient */ }] },
                    shadowBlur: { t: 1 /* number */ },
                    shadowColor: { t: 0 /* string */ },
                    shadowOffsetX: { t: 1 /* number */ },
                    shadowOffsetY: { t: 1 /* number */ },
                };
                SettingsMapping.BaseSettingsChartPanel = {
                    align: { t: 0 /* string */, d: 6 /* enum */ },
                    floating: { t: 9 /* boolean */ },
                    location: { t: 0 /* string */, d: 6 /* enum */ },
                    margin: { t: 1 /* number */ },
                    side: { t: 0 /* string */, d: 6 /* enum */ },
                };
                SettingsMapping.BaseSettingsCredits = {
                    enabled: { t: 9 /* boolean */ },
                    enabledOnExport: { t: 9 /* boolean */ },
                    image: { t: 0 /* string */, d: 4 /* imageUrl */ },
                    imageExport: { t: 0 /* string */, d: 4 /* imageUrl */ },
                    imageScaling: { t: 1 /* number */ },
                    location: { t: 0 /* string */, d: 6 /* enum */ },
                    url: { t: 0 /* string */, d: 5 /* url */ },
                    urlTarget: { t: 0 /* string */ },
                };
                SettingsMapping.BaseSettingsData = {
                    format: { t: 7 /* union */, b: [{ t: 0 /* string */ }] },
                    id: { t: 0 /* string */ },
                    numberOfParallelRequests: { t: 1 /* number */, d: 0 /* integer */ },
                    postprocessorFunction: { t: 4 /* delegate */ },
                    preloaded: { t: 5 /* object */, c: function () { return SettingsMapping.BaseIDataErrorResponse; } },
                    requestTimeout: { t: 1 /* number */, d: 0 /* integer */ },
                    url: { t: 0 /* string */, d: 5 /* url */ },
                    urlParameters: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                                    name: { t: 0 /* string */ },
                                    value: { t: 0 /* string */ },
                                }; } }] },
                };
                SettingsMapping.BaseSettingsEvents = function (TArguments, TClickArguments) { return {
                    chartUpdateDelay: { t: 1 /* number */, d: 0 /* integer */ },
                    onChartUpdate: { t: 4 /* delegate */ },
                    onClick: { t: 4 /* delegate */ },
                    onDoubleClick: { t: 4 /* delegate */ },
                    onError: { t: 4 /* delegate */ },
                    onHoverChange: { t: 4 /* delegate */ },
                    onPositionChange: { t: 4 /* delegate */ },
                    onRightClick: { t: 4 /* delegate */ },
                    onSelectionChange: { t: 4 /* delegate */ },
                    onSettingsChange: { t: 4 /* delegate */ },
                    onTripleClick: { t: 4 /* delegate */ },
                }; };
                SettingsMapping.BaseSettingsInteraction = {
                    resizing: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsResizer; }, x: function () { return Internal.Base.SettingsResizer; } },
                };
                SettingsMapping.BaseSettingsLabelStyle = {
                    align: { t: 7 /* union */, b: [{ t: 0 /* string */ }] },
                    angle: { t: 1 /* number */, d: 0 /* integer */ },
                    aspectRatio: { t: 1 /* number */ },
                    backgroundStyle: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsBackgroundStyle; } },
                    borderRadius: { t: 1 /* number */ },
                    extra: { t: 10 /* any */ },
                    image: { t: 0 /* string */, d: 4 /* imageUrl */ },
                    imageSlicing: { t: 12 /* tuple */, b: [{ t: 1 /* number */ }, { t: 1 /* number */ }, { t: 1 /* number */ }, { t: 1 /* number */ }] },
                    lineSpacing: { t: 1 /* number */ },
                    margin: { t: 1 /* number */ },
                    maxWidth: { t: 1 /* number */ },
                    padding: { t: 1 /* number */ },
                    text: { t: 0 /* string */ },
                    textStyle: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsTextStyle; } },
                };
                SettingsMapping.BaseSettingsLegend = {
                    advanced: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLegendAdvanced; }, x: function () { return Internal.Base.SettingsLegendAdvanced; } },
                    enabled: { t: 9 /* boolean */ },
                    equalizeRowsColumns: { t: 9 /* boolean */ },
                    height: { t: 1 /* number */ },
                    interaction: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLegendInteraction; }, x: function () { return Internal.Base.SettingsLegendInteraction; } },
                    lineSpacing: { t: 1 /* number */ },
                    margin: { t: 1 /* number */ },
                    marker: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLegendMarker; }, x: function () { return Internal.Base.SettingsLegendMarker; } },
                    maxLineSymbols: { t: 1 /* number */, d: 0 /* integer */ },
                    numberOfColumns: { t: 1 /* number */, d: 0 /* integer */ },
                    numberOfRows: { t: 1 /* number */, d: 0 /* integer */ },
                    padding: { t: 1 /* number */ },
                    panel: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLegendPanel; }, x: function () { return Internal.Base.SettingsLegendPanel; } },
                    text: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsTextStyle; } },
                    width: { t: 1 /* number */ },
                };
                SettingsMapping.BaseSettingsLegendAdvanced = {
                    selectedBackground: { t: 0 /* string */, d: 3 /* color */ },
                    selectedBorder: { t: 0 /* string */, d: 3 /* color */ },
                };
                SettingsMapping.BaseSettingsLegendInteraction = {
                    click: { t: 9 /* boolean */ },
                };
                SettingsMapping.BaseSettingsLegendMarker = {
                    alignment: { t: 0 /* string */, d: 6 /* enum */ },
                    lineColor: { t: 0 /* string */, d: 3 /* color */ },
                    size: { t: 1 /* number */ },
                };
                SettingsMapping.BaseSettingsLegendPanel = {
                    padding: { t: 1 /* number */ },
                };
                SettingsMapping.BaseSettingsLineStyle = {
                    lineColor: { t: 0 /* string */ },
                    lineDash: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 1 /* number */ }] },
                    lineWidth: { t: 1 /* number */ },
                };
                SettingsMapping.BaseSettingsLocalization = {
                    closeButton: { t: 0 /* string */ },
                    dataRequestFailed: { t: 0 /* string */ },
                    exportNotAvailable: { t: 0 /* string */ },
                    loadingLabel: { t: 0 /* string */ },
                    toolbar: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLocalizationToolbar; }, x: function () { return Internal.Base.SettingsLocalizationToolbar; } },
                };
                SettingsMapping.BaseSettingsLocalizationToolbar = {
                    backButton: { t: 0 /* string */ },
                    backTitle: { t: 0 /* string */ },
                    exportButton: { t: 0 /* string */ },
                    exportCSV: { t: 0 /* string */ },
                    exportJpeg: { t: 0 /* string */ },
                    exportPDF: { t: 0 /* string */ },
                    exportPNG: { t: 0 /* string */ },
                    exportTitle: { t: 0 /* string */ },
                    exportXLS: { t: 0 /* string */ },
                    fullscreenButton: { t: 0 /* string */ },
                    fullscreenTitle: { t: 0 /* string */ },
                    zoomoutButton: { t: 0 /* string */ },
                    zoomoutTitle: { t: 0 /* string */ },
                };
                SettingsMapping.BaseSettingsResizer = {
                    enabled: { t: 9 /* boolean */ },
                    fixedAspect: { t: 9 /* boolean */ },
                    grabDistance: { t: 1 /* number */ },
                    visibilityDistance: { t: 1 /* number */ },
                };
                SettingsMapping.BaseSettingsTextStyle = {
                    fillColor: { t: 0 /* string */ },
                    font: { t: 0 /* string */ },
                    outlineColor: { t: 0 /* string */ },
                    outlineJoin: { t: 0 /* string */, d: 6 /* enum */ },
                    outlineWidth: { t: 1 /* number */ },
                    shadowBlur: { t: 1 /* number */ },
                    shadowColor: { t: 0 /* string */ },
                    shadowOffsetX: { t: 1 /* number */ },
                    shadowOffsetY: { t: 1 /* number */ },
                };
                SettingsMapping.BaseSettingsTitle = {
                    align: { t: 0 /* string */, d: 6 /* enum */ },
                    enabled: { t: 9 /* boolean */ },
                    enabledOnExport: { t: 9 /* boolean */ },
                    margin: { t: 1 /* number */ },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            fillColor: { t: 0 /* string */ },
                            font: { t: 0 /* string */ },
                        }; } },
                    text: { t: 0 /* string */ },
                };
                SettingsMapping.BaseSettingsToolbar = {
                    align: { t: 0 /* string */, d: 6 /* enum */ },
                    back: { t: 9 /* boolean */ },
                    cssClass: { t: 0 /* string */ },
                    enabled: { t: 9 /* boolean */ },
                    export: { t: 9 /* boolean */ },
                    exportOptions: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 7 /* union */, b: [{ t: 0 /* string */ }] }] },
                    extraItems: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 7 /* union */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }, { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsToolbarItem; }, x: function () { return Internal.Base.SettingsToolbarItem; } }] }] },
                    items: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 7 /* union */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }, { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsToolbarItem; }, x: function () { return Internal.Base.SettingsToolbarItem; } }] }] },
                    location: { t: 0 /* string */, d: 6 /* enum */ },
                    showLabels: { t: 9 /* boolean */ },
                    side: { t: 0 /* string */, d: 6 /* enum */ },
                    zoomOut: { t: 9 /* boolean */ },
                };
                SettingsMapping.BaseSettingsToolbarItem = {
                    align: { t: 0 /* string */, d: 6 /* enum */ },
                    dropDownItems: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsToolbarItemBase; }, x: function () { return Internal.Base.SettingsToolbarItemBase; } }] },
                    item: { t: 0 /* string */, d: 6 /* enum */ },
                    location: { t: 0 /* string */, d: 6 /* enum */ },
                    showLabel: { t: 9 /* boolean */ },
                    side: { t: 0 /* string */, d: 6 /* enum */ },
                };
                SettingsMapping.BaseSettingsToolbarItemBase = {
                    cssClass: { t: 0 /* string */ },
                    enabled: { t: 9 /* boolean */ },
                    image: { t: 0 /* string */, d: 4 /* imageUrl */ },
                    label: { t: 0 /* string */ },
                    onClick: { t: 4 /* delegate */ },
                    title: { t: 0 /* string */ },
                };
                /*#endif*/
                /*#if FacetChart*/
                SettingsMapping.FacetChartIChartClickEventArguments = {};
                SettingsMapping.FacetChartIChartEventArguments = {};
                SettingsMapping.FacetChartSettings = {
                    chartTypes: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            columns: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.FacetChartSettingsSeriesColumns; }, x: function () { return Internal.FacetChart.SettingsSeriesColumns; }, y: true },
                            line: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.FacetChartSettingsSeriesLines; }, x: function () { return Internal.FacetChart.SettingsSeriesLines; }, y: true },
                        }; } },
                    data: { t: 6 /* array */, u: 4 /* mergeByID */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.PieChartSettingsData; }, x: function () { return Internal.PieChart.SettingsData; } }] },
                    events: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsEvents(SettingsMapping.FacetChartIChartEventArguments, SettingsMapping.FacetChartIChartClickEventArguments); }, x: function () { return Internal.LinearChart.SettingsEvents; } },
                    facetAxis: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.FacetChartSettingsFacetAxis; }, x: function () { return Internal.FacetChart.SettingsFacetAxis; } },
                    filters: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            allowZeroValues: { t: 9 /* boolean */ },
                            sliceFilter: { t: 4 /* delegate */ },
                        }; } },
                    interaction: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.FacetChartSettingsInteraction; }, x: function () { return Internal.FacetChart.SettingsInteraction; } },
                    items: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                                    expandable: { t: 9 /* boolean */ },
                                    label: { t: 0 /* string */ },
                                }; } },
                            styleFunction: { t: 4 /* delegate */ },
                        }; } },
                    legend: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsLegend; }, x: function () { return Internal.LinearChart.SettingsLegend; } },
                    navigation: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            initialDrilldown: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }] },
                            initialOffset: { t: 1 /* number */, d: 0 /* integer */ },
                        }; } },
                    scrollButtons: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.FacetChartSettingsScrollButtons; }, x: function () { return Internal.FacetChart.SettingsScrollButtons; } },
                    series: { t: 6 /* array */, u: 4 /* mergeByID */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.FacetChartSettingsSeries; }, x: function () { return Internal.FacetChart.SettingsSeries; }, y: true }] },
                    seriesDefault: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.FacetChartSettingsSeries; }, x: function () { return Internal.FacetChart.SettingsSeries; }, y: true },
                    theme: { t: 5 /* object */, c: function () { return SettingsMapping.FacetChartSettings; }, x: function () { return Internal.FacetChart.Settings; }, y: true },
                    toolbar: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.FacetChartSettingsToolbar; }, x: function () { return Internal.FacetChart.SettingsToolbar; } },
                };
                SettingsMapping.FacetChartSettingsFacetAxis = {
                    defaultUnitWidth: { t: 1 /* number */ },
                    enabled: { t: 9 /* boolean */ },
                    labels: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.FacetChartSettingsFacetAxisLabels; } },
                    maxUnitWidth: { t: 1 /* number */ },
                    size: { t: 1 /* number */ },
                    title: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.FacetChartSettingsFacetAxisTitleStyle; } },
                    zoomOutUnitWidth: { t: 1 /* number */ },
                };
                SettingsMapping.FacetChartSettingsFacetAxisLabels = {
                    allowOverflow: { t: 9 /* boolean */ },
                    enabled: { t: 9 /* boolean */ },
                    interLabelSpacing: { t: 1 /* number */ },
                    text: { t: 0 /* string */ },
                };
                SettingsMapping.FacetChartSettingsFacetAxisTitleStyle = {
                    enabled: { t: 9 /* boolean */ },
                    text: { t: 0 /* string */ },
                    useFacetName: { t: 9 /* boolean */ },
                };
                SettingsMapping.FacetChartSettingsFacetStyle = {};
                SettingsMapping.FacetChartSettingsInteraction = {
                    animation: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            scrollDuration: { t: 1 /* number */, d: 0 /* integer */ },
                        }; } },
                    selection: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.FacetChartSettingsInteractionSelection; }, x: function () { return Internal.FacetChart.SettingsInteractionSelection; } },
                };
                SettingsMapping.FacetChartSettingsInteractionSelection = {
                    enabled: { t: 9 /* boolean */ },
                    tolerance: { t: 1 /* number */ },
                };
                SettingsMapping.FacetChartSettingsScrollButtons = {
                    enabled: { t: 9 /* boolean */ },
                    enabledOnExport: { t: 9 /* boolean */ },
                    size: { t: 1 /* number */ },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            fillColor: { t: 0 /* string */ },
                            hoverFillColor: { t: 0 /* string */ },
                            hoverLineColor: { t: 0 /* string */ },
                            lineColor: { t: 0 /* string */ },
                        }; } },
                };
                SettingsMapping.FacetChartSettingsSeries = {
                    data: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.FacetChartSettingsSeriesData; }, x: function () { return Internal.FacetChart.SettingsSeriesData; } },
                    type: { t: 0 /* string */, d: 6 /* enum */ },
                };
                SettingsMapping.FacetChartSettingsSeriesColumns = {
                    data: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.FacetChartSettingsSeriesData; }, x: function () { return Internal.FacetChart.SettingsSeriesData; } },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.FacetChartSettingsSeriesColumnsStyle; }, x: function () { return Internal.FacetChart.SettingsSeriesColumnsStyle; } },
                };
                SettingsMapping.FacetChartSettingsSeriesColumnsStyle = {
                    previewContents: { t: 9 /* boolean */ },
                    previewLineColor: { t: 0 /* string */ },
                };
                SettingsMapping.FacetChartSettingsSeriesData = {
                    field: { t: 0 /* string */ },
                    valueFunction: { t: 4 /* delegate */ },
                };
                SettingsMapping.FacetChartSettingsSeriesLines = {
                    data: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.FacetChartSettingsSeriesData; }, x: function () { return Internal.FacetChart.SettingsSeriesData; } },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.FacetChartSettingsSeriesLinesStyle; }, x: function () { return Internal.FacetChart.SettingsSeriesLinesStyle; } },
                };
                SettingsMapping.FacetChartSettingsSeriesLinesStyle = {
                    markerStyleFunction: { t: 4 /* delegate */ },
                };
                SettingsMapping.FacetChartSettingsToolbar = {
                    enabled: { t: 9 /* boolean */ },
                    items: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsToolbarItem; }, x: function () { return Internal.Base.SettingsToolbarItem; } }] },
                    logScale: { t: 9 /* boolean */ },
                    zoomOut: { t: 9 /* boolean */ },
                };
                /*#endif*/
                /*#if GeoChart*/
                SettingsMapping.GeoChartIAggregationDataObjectNode = {
                    aggregatedNodes: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.GeoChartIGeoDataObjectNode; } }] },
                    aggregatedWeight: { t: 1 /* number */ },
                };
                SettingsMapping.GeoChartIDataObject = {
                    east: { t: 1 /* number */ },
                    links: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.GeoChartIGeoDataObjectLink; } }] },
                    nodes: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.GeoChartIGeoDataObjectNode; } }] },
                    north: { t: 1 /* number */ },
                    south: { t: 1 /* number */ },
                    west: { t: 1 /* number */ },
                };
                SettingsMapping.GeoChartIGeoDataObjectLink = {};
                SettingsMapping.GeoChartIGeoDataObjectNode = {
                    aggregate: { t: 9 /* boolean */ },
                    coordinates: { t: 7 /* union */, u: 0 /* recursive */, b: [{ t: 12 /* tuple */, b: [{ t: 1 /* number */ }, { t: 1 /* number */ }] }, { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 1 /* number */ }] }] }] },
                    count: { t: 1 /* number */ },
                    shapeFeature: { t: 10 /* any */ },
                    shapeGeometry: { t: 10 /* any */ },
                    type: { t: 0 /* string */ },
                };
                SettingsMapping.GeoChartSettings = {
                    area: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.GeoChartSettingsArea; }, x: function () { return Internal.GeoChart.SettingsArea; } },
                    background: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.GeoChartSettingsBackground; }, x: function () { return Internal.GeoChart.SettingsBackground; } },
                    data: { t: 6 /* array */, u: 4 /* mergeByID */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.GeoChartSettingsData; }, x: function () { return Internal.GeoChart.SettingsData; } }] },
                    filters: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            nodeFilter: { t: 4 /* delegate */ },
                        }; } },
                    interaction: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.GeoChartSettingsInteraction; }, x: function () { return Internal.GeoChart.SettingsInteraction; } },
                    layerTypes: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            aggregateOnShapes: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.GeoChartSettingsLayerAggregated; }, x: function () { return Internal.GeoChart.SettingsLayerAggregated; }, y: true },
                            charts: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.GeoChartSettingsLayerCharts; }, x: function () { return Internal.GeoChart.SettingsLayerCharts; }, y: true },
                            items: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.GeoChartSettingsLayerItems; }, x: function () { return Internal.GeoChart.SettingsLayerItems; }, y: true },
                            shapes: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.GeoChartSettingsLayerShapes; }, x: function () { return Internal.GeoChart.SettingsLayerShapes; }, y: true },
                        }; } },
                    layers: { t: 6 /* array */, u: 4 /* mergeByID */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.GeoChartSettingsLayerBase; }, x: function () { return Internal.GeoChart.SettingsLayerBase; }, y: true }] },
                    layersDefault: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.GeoChartSettingsLayerBase; }, x: function () { return Internal.GeoChart.SettingsLayerBase; }, y: true },
                    navigation: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            drilldownLayer: { t: 0 /* string */ },
                            initialDrilldown: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }] },
                            initialLat: { t: 1 /* number */ },
                            initialLng: { t: 1 /* number */ },
                            initialZoom: { t: 1 /* number */ },
                            maxBounds: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                                    east: { t: 1 /* number */ },
                                    north: { t: 1 /* number */ },
                                    south: { t: 1 /* number */ },
                                    west: { t: 1 /* number */ },
                                }; } },
                            maxZoom: { t: 1 /* number */ },
                            minZoom: { t: 1 /* number */ },
                        }; } },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            fadeTime: { t: 1 /* number */ },
                            selection: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                                    fillColor: { t: 0 /* string */ },
                                    sizeConstant: { t: 1 /* number */ },
                                    sizeProportional: { t: 1 /* number */ },
                                }; } },
                        }; } },
                    theme: { t: 5 /* object */, c: function () { return SettingsMapping.GeoChartSettings; }, x: function () { return Internal.GeoChart.Settings; }, y: true },
                    toolbar: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsToolbar; }, x: function () { return Internal.Base.SettingsToolbar; } },
                };
                SettingsMapping.GeoChartSettingsAggregatedShapeStyle = {
                    mode: { t: 2 /* enum */, e: function () { return ZoomCharts.Configuration.GeoChartSettingsAggregatedShapeStyleMode; } },
                };
                SettingsMapping.GeoChartSettingsAggregation = {
                    distance: { t: 1 /* number */, d: 0 /* integer */ },
                    enabled: { t: 9 /* boolean */ },
                    maxZoom: { t: 1 /* number */, d: 0 /* integer */ },
                    postProcessAggregatedNodes: { t: 4 /* delegate */ },
                    weightFunction: { t: 4 /* delegate */ },
                };
                SettingsMapping.GeoChartSettingsArea = {
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.GeoChartSettingsAreaStyle; }, x: function () { return Internal.GeoChart.SettingsAreaStyle; } },
                };
                SettingsMapping.GeoChartSettingsAreaStyle = {};
                SettingsMapping.GeoChartSettingsBackground = {
                    enabled: { t: 9 /* boolean */ },
                    params: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.GeoChartSettingsBackgroundParams; } },
                    type: { t: 7 /* union */, b: [{ t: 0 /* string */ }] },
                    url: { t: 0 /* string */ },
                };
                SettingsMapping.GeoChartSettingsBackgroundParams = {
                    attribution: { t: 0 /* string */ },
                    continuousWorld: { t: 9 /* boolean */ },
                    detectRetina: { t: 9 /* boolean */ },
                    errorTileUrl: { t: 0 /* string */ },
                    maxNativeZoom: { t: 1 /* number */ },
                    maxZoom: { t: 1 /* number */ },
                    minZoom: { t: 1 /* number */ },
                    noWrap: { t: 9 /* boolean */ },
                    opacity: { t: 1 /* number */ },
                    reuseTiles: { t: 9 /* boolean */ },
                    subdomains: { t: 7 /* union */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }, { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }] }] },
                    tileSize: { t: 1 /* number */ },
                    tms: { t: 9 /* boolean */ },
                    unloadInvisibleTiles: { t: 9 /* boolean */ },
                    updateWhenIdle: { t: 9 /* boolean */ },
                    zIndex: { t: 1 /* number */ },
                    zoomOffset: { t: 1 /* number */ },
                    zoomReverse: { t: 9 /* boolean */ },
                };
                SettingsMapping.GeoChartSettingsData = {
                    aggregationGridSize: { t: 1 /* number */ },
                    aggregationMinCount: { t: 1 /* number */ },
                    bounds: { t: 12 /* tuple */, b: [{ t: 1 /* number */ }, { t: 1 /* number */ }, { t: 1 /* number */ }, { t: 1 /* number */ }] },
                    dataFunction: { t: 4 /* delegate */ },
                    maxRequestRect: { t: 12 /* tuple */, b: [{ t: 1 /* number */ }, { t: 1 /* number */ }] },
                    perBoundsData: { t: 9 /* boolean */ },
                    perDrilldownData: { t: 9 /* boolean */ },
                    perZoomData: { t: 9 /* boolean */ },
                    prefetchRatio: { t: 1 /* number */ },
                    preloaded: { t: 5 /* object */, c: function () { return SettingsMapping.GeoChartIDataObject; } },
                    useGridBasedAggregation: { t: 9 /* boolean */ },
                    wrapLng: { t: 9 /* boolean */ },
                };
                SettingsMapping.GeoChartSettingsInteraction = {
                    mode: { t: 0 /* string */, d: 6 /* enum */ },
                };
                SettingsMapping.GeoChartSettingsLayerAggregated = {
                    aggregation: { t: 0 /* string */, d: 6 /* enum */ },
                    aggregationField: { t: 0 /* string */ },
                    aggregationFunction: { t: 4 /* delegate */ },
                    shapesLayer: { t: 0 /* string */ },
                    styleFunction: { t: 4 /* delegate */ },
                };
                SettingsMapping.GeoChartSettingsLayerBase = {
                    data: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            id: { t: 0 /* string */ },
                        }; } },
                    enabled: { t: 9 /* boolean */ },
                    id: { t: 0 /* string */ },
                    maxZoom: { t: 1 /* number */, d: 0 /* integer */ },
                    minZoom: { t: 1 /* number */, d: 0 /* integer */ },
                    name: { t: 0 /* string */ },
                    perZoomStyle: { t: 9 /* boolean */ },
                    type: { t: 0 /* string */, d: 6 /* enum */ },
                };
                SettingsMapping.GeoChartSettingsLayerCharts = {
                    chartType: { t: 0 /* string */, d: 6 /* enum */ },
                    data: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            id: { t: 0 /* string */ },
                        }; } },
                    settings: { t: 7 /* union */, b: [{ t: 5 /* object */, c: function () { return SettingsMapping.PieChartSettings; }, x: function () { return Internal.PieChart.Settings; }, y: true }, { t: 5 /* object */, c: function () { return SettingsMapping.TimeChartSettings; }, x: function () { return Internal.TimeChart.Settings; }, y: true }, { t: 5 /* object */, c: function () { return SettingsMapping.FacetChartSettings; }, x: function () { return Internal.FacetChart.Settings; }, y: true }] },
                    settingsFunction: { t: 4 /* delegate */ },
                    shapesLayer: { t: 0 /* string */ },
                };
                SettingsMapping.GeoChartSettingsLayerItems = {
                    aggregation: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.GeoChartSettingsAggregation; }, x: function () { return Internal.GeoChart.SettingsAggregation; } },
                    auras: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsNodesLayerAuras; }, x: function () { return Internal.ItemsChart.SettingsNodesLayerAuras; } },
                    layout: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.GeoChartSettingsNodesLayout; }, x: function () { return Internal.GeoChart.SettingsNodesLayout; } },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.GeoChartSettingsNodesLayerStyle; }, x: function () { return Internal.GeoChart.SettingsNodesLayerStyle; } },
                };
                SettingsMapping.GeoChartSettingsLayerOverlay = {
                    shapesLayer: { t: 0 /* string */ },
                };
                SettingsMapping.GeoChartSettingsLayerShapes = {
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.GeoChartSettingsShapesLayerStyle; }, x: function () { return Internal.GeoChart.SettingsShapesLayerStyle; } },
                };
                SettingsMapping.GeoChartSettingsNodesLayerStyle = {
                    aggregatedShape: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.GeoChartSettingsAggregatedShapeStyle; } },
                };
                SettingsMapping.GeoChartSettingsNodesLayout = {
                    anchorStrength: { t: 1 /* number */ },
                    mode: { t: 0 /* string */, d: 6 /* enum */ },
                    nodeSpacing: { t: 1 /* number */, d: 0 /* integer */ },
                };
                SettingsMapping.GeoChartSettingsShapesLayerNodeStyle = {
                    expandable: { t: 9 /* boolean */ },
                };
                SettingsMapping.GeoChartSettingsShapesLayerStyle = {
                    node: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.GeoChartSettingsShapesLayerNodeStyle; } },
                    shapeSimplificationPrecision: { t: 1 /* number */ },
                };
                /*#endif*/
                /*#if ItemsChart*/
                SettingsMapping.ItemsChartIChartClickEventArguments = {};
                SettingsMapping.ItemsChartIChartEventArguments = {};
                SettingsMapping.ItemsChartIDataObjectBase = {};
                SettingsMapping.ItemsChartIDataObjectLink = {
                    className: { t: 0 /* string */ },
                    from: { t: 0 /* string */ },
                    id: { t: 0 /* string */ },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsLinkStyle; } },
                    to: { t: 0 /* string */ },
                };
                SettingsMapping.ItemsChartIDataObjectNode = {
                    className: { t: 0 /* string */ },
                    id: { t: 0 /* string */ },
                    loaded: { t: 9 /* boolean */ },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsNodeStyle; } },
                };
                SettingsMapping.ItemsChartSettings = {
                    advanced: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsAdvanced; }, x: function () { return Internal.ItemsChart.SettingsAdvanced; } },
                    data: { t: 6 /* array */, u: 4 /* mergeByID */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsData; }, x: function () { return Internal.ItemsChart.SettingsData; } }] },
                    events: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsEvents(SettingsMapping.ItemsChartIChartEventArguments, SettingsMapping.ItemsChartIChartClickEventArguments); }, x: function () { return Internal.Base.SettingsEvents; } },
                    info: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            enabled: { t: 9 /* boolean */ },
                            linkContentsFunction: { t: 4 /* delegate */ },
                            nodeContentsFunction: { t: 4 /* delegate */ },
                        }; } },
                    interaction: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsInteraction; }, x: function () { return Internal.ItemsChart.SettingsInteraction; } },
                    linkMenu: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsLinkMenu; }, x: function () { return Internal.ItemsChart.SettingsLinkMenu; } },
                    nodeMenu: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsNodeMenu; }, x: function () { return Internal.ItemsChart.SettingsNodeMenu; } },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {}; } },
                };
                SettingsMapping.ItemsChartSettingsAdvanced = {
                    perNodeLoadingIndicator: { t: 9 /* boolean */ },
                };
                SettingsMapping.ItemsChartSettingsAuraStyle = {
                    enabled: { t: 9 /* boolean */ },
                    legendGroupId: { t: 0 /* string */ },
                    nameLegend: { t: 0 /* string */ },
                    showInLegend: { t: 9 /* boolean */ },
                    zIndex: { t: 1 /* number */ },
                };
                SettingsMapping.ItemsChartSettingsCustomShape = {
                    distanceToEdge: { t: 4 /* delegate */ },
                    hitTest: { t: 4 /* delegate */ },
                    onUpdate: { t: 4 /* delegate */ },
                    paint: { t: 4 /* delegate */ },
                    paintSelection: { t: 4 /* delegate */ },
                };
                SettingsMapping.ItemsChartSettingsData = {
                    cacheSize: { t: 1 /* number */, d: 0 /* integer */ },
                    random: { t: 0 /* string */, d: 6 /* enum */ },
                    randomGridLinkProbability: { t: 1 /* number */ },
                    randomLinks: { t: 1 /* number */, d: 0 /* integer */ },
                    randomNodes: { t: 1 /* number */, d: 0 /* integer */ },
                    randomTreeDensity: { t: 1 /* number */ },
                    requestMaxUnits: { t: 1 /* number */, d: 0 /* integer */ },
                };
                SettingsMapping.ItemsChartSettingsInteraction = {
                    nodesMovable: { t: 9 /* boolean */ },
                    panning: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            enabled: { t: 9 /* boolean */ },
                        }; } },
                    selection: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsInteractionSelection; }, x: function () { return Internal.ItemsChart.SettingsInteractionSelection; } },
                    zooming: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsInteractionZooming; }, x: function () { return Internal.ItemsChart.SettingsInteractionZooming; } },
                };
                SettingsMapping.ItemsChartSettingsInteractionSelection = {
                    allowMoveNodesOffscreen: { t: 9 /* boolean */ },
                    enabled: { t: 9 /* boolean */ },
                    linksSelectable: { t: 9 /* boolean */ },
                    lockNodesOnMove: { t: 9 /* boolean */ },
                    nodesSelectable: { t: 9 /* boolean */ },
                    tolerance: { t: 1 /* number */ },
                };
                SettingsMapping.ItemsChartSettingsInteractionZooming = {
                    autoZoomAfterClick: { t: 9 /* boolean */ },
                    doubleClickZoom: { t: 1 /* number */ },
                    fingers: { t: 9 /* boolean */ },
                    sensitivity: { t: 1 /* number */ },
                    wheel: { t: 9 /* boolean */ },
                    zoomInOnDoubleClick: { t: 9 /* boolean */ },
                };
                SettingsMapping.ItemsChartSettingsItemClass = {
                    className: { t: 0 /* string */ },
                    legendGroupId: { t: 0 /* string */ },
                    nameLegend: { t: 0 /* string */ },
                    showInLegend: { t: 9 /* boolean */ },
                };
                SettingsMapping.ItemsChartSettingsItemsLayerLabelStyle = {
                    scaleWithSize: { t: 9 /* boolean */ },
                    scaleWithZoom: { t: 9 /* boolean */ },
                };
                SettingsMapping.ItemsChartSettingsItemsLayerLinkLabelStyle = {
                    rotateWithLink: { t: 9 /* boolean */ },
                };
                SettingsMapping.ItemsChartSettingsItemsLayerStyle = {
                    allObjectsStyleFunction: { t: 4 /* delegate */ },
                    item: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsItemsLayerLabelStyle; } },
                    link: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsLinkStyle; } },
                    linkClasses: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsLinkClass; }, x: function () { return Internal.ItemsChart.SettingsLinkClass; } }] },
                    linkDecorationMinSize: { t: 1 /* number */ },
                    linkDecorationScale: { t: 1 /* number */ },
                    linkDetailMinSize: { t: 1 /* number */ },
                    linkDetailMinZoom: { t: 1 /* number */ },
                    linkHovered: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsLinkStyle; } },
                    linkLabel: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsItemsLayerLinkLabelStyle; } },
                    linkLabelScaleBase: { t: 1 /* number */ },
                    linkRules: { t: 8 /* dictionary */, u: 0 /* recursive */, b: [{ t: 4 /* delegate */ }] },
                    linkSelected: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsLinkStyle; } },
                    linkStyleFunction: { t: 4 /* delegate */ },
                    node: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsNodeStyle; } },
                    nodeAnchor: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsNodeAnchorStyle; } },
                    nodeBackground: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsNodeStyle; } },
                    nodeClasses: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsNodeClass; }, x: function () { return Internal.ItemsChart.SettingsNodeClass; } }] },
                    nodeDetailMinSize: { t: 1 /* number */ },
                    nodeDetailMinZoom: { t: 1 /* number */ },
                    nodeExpanded: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsNodeStyle; } },
                    nodeFocused: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsNodeStyle; } },
                    nodeHovered: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsNodeStyle; } },
                    nodeLabel: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsItemsLayerLabelStyle; } },
                    nodeLabelScaleBase: { t: 1 /* number */ },
                    nodeLocked: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsNodeStyle; } },
                    nodeNotLoaded: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsNodeStyle; } },
                    nodeRules: { t: 8 /* dictionary */, u: 0 /* recursive */, b: [{ t: 4 /* delegate */ }] },
                    nodeSelected: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsNodeStyle; } },
                    nodeStyleFunction: { t: 4 /* delegate */ },
                    removedColor: { t: 0 /* string */, d: 3 /* color */ },
                    scaleLinksWithZoom: { t: 9 /* boolean */ },
                    scaleObjectsWithZoom: { t: 9 /* boolean */ },
                    selection: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            fillColor: { t: 0 /* string */ },
                            lineColor: { t: 0 /* string */ },
                            shadowBlur: { t: 1 /* number */ },
                            shadowColor: { t: 0 /* string */ },
                            shadowOffsetX: { t: 1 /* number */ },
                            shadowOffsetY: { t: 1 /* number */ },
                            sizeConstant: { t: 1 /* number */ },
                            sizeProportional: { t: 1 /* number */ },
                        }; } },
                };
                SettingsMapping.ItemsChartSettingsLinkClass = {
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsLinkStyle; } },
                };
                SettingsMapping.ItemsChartSettingsLinkItem = {
                    lx: { t: 1 /* number */ },
                    ly: { t: 1 /* number */ },
                    px: { t: 1 /* number */ },
                    py: { t: 1 /* number */ },
                    rotateWithLink: { t: 9 /* boolean */ },
                    x: { t: 1 /* number */ },
                    y: { t: 1 /* number */ },
                };
                SettingsMapping.ItemsChartSettingsLinkMenu = {
                    contentsFunction: { t: 4 /* delegate */ },
                };
                SettingsMapping.ItemsChartSettingsLinkStyle = {
                    cursor: { t: 0 /* string */ },
                    direction: { t: 0 /* string */ },
                    fillColor: { t: 0 /* string */ },
                    fromDecoration: { t: 0 /* string */, d: 6 /* enum */ },
                    invisible: { t: 9 /* boolean */ },
                    items: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsLinkItem; } }] },
                    label: { t: 0 /* string */ },
                    length: { t: 1 /* number */ },
                    lineDash: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 1 /* number */ }] },
                    radius: { t: 1 /* number */ },
                    shadowBlur: { t: 1 /* number */ },
                    shadowColor: { t: 0 /* string */ },
                    shadowOffsetX: { t: 1 /* number */ },
                    shadowOffsetY: { t: 1 /* number */ },
                    strength: { t: 1 /* number */ },
                    toDecoration: { t: 0 /* string */, d: 6 /* enum */ },
                    toPieColor: { t: 0 /* string */ },
                    toPieValue: { t: 1 /* number */ },
                };
                SettingsMapping.ItemsChartSettingsMenu = {
                    buttons: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 7 /* union */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }, { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsMenuButton; }, x: function () { return Internal.ItemsChart.SettingsMenuButton; } }] }] },
                    contentsFunction: { t: 4 /* delegate */ },
                    enabled: { t: 9 /* boolean */ },
                    showData: { t: 9 /* boolean */ },
                };
                SettingsMapping.ItemsChartSettingsMenuButton = {
                    className: { t: 0 /* string */ },
                    onClick: { t: 4 /* delegate */ },
                    onInit: { t: 4 /* delegate */ },
                    onRefresh: { t: 4 /* delegate */ },
                    text: { t: 0 /* string */ },
                };
                SettingsMapping.ItemsChartSettingsNodeAnchorStyle = {
                    lineColor: { t: 0 /* string */ },
                    lineDash: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 1 /* number */ }] },
                    lineWidth: { t: 1 /* number */ },
                    shadowBlur: { t: 1 /* number */ },
                    shadowColor: { t: 0 /* string */ },
                    shadowOffsetX: { t: 1 /* number */ },
                    shadowOffsetY: { t: 1 /* number */ },
                };
                SettingsMapping.ItemsChartSettingsNodeClass = {
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsNodeStyle; } },
                };
                SettingsMapping.ItemsChartSettingsNodeItem = {
                    px: { t: 1 /* number */ },
                    py: { t: 1 /* number */ },
                    x: { t: 1 /* number */ },
                    y: { t: 1 /* number */ },
                };
                SettingsMapping.ItemsChartSettingsNodeMenu = {
                    contentsFunction: { t: 4 /* delegate */ },
                };
                SettingsMapping.ItemsChartSettingsNodeStyle = {
                    anchorMode: { t: 2 /* enum */, e: function () { return Internal.ItemsChart.NodeAnchorMode; } },
                    anchorStyle: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsNodeAnchorStyle; } },
                    anchorX: { t: 1 /* number */ },
                    anchorY: { t: 1 /* number */ },
                    aspectRatio: { t: 1 /* number */ },
                    aura: { t: 7 /* union */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }, { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }] }] },
                    coordinates: { t: 7 /* union */, u: 0 /* recursive */, b: [{ t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 1 /* number */ }] }, { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 1 /* number */ }] }] }] },
                    cursor: { t: 0 /* string */, d: 7 /* cursor */ },
                    customShape: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsCustomShape; } },
                    display: { t: 0 /* string */ },
                    fillColor: { t: 0 /* string */ },
                    image: { t: 0 /* string */ },
                    imageCropping: { t: 7 /* union */, b: [{ t: 0 /* string */ }, { t: 9 /* boolean */ }] },
                    invisible: { t: 9 /* boolean */ },
                    items: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsNodeItem; } }] },
                    label: { t: 0 /* string */ },
                    labelStyle: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsItemsLayerLabelStyle; } },
                    lineColor: { t: 0 /* string */ },
                    lineDash: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 1 /* number */ }] },
                    lineWidth: { t: 1 /* number */ },
                    opacity: { t: 1 /* number */ },
                    radius: { t: 1 /* number */ },
                    shadowBlur: { t: 1 /* number */ },
                    shadowColor: { t: 0 /* string */ },
                    shadowOffsetX: { t: 1 /* number */ },
                    shadowOffsetY: { t: 1 /* number */ },
                };
                SettingsMapping.ItemsChartSettingsNodesLayerAuras = {
                    cellSize: { t: 1 /* number */ },
                    defaultColors: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }] },
                    drawLimit: { t: 1 /* number */ },
                    enabled: { t: 9 /* boolean */ },
                    intensity: { t: 1 /* number */ },
                    overlap: { t: 9 /* boolean */ },
                    style: { t: 8 /* dictionary */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsAuraStyle; } }] },
                };
                SettingsMapping.ItemsChartSettingsNodesLayerStyle = {
                    fadeTime: { t: 1 /* number */, d: 0 /* integer */ },
                    hiddenLinks: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            lineColor: { t: 0 /* string */ },
                            lineWidth: { t: 1 /* number */ },
                            size: { t: 1 /* number */ },
                        }; } },
                    linkAutoScaling: { t: 0 /* string */, d: 6 /* enum */ },
                    linkLengthAutoScaling: { t: 0 /* string */, d: 6 /* enum */ },
                    linkLengthExtent: { t: 12 /* tuple */, b: [{ t: 1 /* number */ }, { t: 1 /* number */ }] },
                    linkRadiusExtent: { t: 12 /* tuple */, b: [{ t: 1 /* number */ }, { t: 1 /* number */ }] },
                    linkStrengthAutoScaling: { t: 0 /* string */, d: 6 /* enum */ },
                    linkStrengthExtent: { t: 12 /* tuple */, b: [{ t: 1 /* number */ }, { t: 1 /* number */ }] },
                    multilinkSpacing: { t: 1 /* number */ },
                    nodeAutoScaling: { t: 0 /* string */, d: 6 /* enum */ },
                    nodeRadiusExtent: { t: 12 /* tuple */, b: [{ t: 1 /* number */, d: 0 /* integer */ }, { t: 1 /* number */, d: 0 /* integer */ }] },
                };
                /*#endif*/
                /*#if LinearChart*/
                SettingsMapping.LinearChartSettings = {
                    area: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsArea; }, x: function () { return Internal.LinearChart.SettingsArea; } },
                    chartTypes: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            candlestick: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsSeriesCandleStick; }, x: function () { return Internal.LinearChart.SettingsSeriesCandleStick; }, y: true },
                            columns: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsSeriesColumns; }, x: function () { return Internal.LinearChart.SettingsSeriesColumns; }, y: true },
                            line: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsSeriesLines; }, x: function () { return Internal.LinearChart.SettingsSeriesLines; }, y: true },
                        }; } },
                    events: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsEvents(SettingsMapping.BaseIChartEventArguments, SettingsMapping.BaseIChartEventArguments); }, x: function () { return Internal.LinearChart.SettingsEvents; } },
                    info: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsInfoPopup; }, x: function () { return Internal.LinearChart.SettingsInfoPopup; } },
                    interaction: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsInteraction; }, x: function () { return Internal.LinearChart.SettingsInteraction; } },
                    legend: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsLegend; }, x: function () { return Internal.LinearChart.SettingsLegend; } },
                    localization: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsLocalization; }, x: function () { return Internal.LinearChart.SettingsLocalization; } },
                    series: { t: 6 /* array */, u: 4 /* mergeByID */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsSeries; }, x: function () { return Internal.LinearChart.SettingsSeries; }, y: true }] },
                    seriesDefault: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsSeries; }, x: function () { return Internal.LinearChart.SettingsSeries; }, y: true },
                    stacks: { t: 8 /* dictionary */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsStack; }, x: function () { return Internal.LinearChart.SettingsStack; } }] },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            columnColors: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }] },
                            lineColors: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }] },
                        }; } },
                    valueAxis: { t: 8 /* dictionary */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsValueAxis; }, x: function () { return Internal.LinearChart.SettingsValueAxis; }, y: true }] },
                    valueAxisDefault: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsValueAxis; }, x: function () { return Internal.LinearChart.SettingsValueAxis; } },
                };
                SettingsMapping.LinearChartSettingsArea = {
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsAreaStyle; }, x: function () { return Internal.LinearChart.SettingsAreaStyle; } },
                };
                SettingsMapping.LinearChartSettingsAreaStyle = {
                    noData: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            fillColor: { t: 0 /* string */ },
                            image: { t: 0 /* string */, d: 5 /* url */ },
                        }; } },
                    zoomHighlight: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsHighlightStyle; } },
                    zoomHighlightInactive: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            fillColor: { t: 0 /* string */ },
                        }; } },
                };
                SettingsMapping.LinearChartSettingsCandleStickMotionStyle = {
                    bar: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            lineColor: { t: 0 /* string */ },
                            lineDash: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 1 /* number */ }] },
                            lineWidth: { t: 1 /* number */ },
                            shadowBlur: { t: 1 /* number */ },
                            shadowColor: { t: 0 /* string */ },
                            shadowOffsetX: { t: 1 /* number */ },
                            shadowOffsetY: { t: 1 /* number */ },
                        }; } },
                    candlestick: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            fillColor: { t: 0 /* string */ },
                            lineColor: { t: 0 /* string */, d: 3 /* color */ },
                            lineDash: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 1 /* number */ }] },
                            lineWidth: { t: 1 /* number */ },
                            shadowBlur: { t: 1 /* number */ },
                            shadowColor: { t: 0 /* string */ },
                            shadowOffsetX: { t: 1 /* number */ },
                            shadowOffsetY: { t: 1 /* number */ },
                        }; } },
                };
                SettingsMapping.LinearChartSettingsEvents = function (TArguments, TClickArguments) { return {
                    onAnimationDone: { t: 4 /* delegate */ },
                }; };
                SettingsMapping.LinearChartSettingsHighlightStyle = {
                    fadeIn: { t: 1 /* number */, d: 0 /* integer */ },
                    fadeOut: { t: 1 /* number */, d: 0 /* integer */ },
                    fillColor: { t: 0 /* string */ },
                };
                SettingsMapping.LinearChartSettingsInfoPopup = {
                    advanced: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            contentsFunction: { t: 4 /* delegate */ },
                            scope: { t: 0 /* string */, d: 6 /* enum */ },
                            showHeader: { t: 9 /* boolean */ },
                            showOnlyHoveredSeries: { t: 9 /* boolean */ },
                        }; } },
                    aggregations: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 0 /* string */, d: 6 /* enum */ }] },
                    enabled: { t: 9 /* boolean */ },
                    position: { t: 0 /* string */, d: 6 /* enum */ },
                    showNoData: { t: 9 /* boolean */ },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            highlight: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsHighlightStyle; } },
                        }; } },
                    valueFormatterFunction: { t: 4 /* delegate */ },
                };
                SettingsMapping.LinearChartSettingsInteraction = {
                    ignoreBottomAxis: { t: 9 /* boolean */ },
                    scrolling: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsInteractionScrolling; }, x: function () { return Internal.LinearChart.SettingsInteractionScrolling; } },
                    swipeSensitivity: { t: 1 /* number */ },
                    zooming: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsInteractionZooming; }, x: function () { return Internal.LinearChart.SettingsInteractionZooming; } },
                };
                SettingsMapping.LinearChartSettingsInteractionScrolling = {
                    enabled: { t: 9 /* boolean */ },
                    kineticFriction: { t: 1 /* number */ },
                    maxAnimationLength: { t: 1 /* number */, d: 0 /* integer */ },
                    swipePageFlipping: { t: 9 /* boolean */ },
                };
                SettingsMapping.LinearChartSettingsInteractionZooming = {
                    enabled: { t: 9 /* boolean */ },
                    fingers: { t: 9 /* boolean */ },
                    fingersMaxZoom: { t: 1 /* number */ },
                    sensitivity: { t: 1 /* number */ },
                    swipe: { t: 9 /* boolean */ },
                    upDownTreshold: { t: 1 /* number */ },
                    wheel: { t: 9 /* boolean */ },
                    wheelSensitivity: { t: 1 /* number */ },
                    zoomHighlightThreshold: { t: 1 /* number */ },
                };
                SettingsMapping.LinearChartSettingsLegend = {
                    advanced: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsLegendAdvanced; }, x: function () { return Internal.LinearChart.SettingsLegendAdvanced; } },
                    marker: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsLegendMarker; }, x: function () { return Internal.LinearChart.SettingsLegendMarker; } },
                    panel: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLegendPanel; }, x: function () { return Internal.Base.SettingsLegendPanel; } },
                };
                SettingsMapping.LinearChartSettingsLegendAdvanced = {
                    disabledSeries: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            fillColor: { t: 0 /* string */ },
                            lineColor: { t: 0 /* string */ },
                            textColor: { t: 0 /* string */ },
                        }; } },
                };
                SettingsMapping.LinearChartSettingsLegendMarker = {
                    shape: { t: 7 /* union */, d: 6 /* enum */, b: [{ t: 0 /* string */ }] },
                };
                SettingsMapping.LinearChartSettingsLocalization = {
                    noDataLabel: { t: 0 /* string */ },
                    toolbar: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsLocalizationToolbar; }, x: function () { return Internal.LinearChart.SettingsLocalizationToolbar; } },
                    unnamedSeries: { t: 0 /* string */ },
                    valueUnits: { t: 8 /* dictionary */, u: 0 /* recursive */, b: [{ t: 1 /* number */, d: 0 /* integer */ }] },
                };
                SettingsMapping.LinearChartSettingsLocalizationToolbar = {
                    linButton: { t: 0 /* string */ },
                    linLogTitle: { t: 0 /* string */ },
                    logButton: { t: 0 /* string */ },
                };
                SettingsMapping.LinearChartSettingsSeries = {
                    cluster: { t: 0 /* string */ },
                    data: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsSeriesData; }, x: function () { return Internal.LinearChart.SettingsSeriesData; } },
                    enabled: { t: 9 /* boolean */ },
                    extra: { t: 10 /* any */ },
                    id: { t: 0 /* string */ },
                    legendGroupId: { t: 0 /* string */ },
                    name: { t: 0 /* string */ },
                    nameLegend: { t: 0 /* string */ },
                    showInLegend: { t: 9 /* boolean */ },
                    stack: { t: 0 /* string */ },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsSeriesStyle; }, x: function () { return Internal.LinearChart.SettingsSeriesStyle; } },
                    type: { t: 0 /* string */, d: 6 /* enum */ },
                    valueAxis: { t: 0 /* string */ },
                };
                SettingsMapping.LinearChartSettingsSeriesCandleStick = {
                    localization: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            close: { t: 0 /* string */ },
                            high: { t: 0 /* string */ },
                            low: { t: 0 /* string */ },
                            open: { t: 0 /* string */ },
                        }; } },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsSeriesCandleStickStyle; }, x: function () { return Internal.LinearChart.SettingsSeriesCandleStickStyle; } },
                };
                SettingsMapping.LinearChartSettingsSeriesCandleStickStyle = {
                    decrease: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsCandleStickMotionStyle; } },
                    increase: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsCandleStickMotionStyle; } },
                    padding: { t: 12 /* tuple */, b: [{ t: 1 /* number */, d: 0 /* integer */ }, { t: 1 /* number */, d: 0 /* integer */ }] },
                    pattern: { t: 0 /* string */, d: 6 /* enum */ },
                };
                SettingsMapping.LinearChartSettingsSeriesColumns = {
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsSeriesColumnsStyle; }, x: function () { return Internal.LinearChart.SettingsSeriesColumnsStyle; } },
                    valueLabels: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsValueLabels; } },
                };
                SettingsMapping.LinearChartSettingsSeriesColumnsStyle = {
                    depth: { t: 1 /* number */ },
                    depthBrightness: { t: 1 /* number */ },
                    gradient: { t: 1 /* number */ },
                    lineColor: { t: 0 /* string */, d: 3 /* color */ },
                    minHeight: { t: 1 /* number */, d: 0 /* integer */ },
                    padding: { t: 12 /* tuple */, b: [{ t: 1 /* number */, d: 0 /* integer */ }, { t: 1 /* number */, d: 0 /* integer */ }] },
                    shadowBlur: { t: 1 /* number */, d: 0 /* integer */ },
                };
                SettingsMapping.LinearChartSettingsSeriesData = {
                    aggregatedValueFunction: { t: 4 /* delegate */ },
                    aggregation: { t: 0 /* string */, d: 6 /* enum */ },
                    noDataPolicy: { t: 0 /* string */, d: 6 /* enum */ },
                    source: { t: 0 /* string */ },
                    valueFunction: { t: 4 /* delegate */ },
                };
                SettingsMapping.LinearChartSettingsSeriesLines = {
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsSeriesLinesStyle; }, x: function () { return Internal.LinearChart.SettingsSeriesLinesStyle; } },
                    valueLabels: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsValueLabels; } },
                };
                SettingsMapping.LinearChartSettingsSeriesLinesStyle = {
                    marker: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsSeriesStyleMarker; } },
                    markerStyleFunction: { t: 4 /* delegate */ },
                    shadowBlur: { t: 1 /* number */, d: 0 /* integer */ },
                    smoothing: { t: 9 /* boolean */ },
                    steps: { t: 9 /* boolean */ },
                };
                SettingsMapping.LinearChartSettingsSeriesStyle = {
                    depth: { t: 1 /* number */ },
                    fillColor: { t: 0 /* string */, d: 3 /* color */ },
                    fillGradient: { t: 11 /* GradientDefinition */ },
                    fillPattern: { t: 0 /* string */ },
                    legend: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            marker: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsSeriesStyleMarker; } },
                            textColor: { t: 0 /* string */, d: 3 /* color */ },
                        }; } },
                    lineColor: { t: 0 /* string */ },
                    lineDash: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 1 /* number */ }] },
                    lineWidth: { t: 1 /* number */ },
                    shadowColor: { t: 0 /* string */, d: 3 /* color */ },
                    shadowOffsetX: { t: 1 /* number */, d: 0 /* integer */ },
                    shadowOffsetY: { t: 1 /* number */, d: 0 /* integer */ },
                };
                SettingsMapping.LinearChartSettingsSeriesStyleMarker = {
                    fillColor: { t: 0 /* string */, d: 3 /* color */ },
                    lineColor: { t: 0 /* string */, d: 3 /* color */ },
                    lineWidth: { t: 1 /* number */ },
                    shape: { t: 7 /* union */, d: 6 /* enum */, b: [{ t: 0 /* string */ }] },
                    width: { t: 1 /* number */, d: 0 /* integer */ },
                };
                SettingsMapping.LinearChartSettingsStack = {
                    name: { t: 0 /* string */ },
                    separateNegativeValues: { t: 9 /* boolean */ },
                    type: { t: 0 /* string */, d: 6 /* enum */ },
                };
                SettingsMapping.LinearChartSettingsValueAxis = {
                    axisLine: { t: 9 /* boolean */ },
                    enabled: { t: 9 /* boolean */ },
                    hgrid: { t: 9 /* boolean */ },
                    logScale: { t: 9 /* boolean */ },
                    maxValue: { t: 1 /* number */ },
                    minValue: { t: 1 /* number */ },
                    position: { t: 0 /* string */, d: 6 /* enum */ },
                    scaleAdjustmentAnimation: { t: 0 /* string */, d: 6 /* enum */ },
                    scaleAdjustmentAnimationDelay: { t: 1 /* number */, d: 0 /* integer */ },
                    scaleAdjustmentTolerance: { t: 1 /* number */ },
                    scaleMinStep: { t: 1 /* number */ },
                    scaleStep: { t: 1 /* number */ },
                    side: { t: 7 /* union */, b: [{ t: 0 /* string */ }] },
                    size: { t: 1 /* number */, d: 0 /* integer */ },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            axisLine: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLineStyle; } },
                            baseLine: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsValueAxisBaseLineStyle; } },
                            hgrid: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLineStyle; } },
                            labelSpacing: { t: 1 /* number */ },
                            tick: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLineStyle; } },
                            title: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsValueAxisTitleStyle; } },
                            valueLabel: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLabelStyle; } },
                        }; } },
                    thresholds: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.LinearChartSettingsValueAxisThreshold; }, x: function () { return Internal.LinearChart.SettingsValueAxisThreshold; } }] },
                    title: { t: 0 /* string */ },
                    valueFormatterFunction: { t: 4 /* delegate */ },
                    zeroLine: { t: 0 /* string */, d: 6 /* enum */ },
                };
                SettingsMapping.LinearChartSettingsValueAxisBaseLineStyle = {
                    depthColor: { t: 0 /* string */, d: 3 /* color */ },
                    lineDepth: { t: 1 /* number */, d: 0 /* integer */ },
                    showLabel: { t: 2 /* enum */, e: function () { return ZoomCharts.Configuration.LinearChartSettingsValueAxisBaseLineLabelMode; } },
                };
                SettingsMapping.LinearChartSettingsValueAxisThreshold = {
                    from: { t: 1 /* number */ },
                    position: { t: 0 /* string */, d: 6 /* enum */ },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            fillColor: { t: 0 /* string */, d: 3 /* color */ },
                            lineColor: { t: 0 /* string */, d: 3 /* color */ },
                            lineDash: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 1 /* number */ }] },
                            lineWidth: { t: 1 /* number */ },
                        }; } },
                    to: { t: 1 /* number */ },
                };
                SettingsMapping.LinearChartSettingsValueAxisTitleStyle = {
                    reverseDirection: { t: 9 /* boolean */ },
                };
                SettingsMapping.LinearChartSettingsValueLabels = {
                    contentsFunction: { t: 4 /* delegate */ },
                    enabled: { t: 9 /* boolean */ },
                    minFontSize: { t: 1 /* number */ },
                    position: { t: 0 /* string */, d: 6 /* enum */ },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLabelStyle; } },
                    useStackedValue: { t: 9 /* boolean */ },
                };
                /*#endif*/
                /*#if NetChart*/
                SettingsMapping.NetChartBarSettingsLocalizationToolbar = {
                    fitButton: { t: 0 /* string */ },
                    fitTitle: { t: 0 /* string */ },
                    freezeButton: { t: 0 /* string */ },
                    freezeTitle: { t: 0 /* string */ },
                    rearrangeButton: { t: 0 /* string */ },
                    rearrangeTitle: { t: 0 /* string */ },
                    unfreezeTitle: { t: 0 /* string */ },
                };
                SettingsMapping.NetChartBarSettingsToolbar = {
                    zoomControl: { t: 9 /* boolean */ },
                };
                SettingsMapping.NetChartIChartClickEventArguments = {};
                SettingsMapping.NetChartIChartEventArguments = {};
                SettingsMapping.NetChartIDataObject = {
                    links: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.NetChartIDataObjectLink; } }] },
                    nodes: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.NetChartIDataObjectNode; } }] },
                };
                SettingsMapping.NetChartIDataObjectLink = {};
                SettingsMapping.NetChartIDataObjectNode = {
                    x: { t: 1 /* number */ },
                    y: { t: 1 /* number */ },
                };
                SettingsMapping.NetChartSettings = {
                    area: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.NetChartSettingsArea; }, x: function () { return Internal.NetChart.SettingsArea; } },
                    auras: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.ItemsChartSettingsNodesLayerAuras; }, x: function () { return Internal.ItemsChart.SettingsNodesLayerAuras; } },
                    data: { t: 6 /* array */, u: 4 /* mergeByID */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.NetChartSettingsData; }, x: function () { return Internal.NetChart.SettingsData; } }] },
                    events: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsEvents(SettingsMapping.NetChartIChartEventArguments, SettingsMapping.NetChartIChartClickEventArguments); }, x: function () { return Internal.Base.SettingsEvents; } },
                    filters: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            linkFilter: { t: 4 /* delegate */ },
                            multilinkProcessor: { t: 4 /* delegate */ },
                            nodeFilter: { t: 4 /* delegate */ },
                            nodeLinksProcessor: { t: 4 /* delegate */ },
                        }; } },
                    interaction: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.NetChartSettingsInteraction; }, x: function () { return Internal.NetChart.SettingsInteraction; } },
                    layout: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.NetChartSettingsLayout; }, x: function () { return Internal.NetChart.SettingsLayout; } },
                    legend: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.NetChartSettingsLegend; }, x: function () { return Internal.NetChart.SettingsLegend; } },
                    localization: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.NetChartSettingsLocalization; }, x: function () { return Internal.NetChart.SettingsLocalization; } },
                    navigation: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.NetChartSettingsNavigation; }, x: function () { return Internal.NetChart.SettingsNavigation; } },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.NetChartSettingsStyle; }, x: function () { return Internal.NetChart.SettingsStyle; } },
                    theme: { t: 5 /* object */, c: function () { return SettingsMapping.NetChartSettings; }, x: function () { return Internal.NetChart.Settings; }, y: true },
                    toolbar: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.NetChartBarSettingsToolbar; }, x: function () { return Internal.NetChart.Bar.SettingsToolbar; } },
                };
                SettingsMapping.NetChartSettingsArea = {
                    centerX: { t: 1 /* number */ },
                    centerY: { t: 1 /* number */ },
                    paddingBottom: { t: 1 /* number */ },
                    paddingLeft: { t: 1 /* number */ },
                    paddingRight: { t: 1 /* number */ },
                    paddingTop: { t: 1 /* number */ },
                };
                SettingsMapping.NetChartSettingsData = {
                    dataFunction: { t: 4 /* delegate */ },
                    preloaded: { t: 5 /* object */, c: function () { return SettingsMapping.NetChartIDataObject; } },
                };
                SettingsMapping.NetChartSettingsInteraction = {
                    rotation: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            fingers: { t: 9 /* boolean */ },
                        }; } },
                    selection: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.NetChartSettingsInteractionSelection; }, x: function () { return Internal.NetChart.SettingsInteractionSelection; } },
                    zooming: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.NetChartSettingsInteractionZooming; }, x: function () { return Internal.NetChart.SettingsInteractionZooming; } },
                };
                SettingsMapping.NetChartSettingsInteractionSelection = {
                    dragSelect: { t: 9 /* boolean */ },
                };
                SettingsMapping.NetChartSettingsInteractionZooming = {
                    autoZoomExtent: { t: 12 /* tuple */, b: [{ t: 1 /* number */ }, { t: 1 /* number */ }] },
                    autoZoomPositionEllasticity: { t: 1 /* number */ },
                    autoZoomSize: { t: 1 /* number */ },
                    initialAutoZoom: { t: 0 /* string */, d: 6 /* enum */ },
                    zoomExtent: { t: 12 /* tuple */, b: [{ t: 1 /* number */ }, { t: 1 /* number */ }] },
                };
                SettingsMapping.NetChartSettingsLayout = {
                    advanced: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            adaptiveFreezeTreshold: { t: 1 /* number */ },
                        }; } },
                    aspectRatio: { t: 9 /* boolean */ },
                    globalLayoutOnChanges: { t: 9 /* boolean */ },
                    incrementalLayoutMaxTime: { t: 1 /* number */, d: 0 /* integer */ },
                    initialLayoutMaxTime: { t: 1 /* number */, d: 0 /* integer */ },
                    layoutFreezeMinTimeout: { t: 1 /* number */, d: 0 /* integer */ },
                    layoutFreezeTimeout: { t: 1 /* number */, d: 0 /* integer */ },
                    mode: { t: 0 /* string */, d: 6 /* enum */ },
                    nodeSpacing: { t: 1 /* number */, d: 0 /* integer */ },
                    rotation: { t: 1 /* number */ },
                    rowSpacing: { t: 1 /* number */, d: 0 /* integer */ },
                    twoRingRadialLayout: { t: 9 /* boolean */ },
                };
                SettingsMapping.NetChartSettingsLegend = {
                    advanced: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.NetChartSettingsLegendAdvanced; }, x: function () { return Internal.NetChart.SettingsLegendAdvanced; } },
                    panel: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLegendPanel; }, x: function () { return Internal.Base.SettingsLegendPanel; } },
                };
                SettingsMapping.NetChartSettingsLegendAdvanced = {
                    showItemsWithClasses: { t: 7 /* union */, d: 6 /* enum */, b: [{ t: 0 /* string */ }] },
                    textColorDisabled: { t: 0 /* string */ },
                };
                SettingsMapping.NetChartSettingsLocalization = {
                    menu: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            close: { t: 0 /* string */ },
                            collapse: { t: 0 /* string */ },
                            dynamic: { t: 0 /* string */ },
                            expand: { t: 0 /* string */ },
                            fixed: { t: 0 /* string */ },
                            focus: { t: 0 /* string */ },
                            hide: { t: 0 /* string */ },
                            unfocus: { t: 0 /* string */ },
                        }; } },
                    toolbar: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.NetChartBarSettingsLocalizationToolbar; }, x: function () { return Internal.NetChart.Bar.SettingsLocalizationToolbar; } },
                };
                SettingsMapping.NetChartSettingsNavigation = {
                    autoUnfocus: { t: 9 /* boolean */ },
                    autoZoomOnFocus: { t: 9 /* boolean */ },
                    expandDelay: { t: 1 /* number */, d: 0 /* integer */ },
                    expandOnClick: { t: 9 /* boolean */ },
                    focusAutoFadeout: { t: 9 /* boolean */ },
                    focusNodeExpansionRadius: { t: 1 /* number */ },
                    focusNodeTailExpansionRadius: { t: 1 /* number */ },
                    initialNodes: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }] },
                    minNumberOfFocusNodes: { t: 1 /* number */, d: 0 /* integer */ },
                    mode: { t: 0 /* string */, d: 6 /* enum */ },
                    numberOfFocusNodes: { t: 1 /* number */, d: 0 /* integer */ },
                };
                SettingsMapping.NetChartSettingsStyle = {
                    dragSelection: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsBackgroundStyle; } },
                };
                /*#endif*/
                /*#if PieChart*/
                SettingsMapping.PieChartIChartClickEventArguments = {};
                SettingsMapping.PieChartIChartEventArguments = {};
                SettingsMapping.PieChartIDataObject = {
                    id: { t: 0 /* string */ },
                    name: { t: 0 /* string */ },
                    nameLegend: { t: 0 /* string */ },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.PieChartSettingsSliceStyle; } },
                    subvalues: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.PieChartIDataObject; } }] },
                    value: { t: 1 /* number */ },
                };
                SettingsMapping.PieChartIDataObjectCommon = {
                    id: { t: 0 /* string */ },
                    name: { t: 0 /* string */ },
                    subvalues: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.PieChartIDataObject; } }] },
                };
                SettingsMapping.PieChartIDataObjectRoot = {
                    afterSum: { t: 1 /* number */ },
                    beforeSum: { t: 1 /* number */ },
                    id: { t: 0 /* string */ },
                    limit: { t: 1 /* number */ },
                    name: { t: 0 /* string */ },
                    offset: { t: 1 /* number */ },
                    subvalues: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.PieChartIDataObject; } }] },
                    sum: { t: 1 /* number */ },
                };
                SettingsMapping.PieChartSettings = {
                    advanced: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.PieChartSettingsAdvanced; }, x: function () { return Internal.PieChart.SettingsAdvanced; } },
                    data: { t: 6 /* array */, u: 4 /* mergeByID */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.PieChartSettingsData; }, x: function () { return Internal.PieChart.SettingsData; } }] },
                    events: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.PieChartSettingsEvents; }, x: function () { return Internal.PieChart.SettingsEvents; } },
                    filters: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            allowZeroValues: { t: 9 /* boolean */ },
                            sliceFilter: { t: 4 /* delegate */ },
                        }; } },
                    icons: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            autohideWhenTooSmall: { t: 9 /* boolean */ },
                            placement: { t: 0 /* string */, d: 6 /* enum */ },
                            sizeExtent: { t: 12 /* tuple */, b: [{ t: 1 /* number */ }, { t: 1 /* number */ }] },
                        }; } },
                    info: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            contentsFunction: { t: 4 /* delegate */ },
                            enabled: { t: 9 /* boolean */ },
                        }; } },
                    interaction: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.PieChartSettingsInteraction; }, x: function () { return Internal.PieChart.SettingsInteraction; } },
                    labels: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.PieChartSettingsLabels; }, x: function () { return Internal.PieChart.SettingsLabels; } },
                    legend: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.PieChartSettingsLegend; }, x: function () { return Internal.PieChart.SettingsLegend; } },
                    localization: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.PieChartSettingsLocalization; }, x: function () { return Internal.PieChart.SettingsLocalization; } },
                    navigation: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            initialDrilldown: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }] },
                            initialOffset: { t: 1 /* number */, d: 0 /* integer */ },
                        }; } },
                    pie: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            adaptiveRadius: { t: 9 /* boolean */ },
                            backgroundHoveredStyle: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.PieChartSettingsPieStyle; } },
                            backgroundStyle: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.PieChartSettingsPieStyle; } },
                            centerMargin: { t: 1 /* number */, d: 0 /* integer */ },
                            depth: { t: 1 /* number */, d: 0 /* integer */ },
                            endAngle: { t: 1 /* number */ },
                            innerRadius: { t: 1 /* number */ },
                            innerRadiusWhenDrilldown: { t: 1 /* number */ },
                            margin: { t: 1 /* number */ },
                            noDataStyle: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.PieChartSettingsPieStyle; } },
                            outerMargin: { t: 1 /* number */ },
                            radius: { t: 1 /* number */ },
                            rotationSpeed: { t: 1 /* number */ },
                            showInnerPies: { t: 9 /* boolean */ },
                            showInnerPiesExport: { t: 9 /* boolean */ },
                            startAngle: { t: 1 /* number */ },
                            style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.PieChartSettingsPieStyle; } },
                            styleFunction: { t: 4 /* delegate */ },
                            theme: { t: 0 /* string */, d: 6 /* enum */ },
                            x: { t: 1 /* number */ },
                            y: { t: 1 /* number */ },
                        }; } },
                    slice: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            backgroundActiveStyle: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                                    brightness: { t: 1 /* number */ },
                                }; } },
                            backgroundStyle: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                                    fillColor: { t: 0 /* string */ },
                                    fillColor2: { t: 0 /* string */, d: 3 /* color */ },
                                }; } },
                            connectorStyle: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLineStyle; } },
                            expandableMarkStyle: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                                    distance: { t: 1 /* number */ },
                                    lineColor: { t: 0 /* string */ },
                                    lineDash: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 1 /* number */ }] },
                                    lineWidth: { t: 1 /* number */ },
                                }; } },
                            hoverStyle: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.PieChartSettingsSliceStyle; } },
                            margin: { t: 1 /* number */ },
                            minFraction: { t: 1 /* number */ },
                            othersStyle: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                                    fillColor: { t: 0 /* string */ },
                                    lineDecoration: { t: 0 /* string */, d: 6 /* enum */ },
                                }; } },
                            previousStyle: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                                    fillColor: { t: 0 /* string */ },
                                    lineDecoration: { t: 0 /* string */, d: 6 /* enum */ },
                                }; } },
                            selectedStyle: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.PieChartSettingsSliceStyle; } },
                            style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.PieChartSettingsSliceStyle; } },
                            styleFunction: { t: 4 /* delegate */ },
                        }; } },
                    theme: { t: 5 /* object */, c: function () { return SettingsMapping.PieChartSettings; }, x: function () { return Internal.PieChart.Settings; }, y: true },
                    toolbar: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsToolbar; }, x: function () { return Internal.Base.SettingsToolbar; } },
                };
                SettingsMapping.PieChartSettingsAdvanced = {
                    backAlwaysVisible: { t: 9 /* boolean */ },
                    backImage: { t: 0 /* string */, d: 4 /* imageUrl */ },
                    backImageBackground: { t: 0 /* string */ },
                    iconMinSize: { t: 1 /* number */ },
                    initialAnimation: { t: 9 /* boolean */ },
                    labelInsideTreshold: { t: 1 /* number */, d: 0 /* integer */ },
                    renderQuality: { t: 1 /* number */, d: 0 /* integer */ },
                };
                SettingsMapping.PieChartSettingsData = {
                    autoCategories: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 7 /* union */, b: [{ t: 0 /* string */ }, { t: 4 /* delegate */ }] }] },
                    dataFunction: { t: 4 /* delegate */ },
                    itemsToLoad: { t: 1 /* number */, d: 0 /* integer */ },
                    partialLoad: { t: 9 /* boolean */ },
                    preloaded: { t: 5 /* object */, c: function () { return SettingsMapping.PieChartIDataObjectRoot; } },
                    sortField: { t: 7 /* union */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }, { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }] }, { t: 4 /* delegate */ }] },
                };
                SettingsMapping.PieChartSettingsEvents = {
                    onPieChange: { t: 4 /* delegate */ },
                    onPieReadyStateChanged: { t: 4 /* delegate */ },
                };
                SettingsMapping.PieChartSettingsInteraction = {
                    animation: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            hoverDuration: { t: 1 /* number */, d: 0 /* integer */ },
                            scrollDuration: { t: 1 /* number */, d: 0 /* integer */ },
                        }; } },
                    coverCenter: { t: 9 /* boolean */ },
                    mode: { t: 0 /* string */, d: 6 /* enum */ },
                    others: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            centerGoesToPrevious: { t: 9 /* boolean */ },
                            enabled: { t: 9 /* boolean */ },
                            maxOthersFraction: { t: 1 /* number */ },
                            maxSlicesVisible: { t: 1 /* number */, d: 0 /* integer */ },
                            minSliceFraction: { t: 1 /* number */ },
                            minSlices: { t: 1 /* number */ },
                            navigationFraction: { t: 1 /* number */ },
                        }; } },
                    scrolling: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            enabled: { t: 9 /* boolean */ },
                        }; } },
                    selection: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            enabled: { t: 9 /* boolean */ },
                            maxSwipeDistance: { t: 1 /* number */ },
                            partialSwipe: { t: 9 /* boolean */ },
                            swipe: { t: 9 /* boolean */ },
                            swipeSensitivity: { t: 1 /* number */ },
                            tolerance: { t: 1 /* number */ },
                        }; } },
                };
                SettingsMapping.PieChartSettingsLabels = {
                    angle: { t: 1 /* number */, d: 0 /* integer */ },
                    connectorLength: { t: 1 /* number */, d: 0 /* integer */ },
                    connectors: { t: 9 /* boolean */ },
                    enabled: { t: 9 /* boolean */ },
                    insideLabel: { t: 0 /* string */, d: 6 /* enum */ },
                    insideLabelVisibilityFraction: { t: 1 /* number */ },
                    interLabelSpacing: { t: 1 /* number */ },
                    placement: { t: 0 /* string */, d: 6 /* enum */ },
                };
                SettingsMapping.PieChartSettingsLegend = {
                    marker: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.PieChartSettingsLegendMarker; }, x: function () { return Internal.PieChart.SettingsLegendMarker; } },
                    showOthers: { t: 9 /* boolean */ },
                };
                SettingsMapping.PieChartSettingsLegendMarker = {
                    shape: { t: 7 /* union */, d: 6 /* enum */, b: [{ t: 0 /* string */ }] },
                };
                SettingsMapping.PieChartSettingsLocalization = {
                    othersLabel: { t: 0 /* string */ },
                    previousLabel: { t: 0 /* string */ },
                };
                SettingsMapping.PieChartSettingsPieStyle = {
                    background: { t: 9 /* boolean */ },
                    brightness: { t: 1 /* number */ },
                    colorDistribution: { t: 0 /* string */, d: 6 /* enum */ },
                    fillColor: { t: 0 /* string */, d: 3 /* color */ },
                    sliceColors: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 0 /* string */, d: 3 /* color */ }] },
                };
                SettingsMapping.PieChartSettingsSliceStyle = {
                    brightness: { t: 1 /* number */ },
                    cutoutDistance: { t: 1 /* number */ },
                    expandable: { t: 9 /* boolean */ },
                    fillColor: { t: 0 /* string */, d: 3 /* color */ },
                    icon: { t: 0 /* string */, d: 4 /* imageUrl */ },
                    insideLabel: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLabelStyle; } },
                    label: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLabelStyle; } },
                    lineBrightness: { t: 1 /* number */, d: 0 /* integer */ },
                    lineColor: { t: 0 /* string */, d: 3 /* color */ },
                    lineDash: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 1 /* number */ }] },
                    lineWidth: { t: 1 /* number */, d: 0 /* integer */ },
                    url: { t: 0 /* string */, d: 5 /* url */ },
                };
                /*#endif*/
                /*#if TimeChart*/
                SettingsMapping.TimeChartIChartEventArguments = {};
                SettingsMapping.TimeChartIDataObject = {
                    data: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 7 /* union */, b: [{ t: 1 /* number */ }, { t: 0 /* string */ }] }] }] },
                    dataLimitFrom: { t: 7 /* union */, b: [{ t: 1 /* number */ }, { t: 0 /* string */ }] },
                    dataLimitTo: { t: 7 /* union */, b: [{ t: 1 /* number */ }, { t: 0 /* string */ }] },
                    from: { t: 7 /* union */, b: [{ t: 1 /* number */ }, { t: 0 /* string */ }] },
                    timeZone: { t: 0 /* string */ },
                    to: { t: 7 /* union */, b: [{ t: 1 /* number */ }, { t: 0 /* string */ }] },
                    unit: { t: 0 /* string */ },
                    values: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 7 /* union */, u: 0 /* recursive */, b: [{ t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 7 /* union */, b: [{ t: 1 /* number */ }, { t: 0 /* string */ }] }] }, { t: 15 /* Float64Array */ }, { t: 16 /* Float32Array */ }, { t: 17 /* Int32Array */ }, { t: 18 /* Uint32Array */ }] }] },
                };
                SettingsMapping.TimeChartSettings = {
                    advanced: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsAdvanced; }, x: function () { return Internal.TimeChart.SettingsAdvanced; } },
                    area: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsArea; }, x: function () { return Internal.TimeChart.SettingsArea; } },
                    chartTypes: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            candlestick: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsSeriesCandleStick; }, x: function () { return Internal.TimeChart.SettingsSeriesCandleStick; }, y: true },
                            columns: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsSeriesColumns; }, x: function () { return Internal.TimeChart.SettingsSeriesColumns; }, y: true },
                            line: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsSeriesLines; }, x: function () { return Internal.TimeChart.SettingsSeriesLines; }, y: true },
                        }; } },
                    currentTime: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsCurrentTime; }, x: function () { return Internal.TimeChart.SettingsCurrentTime; } },
                    data: { t: 6 /* array */, u: 4 /* mergeByID */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsData; }, x: function () { return Internal.TimeChart.SettingsData; } }] },
                    events: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsEvents; }, x: function () { return Internal.TimeChart.SettingsEvents; } },
                    interaction: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsInteraction; }, x: function () { return Internal.TimeChart.SettingsInteraction; } },
                    localization: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsLocalization; }, x: function () { return Internal.TimeChart.SettingsLocalization; } },
                    milestones: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsMarker; }, x: function () { return Internal.TimeChart.SettingsMarker; } }] },
                    navigation: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            followAnchor: { t: 9 /* boolean */ },
                            initialDisplayAnchor: { t: 7 /* union */, b: [{ t: 0 /* string */ }, { t: 1 /* number */ }] },
                            initialDisplayPeriod: { t: 0 /* string */ },
                            initialDisplayUnit: { t: 0 /* string */ },
                        }; } },
                    series: { t: 6 /* array */, u: 4 /* mergeByID */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsSeries; }, x: function () { return Internal.TimeChart.SettingsSeries; }, y: true }] },
                    seriesDefault: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsSeries; }, x: function () { return Internal.TimeChart.SettingsSeries; }, y: true },
                    theme: { t: 5 /* object */, c: function () { return SettingsMapping.TimeChartSettings; }, x: function () { return Internal.TimeChart.Settings; }, y: true },
                    timeAxis: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsTimeAxis; }, x: function () { return Internal.TimeChart.SettingsTimeAxis; } },
                    toolbar: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsToolbar; }, x: function () { return Internal.TimeChart.SettingsToolbar; } },
                };
                SettingsMapping.TimeChartSettingsAdvanced = {
                    dataUpdateInterval: { t: 1 /* number */, d: 0 /* integer */ },
                    maxUnitsToDisplay: { t: 1 /* number */ },
                    timeUpdateInterval: { t: 1 /* number */, d: 0 /* integer */ },
                };
                SettingsMapping.TimeChartSettingsArea = {
                    displayPeriods: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                                    unit: { t: 0 /* string */ },
                                }; } }] },
                    displayUnits: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                                    unit: { t: 0 /* string */ },
                                    name: { t: 0 /* string */ },
                                }; } }] },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsAreaStyle; }, x: function () { return Internal.TimeChart.SettingsAreaStyle; } },
                };
                SettingsMapping.TimeChartSettingsAreaDisplayPeriod = {
                    displayAnchor: { t: 7 /* union */, b: [{ t: 0 /* string */ }, { t: 1 /* number */ }] },
                    displayPeriod: { t: 0 /* string */ },
                    displayUnit: { t: 0 /* string */ },
                    name: { t: 0 /* string */ },
                };
                SettingsMapping.TimeChartSettingsAreaStyle = {
                    markerText: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsTextStyle; } },
                    selection: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsAreaStyleSelection; }, x: function () { return Internal.TimeChart.SettingsAreaStyleSelection; } },
                    selectionLabel: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsTextStyle; } },
                };
                SettingsMapping.TimeChartSettingsAreaStyleSelection = {
                    behindSeries: { t: 9 /* boolean */ },
                    fillColor: { t: 0 /* string */ },
                    lineColor: { t: 0 /* string */ },
                    lineWidth: { t: 1 /* number */ },
                };
                SettingsMapping.TimeChartSettingsCurrentTime = {
                    align: { t: 7 /* union */, b: [{ t: 0 /* string */ }] },
                    label: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLabelStyle; } },
                    showTime: { t: 9 /* boolean */ },
                    side: { t: 7 /* union */, b: [{ t: 0 /* string */ }] },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLineStyle; } },
                };
                SettingsMapping.TimeChartSettingsData = {
                    cacheSize: { t: 1 /* number */, d: 0 /* integer */ },
                    dataFunction: { t: 4 /* delegate */ },
                    minimizeRequests: { t: 9 /* boolean */ },
                    prefetchRatio: { t: 1 /* number */ },
                    preloaded: { t: 5 /* object */, c: function () { return SettingsMapping.TimeChartIDataObject; } },
                    requestMaxUnits: { t: 1 /* number */, d: 0 /* integer */ },
                    stringTimestampFormat: { t: 7 /* union */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }, { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }] }] },
                    suppressWarnings: { t: 9 /* boolean */ },
                    timeZoneOffset: { t: 7 /* union */, b: [{ t: 0 /* string */ }, { t: 1 /* number */ }] },
                    timestampInSeconds: { t: 9 /* boolean */ },
                    units: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }] },
                    url: { t: 0 /* string */, d: 5 /* url */ },
                    urlByUnit: { t: 8 /* dictionary */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }] },
                    useSmallerUnitCache: { t: 9 /* boolean */ },
                };
                SettingsMapping.TimeChartSettingsEvents = {
                    onTimeChange: { t: 4 /* delegate */ },
                    selectionChangeDuringInteraction: { t: 9 /* boolean */ },
                };
                SettingsMapping.TimeChartSettingsInteraction = {
                    scrolling: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsInteractionScrolling; }, x: function () { return Internal.TimeChart.SettingsInteractionScrolling; } },
                    selection: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsInteractionSelection; }, x: function () { return Internal.TimeChart.SettingsInteractionSelection; } },
                    snapMode: { t: 0 /* string */, d: 6 /* enum */ },
                    zooming: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsInteractionZooming; }, x: function () { return Internal.TimeChart.SettingsInteractionZooming; } },
                };
                SettingsMapping.TimeChartSettingsInteractionScrolling = {
                    limitFrom: { t: 7 /* union */, b: [{ t: 0 /* string */ }, { t: 1 /* number */ }] },
                    limitMode: { t: 0 /* string */, d: 6 /* enum */ },
                    limitTo: { t: 7 /* union */, b: [{ t: 0 /* string */ }, { t: 1 /* number */ }] },
                    overscrollProportion: { t: 1 /* number */ },
                };
                SettingsMapping.TimeChartSettingsInteractionSelection = {
                    enabled: { t: 9 /* boolean */ },
                    moveByDragging: { t: 9 /* boolean */ },
                    resizeSensitivity: { t: 1 /* number */ },
                    resizeTolerance: { t: 1 /* number */ },
                    tolerance: { t: 1 /* number */ },
                };
                SettingsMapping.TimeChartSettingsInteractionZooming = {
                    click: { t: 9 /* boolean */ },
                    enabled: { t: 9 /* boolean */ },
                };
                SettingsMapping.TimeChartSettingsLocalization = {
                    calendar: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsLocalizationCalendar; } },
                    determiningDataBounds: { t: 0 /* string */ },
                    holidayWeekdays: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 1 /* number */, d: 0 /* integer */ }] },
                    infoDates: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            fullTimeFormats: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsLocalizationTimeUnits; } },
                            majorTimeFormats: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsLocalizationTimeUnits; } },
                            minorTimeFormats: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsLocalizationTimeUnits; } },
                        }; } },
                    loadingLabel: { t: 0 /* string */ },
                    markerDates: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            timeFormats: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsLocalizationTimeUnits; } },
                        }; } },
                    timeAxisDates: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            majorLabelFullTimeFormats: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsLocalizationTimeUnits; } },
                            majorLabelTimeFormats: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsLocalizationTimeUnits; } },
                            minorLabelTimeFormats: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsLocalizationTimeUnits; } },
                        }; } },
                    timeUnitsNames: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsLocalizationTimeUnits; } },
                    timeUnitsNamesPlural: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsLocalizationTimeUnits; } },
                    toolbar: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsLocalizationToolbar; }, x: function () { return Internal.TimeChart.SettingsLocalizationToolbar; } },
                };
                SettingsMapping.TimeChartSettingsLocalizationCalendar = {
                    months: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }] },
                    monthsShort: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }] },
                    parentLocale: { t: 0 /* string */ },
                    week: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            dow: { t: 1 /* number */, d: 0 /* integer */ },
                            doy: { t: 1 /* number */ },
                        }; } },
                    weekdays: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }] },
                    weekdaysMin: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }] },
                    weekdaysShort: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }] },
                };
                SettingsMapping.TimeChartSettingsLocalizationTimeUnits = {
                    M: { t: 0 /* string */ },
                    d: { t: 0 /* string */ },
                    h: { t: 0 /* string */ },
                    m: { t: 0 /* string */ },
                    ms: { t: 0 /* string */ },
                    s: { t: 0 /* string */ },
                    w: { t: 0 /* string */ },
                    y: { t: 0 /* string */ },
                };
                SettingsMapping.TimeChartSettingsLocalizationToolbar = {
                    customPeriod: { t: 0 /* string */ },
                    periodDropdownTitle: { t: 0 /* string */ },
                    unavailableUnitTitle: { t: 0 /* string */ },
                    unitDropdownTitle: { t: 0 /* string */ },
                    zoomoutButton: { t: 0 /* string */ },
                    zoomoutTitle: { t: 0 /* string */ },
                };
                SettingsMapping.TimeChartSettingsMarker = {
                    align: { t: 7 /* union */, b: [{ t: 0 /* string */ }] },
                    enabled: { t: 9 /* boolean */ },
                    label: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLabelStyle; } },
                    overrideLimits: { t: 9 /* boolean */ },
                    showTime: { t: 9 /* boolean */ },
                    side: { t: 7 /* union */, b: [{ t: 0 /* string */ }] },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLineStyle; } },
                    time: { t: 1 /* number */, d: 0 /* integer */ },
                };
                SettingsMapping.TimeChartSettingsSeries = {
                    data: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsSeriesData; }, x: function () { return Internal.TimeChart.SettingsSeriesData; } },
                };
                SettingsMapping.TimeChartSettingsSeriesCandleStick = {
                    data: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsSeriesCandleStickData; }, x: function () { return Internal.TimeChart.SettingsSeriesCandleStickData; } },
                };
                SettingsMapping.TimeChartSettingsSeriesCandleStickData = {
                    close: { t: 1 /* number */ },
                    high: { t: 1 /* number */ },
                    low: { t: 1 /* number */ },
                    open: { t: 1 /* number */ },
                };
                SettingsMapping.TimeChartSettingsSeriesColumns = {
                    data: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsSeriesData; }, x: function () { return Internal.TimeChart.SettingsSeriesData; } },
                };
                SettingsMapping.TimeChartSettingsSeriesData = {
                    countIndex: { t: 1 /* number */ },
                    index: { t: 1 /* number */, d: 0 /* integer */ },
                };
                SettingsMapping.TimeChartSettingsSeriesLines = {
                    data: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsSeriesData; }, x: function () { return Internal.TimeChart.SettingsSeriesData; } },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsSeriesLinesStyle; }, x: function () { return Internal.TimeChart.SettingsSeriesLinesStyle; } },
                };
                SettingsMapping.TimeChartSettingsSeriesLinesStyle = {
                    markerStyleFunction: { t: 4 /* delegate */ },
                };
                SettingsMapping.TimeChartSettingsTimeAxis = {
                    enabled: { t: 9 /* boolean */ },
                    maxUnitWidth: { t: 1 /* number */ },
                    minUnitWidth: { t: 1 /* number */ },
                    miniTimeRuler: { t: 9 /* boolean */ },
                    showHolidays: { t: 9 /* boolean */ },
                    style: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                            dateHolidays: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsBackgroundStyle; } },
                            dateLighten: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return {
                                    fillColor: { t: 0 /* string */ },
                                }; } },
                            majorTimeBalloonStyle: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsBackgroundStyle; } },
                            majorTimeLabel: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsTextStyle; } },
                            minorTimeBalloonStyle: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsBackgroundStyle; } },
                            minorTimeLabel: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsTextStyle; } },
                            minorTimeRuler: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLineStyle; } },
                            showMajorTimeBalloons: { t: 9 /* boolean */ },
                            showMinorTimeBalloons: { t: 9 /* boolean */ },
                            vgrid: { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsLineStyle; } },
                        }; } },
                    timeZone: { t: 0 /* string */ },
                    timeZoneOffset: { t: 7 /* union */, b: [{ t: 0 /* string */ }, { t: 1 /* number */ }] },
                    unitSizePolicy: { t: 0 /* string */, d: 6 /* enum */ },
                    vgrid: { t: 9 /* boolean */ },
                };
                SettingsMapping.TimeChartSettingsToolbar = {
                    displayPeriod: { t: 9 /* boolean */ },
                    displayUnit: { t: 9 /* boolean */ },
                    enabled: { t: 9 /* boolean */ },
                    items: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 7 /* union */, u: 0 /* recursive */, b: [{ t: 0 /* string */ }, { t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.BaseSettingsToolbarItem; }, x: function () { return Internal.Base.SettingsToolbarItem; } }] }] },
                    logScale: { t: 9 /* boolean */ },
                    periods: { t: 6 /* array */, u: 0 /* recursive */, b: [{ t: 5 /* object */, u: 0 /* recursive */, c: function () { return SettingsMapping.TimeChartSettingsAreaDisplayPeriod; }, x: function () { return Internal.TimeChart.SettingsAreaDisplayPeriod; } }] },
                    zoomOut: { t: 9 /* boolean */ },
                    zoomOutFunction: { t: 4 /* delegate */ },
                };
                return SettingsMapping;
            }());
            Base.SettingsMapping = SettingsMapping;
            function extendMapping(derived, base) {
                for (var key in base) {
                    if (base.hasOwnProperty(key) && !derived.hasOwnProperty(key))
                        derived[key] = base[key];
                }
            }
            /*#if Base*/
            extendMapping(SettingsMapping.BaseIChartErrorEventArguments, SettingsMapping.BaseIChartEventArguments);
            extendMapping(SettingsMapping.BaseIChartSettingsChangeEventArguments, SettingsMapping.BaseIChartEventArguments);
            extendMapping(SettingsMapping.BaseIDataErrorResponse, SettingsMapping.BaseIDataObjectBase);
            extendMapping(SettingsMapping.BaseSettingsBackgroundStyle, SettingsMapping.BaseSettingsLineStyle);
            extendMapping(SettingsMapping.BaseSettingsAdvancedStyleMessageBackground, SettingsMapping.BaseSettingsBackgroundStyle);
            extendMapping(SettingsMapping.BaseSettingsLegendPanel, SettingsMapping.BaseSettingsChartPanel);
            extendMapping(SettingsMapping.BaseSettingsToolbarItem, SettingsMapping.BaseSettingsToolbarItemBase);
            /*#endif*/
            /*#if FacetChart*/
            extendMapping(SettingsMapping.FacetChartIChartEventArguments, SettingsMapping.BaseIChartEventArguments);
            extendMapping(SettingsMapping.FacetChartIChartClickEventArguments, SettingsMapping.FacetChartIChartEventArguments);
            /*#endif*/
            /*#if LinearChart*/
            extendMapping(SettingsMapping.LinearChartSettings, SettingsMapping.BaseSettings);
            /*#endif*/
            /*#if FacetChart*/
            extendMapping(SettingsMapping.FacetChartSettings, SettingsMapping.LinearChartSettings);
            extendMapping(SettingsMapping.FacetChartSettingsFacetAxisLabels, SettingsMapping.BaseSettingsLabelStyle);
            extendMapping(SettingsMapping.FacetChartSettingsFacetAxisTitleStyle, SettingsMapping.BaseSettingsLabelStyle);
            /*#endif*/
            /*#if LinearChart*/
            extendMapping(SettingsMapping.LinearChartSettingsSeriesColumnsStyle, SettingsMapping.LinearChartSettingsSeriesStyle);
            /*#endif*/
            /*#if FacetChart*/
            extendMapping(SettingsMapping.FacetChartSettingsSeriesColumnsStyle, SettingsMapping.LinearChartSettingsSeriesColumnsStyle);
            extendMapping(SettingsMapping.FacetChartSettingsFacetStyle, SettingsMapping.FacetChartSettingsSeriesColumnsStyle);
            /*#endif*/
            /*#if LinearChart*/
            extendMapping(SettingsMapping.LinearChartSettingsInteraction, SettingsMapping.BaseSettingsInteraction);
            /*#endif*/
            /*#if FacetChart*/
            extendMapping(SettingsMapping.FacetChartSettingsInteraction, SettingsMapping.LinearChartSettingsInteraction);
            extendMapping(SettingsMapping.FacetChartSettingsSeries, SettingsMapping.LinearChartSettingsSeries);
            /*#endif*/
            /*#if LinearChart*/
            extendMapping(SettingsMapping.LinearChartSettingsSeriesColumns, SettingsMapping.LinearChartSettingsSeries);
            /*#endif*/
            /*#if FacetChart*/
            extendMapping(SettingsMapping.FacetChartSettingsSeriesColumns, SettingsMapping.LinearChartSettingsSeriesColumns);
            extendMapping(SettingsMapping.FacetChartSettingsSeriesData, SettingsMapping.LinearChartSettingsSeriesData);
            /*#endif*/
            /*#if LinearChart*/
            extendMapping(SettingsMapping.LinearChartSettingsSeriesLines, SettingsMapping.LinearChartSettingsSeries);
            /*#endif*/
            /*#if FacetChart*/
            extendMapping(SettingsMapping.FacetChartSettingsSeriesLines, SettingsMapping.LinearChartSettingsSeriesLines);
            /*#endif*/
            /*#if LinearChart*/
            extendMapping(SettingsMapping.LinearChartSettingsSeriesLinesStyle, SettingsMapping.LinearChartSettingsSeriesStyle);
            /*#endif*/
            /*#if FacetChart*/
            extendMapping(SettingsMapping.FacetChartSettingsSeriesLinesStyle, SettingsMapping.LinearChartSettingsSeriesLinesStyle);
            extendMapping(SettingsMapping.FacetChartSettingsToolbar, SettingsMapping.BaseSettingsToolbar);
            /*#endif*/
            /*#if ItemsChart*/
            extendMapping(SettingsMapping.ItemsChartIDataObjectBase, SettingsMapping.BaseIDataErrorResponse);
            extendMapping(SettingsMapping.ItemsChartIDataObjectNode, SettingsMapping.ItemsChartIDataObjectBase);
            /*#endif*/
            /*#if GeoChart*/
            extendMapping(SettingsMapping.GeoChartIGeoDataObjectNode, SettingsMapping.ItemsChartIDataObjectNode);
            extendMapping(SettingsMapping.GeoChartIAggregationDataObjectNode, SettingsMapping.GeoChartIGeoDataObjectNode);
            extendMapping(SettingsMapping.GeoChartIDataObject, SettingsMapping.BaseIDataErrorResponse);
            /*#endif*/
            /*#if ItemsChart*/
            extendMapping(SettingsMapping.ItemsChartIDataObjectLink, SettingsMapping.ItemsChartIDataObjectBase);
            /*#endif*/
            /*#if GeoChart*/
            extendMapping(SettingsMapping.GeoChartIGeoDataObjectLink, SettingsMapping.ItemsChartIDataObjectLink);
            /*#endif*/
            /*#if ItemsChart*/
            extendMapping(SettingsMapping.ItemsChartSettings, SettingsMapping.BaseSettings);
            /*#endif*/
            /*#if GeoChart*/
            extendMapping(SettingsMapping.GeoChartSettings, SettingsMapping.ItemsChartSettings);
            extendMapping(SettingsMapping.GeoChartSettingsAggregatedShapeStyle, SettingsMapping.BaseSettingsBackgroundStyle);
            extendMapping(SettingsMapping.GeoChartSettingsArea, SettingsMapping.BaseSettingsArea);
            extendMapping(SettingsMapping.GeoChartSettingsAreaStyle, SettingsMapping.BaseSettingsAreaStyle);
            /*#endif*/
            /*#if ItemsChart*/
            extendMapping(SettingsMapping.ItemsChartSettingsData, SettingsMapping.BaseSettingsData);
            /*#endif*/
            /*#if GeoChart*/
            extendMapping(SettingsMapping.GeoChartSettingsData, SettingsMapping.ItemsChartSettingsData);
            /*#endif*/
            /*#if ItemsChart*/
            extendMapping(SettingsMapping.ItemsChartSettingsInteraction, SettingsMapping.BaseSettingsInteraction);
            /*#endif*/
            /*#if GeoChart*/
            extendMapping(SettingsMapping.GeoChartSettingsInteraction, SettingsMapping.ItemsChartSettingsInteraction);
            extendMapping(SettingsMapping.GeoChartSettingsLayerOverlay, SettingsMapping.GeoChartSettingsLayerBase);
            extendMapping(SettingsMapping.GeoChartSettingsLayerAggregated, SettingsMapping.GeoChartSettingsLayerOverlay);
            extendMapping(SettingsMapping.GeoChartSettingsLayerCharts, SettingsMapping.GeoChartSettingsLayerOverlay);
            extendMapping(SettingsMapping.GeoChartSettingsLayerItems, SettingsMapping.GeoChartSettingsLayerBase);
            extendMapping(SettingsMapping.GeoChartSettingsLayerShapes, SettingsMapping.GeoChartSettingsLayerBase);
            /*#endif*/
            /*#if ItemsChart*/
            extendMapping(SettingsMapping.ItemsChartSettingsNodesLayerStyle, SettingsMapping.ItemsChartSettingsItemsLayerStyle);
            /*#endif*/
            /*#if GeoChart*/
            extendMapping(SettingsMapping.GeoChartSettingsNodesLayerStyle, SettingsMapping.ItemsChartSettingsNodesLayerStyle);
            extendMapping(SettingsMapping.GeoChartSettingsShapesLayerNodeStyle, SettingsMapping.ItemsChartSettingsNodeStyle);
            extendMapping(SettingsMapping.GeoChartSettingsShapesLayerStyle, SettingsMapping.GeoChartSettingsNodesLayerStyle);
            /*#endif*/
            /*#if ItemsChart*/
            extendMapping(SettingsMapping.ItemsChartIChartEventArguments, SettingsMapping.BaseIChartEventArguments);
            extendMapping(SettingsMapping.ItemsChartIChartClickEventArguments, SettingsMapping.ItemsChartIChartEventArguments);
            extendMapping(SettingsMapping.ItemsChartSettingsAdvanced, SettingsMapping.BaseSettingsAdvanced);
            extendMapping(SettingsMapping.ItemsChartSettingsAuraStyle, SettingsMapping.BaseSettingsBackgroundStyle);
            extendMapping(SettingsMapping.ItemsChartSettingsItemsLayerLabelStyle, SettingsMapping.BaseSettingsLabelStyle);
            extendMapping(SettingsMapping.ItemsChartSettingsItemsLayerLinkLabelStyle, SettingsMapping.ItemsChartSettingsItemsLayerLabelStyle);
            extendMapping(SettingsMapping.ItemsChartSettingsLinkClass, SettingsMapping.ItemsChartSettingsItemClass);
            extendMapping(SettingsMapping.ItemsChartSettingsLinkItem, SettingsMapping.ItemsChartSettingsItemsLayerLabelStyle);
            extendMapping(SettingsMapping.ItemsChartSettingsLinkMenu, SettingsMapping.ItemsChartSettingsMenu);
            extendMapping(SettingsMapping.ItemsChartSettingsNodeClass, SettingsMapping.ItemsChartSettingsItemClass);
            extendMapping(SettingsMapping.ItemsChartSettingsNodeItem, SettingsMapping.ItemsChartSettingsItemsLayerLabelStyle);
            extendMapping(SettingsMapping.ItemsChartSettingsNodeMenu, SettingsMapping.ItemsChartSettingsMenu);
            /*#endif*/
            /*#if LinearChart*/
            extendMapping(SettingsMapping.LinearChartSettingsArea, SettingsMapping.BaseSettingsArea);
            extendMapping(SettingsMapping.LinearChartSettingsAreaStyle, SettingsMapping.BaseSettingsAreaStyle);
            var origLinearChartSettingsEvents = SettingsMapping.LinearChartSettingsEvents;
            SettingsMapping.LinearChartSettingsEvents = function (TArguments, TClickArguments) {
                var x = origLinearChartSettingsEvents(TArguments, TClickArguments);
                extendMapping(x, SettingsMapping.BaseSettingsEvents(TArguments, TClickArguments));
                return x;
            };
            extendMapping(SettingsMapping.LinearChartSettingsLegend, SettingsMapping.BaseSettingsLegend);
            extendMapping(SettingsMapping.LinearChartSettingsLegendAdvanced, SettingsMapping.BaseSettingsLegendAdvanced);
            extendMapping(SettingsMapping.LinearChartSettingsLegendMarker, SettingsMapping.BaseSettingsLegendMarker);
            extendMapping(SettingsMapping.LinearChartSettingsLocalization, SettingsMapping.BaseSettingsLocalization);
            extendMapping(SettingsMapping.LinearChartSettingsLocalizationToolbar, SettingsMapping.BaseSettingsLocalizationToolbar);
            extendMapping(SettingsMapping.LinearChartSettingsSeriesCandleStick, SettingsMapping.LinearChartSettingsSeries);
            extendMapping(SettingsMapping.LinearChartSettingsSeriesCandleStickStyle, SettingsMapping.LinearChartSettingsSeriesStyle);
            extendMapping(SettingsMapping.LinearChartSettingsValueAxisBaseLineStyle, SettingsMapping.BaseSettingsLineStyle);
            extendMapping(SettingsMapping.LinearChartSettingsValueAxisTitleStyle, SettingsMapping.BaseSettingsLabelStyle);
            /*#endif*/
            /*#if NetChart*/
            extendMapping(SettingsMapping.NetChartBarSettingsLocalizationToolbar, SettingsMapping.BaseSettingsLocalizationToolbar);
            extendMapping(SettingsMapping.NetChartBarSettingsToolbar, SettingsMapping.BaseSettingsToolbar);
            extendMapping(SettingsMapping.NetChartIChartEventArguments, SettingsMapping.ItemsChartIChartEventArguments);
            extendMapping(SettingsMapping.NetChartIChartClickEventArguments, SettingsMapping.NetChartIChartEventArguments);
            extendMapping(SettingsMapping.NetChartIDataObject, SettingsMapping.BaseIDataErrorResponse);
            extendMapping(SettingsMapping.NetChartIDataObjectLink, SettingsMapping.ItemsChartIDataObjectLink);
            extendMapping(SettingsMapping.NetChartIDataObjectNode, SettingsMapping.ItemsChartIDataObjectNode);
            extendMapping(SettingsMapping.NetChartSettings, SettingsMapping.ItemsChartSettings);
            extendMapping(SettingsMapping.NetChartSettingsArea, SettingsMapping.BaseSettingsArea);
            extendMapping(SettingsMapping.NetChartSettingsData, SettingsMapping.ItemsChartSettingsData);
            extendMapping(SettingsMapping.NetChartSettingsInteraction, SettingsMapping.ItemsChartSettingsInteraction);
            extendMapping(SettingsMapping.NetChartSettingsInteractionSelection, SettingsMapping.ItemsChartSettingsInteractionSelection);
            extendMapping(SettingsMapping.NetChartSettingsInteractionZooming, SettingsMapping.ItemsChartSettingsInteractionZooming);
            extendMapping(SettingsMapping.NetChartSettingsLegend, SettingsMapping.BaseSettingsLegend);
            extendMapping(SettingsMapping.NetChartSettingsLegendAdvanced, SettingsMapping.BaseSettingsLegendAdvanced);
            extendMapping(SettingsMapping.NetChartSettingsLocalization, SettingsMapping.BaseSettingsLocalization);
            extendMapping(SettingsMapping.NetChartSettingsStyle, SettingsMapping.ItemsChartSettingsNodesLayerStyle);
            /*#endif*/
            /*#if PieChart*/
            extendMapping(SettingsMapping.PieChartIChartEventArguments, SettingsMapping.BaseIChartEventArguments);
            extendMapping(SettingsMapping.PieChartIChartClickEventArguments, SettingsMapping.PieChartIChartEventArguments);
            extendMapping(SettingsMapping.PieChartIDataObjectCommon, SettingsMapping.BaseIDataObjectBase);
            extendMapping(SettingsMapping.PieChartIDataObject, SettingsMapping.PieChartIDataObjectCommon);
            extendMapping(SettingsMapping.PieChartIDataObjectRoot, SettingsMapping.PieChartIDataObjectCommon);
            extendMapping(SettingsMapping.PieChartIDataObjectRoot, SettingsMapping.BaseIDataErrorResponse);
            extendMapping(SettingsMapping.PieChartSettings, SettingsMapping.BaseSettings);
            extendMapping(SettingsMapping.PieChartSettingsAdvanced, SettingsMapping.BaseSettingsAdvanced);
            extendMapping(SettingsMapping.PieChartSettingsData, SettingsMapping.BaseSettingsData);
            extendMapping(SettingsMapping.PieChartSettingsEvents, SettingsMapping.BaseSettingsEvents(SettingsMapping.PieChartIChartEventArguments, SettingsMapping.PieChartIChartClickEventArguments));
            extendMapping(SettingsMapping.PieChartSettingsInteraction, SettingsMapping.BaseSettingsInteraction);
            extendMapping(SettingsMapping.PieChartSettingsLegend, SettingsMapping.BaseSettingsLegend);
            extendMapping(SettingsMapping.PieChartSettingsLegendMarker, SettingsMapping.BaseSettingsLegendMarker);
            extendMapping(SettingsMapping.PieChartSettingsLocalization, SettingsMapping.BaseSettingsLocalization);
            /*#endif*/
            /*#if TimeChart*/
            extendMapping(SettingsMapping.TimeChartIChartEventArguments, SettingsMapping.BaseIChartEventArguments);
            extendMapping(SettingsMapping.TimeChartIDataObject, SettingsMapping.BaseIDataErrorResponse);
            extendMapping(SettingsMapping.TimeChartSettings, SettingsMapping.LinearChartSettings);
            extendMapping(SettingsMapping.TimeChartSettingsAdvanced, SettingsMapping.BaseSettingsAdvanced);
            extendMapping(SettingsMapping.TimeChartSettingsArea, SettingsMapping.LinearChartSettingsArea);
            extendMapping(SettingsMapping.TimeChartSettingsAreaStyle, SettingsMapping.LinearChartSettingsAreaStyle);
            extendMapping(SettingsMapping.TimeChartSettingsCurrentTime, SettingsMapping.TimeChartSettingsMarker);
            extendMapping(SettingsMapping.TimeChartSettingsData, SettingsMapping.BaseSettingsData);
            extendMapping(SettingsMapping.TimeChartSettingsEvents, SettingsMapping.LinearChartSettingsEvents(SettingsMapping.TimeChartIChartEventArguments, SettingsMapping.TimeChartIChartEventArguments));
            extendMapping(SettingsMapping.TimeChartSettingsInteraction, SettingsMapping.LinearChartSettingsInteraction);
            extendMapping(SettingsMapping.TimeChartSettingsInteractionScrolling, SettingsMapping.LinearChartSettingsInteractionScrolling);
            extendMapping(SettingsMapping.TimeChartSettingsInteractionZooming, SettingsMapping.LinearChartSettingsInteractionZooming);
            extendMapping(SettingsMapping.TimeChartSettingsLocalization, SettingsMapping.LinearChartSettingsLocalization);
            extendMapping(SettingsMapping.TimeChartSettingsLocalizationToolbar, SettingsMapping.LinearChartSettingsLocalizationToolbar);
            extendMapping(SettingsMapping.TimeChartSettingsSeries, SettingsMapping.LinearChartSettingsSeries);
            extendMapping(SettingsMapping.TimeChartSettingsSeriesCandleStick, SettingsMapping.LinearChartSettingsSeriesCandleStick);
            extendMapping(SettingsMapping.TimeChartSettingsSeriesData, SettingsMapping.LinearChartSettingsSeriesData);
            extendMapping(SettingsMapping.TimeChartSettingsSeriesCandleStickData, SettingsMapping.TimeChartSettingsSeriesData);
            extendMapping(SettingsMapping.TimeChartSettingsSeriesColumns, SettingsMapping.LinearChartSettingsSeriesColumns);
            extendMapping(SettingsMapping.TimeChartSettingsSeriesLines, SettingsMapping.LinearChartSettingsSeriesLines);
            extendMapping(SettingsMapping.TimeChartSettingsSeriesLinesStyle, SettingsMapping.LinearChartSettingsSeriesLinesStyle);
            extendMapping(SettingsMapping.TimeChartSettingsToolbar, SettingsMapping.BaseSettingsToolbar);
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Configuration;
    (function (Configuration) {
        (function (GeoChartSettingsAggregatedShapeStyleMode) {
            // referenced by: ZoomCharts.Internal.GeoChart.SettingsLayerShapes.style.$base.aggregatedShape.mode
            /** The aggregated shapes will always be shown for all nodes. */
            GeoChartSettingsAggregatedShapeStyleMode[GeoChartSettingsAggregatedShapeStyleMode["always"] = 2] = "always";
            /** The aggregated shape will never be shown. */
            GeoChartSettingsAggregatedShapeStyleMode[GeoChartSettingsAggregatedShapeStyleMode["disabled"] = 0] = "disabled";
            /** The aggregated shape will only be shown for the hovered node (this is the default). */
            GeoChartSettingsAggregatedShapeStyleMode[GeoChartSettingsAggregatedShapeStyleMode["hovered"] = 1] = "hovered";
            /** The aggregated shapes will always be shown for selected nodes. */
            GeoChartSettingsAggregatedShapeStyleMode[GeoChartSettingsAggregatedShapeStyleMode["selected"] = 3] = "selected";
        })(Configuration.GeoChartSettingsAggregatedShapeStyleMode || (Configuration.GeoChartSettingsAggregatedShapeStyleMode = {}));
        var GeoChartSettingsAggregatedShapeStyleMode = Configuration.GeoChartSettingsAggregatedShapeStyleMode;
        (function (LinearChartSettingsValueAxisBaseLineLabelMode) {
            // referenced by: ZoomCharts.Internal.LinearChart.Settings.valueAxisDefault.baseLine.showLabel
            /** The label is drawn always if the line itself is visible. */
            LinearChartSettingsValueAxisBaseLineLabelMode[LinearChartSettingsValueAxisBaseLineLabelMode["always"] = 2] = "always";
            /** Unless the zero line is not visible, the label is drawn always for outside axis. For value axis that are located inside the chart area
            the label is only drawn if the value axis also shows negative values. */
            LinearChartSettingsValueAxisBaseLineLabelMode[LinearChartSettingsValueAxisBaseLineLabelMode["auto"] = 1] = "auto";
            /** The label is never drawn. */
            LinearChartSettingsValueAxisBaseLineLabelMode[LinearChartSettingsValueAxisBaseLineLabelMode["never"] = 0] = "never";
        })(Configuration.LinearChartSettingsValueAxisBaseLineLabelMode || (Configuration.LinearChartSettingsValueAxisBaseLineLabelMode = {}));
        var LinearChartSettingsValueAxisBaseLineLabelMode = Configuration.LinearChartSettingsValueAxisBaseLineLabelMode;
    })(Configuration = ZoomCharts.Configuration || (ZoomCharts.Configuration = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="SettingsGeneratedCode.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var SettingsHelper = (function () {
                function SettingsHelper() {
                }
                /** Creates an array of objects created by merging various default values together.
                This method is used when the defaults can be specified in the settings separately from the actual objects (such as series/layers etc.) */
                SettingsHelper.mergeDefaultValues = function (
                    /** The values for specific entries */ dataArray, 
                    /** The most default values (overwritten by any other value) */ defaultValues, 
                    /** The default values by type (overwritten by values in dataArray) */ typeDefaults, 
                    /** Delegate to create new instances of the final objects */ ctor, 
                    /** Delegate to retrieve the correct mapping information */ mapping, 
                    /** The path in the settings hierarchy where `dataArray` is defined */ path) {
                    var defaultType = defaultValues ? defaultValues.type : null;
                    if (!dataArray || dataArray.length === 0) {
                        // if default values are not specified, return since the type value will not be present.
                        if (!defaultType)
                            return [];
                        dataArray = [{ type: defaultType }];
                    }
                    var result = [];
                    for (var i = 0; i < dataArray.length; i++) {
                        var source = dataArray[i];
                        var sPath = path + "[" + i + "]";
                        if (!Base.Helpers.isObjectOrArray(source))
                            continue;
                        var type = source.type || defaultType;
                        if (!type)
                            throw new Error("`type` property must be specified in the settings for value: " + sPath);
                        var target = ctor(source, type);
                        var typeValues = typeDefaults[type];
                        if (defaultValues) {
                            delete defaultValues.type;
                            SettingsHelper.updateRecursive(target, defaultValues, mapping(target, defaultValues), {}, sPath);
                            defaultValues.type = defaultType;
                        }
                        if (typeValues) {
                            SettingsHelper.updateRecursive(target, typeValues, mapping(target, typeValues), {}, sPath);
                        }
                        SettingsHelper.updateRecursive(target, source, mapping(target, source), {}, sPath);
                        result.push(target);
                    }
                    return result;
                };
                SettingsHelper.updateRecursive = function (target, source, map, outputChanges, path) {
                    if (path === void 0) { path = ""; }
                    if (!target)
                        throw new Error("Cannot update settings path '" + path + "' because the target object is not defined.");
                    if (!source)
                        return;
                    for (var key in source) {
                        if (!source.hasOwnProperty(key))
                            continue;
                        var value = source[key];
                        var keyPath = (path.length ? (path + ".") : "") + key;
                        var conf = this.findPropertyConfiguration(key, map, keyPath);
                        if (conf === null || value === void 0)
                            continue;
                        this.copyValue(target, key, value, conf, outputChanges, keyPath);
                    }
                };
                SettingsHelper.copyValueMergeByID = function (target, targetKey, value, conf, outputChanges, keyPath) {
                    if (value == null)
                        return;
                    if (conf.t !== 6 /* array */)
                        throw new Error("Property '" + keyPath + "' is set to use merge-by-ID update mode which is only supported on arrays.");
                    if (this.replacingSettings)
                        return this.copyValueRecursive(target, targetKey, value, conf, outputChanges, keyPath);
                    var current = target[targetKey];
                    if (current == null)
                        target[targetKey] = current = [];
                    // create a map for the existing objects
                    var map = {};
                    for (var i = 0; i < current.length; i++) {
                        map[current[i].id] = current[i];
                    }
                    for (var j = 0; j < value.length; j++) {
                        var c = value[j];
                        if (c == null)
                            continue;
                        if (!c.id) {
                            // Generate new ID if not specified
                            c.id = Base.Helpers.getIdentifierStr();
                        }
                        var exists = map[c.id];
                        if (!outputChanges[targetKey])
                            outputChanges[targetKey] = {};
                        this.copyValue(map, c.id, c, conf.b[0], outputChanges[targetKey], keyPath + "[" + c.id + "]");
                        if (!exists) {
                            // in this case copyValue has created a new object
                            current.push(map[c.id]);
                        }
                    }
                };
                SettingsHelper.retrieveOwnMethod = function (ctor, name) {
                    if (!ctor)
                        return null;
                    var method = ctor[name];
                    var baseType = ctor.__baseType;
                    // __baseType is set by our custom __extends implementation
                    if (baseType && baseType[name] === method)
                        return null;
                    return method;
                };
                SettingsHelper.copyValueRecursive = function (target, targetKey, value, conf, outputChanges, keyPath) {
                    if (value == null)
                        return;
                    var current = target[targetKey];
                    if (!conf.c) {
                        if (conf.t === 6 /* array */) {
                            target[targetKey] = current = [];
                            this.copyArray(current, value, conf.b[0], outputChanges[targetKey] = [], keyPath);
                        }
                        else if (conf.t === 8 /* dictionary */) {
                            if (current == null || this.replacingSettings)
                                target[targetKey] = current = {};
                            this.copyDictionary(current, value, conf.b[0], outputChanges[targetKey] = {}, keyPath);
                        }
                        else {
                            throw new Error("Property '" + keyPath + "' is set to use recursive update but does not define target object mapping.");
                        }
                    }
                    else {
                        var ctor = conf.x ? conf.x() : null;
                        var getMapping = this.retrieveOwnMethod(ctor, "getMapping");
                        var nextConfig = getMapping ? getMapping(current, value) : conf.c();
                        if (current == null) {
                            if (ctor && !conf.y && !this._ignoringCtor) {
                                var createInstance = this.retrieveOwnMethod(ctor, "createInstance");
                                current = createInstance ? createInstance(value) : new ctor();
                            }
                            else {
                                current = {};
                            }
                            target[targetKey] = current;
                        }
                        if (conf.y) {
                            try {
                                this._ignoringCtor++;
                                this.updateRecursive(current, value, nextConfig, outputChanges[targetKey] = {}, keyPath);
                            }
                            finally {
                                this._ignoringCtor--;
                            }
                        }
                        else {
                            this.updateRecursive(current, value, nextConfig, outputChanges[targetKey] = {}, keyPath);
                        }
                    }
                };
                SettingsHelper.copyValue = function (target, targetKey, value, conf, outputChanges, keyPath) {
                    if (value === void 0) {
                        delete target[targetKey];
                        outputChanges[targetKey] = true;
                        return;
                    }
                    var checkResult = this.ensurePropertyType(value, conf, keyPath);
                    if (!checkResult)
                        return;
                    value = checkResult.value;
                    conf = checkResult.configuration || conf;
                    var current = target[targetKey];
                    if (conf.u === 1 /* reference */ || conf.u === void 0) {
                        if (current !== value) {
                            outputChanges[targetKey] = value;
                            target[targetKey] = value;
                        }
                    }
                    else if (conf.u === 2 /* jsonClone */) {
                        value = JSON.parse(JSON.stringify(value));
                        outputChanges[targetKey] = value;
                        target[targetKey] = value;
                    }
                    else if (conf.u === 4 /* mergeByID */) {
                        this.copyValueMergeByID(target, targetKey, value, conf, outputChanges, keyPath);
                    }
                    else if (conf.u === 3 /* concat */) {
                        if (value != null) {
                            if (conf.t === 6 /* array */) {
                                if (!current || this.replacingSettings)
                                    target[targetKey] = current = [];
                                this.copyArray(current, value, conf.b[0], outputChanges[targetKey] = [], keyPath);
                            }
                            else {
                                throw new Error("Property '" + keyPath + "' is set to use concat update which is only supported for arrays.");
                            }
                        }
                    }
                    else if (conf.u === 0 /* recursive */) {
                        this.copyValueRecursive(target, targetKey, value, conf, outputChanges, keyPath);
                    }
                    else {
                        throw new Error("Property '" + keyPath + "' does not have an update mode defined in the settings mapping or it is not implemented.");
                    }
                };
                SettingsHelper.copyDictionary = function (target, source, conf, outputChanges, keyPath) {
                    var keys = Object.keys(source);
                    for (var i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        var changes = {};
                        this.copyValue(target, key, source[key], conf, changes, keyPath + "." + key);
                        if (Base.Helpers.hasProperties(changes))
                            outputChanges[key] = changes;
                    }
                };
                SettingsHelper.copyArray = function (target, source, conf, outputChanges, keyPath) {
                    for (var i = 0; i < source.length; i++) {
                        this.copyValue(target, target.length, source[i], conf, outputChanges, keyPath + "[" + i + "]");
                    }
                };
                SettingsHelper.ensurePropertyType = function (value, configuration, path, suppressError) {
                    if (suppressError === void 0) { suppressError = false; }
                    if (value == null)
                        return { value: value };
                    var simpleError = null;
                    var complexError = null;
                    var result = void 0;
                    var replaceConfig = null;
                    switch (configuration.t) {
                        case 0 /* string */:
                            if (value instanceof String)
                                value = value.valueOf();
                            if (!Base.Helpers.isString(value))
                                simpleError = "String";
                            break;
                        case 1 /* number */:
                            if (value instanceof Number)
                                value = value.valueOf();
                            if (configuration.d === 0 /* integer */) {
                                result = parseFloat(value);
                                var rounded = Math.round(result);
                                if (isNaN(result)) {
                                    simpleError = "Integer";
                                }
                                else if (rounded !== result) {
                                    var delta = Math.abs(rounded - result);
                                    if (!suppressError) {
                                        Base.Helpers.warn("Settings value '" + path + "' expected to be an Integer but contains a decimal point: " + result + ".");
                                    }
                                    // be friendly to the user and round if it looks like to be just because of floating point
                                    if (delta < 10e-9)
                                        result = rounded;
                                }
                            }
                            else {
                                result = parseFloat(value);
                                if (isNaN(result))
                                    simpleError = "Float";
                            }
                            break;
                        case 3 /* HTMLElement */:
                            if (Base.Helpers.isString(value)) {
                                result = document.getElementById(value);
                                if (!result)
                                    complexError = "the property expects either a reference to a DOM element or a string containing the ID of the element."
                                        + " There is no element with the given ID '" + value + "'.";
                            }
                            else if (!Base.Helpers.isDomObject(value)) {
                                complexError = "the property expects either a reference to a DOM element or a string containing the ID of the element.";
                            }
                            break;
                        case 4 /* delegate */:
                            if (!Base.Helpers.isFunction(value))
                                simpleError = "Function";
                            break;
                        case 6 /* array */:
                            if (!Array.isArray(value)) {
                                if (!suppressError) {
                                    Base.Helpers.warn("Settings value '" + path + "' expected to be an array but found " + typeof value + ". The value will be wrapped in an array.");
                                    result = [value];
                                }
                                else {
                                    simpleError = "Array";
                                }
                            }
                            break;
                        case 16 /* Float32Array */:
                            if (typeof Float32Array === typeof void 0 || !(value instanceof Float32Array)) {
                                simpleError = "Float32Array";
                            }
                            break;
                        case 16 /* Float32Array */:
                            if (typeof Float32Array === typeof void 0 || !(value instanceof Float32Array)) {
                                simpleError = "Float32Array";
                            }
                            break;
                        case 17 /* Int32Array */:
                            if (typeof Int32Array === typeof void 0 || !(value instanceof Int32Array)) {
                                simpleError = "Int32Array";
                            }
                            break;
                        case 18 /* Uint32Array */:
                            if (typeof Uint32Array === typeof void 0 || !(value instanceof Uint32Array)) {
                                simpleError = "UInt32Array";
                            }
                            break;
                        case 11 /* GradientDefinition */:
                            if (!Array.isArray(value)) {
                                complexError = "the property has to be an array where each item is an array with two elements - a number and a string.";
                            }
                            else {
                                for (var gdi = 0; gdi < value.length; gdi++) {
                                    var x = value[gdi];
                                    if (!Array.isArray(x) || x.length !== 2 || !Base.Helpers.isNumber(x[0]) || !Base.Helpers.isString(x[1])) {
                                        complexError = "the property at index " + gdi + " has to be an array with two elements - a number and a string.";
                                        break;
                                    }
                                }
                            }
                            break;
                        case 2 /* enum */:
                            var enumType = configuration.e();
                            var isNumber = Base.Helpers.isNumber(value);
                            if (isNumber || Base.Helpers.isString(value)) {
                                result = enumType[value];
                                if (result === void 0) {
                                    complexError = "'" + value + "' is not a valid enumeration value. Please review the documentation for valid values.";
                                    // since value is added to the console output, this will display the list of valid values
                                    value = enumType;
                                }
                                // lookup by number returns a string, use the original number instead.
                                if (isNumber)
                                    result = value;
                            }
                            else {
                                complexError = "the value must be a number or a string (the preferred way is to use the enumeration from 'ZoomCharts.Configuration' namespace).";
                                // since value is added to the console output, this will display the list of valid values
                                value = enumType;
                            }
                            break;
                        case 14 /* CanvasGradient */:
                            if (!(value instanceof CanvasGradient))
                                simpleError = "CanvasGradient";
                            break;
                        case 12 /* tuple */:
                            if (!Array.isArray(value) || value.length !== configuration.b.length) {
                                complexError = "the property expects an array with exactly " + configuration.b.length + " elements.";
                            }
                            else {
                                for (var ti = 0; ti < value.length; ti++) {
                                    var temp = this.ensurePropertyType(value[ti], configuration.b[ti], path + "[" + ti + "]", suppressError);
                                    if (!temp) {
                                        // the error message has been shown by the ensurePropertyType() call.
                                        return null;
                                    }
                                    else {
                                        value[ti] = temp.value;
                                    }
                                }
                            }
                            break;
                        case 7 /* union */:
                            var unionValid = false;
                            for (var ui = 0; ui < configuration.b.length; ui++) {
                                var utemp = this.ensurePropertyType(value, configuration.b[ui], path, true);
                                if (utemp) {
                                    result = utemp.value;
                                    replaceConfig = utemp.configuration || configuration.b[ui];
                                    unionValid = true;
                                    break;
                                }
                            }
                            if (!unionValid) {
                                complexError = "the the given value does not match any constituent of the union type. Please review the documentation on the correct type.";
                            }
                            break;
                        case 5 /* object */:
                        case 8 /* dictionary */:
                            if (!Base.Helpers.isObjectOrArray(value))
                                simpleError = "Object";
                            break;
                        case 9 /* boolean */:
                            if (value instanceof Boolean)
                                value = value.valueOf();
                            if (value !== null && value !== true && value !== false)
                                simpleError = "Boolean";
                            break;
                        case 10 /* any */:
                            break;
                        default:
                            throw new Error("Unsupported data type: " + configuration.t);
                    }
                    if (simpleError !== null && complexError === null)
                        complexError = "the given value '" + value + "' is not of type '" + simpleError + "'.";
                    if (complexError !== null) {
                        if (!suppressError)
                            Base.Helpers.error("Cannot update settings value '" + path + "' because " + complexError, value);
                        return null;
                    }
                    if (result !== void 0)
                        value = result;
                    return { value: value, configuration: replaceConfig };
                };
                SettingsHelper.findPropertyConfiguration = function (name, map, path) {
                    var p = map[name];
                    if (p !== void 0)
                        return p;
                    Base.Helpers.warn("Cannot update settings value '" + path + "' because such property does not exist.", null, true);
                    return null;
                };
                SettingsHelper._ignoringCtor = 0;
                /** A global override to replace arrays and dictionaries instead of merging them.
                If this is ever set it must be wrapped in try/finally and always restored to `false` in the `finally` block. */
                SettingsHelper.replacingSettings = false;
                return SettingsHelper;
            }());
            Base.SettingsHelper = SettingsHelper;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Helpers.ts" />
/// <reference path="Images.ts" />
/// <reference path="Data.ts" />
/// <reference path="Credits.ts" />
/// <reference path="Title.ts" />
/// <reference path="Legend.ts" />
/// <reference path="Bar/Toolbar.ts" />
/// <reference path="Resizer.ts" />
/// <reference path="SettingsHelper.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var Settings = (function () {
                //#region Constructor
                function Settings(mapping) {
                    this._mapping = null;
                    //#region Computed properties
                    this._computedDataMap = {};
                    this._initializing = true;
                    //#endregion
                    /** Element of the page where the chart will be inserted. Any HTML element should work, for example you can use a `<div>`.
                    
                    Any contents of the element will be cleared - this behavior can be used to specify a loading message as the initial content,
                    for example `<div>Chart is being initialized...</div>`.
                    
                    Note that a single element can host only one chart. If the same container is given to another chart, the previous chart will
                    be automatically disposed.
            
                    Unless `parentChart` is specified, the value of the property is mandatory and can only be specified while creating the chart,
                    not with `updateSettings`. The value can be either an ID of an existing element or a reference to a DOM element.
                    @update reference
                    */
                    this.container = null;
                    /** Theme to apply. You can either use this to share configuration objects between multiple charts or use one of the predefined
                    themes.
                    @update !important reference  */
                    this.theme = null;
                    /** The URL root where the ZoomCharts library and assets are located. For example, if the base.css file is available at
                    'http://server/css/zoomcharts/zc.css' then this value should be set to 'http://server/css/zoomcharts/'.
                    Note that the library will try to determine its location automatically by searching the included script tags.
                    So this property can be skipped if the assets folder is located next to 'zoomcharts.js' file on the server. */
                    this.assetsUrlBase = "";
                    /** Chart area related settings. */
                    this.area = new SettingsArea();
                    /** Settings used to load data into chart. Customise preferred data source feeding methods.
                    You can use one of these options: url, data function, preloaded data.
                    !important @update mergeByID */
                    this.data = [];
                    this.advanced = new SettingsAdvanced();
                    /** The events used to handle user interaction with UI elements. */
                    this.events = new SettingsEvents();
                    /** Customise chart resize handles or animation duration settings. */
                    this.interaction = new SettingsInteraction();
                    /** Localizeable strings including export type options and useful default buttons used for chart interaction.
                    Buttons like to navigate back, set the chart on full screen and others. */
                    this.localization = new SettingsLocalization();
                    /** Adjustable settings to manage default and custom toolbar items, as well as toolbar overall appearance. */
                    this.toolbar = new Base.SettingsToolbar();
                    /** The chart's main title. */
                    this.title = new Base.SettingsTitle();
                    /** Settings for displaying chart credits. Use it as a reference to additional data sources if necessery.
            
                    ![Chart including credits](images/settings-credits.png)
            
                    Note that even if credits enabled on page load, it's possible to hide on exported images. */
                    this.credits = new Base.SettingsCredits();
                    this.legend = new Base.SettingsLegend();
                    this._mapping = mapping;
                }
                //#endregion
                /**@ignore*/
                Settings.prototype.applyGlobalCustomizations = function () {
                    // apply default theme
                    if (this.theme) {
                        Base.SettingsHelper.updateRecursive(this, this.theme, this._mapping, {});
                    }
                };
                //#region Apply methods
                /**@ignore*/
                Settings.prototype.applyCompatibility = function (settings, compatList, path) {
                    path = path == null ? "" : (path + ".");
                    for (var itemIndex = 0; itemIndex < compatList.length; itemIndex++) {
                        var item = compatList[itemIndex];
                        var from = item.from;
                        var val = Base.Helpers.getProp(settings, from, !!item.to && !item.filter);
                        if (val === void 0 || (item.filter && !item.filter(val))) {
                            continue;
                        }
                        if (item.to) {
                            if (item.transform) {
                                val = item.transform(val);
                            }
                            Base.Helpers.extendDeep(settings, Base.Helpers.wrapValue(val, item.to));
                            Base.Helpers.warn(("Setting `" + path + from + "` is being deprecated. Compatibility layer moved the value automatically to `" + path + item.to + "`.") +
                                " Please update the configuration to avoid using the obsolete property.", null, true);
                        }
                        else {
                            var isw = item.alternativeAsWarning;
                            var msg = "Setting `" + path + from + "` " + (isw ? "is being deprecated" : "is no longer supported") + ". Consider using `" + item.alternative + "` instead.";
                            if (isw) {
                                Base.Helpers.warn(msg, null, true);
                            }
                            else {
                                Base.Helpers.error(msg);
                            }
                        }
                    }
                };
                /** returns actually changed values
                @ignore*/
                Settings.prototype.apply = function (settings) {
                    this.applyCompatibility(settings, [
                        { from: "width", to: "area.width" },
                        { from: "height", to: "area.height" },
                        { from: "minHeight", to: "area.minHeight" },
                        { from: "maxHeight", to: "area.maxHeight" },
                        { from: "minWidth", to: "area.minWidth" },
                        { from: "maxWidth", to: "area.maxWidth" },
                    ]);
                    var changes = {};
                    var unwrapDataArray = false;
                    if (this._initializing) {
                        this.applyGlobalCustomizations();
                        if (!settings)
                            settings = {};
                        if (!settings.data)
                            settings.data = [{}];
                    }
                    else if (!settings) {
                        return changes;
                    }
                    if (settings.data) {
                        if (!Array.isArray(settings.data)) {
                            settings.data = [settings.data];
                            unwrapDataArray = true;
                        }
                        // generate default ID values when needed
                        for (var dIndex = 0; dIndex < settings.data.length; dIndex++) {
                            var d0 = settings.data[dIndex];
                            // COMPATIBILITY: name was used for ID, fallback to default-<n>
                            if (!d0.id) {
                                if (d0.name) {
                                    Base.Helpers.warn("The property `name` in the data object configuration is deprecated in favor of `id` property." +
                                        " Please update the configuration to avoid using the obsolete property.", null, true);
                                    d0.id = d0.name;
                                    delete d0.name;
                                }
                                else if (dIndex === 0) {
                                    d0.id = "default";
                                }
                                else {
                                    d0.id = "default-" + dIndex.toString(10);
                                }
                            }
                        }
                    }
                    // merge data
                    Base.SettingsHelper.updateRecursive(this, settings.theme, this._mapping, changes);
                    Base.SettingsHelper.updateRecursive(this, settings, this._mapping, changes);
                    if (unwrapDataArray) {
                        // restore the original state of the settings object to make it reusable from the client code.
                        settings.data = settings.data[0];
                    }
                    if (changes["data"] || this._initializing) {
                        this._computedDataMap = {};
                        for (var dIndex = 0; dIndex < this.data.length; dIndex++) {
                            var d = this.data[dIndex];
                            this._computedDataMap[d.id] = d;
                        }
                    }
                    return changes;
                };
                return Settings;
            }());
            Base.Settings = Settings;
            var SettingsEvents = (function () {
                function SettingsEvents() {
                    // IMPORTANT - if events are added here, they should be doubled in the overloads for `Base.Api.on()` and in derived instances.
                    /** Function called when error occurs, default behavior is log to console. */
                    this.onError = null;
                    /** Function called when settings are changed. */
                    this.onSettingsChange = null;
                    /** Function called when user clicks on chart. */
                    this.onClick = null;
                    /** Function called when user double clicks on chart. */
                    this.onDoubleClick = null;
                    /** Function called when user triple clicks on chart. Use it for custom function call. */
                    this.onTripleClick = null;
                    /** Function called when user right clicks on chart. */
                    this.onRightClick = null;
                    /** Function called when object pointer is on changes. */
                    this.onHoverChange = null;
                    /** Function called when selected slices has changed. */
                    this.onSelectionChange = null;
                    /** Function called when whenever current view has changed. Usually after panning and navigation. Use to update any linked views.
                    Note that this is also fired after chart initialization and API methods. Use args.origin field to determine event's origin. */
                    this.onChartUpdate = null;
                    /** Function called whenever chart placement on screen changes. Note that this is called on every animation frame and is intended
                    for painting overlays only. */
                    this.onPositionChange = null;
                    // onAnimationDone event is only defined for LinearChart (Facet&Time)
                    /** Time to wait after last action before firing onChartUpdate event.
                    @type integer */
                    this.chartUpdateDelay = 0;
                }
                return SettingsEvents;
            }());
            Base.SettingsEvents = SettingsEvents;
            var SettingsLocalization = (function () {
                function SettingsLocalization() {
                    /** Strings used in toolbars. */
                    this.toolbar = new SettingsLocalizationToolbar();
                    /** Message to show when data loading is in progress. */
                    this.loadingLabel = "Loading...";
                    /** Text used on menu close button. */
                    this.closeButton = "Close";
                    /** Error message when data request has failed. */
                    this.dataRequestFailed = "Data request failed";
                    /** Error message when the browser does not support launching file save dialog from the script without
                    using `advanced.exportProxyURL` and that setting has been disabled.
                    @version 1.15.6 */
                    this.exportNotAvailable = "Your browser does not support exporting the chart.";
                }
                return SettingsLocalization;
            }());
            Base.SettingsLocalization = SettingsLocalization;
            var SettingsLocalizationToolbar = (function () {
                function SettingsLocalizationToolbar() {
                    this.backButton = "Back";
                    this.backTitle = "Move one step back in navigation";
                    this.fullscreenButton = "Fullscreen";
                    this.fullscreenTitle = "Toggle fullscreen mode";
                    this.zoomoutButton = "Zoom-out";
                    this.zoomoutTitle = "Zoom out";
                    this.exportButton = "Export";
                    this.exportTitle = "Export Data";
                    this.exportJpeg = "For Office and Web (jpeg)";
                    this.exportPNG = "For Photoshop (png)";
                    this.exportPDF = "For Printer (pdf)";
                    this.exportCSV = "Spreadsheet (csv)";
                    this.exportXLS = "Spreadsheet (xls)";
                }
                return SettingsLocalizationToolbar;
            }());
            Base.SettingsLocalizationToolbar = SettingsLocalizationToolbar;
            var SettingsArea = (function () {
                function SettingsArea() {
                    /** The default height of the chart if one is not specified neither in settings nor on the HTML element.
                    @ignore - used only internally so that GeoChart can be larger than other charts by default. The user is expected to use `height` instead.*/
                    this.defaultHeight = 300;
                    /** Width of the chart. If undefined the chart width will adapt to container element.
                     @type float
                     @min 1
                     @units pixels */
                    this.width = null;
                    /** Height of the chart. If undefined the chart height will adapt to container element.
                     @type float
                     @min 1
                     @units pixels */
                    this.height = null;
                    /** The vertical position of the chart. This setting only applies when this chart is nested within another by using `parentChart` setting.
                    @type float
                    @units pixels */
                    this.top = null;
                    /** The horizontal position of the chart. This setting only applies when this chart is nested within another by using `parentChart` setting.
                    @type float
                    @units pixels */
                    this.left = null;
                    /** The minimum chart height. Chart will not resize below this.
                     @type float
                     @units pixels */
                    this.minHeight = 50;
                    /** The maximum chart height. Chart will not resize below this.
                     @type float
                     @units pixels */
                    this.maxHeight = 20000;
                    /** The minimum chart width. The chart will not resize below this
                     @type float
                     @units pixels */
                    this.minWidth = 50;
                    /** The maximum chart width. The chart will not resize below this
                     @type float
                     @units pixels */
                    this.maxWidth = 20000;
                    /** Area style. */
                    this.style = new SettingsAreaStyle();
                }
                return SettingsArea;
            }());
            Base.SettingsArea = SettingsArea;
            var SettingsAreaStyle = (function () {
                function SettingsAreaStyle() {
                    /** Background fill color of chart area
                    @type color */
                    this.fillColor = "transparent";
                    /** Background image of  chart area.
                    @type imageUrl */
                    this.image = null;
                    /** The foreground fill color of the chart area. `rgba()` with alpha transparency should be used
                    @type color */
                    this.overlayColor = null;
                }
                return SettingsAreaStyle;
            }());
            Base.SettingsAreaStyle = SettingsAreaStyle;
            var SettingsInteraction = (function () {
                function SettingsInteraction() {
                    /** Controls chart resize handles.
            
                    It's a horizontal line right below any chart to handle whole chart resizes by small steps.
                    
                    Note that the full screen button used as a main alternative to get a full screen by one click. */
                    this.resizing = new Base.SettingsResizer();
                }
                return SettingsInteraction;
            }());
            Base.SettingsInteraction = SettingsInteraction;
            var SettingsAdvanced = (function () {
                function SettingsAdvanced() {
                    /** Whether to store entire label into bitmap. Use it to improve the performance of your application. */
                    this.labelCache = true;
                    /** Whether to store labels that are rendered rotated in the cache.
                    @version 1.14.0 */
                    this.labelCacheRotated = true;
                    /** Enables high resolution rendering on high DPI screens. As performance is varied across different browsers, disable this to
                    improve the performance of your application.
                    
                    This setting can either be set to `false` to disable the scaling, `true` to render according to the browser DPI setting
                    and a number to force a constant scale, ignoring browser DPI settings.
            
                    @version 1.13.0 - a constant scale using a number can now be specified, previously only `true/false` was supported. */
                    this.highDPI = true;
                    /** Pointer related settings. */
                    this.pointer = new SettingsAdvancedPointer();
                    /** Whether to use requestAnimationFrame for requested paint instead of setTimeout. */
                    this.useAnimationFrame = true;
                    /** Whether to use debugging option to paint pointer trails on screen. */
                    this.showTouches = false;
                    /** Whether to show the trail of each touch pointer and also display pointers that are no longer active.
                    For this setting to have effect, `showTouches` must be `true`. */
                    this.showTouchTrail = true;
                    /** Whether to show frames per second on the chart. */
                    this.showFPS = false;
                    /** Whether to show the current timestamp on the chart. Use only for debugging. */
                    this.showTimestamp = false;
                    /** Whether to show verbose logging. */
                    this.logging = false;
                    /** Miscellaneous style settings. */
                    this.style = new SettingsAdvancedStyle();
                    /** Maximum width in pixels of the canvas object.
            
                    When the width exceeds this value, the canvas is scaled up to match the required resolution. For example, if the maximum width is
                    set to 4096px but the container width is 5000px, the canvas will be rendered at 2500px width with the scale factor of 2.
                    @type integer
                    @units pixels
                    @version 1.16.0 - increased value from 2047 to 4096; the upscale is now always done by integer factor (e.g. x2 not x1.7) */
                    this.maxCanvasWidth = 4096;
                    /** Maximum height in pixels of the canvas object.
            
                    When the height exceeds this value, the canvas is scaled up to match the required resolution. For example, if the maximum height is
                    set to 4096px but the container height is 5000px, the canvas will be rendered at 2500px height with the scale factor of 2.
                    @type integer
                    @units pixels
                    @version 1.16.0 - increased value from 2047 to 4096; the upscale is now always done by integer factor (e.g. x2 not x1.7) */
                    this.maxCanvasHeight = 4096;
                    /** CSS class for current theme. Used to reference chart container in CSS files. */
                    this.themeCSSClass = "DVSL-round";
                    /** List of assets to load from assets directory. This should be used to load CSS of JS files that
                    are required for the chart to work.
            
                    If `required` is specified, it can be used to determine at runtime if the file has to be included.
                    For example, `zc.css` is only included if the page does not already defines the class `.DVSL-suppress-default-styles { color: #abc }`
                    (note that the `color: #abc` rule has to be defined since that rule is verified and not the class as a whole).
            
                    Note that in order to support older browsers such as Android 4.1, it is required for any `.css` asset
                    to define the `required` delegate that can be used to verify if the asset has been loaded.
                    @update concat */
                    this.assets = [
                        { url: "assets://zc.css", required: function () { return !Base.Helpers.isStyleSheetDefined("DVSL-suppress-default-styles", "color"); } }
                    ];
                    /** The list of assets for `builtin://` scheme - these assets usually are data-uri-s that can be used without external requests.
                    @ignore */
                    this.builtinAssets = {
                        "logo-supported-by": Internal.Resources.LicenseBannerSupportedBy,
                        "logo-development": Internal.Resources.LicenseBannerDevelopment,
                        "logo-license-expired": Internal.Resources.LicenseExpired,
                    };
                    /** URL for export proxy requests. To host the service on your own server, please visit <https://github.com/zoomcharts/proxy-export-dotnet/>.
            
                    @version 1.12.0 - changed the default value; request format modified and is no longer compatible with previous versions
                    @version 1.15.6 - if the value is set to `null`, the user will be informed if the browser does not support the download without the proxy.
                    @type url */
                    this.exportProxyURL = "https://echo.zoomcharts-cloud.com/download";
                    /** The page size in milimeters for the exported PDF documents. For A4 use `[210, 297]` (this is the default),
                    for letter size use `[215.9, 279.4]`. The first number is the width, the second is the height. */
                    this.exportPdfSize = [210, 297];
                    /** Specifies if the image requests issued by the chart are issued with `crossOrigin: anonymous` attribute.
            
                    Setting this to `true` enables using of images hosted on other servers for chart export. However it requires
                    that all image resources used provide `Access-Control-Allow-Origin` header in the response.
            
                    Note that currently the chart only uses this header when requesting images. It is not used when requesting
                    other assets like scripts or stylesheets.
                    @see MDN: [CORS enabled image](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_Enabled_Image)
                    @version 1.16.0 */
                    this.crossOriginHeader = null;
                }
                return SettingsAdvanced;
            }());
            Base.SettingsAdvanced = SettingsAdvanced;
            var SettingsAdvancedPointer = (function () {
                function SettingsAdvancedPointer() {
                    /** If enabled, normal click event is not sent when user performs a double click. A not so nice side effect is that any on click
                    actions are delayed by the double click timeout. Set to false if you are not relying on double click events. */
                    this.noClickOnDoubleClick = true;
                    /** Pixels pointer can move around and still be registered as a click.
                    @type float
                    @units pixels */
                    this.clickSensitivity = 10;
                    /** Pixels pointer can move around and still be registered as double click.
                    @type float
                    @units pixels */
                    this.doubleClickSensitivity = 20;
                    /** Maximum time in ms between clicks to register a double click.
                    @type integer
                    @units milliseconds */
                    this.doubleClickTimeout = 300;
                    /** Time in ms the pointer has to be hold to register a long press (an alternative to clicking the right mouse button).
                    @type integer
                    @units milliseconds */
                    this.longPressTimeout = 500;
                    /** The distance in pixels the pointer is allowed to be moved before the long-press event is cancelled.
                    @type integer
                    @units pixels */
                    this.longPressSensitivity = 10;
                    /** Time window to use for pointer speed estimation.
                    @type integer
                    @units milliseconds */
                    this.speedAveragingPeriod = 200;
                    /** Specifies if the chart container is scrolled into view once the chart is clicked.
            
                    Note that the scroll happens on a click, if the pointer is used to for example, drag
                    the chart, it will not scroll into view so that the user interaction works properly.
                    @version 1.12.0 - added the setting, previously the default was `true`. */
                    this.scrollIntoView = false;
                    /** Specifies if the mouse wheel is only captured when the chart has focus. Setting this to `true` will require that the
                    user first clicks the chart area.
                    @version 1.13.0 */
                    this.mouseWheelRequiresFocus = false;
                }
                return SettingsAdvancedPointer;
            }());
            Base.SettingsAdvancedPointer = SettingsAdvancedPointer;
            var SettingsAdvancedStyle = (function () {
                function SettingsAdvancedStyle() {
                    /** Message text. Note that the text position is taken from `loadingArcStyle.location`. */
                    this.messageTextStyle = {
                        fillColor: "#000",
                        font: "15px Arial"
                    };
                    /** The background that is drawn under the message. The box includes the loading indicator as well.
            
                    Note that the background is not drawn if the loading indicator is shown without this background.
                    @version 1.13.2 */
                    this.messageBackgroundStyle = {
                        padding: 5
                    };
                    /** Loading arc animation style */
                    this.loadingArcStyle = {
                        /** Loading arc radius.
                        @type float
                        @units pixels */
                        r: 10,
                        lineColor: "#444",
                        lineWidth: 1,
                        /** Specifies the location of the loading indicator and the status message as well.
                        @type enum
                        @value corner - The indicator is displayed in the top right corner
                        @value center - The indicator is displayed in the center of the chart
                        @value hidden - The indicator is not displayed
                        */
                        location: "center"
                    };
                }
                return SettingsAdvancedStyle;
            }());
            Base.SettingsAdvancedStyle = SettingsAdvancedStyle;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var Rect = (function () {
                function Rect(x0, y0, x1, y1) {
                    if (x0 !== Infinity && x0 > x1) {
                        this.x1 = x0;
                        this.x0 = x1;
                    }
                    else {
                        this.x1 = x1;
                        this.x0 = x0;
                    }
                    if (y0 !== Infinity && y0 > y1) {
                        this.y1 = y0;
                        this.y0 = y1;
                    }
                    else {
                        this.y1 = y1;
                        this.y0 = y0;
                    }
                }
                Rect.createEmpty = function () {
                    return new Rect(Infinity, Infinity, -Infinity, -Infinity);
                };
                Rect.prototype.isEmpty = function () {
                    return this.x0 >= this.x1 || this.y0 >= this.y1;
                };
                Rect.prototype.clone = function () {
                    return new Rect(this.x0, this.y0, this.x1, this.y1);
                };
                Rect.prototype.w = function () {
                    return this.x1 - this.x0;
                };
                Rect.prototype.h = function () {
                    return this.y1 - this.y0;
                };
                Rect.prototype.equals = function (b) {
                    return this.x0 === b.x0 && this.x1 === b.x1 && this.y0 === b.y0 && this.y1 === b.y1;
                };
                Rect.prototype.inflate = function (scale) {
                    var cx = (this.x0 + this.x1) / 2;
                    var cy = (this.y0 + this.y1) / 2;
                    this.x0 = (this.x0 - cx) * scale + cx;
                    this.x1 = (this.x1 - cx) * scale + cx;
                    this.y0 = (this.y0 - cy) * scale + cy;
                    this.y1 = (this.y1 - cy) * scale + cy;
                    return this;
                };
                Rect.prototype.clip = function (rect) {
                    this.x0 = Math.max(this.x0, rect.x0);
                    this.x1 = Math.min(this.x1, rect.x1);
                    this.y0 = Math.max(this.y0, rect.y0);
                    this.y1 = Math.min(this.y1, rect.y1);
                    return this;
                };
                Rect.prototype.isInside = function (rect) {
                    return this.x0 >= rect.x0 && this.x1 <= rect.x1 && this.y0 >= rect.y0 && this.y1 <= rect.y1;
                };
                Rect.prototype.isOutside = function (rect) {
                    return this.x0 > rect.x1 || this.x1 < rect.x0 || this.y0 > rect.y1 || this.y1 < rect.y0;
                };
                Rect.prototype.overlapsRect = function (x0, y0, x1, y1) {
                    return (x0 < this.x1 && x1 > this.x0 && y0 < this.y1 && y1 > this.y0);
                };
                Rect.prototype.intersectsSegment = function (x0, y0, x1, y1) {
                    return Base.Geometry.clipSegmentToRect(x0, y0, x1 - x0, y1 - y0, this.x0, this.y0, this.x1, this.y1) != null;
                };
                Rect.prototype.area = function () {
                    return (this.x1 - this.x0) * (this.y1 - this.y0);
                };
                Rect.prototype.toString = function () {
                    return (this.x0 + "," + this.y0 + ", " + this.x1 + ", " + this.y1);
                };
                Rect.prototype.addPoint = function (x, y) {
                    this.x0 = Math.min(this.x0, x);
                    this.x1 = Math.max(this.x1, x);
                    this.y0 = Math.min(this.y0, y);
                    this.y1 = Math.max(this.y1, y);
                    return this;
                };
                Rect.prototype.addBounds = function (x0, y0, x1, y1) {
                    this.x0 = Math.min(this.x0, x0);
                    this.x1 = Math.max(this.x1, x1);
                    this.y0 = Math.min(this.y0, y0);
                    this.y1 = Math.max(this.y1, y1);
                    return this;
                };
                Rect.prototype.addRect = function (rect) {
                    this.x0 = Math.min(this.x0, rect.x0);
                    this.x1 = Math.max(this.x1, rect.x1);
                    this.y0 = Math.min(this.y0, rect.y0);
                    this.y1 = Math.max(this.y1, rect.y1);
                    return this;
                };
                Rect.prototype.moveBy = function (x, y) {
                    this.x0 += x;
                    this.x1 += x;
                    this.y0 += y;
                    this.y1 += y;
                    return this;
                };
                Rect.prototype.containsPoint = function (x, y) {
                    return x >= this.x0 && x < this.x1 && y >= this.y0 && y < this.y1;
                };
                Rect.prototype.addLine = function (lineArray) {
                    for (var i = 0; i <= lineArray.length - 2; i += 2) {
                        this.addPoint(lineArray[i], lineArray[i + 1]);
                    }
                    return this;
                };
                Rect.prototype.translate = function (txm, txa, tym, tya) {
                    this.x0 = this.x0 * txm + txa;
                    this.x1 = this.x1 * txm + txa;
                    this.y0 = this.y0 * tym + tya;
                    this.y1 = this.y1 * tym + tya;
                    return this;
                };
                Rect.prototype.overlaps = function (bounds) {
                    return this.x0 < bounds.x1 && this.x1 > bounds.x0 && this.y0 < bounds.y1 && this.y1 > bounds.y0;
                };
                return Rect;
            }());
            Base.Rect = Rect;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Rect.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var AreaSlice = (function () {
                function AreaSlice(y0, y1, x) {
                    if (x === void 0) { x = []; }
                    this.x = x;
                    this.y1 = y1;
                    this.y0 = y0;
                    // X is sorted array of x0,x1 pairs
                }
                AreaSlice.prototype.isEmpty = function () {
                    return this.x.length === 0;
                };
                AreaSlice.prototype.makeCopy = function () {
                    return new AreaSlice(this.y0, this.y1, this.x.slice(0));
                };
                AreaSlice.prototype.split = function (newY) {
                    var s = new AreaSlice(newY, this.y1);
                    this.y1 = newY;
                    s.x = this.x.slice(0);
                    return s;
                };
                AreaSlice.prototype.add = function (x0, x1) {
                    var newX = [];
                    var l = this.x.length;
                    var i = 0;
                    // skip all before x0
                    while (i < l && this.x[i + 1] < x0) {
                        newX.push(this.x[i], this.x[i + 1]);
                        i += 2;
                    }
                    if (i < l) {
                        x0 = Math.min(this.x[i], x0);
                    }
                    // discard all between x0 and x1
                    while (i < l && this.x[i] <= x1) {
                        x1 = Math.max(x1, this.x[i + 1]);
                        i += 2;
                    }
                    newX.push(x0, x1);
                    // add remaining after x1
                    while (i < l) {
                        newX.push(this.x[i], this.x[i + 1]);
                        i += 2;
                    }
                    this.x = newX;
                    return this;
                };
                AreaSlice.prototype.subtract = function (x0, x1) {
                    var newX = [];
                    var l = this.x.length;
                    var i = 0;
                    // skip all before x0
                    while (i < l && this.x[i + 1] <= x0) {
                        newX.push(this.x[i], this.x[i + 1]);
                        i += 2;
                    }
                    // cut before
                    if (i < l && this.x[i] < x0) {
                        newX.push(this.x[i], x0);
                    }
                    // discard all between x0 and x1
                    while (i < l && this.x[i + 1] <= x1) {
                        i += 2;
                    }
                    // cut after
                    if (i < l && this.x[i] < x1) {
                        newX.push(x1, this.x[i + 1]);
                        i += 2;
                    }
                    // add remaining after x1
                    while (i < l) {
                        newX.push(this.x[i], this.x[i + 1]);
                        i += 2;
                    }
                    this.x = newX;
                    return this;
                };
                AreaSlice.prototype.subtractSlice = function (slice) {
                    if (this.isEmpty() || slice.isEmpty()) {
                        return this;
                    }
                    var newX = [];
                    var xes0 = this.x;
                    var xes1 = slice.x;
                    var l0 = xes0.length;
                    var l1 = xes1.length;
                    var i0 = 0;
                    var i1 = 0;
                    var bx0 = xes0[i0];
                    var bx1 = xes0[i0 + 1];
                    while (i1 < l1) {
                        var sx0 = xes1[i1];
                        var sx1 = xes1[i1 + 1];
                        if (bx0 >= sx1) {
                            i1 += 2;
                        }
                        else if (sx0 >= bx1) {
                            newX.push(bx0, bx1);
                            i0 += 2;
                            if (i0 === l0) {
                                break;
                            }
                            bx0 = xes0[i0];
                            bx1 = xes0[i0 + 1];
                        }
                        else {
                            // overlaps
                            if (sx0 > bx0) {
                                // remainder before
                                newX.push(bx0, sx0);
                            }
                            if (sx1 < bx1) {
                                // remainder after
                                bx0 = sx1;
                                i1 += 2;
                            }
                            else {
                                i0 += 2;
                                if (i0 === l0) {
                                    break;
                                }
                                bx0 = xes0[i0];
                                bx1 = xes0[i0 + 1];
                            }
                        }
                    }
                    // add remaining
                    while (i0 < l0) {
                        newX.push(bx0, bx1);
                        i0 += 2;
                        if (i0 === l0) {
                            break;
                        }
                        bx0 = xes0[i0];
                        bx1 = xes0[i0 + 1];
                    }
                    this.x = newX;
                    return this;
                };
                AreaSlice.prototype.intersectsSlice = function (slice) {
                    if (this.isEmpty() || slice.isEmpty()) {
                        return false;
                    }
                    var xes0 = this.x;
                    var xes1 = slice.x;
                    var l0 = xes0.length;
                    var l1 = xes1.length;
                    var i0 = 0;
                    var i1 = 0;
                    while (i1 < l1 && i0 < l0) {
                        var bx0 = xes0[i0];
                        var bx1 = xes0[i0 + 1];
                        var sx0 = xes1[i1];
                        var sx1 = xes1[i1 + 1];
                        if (bx0 >= sx1) {
                            i1 += 2;
                        }
                        else if (sx0 >= bx1) {
                            i0 += 2;
                        }
                        else {
                            // overlaps
                            return true;
                        }
                    }
                    return false;
                };
                AreaSlice.prototype.coversSlice = function (slice) {
                    if (slice.isEmpty()) {
                        return true;
                    }
                    var xes0 = this.x;
                    var xes1 = slice.x;
                    var l0 = xes0.length;
                    var l1 = xes1.length;
                    var i0 = 0;
                    var i1 = 0;
                    while (i1 < l1 && i0 < l0) {
                        var bx0 = xes0[i0];
                        var bx1 = xes0[i0 + 1];
                        var sx0 = xes1[i1];
                        var sx1 = xes1[i1 + 1];
                        if (sx0 >= bx1) {
                            // source segment before target segment
                            i0 += 2;
                        }
                        else if (sx0 >= bx0 && sx1 <= bx1) {
                            // target segment covered, move to next
                            i1 += 2;
                        }
                        else {
                            // target segment not covered
                            return false;
                        }
                    }
                    return i1 === l1;
                };
                AreaSlice.prototype.clip = function (x0, x1) {
                    var newX = [];
                    for (var i = 0; i <= this.x.length - 2; i += 2) {
                        var xa = this.x[i];
                        var xb = this.x[i + 1];
                        if (xb > x0 && xa < x1) {
                            newX.push(Math.max(xa, x0));
                            newX.push(Math.min(xb, x1));
                        }
                    }
                    this.x = newX;
                    return this;
                };
                AreaSlice.prototype.tryMerge = function (slice) {
                    if (!(this.x.length === slice.x.length && this.y1 === slice.y0)) {
                        return false;
                    }
                    for (var i = 0; i <= this.x.length - 1; i++) {
                        if (this.x[i] !== slice.x[i]) {
                            return false;
                        }
                    }
                    this.y1 = slice.y1;
                    return true;
                };
                AreaSlice.prototype.intersects = function (x0, x1) {
                    for (var i = 0; i <= this.x.length - 2; i += 2) {
                        var xa = this.x[i];
                        var xb = this.x[i + 1];
                        if (xa < x1 && xb > x0) {
                            return true;
                        }
                    }
                    return false;
                };
                AreaSlice.prototype.covers = function (x0, x1) {
                    for (var i = 0; i <= this.x.length - 2; i += 2) {
                        var xa = this.x[i];
                        var xb = this.x[i + 1];
                        if (xa <= x0 && xb >= x1) {
                            return true;
                        }
                    }
                    return false;
                };
                AreaSlice.prototype.findOverlappingRect = function (x0, x1, sx) {
                    var overlaps = false;
                    for (var i = 0; i <= this.x.length - 2; i += 2) {
                        var xa = this.x[i];
                        var xb = this.x[i + 1];
                        if (xa < x1 && x1 - sx < xb) {
                            x0 = Math.min(x0, Math.max(xa, x1 - sx));
                            overlaps = true;
                        }
                        if (xb > x0 && x0 + sx > xa) {
                            x1 = Math.max(x1, Math.min(xb, x0 + sx));
                            overlaps = true;
                        }
                    }
                    return {
                        x0: x0,
                        x1: x1,
                        overlaps: overlaps
                    };
                };
                AreaSlice.prototype.toRects = function (rects) {
                    for (var i = 0; i <= this.x.length - 2; i += 2) {
                        var xa = this.x[i];
                        var xb = this.x[i + 1];
                        rects.push(new Base.Rect(xa, this.y0, xb, this.y1));
                    }
                };
                return AreaSlice;
            }());
            Base.AreaSlice = AreaSlice;
            var AreaCollection = (function () {
                function AreaCollection() {
                    // each line contains top, bottom, and positions
                    this.slices = [new AreaSlice(-1e30, 1e30)];
                    // TODO: simple sorted array for now, might use AVL tree here
                }
                AreaCollection.prototype.makeCopy = function () {
                    var r = new AreaCollection();
                    r.slices = [];
                    for (var sIndex = 0; sIndex < this.slices.length; sIndex++) {
                        var s = this.slices[sIndex];
                        r.slices.push(s.makeCopy());
                    }
                    return r;
                };
                AreaCollection.prototype.getBounds = function () {
                    var x0 = Infinity;
                    var x1 = -Infinity;
                    var y0 = Infinity;
                    var y1 = -Infinity;
                    if (this.slices.length > 1) {
                        y0 = this.slices[1].y0;
                        y1 = this.slices[this.slices.length - 1].y1;
                        for (var sliceIndex = 0; sliceIndex < this.slices.length; sliceIndex++) {
                            var slice = this.slices[sliceIndex];
                            if (slice.x.length > 0) {
                                x0 = Math.min(x0, slice.x[0]);
                                x1 = Math.max(x1, slice.x[slice.x.length - 1]);
                            }
                        }
                    }
                    return new Base.Rect(x0, y0, x1, y1);
                };
                AreaCollection.prototype.addRect = function (rect) {
                    if (rect.isEmpty()) {
                        return this;
                    }
                    var x0 = rect.x0;
                    var x1 = rect.x1;
                    var y0 = rect.y0;
                    var y1 = rect.y1;
                    // perform merge
                    var newSlices = [];
                    var prevSlice = null;
                    for (var i = 0; i < this.slices.length; i++) {
                        var slice = this.slices[i];
                        if (slice.y0 >= y1 || slice.y1 <= y0) {
                            // no intersection, skip
                            if (!prevSlice || !prevSlice.tryMerge(slice)) {
                                newSlices.push(slice);
                                prevSlice = slice;
                            }
                        }
                        else {
                            // handle rect top
                            if (y0 > slice.y0) {
                                // slice is above rect
                                var slice1 = slice.split(y0);
                                if (!prevSlice || !prevSlice.tryMerge(slice)) {
                                    newSlices.push(slice);
                                    prevSlice = slice;
                                }
                                slice = slice1;
                            }
                            // handle rect bottom
                            if (y1 < slice.y1) {
                                // last rect is below slice
                                var slice1 = slice.split(y1);
                                slice.add(x0, x1);
                                if (!prevSlice || !prevSlice.tryMerge(slice)) {
                                    newSlices.push(slice);
                                    prevSlice = slice;
                                }
                                slice = slice1;
                            }
                            else {
                                slice.add(x0, x1);
                            }
                            if (!prevSlice || !prevSlice.tryMerge(slice)) {
                                newSlices.push(slice);
                                prevSlice = slice;
                            }
                        }
                    }
                    this.slices = newSlices;
                    return this;
                };
                AreaCollection.prototype.subtractRect = function (rect) {
                    if (rect.isEmpty()) {
                        return this;
                    }
                    var x0 = rect.x0;
                    var x1 = rect.x1;
                    var y0 = rect.y0;
                    var y1 = rect.y1;
                    // perform merge
                    var newSlices = [];
                    var prevSlice = null;
                    for (var i = 0; i < this.slices.length; i++) {
                        var slice = this.slices[i];
                        if (slice.y0 >= y1 || slice.y1 <= y0) {
                            // no intersection, skip
                            if (!prevSlice || !prevSlice.tryMerge(slice)) {
                                newSlices.push(slice);
                                prevSlice = slice;
                            }
                        }
                        else {
                            // handle rect top
                            if (y0 > slice.y0) {
                                // slice is above rect
                                var slice1 = slice.split(y0);
                                if (!prevSlice || !prevSlice.tryMerge(slice)) {
                                    newSlices.push(slice);
                                    prevSlice = slice;
                                }
                                slice = slice1;
                            }
                            // handle rect bottom
                            if (y1 < slice.y1) {
                                // last rect is below slice
                                var slice1 = slice.split(y1);
                                slice.subtract(x0, x1);
                                if (!prevSlice || !prevSlice.tryMerge(slice)) {
                                    newSlices.push(slice);
                                    prevSlice = slice;
                                }
                                slice = slice1;
                            }
                            else {
                                slice.subtract(x0, x1);
                            }
                            if (!prevSlice || !prevSlice.tryMerge(slice)) {
                                newSlices.push(slice);
                                prevSlice = slice;
                            }
                        }
                    }
                    this.slices = newSlices;
                    return this;
                };
                AreaCollection.prototype.clip = function (rect) {
                    return 1;
                    // TODO:
                };
                AreaCollection.prototype.subtractArea = function (area) {
                    if (area.isEmpty()) {
                        return this;
                    }
                    var newSlices = [];
                    var prevSlice = null;
                    var slices0 = this.slices;
                    var slices1 = area.slices;
                    var l0 = slices0.length;
                    var l1 = slices1.length;
                    var i0 = 0;
                    var i1 = 0;
                    var s0 = slices0[i0];
                    while (i1 < l1) {
                        var s1 = slices1[i1];
                        if (s0.y1 <= s1.y0) {
                            // s0 is before, just copy
                            if (!prevSlice || !prevSlice.tryMerge(s0)) {
                                newSlices.push(s0);
                                prevSlice = s0;
                            }
                            i0 += 1;
                            if (i0 === l0) {
                                break;
                            }
                            s0 = slices0[i0];
                        }
                        else if (s1.y1 <= s0.y0 || s1.isEmpty()) {
                            // s1 is before or empty, ignore it
                            i1 += 1;
                        }
                        else {
                            // overlap exists
                            if (s0.y0 < s1.y0) {
                                // s0  is above s1
                                var slice1 = s0.split(s1.y0);
                                if (!prevSlice || !prevSlice.tryMerge(s0)) {
                                    newSlices.push(s0);
                                    prevSlice = s0;
                                }
                                s0 = slice1;
                            }
                            if (s0.y1 > s1.y1) {
                                // s1 ends first
                                var slice1 = s0.split(s1.y1);
                                s0.subtractSlice(s1);
                                if (!prevSlice || !prevSlice.tryMerge(s0)) {
                                    newSlices.push(s0);
                                    prevSlice = s0;
                                }
                                s0 = slice1;
                                i1 += 1;
                            }
                            else {
                                // s0 ends first
                                s0.subtractSlice(s1);
                                if (!prevSlice || !prevSlice.tryMerge(s0)) {
                                    newSlices.push(s0);
                                    prevSlice = s0;
                                }
                                i0 += 1;
                                if (i0 === l0) {
                                    break;
                                }
                                s0 = slices0[i0];
                            }
                        }
                    }
                    // add slices after
                    while (i0 < l0) {
                        if (!prevSlice || !prevSlice.tryMerge(s0)) {
                            newSlices.push(s0);
                            prevSlice = s0;
                        }
                        i0 += 1;
                        if (i0 === l0) {
                            break;
                        }
                        s0 = slices0[i0];
                    }
                    this.slices = newSlices;
                    return this;
                };
                AreaCollection.prototype.intersectsArea = function (area) {
                    if (area.isEmpty() || this.isEmpty()) {
                        return false;
                    }
                    var slices0 = this.slices;
                    var slices1 = area.slices;
                    var l0 = slices0.length;
                    var l1 = slices1.length;
                    var i0 = 0;
                    var i1 = 0;
                    while (i1 < l1 && i0 < l0) {
                        var s1 = slices1[i1];
                        var s0 = slices0[i0];
                        if (s0.intersectsSlice(s1)) {
                            return true;
                        }
                        else if (s0.y1 < s1.y1) {
                            i0 += 1;
                        }
                        else if (s1.y1 < s0.y1) {
                            i1 += 1;
                        }
                        else {
                            i0 += 1;
                            i1 += 1;
                        }
                    }
                    return false;
                };
                AreaCollection.prototype.coversArea = function (area) {
                    if (area.isEmpty()) {
                        return true;
                    }
                    var slices0 = this.slices;
                    var slices1 = area.slices;
                    var l0 = slices0.length;
                    var l1 = slices1.length;
                    var i0 = 0;
                    var i1 = 0;
                    while (i1 < l1 && i0 < l0) {
                        var s1 = slices1[i1];
                        var s0 = slices0[i0];
                        if (!s0.coversSlice(s1)) {
                            return false;
                        }
                        if (s0.y1 < s1.y1) {
                            i0 += 1;
                        }
                        else if (s1.y1 < s0.y1) {
                            i1 += 1;
                        }
                        else {
                            i0 += 1;
                            i1 += 1;
                        }
                    }
                    return true;
                };
                AreaCollection.prototype.findOverlappingRect = function (sx, sy) {
                    if (this.isEmpty()) {
                        return null;
                    }
                    var x0 = this.slices[1].x[0];
                    var x1 = Math.min(this.slices[1].x[1], x0 + sx);
                    var y0 = this.slices[1].y0;
                    var y1 = Math.min(this.slices[1].y1, y0 + sy);
                    for (var sliceIndex = 0; sliceIndex < this.slices.length; sliceIndex++) {
                        var slice = this.slices[sliceIndex];
                        if (slice.y0 >= y0 + sy) {
                            break;
                        }
                        var findOverlappingRectResult = slice.findOverlappingRect(x0, x1, sx);
                        x0 = findOverlappingRectResult.x0;
                        x1 = findOverlappingRectResult.x1;
                        var overlaps = findOverlappingRectResult.overlaps;
                        if (overlaps) {
                            y1 = Math.min(slice.y1, y0 + sy);
                        }
                    }
                    return new Base.Rect(x0, y0, x1, y1);
                };
                /** Returns the top edge of the area for the given X coordinate range. */
                AreaCollection.prototype.findTopPosition = function (x0, x1) {
                    var top = Infinity;
                    for (var sliceIndex = 0; sliceIndex < this.slices.length; sliceIndex++) {
                        var slice = this.slices[sliceIndex];
                        if (slice.covers(x0, x1)) {
                            top = Math.min(top, slice.y0);
                        }
                    }
                    return top === Infinity ? 0 : top;
                };
                AreaCollection.prototype.intersects = function (rect) {
                    var x0 = rect.x0;
                    var x1 = rect.x1;
                    var y0 = rect.y0;
                    var y1 = rect.y1;
                    for (var sliceIndex = 0; sliceIndex < this.slices.length; sliceIndex++) {
                        var slice = this.slices[sliceIndex];
                        if (slice.y0 < y1 && slice.y1 > y0 && slice.intersects(x0, x1)) {
                            return true;
                        }
                    }
                    return false;
                };
                AreaCollection.prototype.isEmpty = function () {
                    return this.slices.length === 1 && this.slices[0].isEmpty();
                };
                AreaCollection.prototype.coversRect = function (rect) {
                    var x0 = rect.x0;
                    var x1 = rect.x1;
                    var y0 = rect.y0;
                    var y1 = rect.y1;
                    for (var sliceIndex = 0; sliceIndex < this.slices.length; sliceIndex++) {
                        var slice = this.slices[sliceIndex];
                        if (y0 < slice.y1 && y1 > slice.y0) {
                            if (!slice.covers(x0, x1)) {
                                return false;
                            }
                        }
                    }
                    return true;
                };
                AreaCollection.prototype.toRects = function () {
                    // exports to coordinate arrays for painting
                    var rects = [];
                    for (var sliceIndex = 0; sliceIndex < this.slices.length; sliceIndex++) {
                        var slice = this.slices[sliceIndex];
                        slice.toRects(rects);
                    }
                    return rects;
                };
                return AreaCollection;
            }());
            Base.AreaCollection = AreaCollection;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../Helpers.ts" />
/// <reference path="MouseEvents.ts" />
/// <reference path="SceneChanges.ts" />
/// <reference path="ChartEvents.ts" />
/// <reference path="Profiler.ts" />
/// <reference path="../DomLayer.ts" />
/// <reference path="../Settings.ts" />
/// <reference path="../AreaCollection.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var webkitVersionMatch = navigator.userAgent.match(/AppleWebKit\/(\d+)/);
            /** The Webkit version of the current browser or 1e6 for non-webkit browsers. Contains only the major version (e.g. 534) without the minor.*/
            var webkitVersion = webkitVersionMatch ? parseInt(webkitVersionMatch[1], 10) : 1e6;
            var ChartOuterShell = (function () {
                function ChartOuterShell(chart, domLayer) {
                    var _this = this;
                    this.chart = null;
                    this.settings = null;
                    this.scene = null;
                    this.events = null;
                    this.profiler = null;
                    this.container = null;
                    this.canvas = null;
                    this.scaleX = 1;
                    this.scaleY = 1;
                    this.paintRequested = null;
                    this.labelRenderer = null;
                    this.prevTime = null;
                    this.paintNowInProgreess = false;
                    this.animationInProgress = false;
                    this.mouseEvents = null;
                    this.innerAreaCache = null;
                    // chart size on previous updateSize call, to minimize updates
                    this.chartWidth = 0;
                    this.chartHeight = 0;
                    this.sizeChanged = true;
                    this.fullScreenMode = false;
                    this.fullscreenBeforeW = 0;
                    this.fullscreenBeforeH = 0;
                    this.lastCursor = null;
                    this.chart = chart;
                    this.settings = chart.settings;
                    this.scene = chart.scene;
                    this.domLayer = domLayer;
                    this.buildDom();
                    this.labelRenderer = new Base.LabelRenderer(this.settings, this.chart.assetsLoader, this.container);
                    this.mouseEvents = new Base.MouseEvents(this.domLayer.interactionContainer, this.settings.advanced.pointer, [this.domLayer.menuContainer]);
                    this.profiler = new Base.Profiler(this);
                    for (var eventIndex = 0; eventIndex < ChartOuterShell.MouseEventConfig.length; eventIndex++) {
                        var event = ChartOuterShell.MouseEventConfig[eventIndex];
                        // create closure to bind event variable
                        (function (config) {
                            _this.mouseEvents.listen(config.ev, function (ev) { return _this.notifyMouseEvent(ev, config); });
                        })(event);
                    }
                    // TODO: fix keyboard events
                    // this.mouseEvents.listen(MouseEvents.EVENT_KEY, (event) => this.notifyKeyEvent(event));
                    this.events = new Base.ChartEvents(chart, this);
                    this.events.addElement(this.domLayer);
                    this.containerResizeFunc = function () { return _this.updateSize(false); };
                    Base.Helpers.listenResize(this.container, this.containerResizeFunc);
                    Base.Helpers.listen(window, "resize", this.containerResizeFunc);
                }
                ChartOuterShell.prototype.forceChromeRedraw = function () {
                    // A dirty workaround for a Chrome drawing issue, see https://forum.zoomcharts.com/t/closing-the-export-menu/311
                    // the workaround from http://stackoverflow.com/a/27971913/1711598
                    var mcs = this.menuContainer.style;
                    var oldStyle = mcs.transform;
                    mcs.transform = "translateZ(0)";
                    window.setTimeout(function () { mcs.transform = oldStyle; }, 1);
                };
                ChartOuterShell.prototype.updateSize = function (force) {
                    var areaSettings = this.settings.area;
                    // compute desired with and height
                    var clientWidth;
                    var clientHeight;
                    if (this.fullScreenMode) {
                        clientWidth = window.innerWidth;
                        clientHeight = window.innerHeight;
                    }
                    else if (this.fullscreenBeforeW > 0) {
                        // restore after fullscreen exit
                        clientWidth = this.fullscreenBeforeW;
                        clientHeight = this.fullscreenBeforeH;
                        this.fullscreenBeforeW = 0;
                        this.fullscreenBeforeH = 0;
                    }
                    else {
                        clientWidth = areaSettings.width || Math.min(areaSettings.maxWidth, this.container.clientWidth);
                        clientHeight = areaSettings.height || Math.min(areaSettings.maxHeight, this.container.clientHeight);
                        if (clientWidth > 0 && clientHeight < 2) {
                            // default size
                            clientHeight = this.settings.area.height || this.settings.area.defaultHeight;
                        }
                        clientWidth = Math.max(areaSettings.minWidth, clientWidth);
                        clientHeight = Math.max(areaSettings.minHeight, clientHeight);
                    }
                    if (force || (clientWidth >= 2 && clientWidth !== this.chartWidth) || (clientHeight >= 2 && clientHeight !== this.chartHeight)) {
                        this.setSize(clientWidth, clientHeight, force);
                    }
                    Base.Helpers.updateResize(this.container);
                };
                ChartOuterShell.prototype.setSize = function (width, height, force) {
                    this.chart.log("Update size: " + height + ", " + width);
                    var s = this.domLayer.container.style;
                    s.height = height + "px";
                    s.width = width + "px";
                    this.chartHeight = height;
                    this.chartWidth = width;
                    this.sizeChanged = true;
                    this.events.setNewSize(new Base.Rect(0, 0, width, height), true, force);
                };
                ChartOuterShell.prototype.setFullscreen = function (enabled) {
                    if (enabled === this.fullScreenMode) {
                        return;
                    }
                    this.fullScreenMode = enabled;
                    if (enabled) {
                        this.fullscreenBeforeW = this.scene.chartWidth;
                        this.fullscreenBeforeH = this.scene.chartHeight;
                        Base.Helpers.addClass(this.domLayer.container, "DVSL-fullscreen");
                    }
                    else {
                        // disabled
                        Base.Helpers.removeClass(this.domLayer.container, "DVSL-fullscreen");
                    }
                    this.updateSize(true);
                };
                ChartOuterShell.prototype.buildDom = function () {
                    if (!this.settings.container) {
                        throw new Error("Chart container is not defined in the settings.");
                    }
                    if (!Base.Helpers.isDomObject(this.settings.container)) {
                        throw new Error("Chart container is not a DOM object.");
                    }
                    this.container = this.settings.container;
                    // Remove previous chart instance.
                    if (this.container._DVSL_ChartInstance != null) {
                        this.container._DVSL_ChartInstance.remove();
                    }
                    this.container.innerHTML = "<!--ZoomCharts " + ZoomCharts.PackageInfo.Version + "-->";
                    this.container._DVSL_ChartInstance = this.chart;
                    this.domLayer.createDom(this);
                    this.container.appendChild(this.domLayer.container);
                    this.backgroundContainer = this.domLayer.backgroundContainer;
                    this.interactiveContainer = this.domLayer.interactionContainer;
                    this.menuContainer = this.domLayer.menuContainer;
                    this.canvas = this.domLayer.canvas;
                };
                ChartOuterShell.prototype.remove = function () {
                    this.mouseEvents.remove();
                    this.domLayer.remove();
                    Base.Helpers.unlistenResize(this.container);
                    delete this.container._DVSL_ChartInstance;
                    Base.Helpers.unlisten(window, "resize", this.containerResizeFunc);
                    this.container.innerHTML = "";
                };
                ChartOuterShell.prototype.updateSettings = function (changes) {
                    if (changes.area) {
                        this.updateSize(true);
                    }
                    this.domLayer.updateSettings(changes);
                };
                ChartOuterShell.prototype.notifyMouseEvent = function (event, config) {
                    if (this.chart.removed)
                        return;
                    event.consumed = false;
                    this.events.onMouseEvent(event, config);
                    if (!event.cursor) {
                        event.cursor = "default";
                    }
                    if (this.lastCursor !== event.cursor) {
                        this.interactiveContainer.style.cursor = event.cursor;
                        this.menuContainer.style.cursor = event.cursor;
                        this.lastCursor = event.cursor;
                    }
                };
                /*
                public notifyKeyEvent(event: Base.KeyEvent) {
                    if (this.chart.removed) return;
                    this.events.onKeyEvent(event);
                }
                */
                ChartOuterShell.prototype.requestPaint = function () {
                    var _this = this;
                    if (this.paintRequested === null) {
                        if (this.settings.advanced.useAnimationFrame) {
                            this.paintRequested = Base.Helpers.requestAnimationFrame(function (timeStamp, override) { return _this.paintScene(override ? timeStamp : null); });
                        }
                        else {
                            this.paintRequested = window.setTimeout((function () { return _this.paintScene(null); }), 5);
                        }
                    }
                };
                ChartOuterShell.prototype.paintNow = function (force) {
                    if (force === void 0) { force = false; }
                    if (this.paintNowInProgreess) {
                        this.chart.error("paintNow called from within paintNow call");
                        return;
                    }
                    this.paintNowInProgreess = true;
                    // paints immediately, cancels animation frame if in progress
                    if (this.paintRequested !== null || force) {
                        if (this.settings.advanced.useAnimationFrame) {
                            Base.Helpers.cancelAnimationFrame(this.paintRequested);
                        }
                        else {
                            window.clearTimeout(this.paintRequested);
                        }
                        this.paintScene(null);
                    }
                    this.paintNowInProgreess = false;
                };
                ChartOuterShell.prototype.paintScene = function (overrideTimestamp) {
                    if (this.chart.removed) {
                        return;
                    }
                    this.paintRequested = null;
                    var timeStamp = overrideTimestamp !== null ? overrideTimestamp : Base.Helpers.performanceNow();
                    var event = new Base.UpdateEvent();
                    event.timeStamp = timeStamp;
                    event.isExport = false;
                    if (!this.prevTime || !this.animationInProgress) {
                        event.dtime = 30;
                    }
                    else {
                        event.dtime = event.timeStamp - this.prevTime;
                        if (event.dtime > 1000) {
                            event.dtime = 1000;
                        }
                        if (event.dtime < 1) {
                            event.dtime = 1;
                        }
                    }
                    this.prevTime = timeStamp;
                    // No paint if no chart size
                    if (!(this.chartWidth > 0 && this.chartHeight > 0))
                        return;
                    if (this.sizeChanged) {
                        this.resizeCanvas();
                        this.sizeChanged = false;
                    }
                    this.innerAreaCache = null;
                    this.events.animateFrame(event);
                    // request next frame again, if somebody asked for animation during paint
                    if (event.animating) {
                        this.animationInProgress = true;
                        // use this.events because it checks if the painting has not been suspended.
                        this.events.requestPaint();
                    }
                    else {
                        this.animationInProgress = false;
                    }
                    this.profiler.paintDone();
                };
                ChartOuterShell.prototype.resizeCanvas = function () {
                    var config = this.chart.settings.advanced;
                    var scaleX = 1;
                    var scaleY = 1;
                    if (config.highDPI === true) {
                        var scaling = Base.Helpers.canvasScaling();
                        scaleX = scaling.x;
                        scaleY = scaling.y;
                    }
                    else if (config.highDPI > 0) {
                        scaleX = scaleY = config.highDPI;
                    }
                    var cssWidth = this.chartWidth;
                    var cssHeight = this.chartHeight;
                    var widthPx;
                    var heightPx;
                    var maxW = Math.max(100, config.maxCanvasWidth);
                    var maxH = Math.max(100, config.maxCanvasHeight);
                    var scaleXFactor = 0;
                    var scaleYFactor = 0;
                    // perform upscale by integer factor only. this goes together with `image-rendering: pixelated` to render crisper images when upscaling.
                    do {
                        scaleXFactor++;
                        widthPx = Math.ceil(cssWidth * scaleX / scaleXFactor);
                    } while (widthPx > maxW);
                    do {
                        scaleYFactor++;
                        heightPx = Math.ceil(cssHeight * scaleY / scaleYFactor);
                    } while (heightPx > maxH);
                    scaleX = scaleX / scaleXFactor;
                    scaleY = scaleY / scaleYFactor;
                    // effectively round up the css width/height. For example, for scale=0.5 and width=201, the css value must be 402, not 401.
                    cssWidth = widthPx / scaleX;
                    cssHeight = heightPx / scaleY;
                    // console.log(`scaleX=${scaleX}, scaleXFactor=${scaleXFactor}, this.chartWidth=${this.chartWidth}, widthPx=${widthPx}, chartWidth=${chartWidth}`);
                    // console.log(`scaleY=${scaleY}, scaleYFactor=${scaleYFactor}, this.chartHeight=${this.chartHeight}, heightPx=${heightPx}, chartHeight=${chartHeight}`);
                    this.scaleX = scaleX;
                    this.scaleY = scaleY;
                    this.canvas.width = widthPx;
                    this.canvas.height = heightPx;
                    this.canvas.style.width = cssWidth + "px";
                    this.canvas.style.height = cssHeight + "px";
                };
                ChartOuterShell.prototype.prepareContext = function (event) {
                    var scene = this.scene;
                    var canvas = this.canvas;
                    var context = canvas.getContext("2d");
                    context.setTransform(1, 0, 0, 1, 0, 0);
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    // workaround for Android 4.1, 4.2, 4.3
                    // https://code.google.com/p/android/issues/detail?id=39247
                    // http://jimbergman.net/webkit-version-in-android-version/
                    if (webkitVersion === 534) {
                        canvas.style.display = "none"; // detach from DOM
                        /* tslint:disable */
                        canvas.offsetHeight; // force the detach
                        /* tslint:enable */
                        canvas.style.display = "inherit"; // reattach to DOM
                    }
                    this.areaStylesBefore(context, this.canvas);
                    // scale up for high DPI devices
                    var scaleX = this.scaleX;
                    var scaleY = this.scaleY;
                    context.setTransform(scaleX, 0, 0, scaleY, 0, 0);
                    context.__scaleX = scaleX;
                    context.__scaleY = scaleY;
                    event.context = context;
                    event.scaleX = scaleX;
                    event.scaleY = scaleY;
                    event.labelRenderer = this.labelRenderer;
                    this.labelRenderer.startFrame(scene.chartWidth, scene.chartHeight, scaleX, scaleY);
                };
                ChartOuterShell.prototype.areaStylesBefore = function (context, canvas) {
                    var color = this.settings.area.style.fillColor;
                    if (color) {
                        context.fillStyle = color;
                        context.fillRect(0, 0, canvas.width, canvas.height);
                    }
                };
                ChartOuterShell.prototype.areaStylesAfter = function (context, canvas) {
                    var color = this.settings.area.style.overlayColor;
                    if (color) {
                        context.fillStyle = color;
                        context.setTransform(1, 0, 0, 1, 0, 0);
                        context.fillRect(0, 0, canvas.width, canvas.height);
                    }
                };
                ChartOuterShell.prototype.finalizeContext = function (event) {
                    this.areaStylesAfter(event.context, this.canvas);
                    this.labelRenderer.finishFrame();
                };
                ChartOuterShell.prototype.exportToImageGetDimensions = function () {
                    var event = new Base.UpdateEvent();
                    event.isExport = true;
                    event.context = this.canvas.getContext("2d");
                    event.labelRenderer = this.labelRenderer;
                    var exportBounds = this.events.updateLayout(event);
                    // restore previous state
                    event.isExport = false;
                    this.events.updateLayout(event);
                    return {
                        width: exportBounds.w(),
                        height: exportBounds.h()
                    };
                };
                ChartOuterShell.prototype.exportToContext = function (context, canvas, scale) {
                    // place components in export mode
                    var labelRenderer = new Base.LabelRenderer(this.settings, this.chart.assetsLoader, this.container);
                    labelRenderer.allowCache = false;
                    labelRenderer.startFrame(1, 1, scale, scale);
                    var event = new Base.UpdateEvent();
                    event.isExport = true;
                    event.timeStamp = this.prevTime;
                    event.dtime = 0;
                    event.context = context;
                    event.scaleX = scale;
                    event.scaleY = scale;
                    event.labelRenderer = labelRenderer;
                    var exportBounds = this.events.updateLayout(event);
                    this.areaStylesBefore(context, canvas);
                    context.save();
                    context.setTransform(scale, 0, 0, scale, -exportBounds.x0 * scale, -exportBounds.y0 * scale);
                    this.events.doPaint(event);
                    this.areaStylesAfter(context, canvas);
                    // reset placement back to normal
                    event.isExport = false;
                    this.events.updateLayout(event);
                    Base.Graphics.restore(context);
                };
                ChartOuterShell.prototype.getChartInnerArea = function () {
                    if (this.innerAreaCache)
                        return this.innerAreaCache;
                    var area = new Base.AreaCollection();
                    area.addRect(new Base.Rect(this.scene.x0, this.scene.y0, this.scene.x0 + this.scene.width, this.scene.y0 + this.scene.height));
                    var outerRect = this.menuContainer.getBoundingClientRect();
                    var dx = outerRect.left;
                    var dy = outerRect.top;
                    // collect all the dom elements inside the menuContainer.
                    var elements = this.menuContainer.children;
                    for (var i = 0; i < elements.length; i += 1) {
                        var e = elements[i];
                        if (e.offsetHeight > 0 || e.offsetWidth > 0) {
                            var rect = e.getBoundingClientRect();
                            area.subtractRect(new Base.Rect(rect.left - dx, rect.top - dy, rect.right - dx, rect.bottom - dy));
                        }
                    }
                    this.innerAreaCache = area;
                    return area;
                };
                ChartOuterShell.MouseEventConfig = [
                    { ev: Base.MouseEvents.EVENT_GLOBAL_DOWN, name: "GlobalPointerDown" },
                    { ev: Base.MouseEvents.EVENT_DOWN, name: "PointerDown", captures: true },
                    { ev: Base.MouseEvents.EVENT_UP, name: "PointerUp", needsCapture: true, releasesCapture: true },
                    { ev: Base.MouseEvents.EVENT_DRAG, name: "PointerDrag", needsCapture: true, captures: true },
                    { ev: Base.MouseEvents.EVENT_MOVE, name: "PointerMove", captures: true },
                    { ev: Base.MouseEvents.EVENT_LEAVE, name: "PointerOut" },
                    { ev: Base.MouseEvents.EVENT_CANCEL, name: "PointerCancel", needsCapture: true, releasesCapture: true },
                    { ev: Base.MouseEvents.EVENT_CLICK, name: "Click" },
                    { ev: Base.MouseEvents.EVENT_INSTACLICK, name: "InstantClick" },
                    { ev: Base.MouseEvents.EVENT_LONGPRESS, name: "LongPress" },
                    { ev: Base.MouseEvents.EVENT_RCLICK, name: "RightClick" },
                    { ev: Base.MouseEvents.EVENT_DBLCLICK, name: "DoubleClick" },
                    { ev: Base.MouseEvents.EVENT_TPLCLICK, name: "TripleClick" },
                    { ev: Base.MouseEvents.EVENT_WHEEL, name: "Wheel" }
                ];
                return ChartOuterShell;
            }());
            Base.ChartOuterShell = ChartOuterShell;
            var ChartInnerShell = (function () {
                function ChartInnerShell(chart, shell) {
                    this.fullScreenMode = false;
                    this.chart = chart;
                    this.settings = chart.settings;
                    this.scene = chart.scene;
                    this.parentShell = shell;
                    this.buildDom();
                    this.events = new Base.ChartEvents(chart, this);
                    this.parentShell.events.addSubchart(this.chart);
                    this.updateSize();
                }
                ChartInnerShell.prototype.getChartInnerArea = function () {
                    return this.parentShell.getChartInnerArea();
                };
                ChartInnerShell.prototype.requestPaint = function () {
                    this.parentShell.requestPaint();
                };
                ChartInnerShell.prototype.paintNow = function (force) {
                    this.parentShell.paintNow(force);
                };
                ChartInnerShell.prototype.buildDom = function () {
                    this.container = this.parentShell.container;
                    this.interactiveContainer = this.parentShell.interactiveContainer;
                    this.backgroundContainer = this.parentShell.backgroundContainer;
                    this.menuContainer = this.parentShell.menuContainer;
                };
                ChartInnerShell.prototype.remove = function () {
                    this.parentShell.events.removeSubchart(this.chart);
                };
                ChartInnerShell.prototype.updateSettings = function (changes) {
                    if (changes.area) {
                        this.updateSize();
                    }
                };
                ChartInnerShell.prototype.updateSize = function (force) {
                    if (force === void 0) { force = false; }
                    var area = this.settings.area;
                    this.events.setNewSize(new Base.Rect(area.left, area.top, area.left + area.width, area.top + area.height), false, force);
                };
                ChartInnerShell.prototype.prepareContext = function (event) {
                    var settings = this.settings.area.style;
                    if (settings.fillColor) {
                        var context = event.context;
                        var scene = this.scene;
                        context.fillStyle = settings.fillColor;
                        context.fillRect(scene.chartLeft, scene.chartTop, scene.chartWidth, scene.chartHeight);
                    }
                };
                ChartInnerShell.prototype.finalizeContext = function (event) {
                    var settings = this.settings.area.style;
                    if (settings.overlayColor) {
                        var context = event.context;
                        var scene = this.scene;
                        context.fillStyle = settings.overlayColor;
                        context.fillRect(scene.chartLeft, scene.chartTop, scene.chartWidth, scene.chartHeight);
                    }
                };
                ChartInnerShell.prototype.forceChromeRedraw = function () {
                    this.parentShell.forceChromeRedraw();
                };
                ChartInnerShell.prototype.setFullscreen = function (isFullscreen) {
                    // TODO:????
                };
                return ChartInnerShell;
            }());
            Base.ChartInnerShell = ChartInnerShell;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Colors.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var Animator = (function () {
                function Animator(fromVal, toVal, duration, easing, startTime) {
                    if (easing === void 0) { easing = "<>"; }
                    if (startTime === void 0) { startTime = null; }
                    /** time of last frame */
                    this.t = 0;
                    this.startSpeed = 0;
                    this.duration = duration;
                    this.from = fromVal;
                    this.to = toVal;
                    if (this.from == null) {
                        this.from = this.to;
                    }
                    this.startTime = startTime;
                    this.x = this.from;
                    this.t = this.startTime;
                    this.formula = Animator.easingFormulas[easing];
                    if (!this.formula)
                        throw new Error("Easing formula not defined: " + easing);
                }
                Animator.prototype.jump = function (to) {
                    this.to = to;
                    this.from = to;
                    this.x = to;
                    this.t = this.startTime = null;
                };
                Animator.prototype.reset = function (fromVal, toVal, startTime) {
                    if (startTime === void 0) { startTime = null; }
                    this.from = fromVal;
                    this.to = toVal;
                    this.startTime = startTime;
                    this.x = this.from;
                    this.t = this.startTime;
                };
                Animator.prototype.retarget = function (newTo, startTime) {
                    if (this.finished(this.t)) {
                        this.startSpeed = 0;
                    }
                    else {
                        this.startSpeed = this._getSpeed();
                        // if the animator is finished, do not rely on `this.t` since the animator might not have been updated for a long time.
                        if (!startTime)
                            startTime = this.t;
                    }
                    if (startTime) {
                        this.from = this.get(startTime);
                        this.startTime = startTime;
                    }
                    else {
                        this.startTime = null;
                        this.from = this.x;
                    }
                    this.to = newTo;
                    return this;
                };
                Animator.prototype.switchCoordinates = function (trAdd, trMul) {
                    this.from = this.from * trMul + trAdd;
                    this.x = this.x * trMul + trAdd;
                    this.to = this.to * trMul + trAdd;
                    this.startSpeed = this.startSpeed * trMul;
                };
                Animator.prototype.updateAndGet = function (targetValue, time) {
                    var changes = this.x !== targetValue;
                    if (targetValue !== this.to) {
                        this.retarget(targetValue, time);
                    }
                    return {
                        value: this.get(time),
                        changes: changes
                    };
                };
                Animator.prototype.updateAndGetFixed = function (targetValue, time) {
                    var changes = this.x !== targetValue;
                    if (targetValue !== this.to) {
                        this.startSpeed = 0;
                        this.startTime = time;
                        this.from = this.x;
                        this.to = targetValue;
                    }
                    return {
                        value: this.get(time),
                        changes: changes
                    };
                };
                /** Gets the value for the given time the same way `get` does but does not update the inner state of the animator.
                This method should be used if the given timestamp is for a moment in the past. */
                Animator.prototype.getClean = function (time) {
                    if (this.duration <= 0) {
                        return this.to;
                    }
                    if (!this.startTime) {
                        return this.from;
                    }
                    return this._calculate(time);
                };
                Animator.prototype._calculate = function (time) {
                    var percentage = Math.min(1, Math.max(time - this.startTime, 0) / this.duration);
                    if (percentage >= 1) {
                        return this.to;
                    }
                    var easingPerc = this.formula(percentage);
                    var xx = easingPerc * (this.to - this.from);
                    if (this.startSpeed && percentage < 1) {
                        var spx = this.startSpeed * percentage * this.duration;
                        xx = xx * easingPerc + spx * (1 - easingPerc);
                    }
                    xx = this.from + xx;
                    return xx;
                };
                Animator.prototype.get = function (time) {
                    if (this.duration <= 0) {
                        this.t = time;
                        this.x = this.to;
                        return this.to;
                    }
                    if (!this.startTime) {
                        this.startTime = time;
                    }
                    var xx = this._calculate(time);
                    this.t = time;
                    this.x = xx;
                    return xx;
                };
                Animator.prototype.finished = function (time) {
                    if (!this.startTime) {
                        this.startTime = time;
                    }
                    return time >= this.startTime + this.duration;
                };
                Animator.prototype._getSpeed = function () {
                    var time = this.t;
                    var d = this.duration / 1000;
                    var p0 = this.getClean(time - d / 2);
                    var p1 = this.getClean(time + d / 2);
                    this.t = time;
                    return (p1 - p0) / d;
                };
                Animator.easingFormulas = {
                    "=": function (t) { return t; },
                    "<>": function (t) {
                        if (t < 0.5) {
                            return 2 * t * t;
                        }
                        else {
                            return -0.5 * ((t * 2 - 1) * (t * 2 - 3) - 1);
                        }
                    },
                    "scroll": function (t) { return 1 - (1 - t) * (1 - t); }
                };
                return Animator;
            }());
            Base.Animator = Animator;
            /** A wrapper for the basic animator that works with colors instead of simple numbers. */
            var ColorAnimator = (function () {
                function ColorAnimator(fromVal, toVal, duration, easing, startTime) {
                    if (easing === void 0) { easing = "<>"; }
                    if (startTime === void 0) { startTime = null; }
                    this._animator = new Animator(0, 1, duration, easing, startTime);
                    this.reset(fromVal, toVal, startTime);
                }
                /** Restarts the animation from the current color to the given target color.
                Note that even if the new color is very close to the current, the original animation duration will be used. */
                ColorAnimator.prototype.reset = function (fromVal, toVal, startTime) {
                    if (Base.Helpers.isString(fromVal) || fromVal == null) {
                        this._fromColor = Base.Colors.parse(fromVal);
                    }
                    else {
                        this._fromColor = fromVal;
                    }
                    if (Base.Helpers.isString(toVal) || toVal == null) {
                        this._toColor = Base.Colors.parse(toVal);
                    }
                    else {
                        this._toColor = toVal;
                    }
                    // start the animation from zero again
                    this._animator.reset(0, 1, startTime);
                    return this;
                };
                ColorAnimator.prototype.getColor = function (time) {
                    var p = Math.min(1, this._animator.get(time));
                    return this._lastValue = Base.Colors.blend(this._fromColor, this._toColor, p);
                };
                ColorAnimator.prototype.get = function (time) {
                    return Base.Colors.format(this.getColor(time));
                };
                ColorAnimator.prototype.updateAndGet = function (targetValue, time) {
                    if (Base.Helpers.isString(targetValue) || targetValue == null)
                        targetValue = Base.Colors.parse(targetValue);
                    var changes = !Base.Colors.areEqual(this._lastValue, targetValue);
                    if (!Base.Colors.areEqual(this._toColor, targetValue)) {
                        this.reset(this._lastValue, targetValue, time);
                    }
                    return {
                        value: this.get(time),
                        changes: changes
                    };
                };
                ColorAnimator.prototype.finished = function (time) {
                    return this._animator.finished(time);
                };
                return ColorAnimator;
            }());
            Base.ColorAnimator = ColorAnimator;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="core/ChartEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var xlsxmime = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
            var Export = (function () {
                function Export() {
                }
                Export.createImage = function (shell, mime, dimensions, transparent) {
                    var size = Export.getSizes(shell, dimensions);
                    var canvas = document.createElement("canvas");
                    canvas.width = size.width;
                    canvas.height = size.height;
                    var context = canvas.getContext("2d");
                    if (!transparent) {
                        context.fillStyle = "#fff";
                        context.fillRect(0, 0, size.width, size.height);
                    }
                    shell.exportToContext(context, canvas, size.scale);
                    try {
                        return canvas.toDataURL(mime);
                    }
                    catch (exception) {
                        Base.Helpers.error(exception);
                        throw new Error("Browser security prevents exporting this chart. The canvas might be tainted. " +
                            "See `advanced.crossOriginHeader` setting in the documentation.");
                    }
                };
                Export.createPdf = function (shell, dimensions) {
                    var s = shell.exportToImageGetDimensions();
                    var p = [10, 10, 10, 10];
                    var pageSize = shell.settings.advanced.exportPdfSize;
                    var pw = 0;
                    var ph = 0;
                    var dw = 0;
                    var dh = 0;
                    var dpi = 72;
                    var scale = 1;
                    var w = 0;
                    var h = 0;
                    // fit to portrait or landscape
                    var o;
                    if (s.width >= s.height) {
                        pageSize = [pageSize[1], pageSize[0]];
                        o = "l";
                    }
                    else {
                        o = "p";
                    }
                    pw = pageSize[0] / 25.4 * dpi;
                    ph = pageSize[1] / 25.4 * dpi;
                    scale = Math.min(ph / s.height, pw / s.width);
                    if (o === "l") {
                        w = s.width * scale / pw * pageSize[0] - p[1] - p[3];
                        dw = (pageSize[0] - w - p[1] - p[3]) / 2;
                        h = s.height / s.width * w;
                        dh = (pageSize[1] - p[0] - p[2] - h) / 2;
                    }
                    else {
                        h = s.height * scale / ph * pageSize[1] - p[0] - p[2];
                        dh = (pageSize[1] - h - p[0] - p[2]) / 2;
                        w = s.width / s.height * h;
                        dw = (pageSize[0] - p[1] - p[3] - w) / 2;
                    }
                    // get image
                    var out = Export.createImage(shell, "image/jpeg", { scaling: scale * 3 }, false);
                    /* create pdf document
                    first load pdf export libs */
                    var doc = new jsPDF(o, "mm", pageSize);
                    doc.addImage(out, "JPEG", p[3] + dw, p[0] + dh, w, h);
                    return doc.output("datauristring");
                };
                Export.createCsv = function (chart) {
                    var exportVisibleData = chart.exportVisibleData;
                    if (!exportVisibleData)
                        throw new Error("This chart type does not support CSV export.");
                    var payload = chart.exportVisibleData();
                    var needsEscape = /[^a-zA-Z0-9\.]/;
                    var result = "data:text/csv;charset=utf-8,";
                    var nl = encodeURIComponent("\r\n");
                    for (var i = 0; i < payload.length; i++) {
                        var row = payload[i];
                        for (var j = 0; j < row.length; j++) {
                            if (j > 0)
                                result += Export._csvSeparator;
                            var val = row[j];
                            if (val != null) {
                                var sval = void 0;
                                if (val instanceof Date) {
                                    sval = val.toISOString();
                                }
                                else {
                                    sval = "" + val;
                                }
                                if (needsEscape.test(sval)) {
                                    result += "\"" + encodeURIComponent(sval.replace("\"", "\"\"")) + "\"";
                                }
                                else {
                                    result += sval;
                                }
                            }
                        }
                        result += nl;
                    }
                    return result;
                };
                Export.createExcel = function (chart) {
                    var exportVisibleData = chart.exportVisibleData;
                    if (!exportVisibleData)
                        throw new Error("This chart type does not support Excel export.");
                    var payload = chart.exportVisibleData();
                    function datenum(val) {
                        // Date.UTC(1899, 11, 30) -> -2209161600000
                        return (val.getTime() + 2209161600000) / (24 * 60 * 60 * 1000);
                    }
                    var sheet = Object.create(null);
                    var range = { s: { c: Infinity, r: Infinity }, e: { c: 0, r: 0 } };
                    for (var i = 0; i < payload.length; i++) {
                        if (range.s.r > i)
                            range.s.r = i;
                        if (range.e.r < i)
                            range.e.r = i;
                        var row = payload[i];
                        for (var j = 0; j < row.length; j++) {
                            if (range.s.c > j)
                                range.s.c = j;
                            if (range.e.c < j)
                                range.e.c = j;
                            var val = row[j];
                            if (val == null)
                                continue;
                            var cell = { t: "s", v: val };
                            if (typeof val === "number") {
                                cell.t = "n";
                                if (Math.round(val) === val)
                                    cell.z = "0";
                            }
                            else if (typeof val === "boolean") {
                                cell.t = "b";
                            }
                            else if (val instanceof Date) {
                                cell.t = "n";
                                cell.z = XLSX.SSF._table[14];
                                cell.v = datenum(cell.v);
                            }
                            sheet[XLSX.utils.encode_cell({ c: j, r: i })] = cell;
                        }
                    }
                    if (range.s.c < Infinity)
                        sheet["!ref"] = XLSX.utils.encode_range(range);
                    var wb = {
                        SheetNames: ["export"],
                        Sheets: { "export": sheet }
                    };
                    var output = XLSX.write(wb, { bookType: "xlsx", bookSST: true, type: "binary" });
                    return "data:" + xlsxmime + ";base64," + Base.Helpers.base64Encode(output);
                };
                Export.export = function (chart, type, dimensions, transparent, callback) {
                    if (type === void 0) { type = "png"; }
                    if (dimensions === void 0) { dimensions = {}; }
                    if (transparent === void 0) { transparent = null; }
                    var shell = chart.shell;
                    if (!(shell instanceof Base.ChartOuterShell)) {
                        throw new Error("Export functionality is only available on the top level chart, not within nested charts.");
                    }
                    var mime = Export._mimeMap[type];
                    if (type === "xls") {
                        Base.Helpers.warn("XLS format is not supported. XLSX will be used instead.");
                    }
                    else if (type == null) {
                        type = "png";
                        mime = Export._mimeMap["png"];
                    }
                    else if (mime === void 0) {
                        throw new Error("Export image type `" + type + "` is not supported. Supported types: " + Object.keys(Export._mimeMap).join(", "));
                    }
                    if (mime.transparent) {
                        if (transparent == null) {
                            transparent = true;
                        }
                    }
                    else if (transparent) {
                        Base.Helpers.warn("Only PNG images can be exported as transparent.");
                        transparent = false;
                    }
                    if (mime.csv) {
                        callback(Export.createCsv(chart), mime.mime, mime.extension);
                        return;
                    }
                    else if (mime.excel) {
                        chart.assetsLoader.ensureAssetsList([{ url: "assets://xlsx.core.min.js", required: function () { return typeof XLSX === "undefined"; } }], function () { callback(Export.createExcel(chart), mime.mime, mime.extension); });
                        return;
                    }
                    else if (mime.image) {
                        var result = Export.createImage(shell, mime.mime, Export.getDimensions(chart, dimensions), transparent);
                        callback(result, mime.mime, mime.extension);
                        // for compatibility, return the image directly as well.
                        return result;
                    }
                    else if (mime.pdf) {
                        chart.assetsLoader.ensureAssetsList([{ url: "assets://jspdf.js", required: function () { return typeof jsPDF === "undefined"; } }], function () { callback(Export.createPdf(shell, dimensions), mime.mime, mime.extension); });
                        return;
                    }
                    throw new Error("not implemented");
                };
                Export.download = function (chart, type, dimensions, transparent) {
                    var _this = this;
                    if (dimensions === void 0) { dimensions = {}; }
                    this.export(chart, type, dimensions, transparent, function (dataUri, mimeType, extension) {
                        _this.launchDownload(chart, mimeType, extension, dataUri);
                    });
                };
                Export.getSizes = function (shell, dimensions) {
                    var exportToImageGetDimensionsResult = shell.exportToImageGetDimensions();
                    var chartWidth = exportToImageGetDimensionsResult.width;
                    var chartHeight = exportToImageGetDimensionsResult.height;
                    var width = Base.Helpers.tryParseFloat(dimensions.width);
                    var height = Base.Helpers.tryParseFloat(dimensions.height);
                    var scale = 1;
                    if (dimensions.unit === "mm") {
                        var pixelsPerMM = Base.Helpers.tryParseFloat(dimensions.dpi, 300) / 25.4;
                        if (width > 0)
                            width *= pixelsPerMM;
                        if (height > 0)
                            height *= pixelsPerMM;
                    }
                    if (width > 0 && height > 0) {
                        scale = Math.min(width / chartWidth, height / chartHeight);
                    }
                    else if (width > 0) {
                        scale = width / chartWidth;
                        height = chartHeight * scale;
                    }
                    else if (height > 0) {
                        scale = height / chartHeight;
                        width = chartWidth * scale;
                    }
                    else {
                        // scale = Math.max(shell.scaleX, shell.scaleY);
                        width = chartWidth;
                        height = chartHeight;
                    }
                    var reqscale = Base.Helpers.tryParseFloat(dimensions.scaling, 1);
                    if (reqscale !== 1) {
                        scale *= reqscale;
                        width *= reqscale;
                        height *= reqscale;
                    }
                    return {
                        width: width,
                        height: height,
                        scale: scale,
                        chartWidth: chartWidth,
                        chartHeight: chartHeight
                    };
                };
                Export.getDimensions = function (chart, dimensions) {
                    var shell = chart.shell;
                    if (!(shell instanceof Base.ChartOuterShell)) {
                        throw new Error("Export functionality is only available on the top level chart, not within nested charts.");
                    }
                    return this.getSizes(shell, dimensions || {});
                };
                Export.dataUriToBlob = function (mime, data) {
                    var i = data.indexOf(",");
                    var base64 = i > 13 && data.substr(i - 7, 7) === ";base64";
                    data = data.substr(i + 1);
                    if (base64) {
                        data = window.atob(data);
                    }
                    else {
                        data = decodeURIComponent(data);
                    }
                    // write the bytes of the string to an ArrayBuffer
                    var ab = new ArrayBuffer(data.length);
                    var ia = new Uint8Array(ab);
                    for (var x = 0; x < data.length; x++) {
                        ia[x] = data.charCodeAt(x);
                    }
                    return new Blob([ab], { type: mime });
                };
                Export.launchDownload = function (chart, mimeType, extension, data) {
                    var b = document.body;
                    var fname = "export." + extension;
                    var anch = Base.Helpers.createDom("a", null, null, null);
                    if (navigator.msSaveOrOpenBlob && window.atob) {
                        // IE10+ and Edge
                        if (navigator.msSaveOrOpenBlob(Export.dataUriToBlob(mimeType, data), fname)) {
                            return;
                        }
                    }
                    else if (anch.download !== void 0) {
                        // HTML5 adds a "download" attribute to anchor elements that can be used to force Save As dialog
                        anch.download = fname;
                        anch.type = mimeType;
                        anch.href = data;
                        b.appendChild(anch);
                        anch.click();
                        b.removeChild(anch);
                        // it does not seem to be possible to detect if the file download was actually initiated...
                        return;
                    }
                    // the fallback is to use the proxy server to download the data
                    var proxy = chart.settings.advanced.exportProxyURL;
                    if (!proxy) {
                        alert(chart.settings.localization.exportNotAvailable);
                        return;
                    }
                    var f = document.createElement("form");
                    f.action = chart.settings.advanced.exportProxyURL;
                    f.target = "_top"; // required for IE - it will not allow downloads within a frame
                    f.method = "POST";
                    f.style.display = "none";
                    var f1 = document.createElement("input");
                    f1.name = "name";
                    f1.value = fname;
                    f.appendChild(f1);
                    var f2 = document.createElement("textarea");
                    f2.name = "data";
                    f2.value = data;
                    f.appendChild(f2);
                    b.appendChild(f);
                    f.submit();
                    b.removeChild(f);
                };
                Export._csvSeparator = ";";
                Export._mimeMap = {
                    "png": { mime: "image/png", extension: "png", image: true, transparent: true },
                    "jpg": { mime: "image/jpeg", extension: "jpg", image: true },
                    "jpeg": { mime: "image/jpeg", extension: "jpg", image: true },
                    "csv": { mime: "text/csv", extension: "csv", csv: true },
                    "txt": { mime: "text/csv", extension: "csv", csv: true },
                    "xlsx": { mime: xlsxmime, extension: "xlsx", excel: true },
                    "xls": { mime: xlsxmime, extension: "xlsx", excel: true },
                    "pdf": { mime: "application/pdf", extension: "pdf", pdf: true }
                };
                return Export;
            }());
            Base.Export = Export;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="core/ChartEvents.ts" />
/// <reference path="Graphics.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var MessagesOverlay = (function (_super) {
                __extends(MessagesOverlay, _super);
                function MessagesOverlay(chart) {
                    _super.call(this);
                    this.animationOrder = 2000;
                    this.paintOrder = 70;
                    this.updateOrder = 200;
                    this.scene = null;
                    this.loadingTime = null;
                    this.chart = chart;
                    this.scene = chart.scene;
                }
                MessagesOverlay.prototype.doAnimations = function (event) {
                    if (this.scene.loading) {
                        event.animating = true;
                    }
                };
                MessagesOverlay.prototype.paintScene = function (event) {
                    var scene = this.scene;
                    var msg = scene.getMessage();
                    var config = scene.settings.advanced.style;
                    var arcStyle = config.loadingArcStyle;
                    var loading = scene.loading && arcStyle.location !== "hidden";
                    if (!loading) {
                        this.loadingTime = null;
                    }
                    if (!msg && !loading) {
                        return;
                    }
                    if (this.loadingTime === null) {
                        this.loadingTime = event.timeStamp;
                    }
                    var g = event.context;
                    var corner = arcStyle.location === "corner";
                    var arcRadius = arcStyle.r;
                    var arcWidth = arcStyle.lineWidth;
                    var arcX;
                    var arcY;
                    if (corner) {
                        arcX = scene.x0 + scene.width - (arcRadius + arcWidth) * 1.2;
                        arcY = scene.y0 + (arcRadius + arcWidth) * 1.2;
                        // check if there are toolbars are located at the right top corner
                        var area = this.chart.shell.getChartInnerArea();
                        arcY += area.findTopPosition(arcX, arcX);
                    }
                    else {
                        arcX = scene.x0 + scene.width / 2;
                        arcY = scene.y0 + scene.height / 2 + arcRadius;
                    }
                    if (msg) {
                        var textStyle = config.messageTextStyle;
                        g.textBaseline = "top";
                        g.textAlign = "left";
                        var height = Base.Graphics.getTextHeight(g, textStyle.font);
                        var width = Base.Graphics.getTextWidth(g, textStyle, msg);
                        var textX = void 0;
                        var textY = void 0;
                        var bgwidth = void 0;
                        var bgstyle = config.messageBackgroundStyle;
                        var padding = bgstyle.padding || 0;
                        if (loading) {
                            if (corner) {
                                arcX -= padding;
                                textX = arcX - arcRadius * 1.2 - width;
                                textY = (height > arcRadius * 2) ? 4 : (arcY - height / 2);
                                bgwidth = width + arcRadius * 2.2;
                            }
                            else {
                                arcY -= height / 2;
                                textX = arcX - width / 2;
                                textY = arcY + height * 1.3;
                                bgwidth = width;
                            }
                        }
                        var gx = Base.Graphics.beginStrokeAndFill(g, bgstyle);
                        gx.rect(textX - padding, arcY - arcRadius - padding, bgwidth + padding * 2, textY - arcY + arcRadius + padding * 2 + height);
                        Base.Graphics.endStrokeAndFill(g, gx, bgstyle);
                        Base.Graphics.drawText(g, textStyle, msg, textX, textY);
                        Base.Graphics.resetTextStyle(g);
                    }
                    if (loading) {
                        g.save();
                        g.lineCap = "round";
                        g.lineWidth = arcWidth;
                        var a = (event.timeStamp - this.loadingTime) / 700 * Math.PI;
                        var grad = g.createLinearGradient(arcX + arcRadius * Math.cos(a + Math.PI), arcY + arcRadius * Math.sin(a + Math.PI), arcX + arcRadius * Math.cos(a), arcY + arcRadius * Math.sin(a));
                        grad.addColorStop(0, arcStyle.lineColor);
                        grad.addColorStop(1, "transparent");
                        g.strokeStyle = grad;
                        g.beginPath();
                        g.arc(arcX, arcY, arcRadius, a, a + Math.PI);
                        g.stroke();
                        Base.Graphics.restore(g);
                    }
                };
                return MessagesOverlay;
            }(Base.ChartElement));
            Base.MessagesOverlay = MessagesOverlay;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            // Get fallback assetsUrlBase
            var currentScriptElement = (typeof document !== "undefined") ? document.currentScript : null;
            var _defaultAssetsUrlBaseCached = null;
            var defaultAssetsUrlBase = function () {
                if (_defaultAssetsUrlBaseCached)
                    return _defaultAssetsUrlBaseCached;
                // special case for when the library is included from node.js
                if (typeof document === "undefined")
                    return "";
                /** this will be replaced by build script as needed */
                var libName = ZoomCharts.PackageInfo.LibraryName;
                if (libName.substr(0, 2) === "<?")
                    libName = "everything";
                // if the library is custom build, then the name contains codes of included modules (ZoomCharts-PFT)
                var libNameI = libName.indexOf("-");
                if (libNameI > -1)
                    libName = libName.substr(0, libNameI);
                var uriMatcher = new RegExp("^(.*?\/" + libName + "(-dev|\.min|)\.js)");
                var vSource = document.getElementsByTagName("script");
                for (var i = 0; i < vSource.length; i++) {
                    var src = vSource[i].src;
                    if (!src)
                        continue;
                    var match = src.match(uriMatcher);
                    if (match)
                        return _defaultAssetsUrlBaseCached = match[1] + "/../assets/";
                }
                // currentScript is supported in Chrome and FF https://developer.mozilla.org/en-US/docs/Web/API/Document/currentScript
                if (currentScriptElement && currentScriptElement.src) {
                    Base.Helpers.warn("Cannot locate the ZoomCharts script path based on file name '" + libName
                        + ".js'. The script path was detected using `document.currentScript` which is not supported on all browsers. "
                        + "Please specify 'assetsUrlBase' in settings when creating the chart for full browser compatibility.");
                    return _defaultAssetsUrlBaseCached = currentScriptElement.src.match(/^([^?#]*)/)[1] + "/../assets/";
                }
                return _defaultAssetsUrlBaseCached = "";
            };
            var AssetsLoaderStatic = (function () {
                function AssetsLoaderStatic() {
                }
                AssetsLoaderStatic.hasPendingRequests = function () {
                    return Base.Helpers.hasProperties(this._imageLoading) || Base.Helpers.hasProperties(this.pendingHTMLAssets);
                };
                AssetsLoaderStatic.getAssetImage = function (url, useCors, onFirstLoad) {
                    var _this = this;
                    // onFirstLoad will be called only once on image loading, for whoever is the first to request it.
                    if (this._imageCache.hasOwnProperty(url)) {
                        return this._imageCache[url];
                    }
                    else if (this._imageLoading.hasOwnProperty(url)) {
                        return null;
                    }
                    else {
                        if (!url) {
                            return null;
                        }
                        var loadFunc_1 = function (image) {
                            delete _this._imageLoading[url];
                            _this._imageCache[url] = image;
                            if (onFirstLoad) {
                                return onFirstLoad(image);
                            }
                        };
                        var errorFunc = function () {
                            // load error image for failing images
                            var errorResource = Internal.Resources.ErrorImage;
                            var cachedErrorImg = _this._imageCache[errorResource];
                            if (cachedErrorImg) {
                                loadFunc_1(cachedErrorImg);
                            }
                            else {
                                _this._imagesPendingForErrors.push(loadFunc_1);
                                if (!_this._imageLoading.hasOwnProperty(errorResource)) {
                                    var errorImageLoadedFunc = function (errorImage) {
                                        delete _this._imageLoading[errorResource];
                                        _this._imageCache[errorResource] = errorImage;
                                        for (var funcIndex = 0; funcIndex < _this._imagesPendingForErrors.length; funcIndex++) {
                                            var func = _this._imagesPendingForErrors[funcIndex];
                                            func(errorImage);
                                        }
                                        _this._imagesPendingForErrors = null;
                                    };
                                    Base.Helpers.buildImage(errorResource, useCors, errorImageLoadedFunc, function () { Base.Helpers.error("Could not load '" + errorResource + "'"); });
                                    if (!_this._imageCache.hasOwnProperty(errorResource)) {
                                        _this._imageLoading[errorResource] = true;
                                    }
                                }
                            }
                        };
                        this._imageLoading[url] = true;
                        Base.Helpers.buildImage(url, useCors, loadFunc_1, errorFunc);
                        if (this._imageCache.hasOwnProperty(url)) {
                            return this._imageCache[url];
                        }
                        else {
                            return null;
                        }
                    }
                };
                /**
                @returns true if callback will be called.
                */
                AssetsLoaderStatic.loadHtmlAssets = function (urls, onLoad) {
                    var _this = this;
                    var needsCallback = false;
                    for (var i = 0; i < urls.length; i++) {
                        var asset = urls[i];
                        if (!this.loadedHTMLAssets[asset.url]) {
                            if (!this.pendingHTMLAssets[asset.url]) {
                                if (this.loadHTMLAsset(asset, function (str) { return _this.htmlAssetLoaded(str); })) {
                                    this.pendingHTMLAssets[asset.url] = true;
                                    needsCallback = true;
                                }
                            }
                            else {
                                needsCallback = true;
                            }
                        }
                    }
                    if (needsCallback) {
                        this.callbacks.push(onLoad);
                        return true;
                    }
                    else {
                        return false;
                    }
                };
                AssetsLoaderStatic.htmlAssetLoaded = function (url) {
                    delete this.pendingHTMLAssets[url];
                    this.loadedHTMLAssets[url] = true;
                    if (!Base.Helpers.hasProperties(this.pendingHTMLAssets)) {
                        for (var i = 0; i < this.callbacks.length; i += 1) {
                            this.callbacks[i](this.errors);
                        }
                        this.callbacks = [];
                        this.errors = [];
                    }
                };
                /**
                @returns true if callback will be called.
                */
                AssetsLoaderStatic.loadHTMLAsset = function (asset, callback) {
                    var _this = this;
                    var elem;
                    var url = asset.url;
                    var upperUrl = url.toUpperCase();
                    var css = upperUrl.indexOf(".CSS");
                    var js = upperUrl.indexOf(".JS");
                    var ignoreRequiredOnLoad = false;
                    var timer = null;
                    var callbackCalled = false;
                    var loadHandler = function () {
                        if (timer)
                            window.clearInterval(timer);
                        if (callbackCalled)
                            return;
                        callbackCalled = true;
                        if (!ignoreRequiredOnLoad && asset.required && asset.required()) {
                            _this.errors.push("The `required` delegate did not return `false` after loading " + url);
                        }
                        callback(url);
                    };
                    var errorHandler = function () {
                        if (timer)
                            window.clearInterval(timer);
                        if (callbackCalled)
                            return;
                        callbackCalled = true;
                        _this.errors.push("Failed to load asset: " + url);
                        callback(url);
                    };
                    if (css > js) {
                        var linkElem = document.createElement("link");
                        linkElem.rel = "stylesheet";
                        linkElem.href = url;
                        linkElem.type = "text/css";
                        if (!asset.required) {
                            Base.Helpers.warn("Asset url " + url + " does not define the `required` delegate which prevents the detection of asset load in older browsers.");
                            // apply a very simple workaround - after 500ms the asset will be considered to be loaded.
                            var temp_1 = 5;
                            asset.required = function () { return temp_1-- > 0; };
                            ignoreRequiredOnLoad = true;
                        }
                        var counter_1 = 100; // approx 10 sec
                        // apply the workaround for older browsers.
                        timer = window.setInterval(function () {
                            if (counter_1-- < 0) {
                                errorHandler();
                            }
                            else if (!asset.required()) {
                                loadHandler();
                            }
                        }, 100);
                        elem = linkElem;
                    }
                    else if (js > -1) {
                        var scriptElem = document.createElement("script");
                        scriptElem.src = url;
                        scriptElem.type = "text/javascript";
                        // async=false is required by TimeChart which requires both moment.js and moment-timezone.js
                        // without this the order in which the scripts are executed is not defined.
                        scriptElem.async = false;
                        elem = scriptElem;
                    }
                    else {
                        this.errors.push("Assets: Do not know how to load "
                            + url + ". The URL should contain either \".css\" or \".js\" - it can be either in the path, the file name or the query string.");
                        return false;
                    }
                    Base.Helpers.listen(elem, "load", loadHandler);
                    Base.Helpers.listen(elem, "error", errorHandler);
                    document.getElementsByTagName("head")[0].appendChild(elem);
                    return true;
                };
                AssetsLoaderStatic._imageCache = {};
                AssetsLoaderStatic._imageLoading = {};
                AssetsLoaderStatic._imagesPendingForErrors = [];
                AssetsLoaderStatic.loadedHTMLAssets = {};
                AssetsLoaderStatic.pendingHTMLAssets = {};
                AssetsLoaderStatic.callbacks = [];
                AssetsLoaderStatic.errors = [];
                return AssetsLoaderStatic;
            }());
            var AssetsLoader = (function () {
                function AssetsLoader(chart) {
                    this.chart = chart;
                    this.settings = chart.settings;
                    var baseUrl = this.settings.assetsUrlBase || defaultAssetsUrlBase();
                    if (baseUrl.length > 0 && baseUrl[baseUrl.length - 1] !== "/") {
                        baseUrl = baseUrl + "/";
                    }
                    this.assetsUrlBase = baseUrl;
                }
                AssetsLoader.prototype.getAssetUrl = function (asset) {
                    if (asset.indexOf("builtin://") === 0) {
                        return this.settings.advanced.builtinAssets[asset.slice(10)];
                    }
                    else if (asset.indexOf("assets://") === 0) {
                        if (!this.assetsUrlBase) {
                            this.chart.error("Cannot locate the ZoomCharts script path based on file name '" + ZoomCharts.PackageInfo.LibraryName
                                + ".js'. Please specify 'assetsUrlBase' in settings when creating the chart.");
                        }
                        return this.assetsUrlBase + asset.slice(9);
                    }
                    else {
                        return asset;
                    }
                };
                AssetsLoader.prototype.hasPendingRequests = function () {
                    return AssetsLoaderStatic.hasPendingRequests();
                };
                AssetsLoader.prototype.getAssetImage = function (asset, onFirstLoad) {
                    var _this = this;
                    return AssetsLoaderStatic.getAssetImage(this.getAssetUrl(asset), this.settings.advanced.crossOriginHeader, function (img) {
                        // this prevents any random errors where the chart is not repainted with the loaded images
                        _this.chart.events.requestPaint();
                        // in many cases onFirstLoad() will also call requestPaint() but that should not be a problem.
                        if (onFirstLoad)
                            onFirstLoad(img);
                    });
                };
                /** Calls `loadAssetsList()` but always invokes the callback, even if the resources are already loaded. */
                AssetsLoader.prototype.ensureAssetsList = function (assetsList, callback) {
                    var neededAssets = [];
                    for (var i = 0; i < assetsList.length; i++) {
                        var x = assetsList[i];
                        if (Base.Helpers.isString(x)) {
                            neededAssets.push({ url: x, required: null });
                        }
                        else if (!x.required || x.required()) {
                            neededAssets.push(x);
                        }
                    }
                    var waiting = this.loadAssetsList(neededAssets, function () {
                        callback(true);
                    });
                    if (!waiting)
                        callback(false);
                };
                /** Loads list of html assets.
                @param callback - the callback that will be called when the assets finishes loading. Note that it will only be called if the assets are not already loaded.
                @returns true of still loading and will call callback
                */
                AssetsLoader.prototype.loadAssetsList = function (assetsList, callback) {
                    var _this = this;
                    // Convert to full URLS
                    for (var i = 0; i < assetsList.length; i++) {
                        var a = assetsList[i];
                        a.url = this.getAssetUrl(a.url);
                    }
                    var assetsLoaded = function (errors) {
                        for (var i = 0; i < errors.length; i += 1) {
                            _this.chart.error(errors[i]);
                        }
                        _this.chart.log("Assets loaded");
                        callback();
                    };
                    var waiting = AssetsLoaderStatic.loadHtmlAssets(assetsList, assetsLoaded);
                    if (waiting) {
                        this.chart.log("Loading assets");
                    }
                    return waiting;
                };
                return AssetsLoader;
            }());
            Base.AssetsLoader = AssetsLoader;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="core/ChartEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var TouchMarkers = (function (_super) {
                __extends(TouchMarkers, _super);
                function TouchMarkers(chart) {
                    _super.call(this);
                    this.animationOrder = 0;
                    this.paintOrder = 10000;
                    this.touches = {};
                    this.fps = 0;
                    this.prevFrame = null;
                    this.frameCount = 0;
                    this.chart = chart;
                    this.settings = chart.settings.advanced;
                    this.captureTouches = this.settings.showTouches;
                }
                TouchMarkers.prototype.onSceneChange = function (event) {
                    this.captureTouches = this.settings.showTouches;
                };
                TouchMarkers.prototype.paintScene = function (event) {
                    var message = "";
                    if (this.settings.showTimestamp) {
                        message += Math.round(event.timeStamp);
                    }
                    if (this.settings.showFPS) {
                        // update FPS
                        this.frameCount += 1;
                        if (this.prevFrame) {
                            var dt = Math.max(event.timeStamp - this.prevFrame, 1) / 1000;
                            var fp = 1 / dt;
                            var prop = Math.min(1, dt * 3);
                            this.fps = (this.fps * (1 - prop) + fp * prop);
                        }
                        this.prevFrame = event.timeStamp;
                        message += "FPS:" + (Math.round(this.fps));
                    }
                    var g = event.context;
                    if (this.captureTouches) {
                        var showTrail = this.settings.showTouchTrail;
                        var count = 0;
                        for (var k in this.touches) {
                            var t = this.touches[k];
                            if (!this.touches.hasOwnProperty(k)) {
                                continue;
                            }
                            g.beginPath();
                            g.moveTo(t.dx, t.dy);
                            for (var pIndex = 0; pIndex < t.trace.length; pIndex++) {
                                var p = t.trace[pIndex];
                                g.lineTo(p.x, p.y);
                            }
                            if (showTrail && t.cancelled) {
                                g.strokeStyle = "red";
                                g.fillStyle = "red";
                                g.lineWidth = 1;
                            }
                            else if (showTrail && t.up) {
                                g.strokeStyle = "gray";
                                g.fillStyle = "gray";
                                g.lineWidth = 3;
                            }
                            else {
                                g.strokeStyle = "rgba(180,180,180,0.4)";
                                g.fillStyle = "rgba(180,180,180,0.3)";
                                g.lineWidth = 3;
                            }
                            g.moveTo(t.x + 30, t.y);
                            g.stroke();
                            g.lineWidth = 1.5;
                            g.beginPath();
                            g.arc(t.x, t.y, t.animator.get(event.timeStamp), 0, Math.PI * 2);
                            g.stroke();
                            g.fill();
                            if (!t.up) {
                                count += 1;
                            }
                            if (!t.animator.finished(event.timeStamp))
                                event.animating = true;
                        }
                        // paint black points
                        g.beginPath();
                        g.fillStyle = "black";
                        for (var k in this.touches) {
                            if (!this.touches.hasOwnProperty(k)) {
                                continue;
                            }
                            var t = this.touches[k];
                            for (var pIndex = 0; pIndex < t.trace.length; pIndex++) {
                                var p = t.trace[pIndex];
                                g.rect(p.x - 1, p.y - 1, 2, 2);
                            }
                        }
                        g.fill();
                        if (showTrail)
                            message += "\ntouches:" + count;
                    }
                    if (message.length > 0) {
                        var area = this.chart.shell.getChartInnerArea();
                        var y = Math.max(30, area.findTopPosition(50, 200));
                        Base.Graphics.resetTextStyle(g);
                        g.fillStyle = "#000";
                        g.textAlign = "start";
                        g.textBaseline = "middle";
                        g.font = "bold 11px Arial";
                        g.fillText(message, 50, y);
                    }
                };
                TouchMarkers.prototype.previewPointerDown = function (event) {
                    if (!this.captureTouches)
                        return;
                    for (var k in this.touches) {
                        var t = this.touches[k];
                        if (!this.touches.hasOwnProperty(k)) {
                            continue;
                        }
                        if (t.up) {
                            delete this.touches[k];
                        }
                    }
                    this.touches[event.identifier] = {
                        dx: event.x,
                        dy: event.y,
                        x: event.x,
                        y: event.y,
                        up: false,
                        cancelled: false,
                        trace: [],
                        animator: new Base.Animator(10, 40, 200)
                    };
                    event.changes.requestPaint = true;
                };
                TouchMarkers.prototype.previewPointerDrag = function (event) {
                    if (!this.captureTouches)
                        return;
                    var t = this.touches[event.identifier];
                    t.x = event.x;
                    t.y = event.y;
                    if (this.settings.showTouchTrail)
                        t.trace.push({ x: t.x, y: t.y });
                    event.changes.requestPaint = true;
                };
                TouchMarkers.prototype.previewPointerUp = function (event) {
                    if (!this.captureTouches)
                        return;
                    var t = this.touches[event.identifier];
                    t.up = true;
                    t.animator.retarget(0);
                    this.previewPointerDrag(event);
                    event.changes.requestPaint = true;
                };
                TouchMarkers.prototype.previewPointerCancel = function (event) {
                    if (!this.captureTouches)
                        return;
                    var t = this.touches[event.identifier];
                    t.up = true;
                    t.cancelled = true;
                    t.animator.retarget(0);
                    this.previewPointerDrag(event);
                    event.changes.requestPaint = true;
                };
                return TouchMarkers;
            }(Base.ChartElement));
            Base.TouchMarkers = TouchMarkers;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../Export.ts" />
/// <reference path="Toolbar.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var Bar;
            (function (Bar) {
                var ExportDropdown = (function (_super) {
                    __extends(ExportDropdown, _super);
                    function ExportDropdown(chart, options) {
                        var loc = chart.settings.localization.toolbar;
                        if (!options.dropDownItems) {
                            var defaultItems = chart.settings.toolbar.exportOptions;
                            var items = [];
                            if (!defaultItems || defaultItems.indexOf("jpg") > -1) {
                                items.push({
                                    label: loc.exportJpeg,
                                    onClick: function () { return Base.Export.download(chart, "jpg", { scaling: 2 }); },
                                });
                            }
                            if (!defaultItems || defaultItems.indexOf("png") > -1) {
                                items.push({
                                    label: loc.exportPNG,
                                    onClick: function () { return Base.Export.download(chart, "png", { scaling: 3 }); }
                                });
                            }
                            if (!defaultItems || defaultItems.indexOf("pdf") > -1) {
                                items.push({
                                    label: loc.exportPDF,
                                    onClick: function () { return Base.Export.download(chart, "pdf"); }
                                });
                            }
                            if (chart.exportVisibleData) {
                                if (!defaultItems || defaultItems.indexOf("csv") > -1) {
                                    items.push({
                                        label: loc.exportCSV,
                                        onClick: function () { return Base.Export.download(chart, "csv"); }
                                    });
                                }
                                if (!defaultItems || defaultItems.indexOf("xlsx") > -1) {
                                    items.push({
                                        label: loc.exportXLS,
                                        onClick: function () { return Base.Export.download(chart, "xlsx"); }
                                    });
                                }
                            }
                            options.dropDownItems = items;
                        }
                        options.title = options.title || loc.exportTitle;
                        options.label = options.label || loc.exportButton;
                        options.cssClass = options.cssClass || "DVSL-bar-btn-export";
                        _super.call(this, chart, options);
                    }
                    return ExportDropdown;
                }(Bar.Dropdown));
                Bar.ExportDropdown = ExportDropdown;
                Base.Bar.ToolbarItemNames["export"] = function (chart, options) { return new Base.Bar.ExportDropdown(chart, options); };
            })(Bar = Base.Bar || (Base.Bar = {}));
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="core/ChartEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var KeyShortcuts = (function (_super) {
                __extends(KeyShortcuts, _super);
                function KeyShortcuts(chart) {
                    _super.call(this);
                    this.animationOrder = 2000;
                    this.paintOrder = 65;
                    this.updateOrder = 0;
                    this.chart = chart;
                }
                KeyShortcuts.prototype.onKeyDown = function (ev) {
                    if (this.chart.isFullscreen() && ev.keyCode === 27) {
                        // "Escape"
                        this.chart.setFullscreen(false);
                        ev.consumed = true;
                    }
                    else if (ev.keyCode === 8) {
                        // backspace
                        if (this.chart.back(true, "user")) {
                            ev.consumed = true;
                        }
                    }
                };
                return KeyShortcuts;
            }(Base.ChartElement));
            Base.KeyShortcuts = KeyShortcuts;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var publicKey = "C314F39F62CBF2AEFA1D5BA41E38EFFD080E88849EE210BA17971BF63A55C44E159C9F9ED004F8D50856EC8ECE673690F60C29AAC124B7C46D549D20EB22CC2A387B2FB643700546312114F831133F242CFFD023A1788167025FF398F5F09D1003C47C9B3208860A547577F540D07FF66403097FE27E7BB6B8D76036AD31B62B04EAD1BB8B2C314F6DA7489346978286491D0DF7504E9EE85A4459805F4FFCEE664122FC27B80DAD6751A7A6C0D38E9C2ECD7C0AD1F2B774D6FF81C5A2CE14D608F08E13BEE45663450519774ADF87D34CE6150FC819558EBD336511D51405A42E7A38EBB786ED5050345CBC532ED7C0EECB05C5D6D4D00534249ED4585DFABD";
            var RsaCrypto = (function () {
                function RsaCrypto() {
                }
                /**
                 * Verifies if the given hex-encoded signature matches the given plain text.
                 * The signature must be created using SHA256 hash and RSA encryption.
                 */
                RsaCrypto.verifySignature = function (text, signature) {
                    var rsa = new RSAKeyImpl();
                    rsa.setPublic(publicKey, "10001");
                    return rsa.verify(text, signature);
                };
                /**
                 * Creates a hash for the given text using SHA256.
                 * @returns Hex-encoded hash value.
                 */
                RsaCrypto.hash = function (text) {
                    return RSAKeyImpl.hash(text);
                };
                return RsaCrypto;
            }());
            Base.RsaCrypto = RsaCrypto;
            Object.freeze(RsaCrypto);
            var RSAKeyImpl = (function () {
                // Copyright (c) 2005  Tom Wu
                // All Rights Reserved.
                // See "LICENSE" for details.
                // Basic JavaScript BN library - subset useful for RSA encryption.
                // Bits per digit
                var dbits;
                // JavaScript engine analysis
                var canary = 0xdeadbeefcafe;
                var j_lm = ((canary & 0xffffff) == 0xefcafe);
                var windowCrypto = typeof window === typeof void 0 ? null : (window.crypto || window.msCrypto);
                // (public) Constructor
                function BigInteger(a, b) {
                    if (a != null)
                        if (b == null && "string" != typeof a)
                            this.fromString(a, 256);
                        else
                            this.fromString(a, b);
                }
                // return new, unset BigInteger
                function nbi() { return new BigInteger(null); }
                // am: Compute w_j += (x*this_i), propagate carries,
                // c is initial carry, returns final carry.
                // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
                // We need to select the fastest one that works in this environment.
                // am1: use a single mult and divide to get the high bits,
                // max digit bits should be 26 because
                // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
                function am1(i, x, w, j, c, n) {
                    while (--n >= 0) {
                        var v = x * this[i++] + w[j] + c;
                        c = Math.floor(v / 0x4000000);
                        w[j++] = v & 0x3ffffff;
                    }
                    return c;
                }
                // am2 avoids a big mult-and-extract completely.
                // Max digit bits should be <= 30 because we do bitwise ops
                // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
                function am2(i, x, w, j, c, n) {
                    var xl = x & 0x7fff, xh = x >> 15;
                    while (--n >= 0) {
                        var l = this[i] & 0x7fff;
                        var h = this[i++] >> 15;
                        var m = xh * l + h * xl;
                        l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
                        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
                        w[j++] = l & 0x3fffffff;
                    }
                    return c;
                }
                // Alternately, set max digit bits to 28 since some
                // browsers slow down when dealing with 32-bit numbers.
                function am3(i, x, w, j, c, n) {
                    var xl = x & 0x3fff, xh = x >> 14;
                    while (--n >= 0) {
                        var l = this[i] & 0x3fff;
                        var h = this[i++] >> 14;
                        var m = xh * l + h * xl;
                        l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
                        c = (l >> 28) + (m >> 14) + xh * h;
                        w[j++] = l & 0xfffffff;
                    }
                    return c;
                }
                if (j_lm && (typeof navigator !== typeof void 0 && navigator.appName === "Microsoft Internet Explorer")) {
                    BigInteger.prototype.am = am2;
                    dbits = 30;
                }
                else if (j_lm && (typeof navigator !== typeof void 0 && navigator.appName !== "Netscape")) {
                    BigInteger.prototype.am = am1;
                    dbits = 26;
                }
                else {
                    BigInteger.prototype.am = am3;
                    dbits = 28;
                }
                BigInteger.prototype.DB = dbits;
                BigInteger.prototype.DM = ((1 << dbits) - 1);
                BigInteger.prototype.DV = (1 << dbits);
                var BI_FP = 52;
                BigInteger.prototype.FV = Math.pow(2, BI_FP);
                BigInteger.prototype.F1 = BI_FP - dbits;
                BigInteger.prototype.F2 = 2 * dbits - BI_FP;
                // Digit conversions
                var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
                var BI_RC = new Array();
                var rr;
                var vv;
                rr = "0".charCodeAt(0);
                for (vv = 0; vv <= 9; ++vv)
                    BI_RC[rr++] = vv;
                rr = "a".charCodeAt(0);
                for (vv = 10; vv < 36; ++vv)
                    BI_RC[rr++] = vv;
                rr = "A".charCodeAt(0);
                for (vv = 10; vv < 36; ++vv)
                    BI_RC[rr++] = vv;
                function int2char(n) { return BI_RM.charAt(n); }
                function intAt(s, i) {
                    var c = BI_RC[s.charCodeAt(i)];
                    return (c == null) ? -1 : c;
                }
                // (protected) copy this to r
                function bnpCopyTo(r) {
                    for (var i = this.t - 1; i >= 0; --i)
                        r[i] = this[i];
                    r.t = this.t;
                    r.s = this.s;
                }
                // (protected) set from integer value x, -DV <= x < DV
                function bnpFromInt(x) {
                    this.t = 1;
                    this.s = (x < 0) ? -1 : 0;
                    if (x > 0)
                        this[0] = x;
                    else if (x < -1)
                        this[0] = x + this.DV;
                    else
                        this.t = 0;
                }
                // return bigint initialized to value
                function nbv(i) {
                    var r = nbi();
                    r.fromInt(i);
                    return r;
                }
                // (protected) set from string and radix
                function bnpFromString(s, b) {
                    var k;
                    if (b == 16)
                        k = 4;
                    else if (b == 8)
                        k = 3;
                    else if (b == 256)
                        k = 8; // byte array
                    else if (b == 2)
                        k = 1;
                    else if (b == 32)
                        k = 5;
                    else if (b == 4)
                        k = 2;
                    else {
                        this.fromRadix(s, b);
                        return;
                    }
                    this.t = 0;
                    this.s = 0;
                    var i = s.length, mi = false, sh = 0;
                    while (--i >= 0) {
                        var x = (k == 8) ? s[i] & 0xff : intAt(s, i);
                        if (x < 0) {
                            if (s.charAt(i) == "-")
                                mi = true;
                            continue;
                        }
                        mi = false;
                        if (sh == 0)
                            this[this.t++] = x;
                        else if (sh + k > this.DB) {
                            this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
                            this[this.t++] = (x >> (this.DB - sh));
                        }
                        else
                            this[this.t - 1] |= x << sh;
                        sh += k;
                        if (sh >= this.DB)
                            sh -= this.DB;
                    }
                    if (k == 8 && (s[0] & 0x80) != 0) {
                        this.s = -1;
                        if (sh > 0)
                            this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
                    }
                    this.clamp();
                    if (mi)
                        BigInteger.ZERO.subTo(this, this);
                }
                // (protected) clamp off excess high words
                function bnpClamp() {
                    var c = this.s & this.DM;
                    while (this.t > 0 && this[this.t - 1] == c)
                        --this.t;
                }
                // (public) return string representation in given radix
                function bnToString(b) {
                    if (this.s < 0)
                        return "-" + this.negate().toString(b);
                    var k;
                    if (b == 16)
                        k = 4;
                    else if (b == 8)
                        k = 3;
                    else if (b == 2)
                        k = 1;
                    else if (b == 32)
                        k = 5;
                    else if (b == 4)
                        k = 2;
                    else
                        return this.toRadix(b);
                    var km = (1 << k) - 1;
                    var d;
                    var m = false;
                    var r = "";
                    var i = this.t;
                    var p = this.DB - (i * this.DB) % k;
                    if (i-- > 0) {
                        if (p < this.DB && (d = this[i] >> p) > 0) {
                            m = true;
                            r = int2char(d);
                        }
                        while (i >= 0) {
                            if (p < k) {
                                d = (this[i] & ((1 << p) - 1)) << (k - p);
                                d |= this[--i] >> (p += this.DB - k);
                            }
                            else {
                                d = (this[i] >> (p -= k)) & km;
                                if (p <= 0) {
                                    p += this.DB;
                                    --i;
                                }
                            }
                            if (d > 0)
                                m = true;
                            if (m)
                                r += int2char(d);
                        }
                    }
                    return m ? r : "0";
                }
                // (public) -this
                function bnNegate() {
                    var r = nbi();
                    BigInteger.ZERO.subTo(this, r);
                    return r;
                }
                // (public) |this|
                function bnAbs() { return (this.s < 0) ? this.negate() : this; }
                // (public) return + if this > a, - if this < a, 0 if equal
                function bnCompareTo(a) {
                    var r = this.s - a.s;
                    if (r != 0)
                        return r;
                    var i = this.t;
                    r = i - a.t;
                    if (r != 0)
                        return (this.s < 0) ? -r : r;
                    while (--i >= 0)
                        if ((r = this[i] - a[i]) != 0)
                            return r;
                    return 0;
                }
                // returns bit length of the integer x
                function nbits(x) {
                    var r = 1;
                    var t;
                    if ((t = x >>> 16) != 0) {
                        x = t;
                        r += 16;
                    }
                    if ((t = x >> 8) != 0) {
                        x = t;
                        r += 8;
                    }
                    if ((t = x >> 4) != 0) {
                        x = t;
                        r += 4;
                    }
                    if ((t = x >> 2) != 0) {
                        x = t;
                        r += 2;
                    }
                    if ((t = x >> 1) != 0) {
                        x = t;
                        r += 1;
                    }
                    return r;
                }
                // (public) return the number of bits in "this"
                function bnBitLength() {
                    if (this.t <= 0)
                        return 0;
                    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));
                }
                // (protected) r = this << n*DB
                function bnpDLShiftTo(n, r) {
                    var i;
                    for (i = this.t - 1; i >= 0; --i)
                        r[i + n] = this[i];
                    for (i = n - 1; i >= 0; --i)
                        r[i] = 0;
                    r.t = this.t + n;
                    r.s = this.s;
                }
                // (protected) r = this >> n*DB
                function bnpDRShiftTo(n, r) {
                    for (var i = n; i < this.t; ++i)
                        r[i - n] = this[i];
                    r.t = Math.max(this.t - n, 0);
                    r.s = this.s;
                }
                // (protected) r = this << n
                function bnpLShiftTo(n, r) {
                    var bs = n % this.DB;
                    var cbs = this.DB - bs;
                    var bm = (1 << cbs) - 1;
                    var ds = Math.floor(n / this.DB), c = (this.s << bs) & this.DM;
                    var i;
                    for (i = this.t - 1; i >= 0; --i) {
                        r[i + ds + 1] = (this[i] >> cbs) | c;
                        c = (this[i] & bm) << bs;
                    }
                    for (i = ds - 1; i >= 0; --i)
                        r[i] = 0;
                    r[ds] = c;
                    r.t = this.t + ds + 1;
                    r.s = this.s;
                    r.clamp();
                }
                // (protected) r = this >> n
                function bnpRShiftTo(n, r) {
                    r.s = this.s;
                    var ds = Math.floor(n / this.DB);
                    if (ds >= this.t) {
                        r.t = 0;
                        return;
                    }
                    var bs = n % this.DB;
                    var cbs = this.DB - bs;
                    var bm = (1 << bs) - 1;
                    r[0] = this[ds] >> bs;
                    for (var i = ds + 1; i < this.t; ++i) {
                        r[i - ds - 1] |= (this[i] & bm) << cbs;
                        r[i - ds] = this[i] >> bs;
                    }
                    if (bs > 0)
                        r[this.t - ds - 1] |= (this.s & bm) << cbs;
                    r.t = this.t - ds;
                    r.clamp();
                }
                // (protected) r = this - a
                function bnpSubTo(a, r) {
                    var i = 0, c = 0, m = Math.min(a.t, this.t);
                    while (i < m) {
                        c += this[i] - a[i];
                        r[i++] = c & this.DM;
                        c >>= this.DB;
                    }
                    if (a.t < this.t) {
                        c -= a.s;
                        while (i < this.t) {
                            c += this[i];
                            r[i++] = c & this.DM;
                            c >>= this.DB;
                        }
                        c += this.s;
                    }
                    else {
                        c += this.s;
                        while (i < a.t) {
                            c -= a[i];
                            r[i++] = c & this.DM;
                            c >>= this.DB;
                        }
                        c -= a.s;
                    }
                    r.s = (c < 0) ? -1 : 0;
                    if (c < -1)
                        r[i++] = this.DV + c;
                    else if (c > 0)
                        r[i++] = c;
                    r.t = i;
                    r.clamp();
                }
                // (protected) r = this * a, r != this,a (HAC 14.12)
                // "this" should be the larger one if appropriate.
                function bnpMultiplyTo(a, r) {
                    var x = this.abs(), y = a.abs();
                    var i = x.t;
                    r.t = i + y.t;
                    while (--i >= 0)
                        r[i] = 0;
                    for (i = 0; i < y.t; ++i)
                        r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
                    r.s = 0;
                    r.clamp();
                    if (this.s != a.s)
                        BigInteger.ZERO.subTo(r, r);
                }
                // (protected) r = this^2, r != this (HAC 14.16)
                function bnpSquareTo(r) {
                    var x = this.abs();
                    var i = r.t = 2 * x.t;
                    while (--i >= 0)
                        r[i] = 0;
                    for (i = 0; i < x.t - 1; ++i) {
                        var c = x.am(i, x[i], r, 2 * i, 0, 1);
                        if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
                            r[i + x.t] -= x.DV;
                            r[i + x.t + 1] = 1;
                        }
                    }
                    if (r.t > 0)
                        r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
                    r.s = 0;
                    r.clamp();
                }
                // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
                // r != q, this != m.  q or r may be null.
                function bnpDivRemTo(m, q, r) {
                    var pm = m.abs();
                    if (pm.t <= 0)
                        return;
                    var pt = this.abs();
                    if (pt.t < pm.t) {
                        if (q != null)
                            q.fromInt(0);
                        if (r != null)
                            this.copyTo(r);
                        return;
                    }
                    if (r == null)
                        r = nbi();
                    var y = nbi(), ts = this.s, ms = m.s;
                    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus
                    if (nsh > 0) {
                        pm.lShiftTo(nsh, y);
                        pt.lShiftTo(nsh, r);
                    }
                    else {
                        pm.copyTo(y);
                        pt.copyTo(r);
                    }
                    var ys = y.t;
                    var y0 = y[ys - 1];
                    if (y0 == 0)
                        return;
                    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);
                    var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
                    var i = r.t, j = i - ys, t = (q == null) ? nbi() : q;
                    y.dlShiftTo(j, t);
                    if (r.compareTo(t) >= 0) {
                        r[r.t++] = 1;
                        r.subTo(t, r);
                    }
                    BigInteger.ONE.dlShiftTo(ys, t);
                    t.subTo(y, y); // "negative" y so we can replace sub with am later
                    while (y.t < ys)
                        y[y.t++] = 0;
                    while (--j >= 0) {
                        // Estimate quotient digit
                        var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
                        if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
                            y.dlShiftTo(j, t);
                            r.subTo(t, r);
                            while (r[i] < --qd)
                                r.subTo(t, r);
                        }
                    }
                    if (q != null) {
                        r.drShiftTo(ys, q);
                        if (ts != ms)
                            BigInteger.ZERO.subTo(q, q);
                    }
                    r.t = ys;
                    r.clamp();
                    if (nsh > 0)
                        r.rShiftTo(nsh, r); // Denormalize remainder
                    if (ts < 0)
                        BigInteger.ZERO.subTo(r, r);
                }
                // (public) this mod a
                function bnMod(a) {
                    var r = nbi();
                    this.abs().divRemTo(a, null, r);
                    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
                        a.subTo(r, r);
                    return r;
                }
                // Modular reduction using "classic" algorithm
                function Classic(m) { this.m = m; }
                function cConvert(x) {
                    if (x.s < 0 || x.compareTo(this.m) >= 0)
                        return x.mod(this.m);
                    else
                        return x;
                }
                function cRevert(x) { return x; }
                function cReduce(x) { x.divRemTo(this.m, null, x); }
                function cMulTo(x, y, r) {
                    x.multiplyTo(y, r);
                    this.reduce(r);
                }
                function cSqrTo(x, r) {
                    x.squareTo(r);
                    this.reduce(r);
                }
                Classic.prototype.convert = cConvert;
                Classic.prototype.revert = cRevert;
                Classic.prototype.reduce = cReduce;
                Classic.prototype.mulTo = cMulTo;
                Classic.prototype.sqrTo = cSqrTo;
                // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
                // justification:
                //         xy == 1 (mod m)
                //         xy =  1+km
                //   xy(2-xy) = (1+km)(1-km)
                // x[y(2-xy)] = 1-k^2m^2
                // x[y(2-xy)] == 1 (mod m^2)
                // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
                // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
                // JS multiply "overflows" differently from C/C++, so care is needed here.
                function bnpInvDigit() {
                    if (this.t < 1)
                        return 0;
                    var x = this[0];
                    if ((x & 1) == 0)
                        return 0;
                    var y = x & 3; // y == 1/x mod 2^2
                    y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4
                    y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8
                    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16
                    // last step - calculate inverse mod DV directly;
                    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
                    y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits
                    // we really want the negative inverse, and -DV < y < DV
                    return (y > 0) ? this.DV - y : -y;
                }
                // Montgomery reduction
                function Montgomery(m) {
                    this.m = m;
                    this.mp = m.invDigit();
                    this.mpl = this.mp & 0x7fff;
                    this.mph = this.mp >> 15;
                    this.um = (1 << (m.DB - 15)) - 1;
                    this.mt2 = 2 * m.t;
                }
                // xR mod m
                function montConvert(x) {
                    var r = nbi();
                    x.abs().dlShiftTo(this.m.t, r);
                    r.divRemTo(this.m, null, r);
                    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
                        this.m.subTo(r, r);
                    return r;
                }
                // x/R mod m
                function montRevert(x) {
                    var r = nbi();
                    x.copyTo(r);
                    this.reduce(r);
                    return r;
                }
                // x = x/R mod m (HAC 14.32)
                function montReduce(x) {
                    while (x.t <= this.mt2)
                        x[x.t++] = 0;
                    for (var i = 0; i < this.m.t; ++i) {
                        // faster way of calculating u0 = x[i]*mp mod DV
                        var j = x[i] & 0x7fff;
                        var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
                        // use am to combine the multiply-shift-add into one call
                        j = i + this.m.t;
                        x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
                        // propagate carry
                        while (x[j] >= x.DV) {
                            x[j] -= x.DV;
                            x[++j]++;
                        }
                    }
                    x.clamp();
                    x.drShiftTo(this.m.t, x);
                    if (x.compareTo(this.m) >= 0)
                        x.subTo(this.m, x);
                }
                // r = "x^2/R mod m"; x != r
                function montSqrTo(x, r) {
                    x.squareTo(r);
                    this.reduce(r);
                }
                // r = "xy/R mod m"; x,y != r
                function montMulTo(x, y, r) {
                    x.multiplyTo(y, r);
                    this.reduce(r);
                }
                Montgomery.prototype.convert = montConvert;
                Montgomery.prototype.revert = montRevert;
                Montgomery.prototype.reduce = montReduce;
                Montgomery.prototype.mulTo = montMulTo;
                Montgomery.prototype.sqrTo = montSqrTo;
                // (protected) true iff this is even
                function bnpIsEven() { return ((this.t > 0) ? (this[0] & 1) : this.s) == 0; }
                // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
                function bnpExp(e, z) {
                    if (e > 0xffffffff || e < 1)
                        return BigInteger.ONE;
                    var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
                    g.copyTo(r);
                    while (--i >= 0) {
                        z.sqrTo(r, r2);
                        if ((e & (1 << i)) > 0)
                            z.mulTo(r2, g, r);
                        else {
                            var t = r;
                            r = r2;
                            r2 = t;
                        }
                    }
                    return z.revert(r);
                }
                // (public) this^e % m, 0 <= e < 2^32
                function bnModPowInt(e, m) {
                    var z;
                    if (e < 256 || m.isEven())
                        z = new Classic(m);
                    else
                        z = new Montgomery(m);
                    return this.exp(e, z);
                }
                // protected
                BigInteger.prototype.copyTo = bnpCopyTo;
                BigInteger.prototype.fromInt = bnpFromInt;
                BigInteger.prototype.fromString = bnpFromString;
                BigInteger.prototype.clamp = bnpClamp;
                BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
                BigInteger.prototype.drShiftTo = bnpDRShiftTo;
                BigInteger.prototype.lShiftTo = bnpLShiftTo;
                BigInteger.prototype.rShiftTo = bnpRShiftTo;
                BigInteger.prototype.subTo = bnpSubTo;
                BigInteger.prototype.multiplyTo = bnpMultiplyTo;
                BigInteger.prototype.squareTo = bnpSquareTo;
                BigInteger.prototype.divRemTo = bnpDivRemTo;
                BigInteger.prototype.invDigit = bnpInvDigit;
                BigInteger.prototype.isEven = bnpIsEven;
                BigInteger.prototype.exp = bnpExp;
                // public
                BigInteger.prototype.toString = bnToString;
                BigInteger.prototype.negate = bnNegate;
                BigInteger.prototype.abs = bnAbs;
                BigInteger.prototype.compareTo = bnCompareTo;
                BigInteger.prototype.bitLength = bnBitLength;
                BigInteger.prototype.mod = bnMod;
                BigInteger.prototype.modPowInt = bnModPowInt;
                // "constants"
                BigInteger.ZERO = nbv(0);
                BigInteger.ONE = nbv(1);
                /* // methods are not currently needed because RSA encryption is not used
                // prng4.js - uses Arcfour as a PRNG
        
                function Arcfour() {
                    this.i = 0;
                    this.j = 0;
                    this.S = new Array();
                }
        
                // Initialize arcfour context from key, an array of ints, each from [0..255]
                function ARC4init(key) {
                    let i, j, t;
                    for (i = 0; i < 256; ++i)
                        this.S[i] = i;
                    j = 0;
                    for (i = 0; i < 256; ++i) {
                        j = (j + this.S[i] + key[i % key.length]) & 255;
                        t = this.S[i];
                        this.S[i] = this.S[j];
                        this.S[j] = t;
                    }
                    this.i = 0;
                    this.j = 0;
                }
        
                function ARC4next() {
                    let t;
                    this.i = (this.i + 1) & 255;
                    this.j = (this.j + this.S[this.i]) & 255;
                    t = this.S[this.i];
                    this.S[this.i] = this.S[this.j];
                    this.S[this.j] = t;
                    return this.S[(t + this.S[this.i]) & 255];
                }
        
                Arcfour.prototype.init = ARC4init;
                Arcfour.prototype.next = ARC4next;
        
                // Plug in your RNG constructor here
                function prng_newstate() {
                    return new Arcfour();
                }
        
                // Pool size must be a multiple of 4 and greater than 32.
                // An array of bytes the size of the pool will be passed to init()
                let rng_psize = 256;
        
                // Random number generator - requires a PRNG backend, e.g. prng4.js
        
                // For best results, put code like
                // <body onClick='rng_seed_time();' onKeyPress='rng_seed_time();'>
                // in your main HTML document.
        
                let rng_state;
                let rng_pool;
                let rng_pptr;
        
                // Mix in a 32-bit integer into the pool
                function rng_seed_int(x) {
                    rng_pool[rng_pptr++] ^= x & 255;
                    rng_pool[rng_pptr++] ^= (x >> 8) & 255;
                    rng_pool[rng_pptr++] ^= (x >> 16) & 255;
                    rng_pool[rng_pptr++] ^= (x >> 24) & 255;
                    if (rng_pptr >= rng_psize) rng_pptr -= rng_psize;
                }
        
                // Mix in the current time (w/milliseconds) into the pool
                function rng_seed_time() {
                    rng_seed_int(new Date().getTime());
                }
        
                // Initialize the pool with junk if needed.
                if (rng_pool == null) {
                    rng_pool = new Array();
                    rng_pptr = 0;
                    let t;
                    if (windowCrypto && windowCrypto.getRandomValues) {
                        // Use webcrypto if available
                        let ua = new Uint8Array(32);
                        windowCrypto.getRandomValues(ua);
                        for (t = 0; t < 32; ++t)
                            rng_pool[rng_pptr++] = ua[t];
                    }
                    while (rng_pptr < rng_psize) { // extract some randomness from Math.random()
                        t = Math.floor(65536 * Math.random());
                        rng_pool[rng_pptr++] = t >>> 8;
                        rng_pool[rng_pptr++] = t & 255;
                    }
                    rng_pptr = 0;
                    rng_seed_time();
                    //rng_seed_int(window.screenX);
                    //rng_seed_int(window.screenY);
                }
        
                function rng_get_byte() {
                    if (rng_state == null) {
                        rng_seed_time();
                        rng_state = prng_newstate();
                        rng_state.init(rng_pool);
                        for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
                            rng_pool[rng_pptr] = 0;
                        rng_pptr = 0;
                        //rng_pool = null;
                    }
                    // TODO: allow reseeding after first request
                    return rng_state.next();
                }
        
                function rng_get_bytes(ba) {
                    let i;
                    for (i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
                }
        
                function SecureRandom() { }
        
                SecureRandom.prototype.nextBytes = rng_get_bytes;
                */
                // Depends on jsbn.js and rng.js
                // Version 1.1: support utf-8 encoding in pkcs1pad2
                // convert a (hex) string to a bignum object
                function parseBigInt(str, r) {
                    return new BigInteger(str, r);
                }
                // PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint
                /* // encryption currently is not used
                function pkcs1pad2(s, n) {
                    if (n < s.length + 11) { // TODO: fix for utf-8
                        alert("Message too long for RSA");
                        return null;
                    }
                    let ba = new Array();
                    let i = s.length - 1;
                    while (i >= 0 && n > 0) {
                        let c = s.charCodeAt(i--);
                        if (c < 128) { // encode using utf-8
                            ba[--n] = c;
                        } else if ((c > 127) && (c < 2048)) {
                            ba[--n] = (c & 63) | 128;
                            ba[--n] = (c >> 6) | 192;
                        } else {
                            ba[--n] = (c & 63) | 128;
                            ba[--n] = ((c >> 6) & 63) | 128;
                            ba[--n] = (c >> 12) | 224;
                        }
                    }
                    ba[--n] = 0;
                    let rng = new SecureRandom();
                    let x = new Array();
                    while (n > 2) { // random non-zero pad
                        x[0] = 0;
                        while (x[0] == 0) rng.nextBytes(x);
                        ba[--n] = x[0];
                    }
                    ba[--n] = 2;
                    ba[--n] = 0;
                    return new BigInteger(ba);
                }
                */
                // "empty" RSA key constructor
                function RSAKey() {
                    this.n = null;
                    this.e = 0;
                    this.d = null;
                    this.p = null;
                    this.q = null;
                    this.dmp1 = null;
                    this.dmq1 = null;
                    this.coeff = null;
                }
                // Set the public key fields N and e from hex strings
                function RSASetPublic(N, E) {
                    if (N != null && E != null && N.length > 0 && E.length > 0) {
                        this.n = parseBigInt(N, 16);
                        this.e = parseInt(E, 16);
                    }
                    else
                        alert("Invalid RSA public key");
                }
                // Perform raw public operation on "x": return x^e (mod n)
                function RSADoPublic(x) {
                    return x.modPowInt(this.e, this.n);
                }
                // Return the PKCS#1 RSA encryption of "text" as an even-length hex string
                /* // encryption currently is not used
                function RSAEncrypt(text) {
                    let m = pkcs1pad2(text,(this.n.bitLength() + 7) >> 3);
                    if (m == null) return null;
                    let c = this.doPublic(m);
                    if (c == null) return null;
                    let h = c.toString(16);
                    if ((h.length & 1) == 0) return h;
                    else return "0" + h;
                }
                */
                // Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string
                //function RSAEncryptB64(text) {
                //  let h = this.encrypt(text);
                //  if(h) return hex2b64(h); else return null;
                //}
                // protected
                RSAKey.prototype.doPublic = RSADoPublic;
                // public
                RSAKey.prototype.setPublic = RSASetPublic;
                //RSAKey.prototype.encrypt = RSAEncrypt;
                //RSAKey.prototype.encrypt_b64 = RSAEncryptB64;
                /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
                /*  SHA-256 implementation in JavaScript                (c) Chris Veness 2002-2014 / MIT Licence  */
                /*                                                                                                */
                /*  - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                              */
                /*        http://csrc.nist.gov/groups/ST/toolkit/examples.html                                    */
                /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
                /**
             * SHA-256 hash function reference implementation.
             *
             * @namespace
             */
                var Sha256 = {};
                Sha256.utf8Encode = function (val) {
                    return window.unescape(encodeURIComponent(val));
                };
                /**
             * Generates SHA-256 hash of string.
             *
             * @param   {string} msg - String to be hashed
             * @returns {string} Hash of msg as hex character string
             */
                Sha256.hash = function (msg) {
                    // convert string to UTF-8, as SHA only deals with byte-streams
                    msg = Sha256.utf8Encode(msg);
                    // constants [Â§4.2.2]
                    var K = [
                        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
                        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
                        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
                        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
                        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
                        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
                        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
                        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
                    ];
                    // initial hash value [Â§5.3.1]
                    var H = [
                        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
                    ];
                    // PREPROCESSING 
                    msg += String.fromCharCode(0x80); // add trailing '1' bit (+ 0's padding) to string [Â§5.1.1]
                    // convert string msg into 512-bit/16-integer blocks arrays of ints [Â§5.2.1]
                    var l = msg.length / 4 + 2; // length (in 32-bit integers) of msg + â€˜1â€™ + appended length
                    var N = Math.ceil(l / 16); // number of 16-integer-blocks required to hold 'l' ints
                    var M = new Array(N);
                    for (var i = 0; i < N; i++) {
                        M[i] = new Array(16);
                        for (var j = 0; j < 16; j++) {
                            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |
                                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));
                        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0
                    }
                    // add length (in bits) into final pair of 32-bit integers (big-endian) [Â§5.1.1]
                    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts
                    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators
                    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32);
                    M[N - 1][14] = Math.floor(M[N - 1][14]);
                    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;
                    // HASH COMPUTATION [Â§6.1.2]
                    var W = new Array(64);
                    var a;
                    var b;
                    var c;
                    var d;
                    var e;
                    var f;
                    var g;
                    var h;
                    for (var i = 0; i < N; i++) {
                        // 1 - prepare message schedule 'W'
                        for (var t = 0; t < 16; t++)
                            W[t] = M[i][t];
                        for (var t = 16; t < 64; t++)
                            W[t] = (Sha256.s1(W[t - 2]) + W[t - 7] + Sha256.s0(W[t - 15]) + W[t - 16]) & 0xffffffff;
                        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value
                        a = H[0];
                        b = H[1];
                        c = H[2];
                        d = H[3];
                        e = H[4];
                        f = H[5];
                        g = H[6];
                        h = H[7];
                        // 3 - main loop (note 'addition modulo 2^32')
                        for (var t = 0; t < 64; t++) {
                            var T1 = h + Sha256.S1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];
                            var T2 = Sha256.S0(a) + Sha256.Maj(a, b, c);
                            h = g;
                            g = f;
                            f = e;
                            e = (d + T1) & 0xffffffff;
                            d = c;
                            c = b;
                            b = a;
                            a = (T1 + T2) & 0xffffffff;
                        }
                        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')
                        H[0] = (H[0] + a) & 0xffffffff;
                        H[1] = (H[1] + b) & 0xffffffff;
                        H[2] = (H[2] + c) & 0xffffffff;
                        H[3] = (H[3] + d) & 0xffffffff;
                        H[4] = (H[4] + e) & 0xffffffff;
                        H[5] = (H[5] + f) & 0xffffffff;
                        H[6] = (H[6] + g) & 0xffffffff;
                        H[7] = (H[7] + h) & 0xffffffff;
                    }
                    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +
                        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);
                };
                /**
             * Rotates right (circular right shift) value x by n positions [Â§3.2.4].
             * @private
             */
                Sha256.ROTR = function (n, x) {
                    return (x >>> n) | (x << (32 - n));
                };
                /**
             * Logical functions [Â§4.1.2].
             * @private
             */
                Sha256.S0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); };
                Sha256.S1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); };
                Sha256.s0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); };
                Sha256.s1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); };
                Sha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); };
                Sha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); };
                /**
             * Hexadecimal representation of a number.
             * @private
             */
                Sha256.toHexStr = function (n) {
                    // note can't use toString(16) as it is implementation-dependant,
                    // and in IE returns signed numbers when used on full words
                    var s = "";
                    var v;
                    for (var i = 7; i >= 0; i--) {
                        v = (n >>> (i * 4)) & 0xf;
                        s += v.toString(16);
                    }
                    return s;
                };
                /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
                /*! rsasign-1.2.7.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license
                    */
                var KJUR = {
                    crypto: {
                        Util: {
                            DIGESTINFOHEAD: {
                                'sha256': "3031300d060960864801650304020105000420"
                            }
                        }
                    }
                };
                var _RE_HEXDECONLY = new RegExp("[^0-9a-f]", "gi");
                function _rsasign_getAlgNameAndHashFromHexDigestInfo(hDigestInfo) {
                    for (var algName in KJUR.crypto.Util.DIGESTINFOHEAD) {
                        var head = KJUR.crypto.Util.DIGESTINFOHEAD[algName];
                        var len = head.length;
                        if (hDigestInfo.substring(0, len) == head) {
                            return [algName, hDigestInfo.substring(len)];
                        }
                    }
                    return [];
                }
                /**
                 * verifies a sigature for a message string with RSA public key.<br/>
                 * @name verifyString
                 * @memberOf RSAKey#
                 * @function
                 * @param {String} sMsg message string to be verified.
                 * @param {String} hSig hexadecimal string of siganture.<br/>
                 *                 non-hexadecimal charactors including new lines will be ignored.
                 * @return returns 1 if valid, otherwise 0
                 */
                function _rsasign_verifyString(sMsg, hSig) {
                    hSig = hSig.replace(_RE_HEXDECONLY, "");
                    hSig = hSig.replace(/[ \n]+/g, "");
                    var biSig = parseBigInt(hSig, 16);
                    if (biSig.bitLength() > this.n.bitLength())
                        return false;
                    var biDecryptedSig = this.doPublic(biSig);
                    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, "");
                    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDigestInfo(hDigestInfo);
                    if (digestInfoAry.length === 0)
                        return false;
                    var diHashValue = digestInfoAry[1];
                    var msgHashValue = Sha256.hash(sMsg);
                    return (diHashValue === msgHashValue);
                }
                RSAKey.prototype.verify = _rsasign_verifyString;
                RSAKey.hash = Sha256.hash;
                return RSAKey;
            })();
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Helpers.ts" />
/// <reference path="core/ChartEvents.ts" />
/// <reference path="core/ChartShell.ts" />
/// <reference path="DomLayer.ts" />
/// <reference path="Resizer.ts" />
/// <reference path="MessagesOverlay.ts" />
/// <reference path="Credits.ts" />
/// <reference path="AssetsLoader.ts" />
/// <reference path="Title.ts" />
/// <reference path="TouchMarkers.ts" />
/// <reference path="Bar/ExportDropdown.ts" />
/// <reference path="Graphics.ts" />
/// <reference path="KeyShortcuts.ts" />
/// <reference path="RsaCrypto.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            /** The base class for all chart implementation classes */
            var Impl = (function () {
                function Impl(settings, scene, api) {
                    var _this = this;
                    this.api = null;
                    this.scene = null;
                    this.settings = null;
                    this.shell = null;
                    this.events = null;
                    this.removed = true;
                    this.assetsLoaded = false;
                    this.toolbar = null;
                    this.data = {};
                    // current state to be pushed in backStack on navigation
                    this.navigator = null;
                    this.curState = null;
                    this.goingBack = false;
                    // chart update notification state
                    this.chartUpdateOrigin = null;
                    this.chartUpdateTimeout = null;
                    this.scene = scene;
                    this.settings = settings;
                    this.api = api;
                    api._impl = this; // early link to impl to make subcharts work
                    this.scene.settings = settings;
                    this.scene.assetsLoader = this.assetsLoader = new Base.AssetsLoader(this);
                    this.data = {};
                    if (this.settings.parentChart) {
                        this.scene.isActive = false;
                        this.shell = new Base.ChartInnerShell(this, this.settings.parentChart._impl.shell);
                        this.events = this.shell.events;
                    }
                    else {
                        this.shell = new Base.ChartOuterShell(this, this.createDomLayer());
                        this.events = this.shell.events;
                        this.events.addElement(new Base.TouchMarkers(this));
                        this.events.addElement(new Base.Resizer(this));
                        this.events.addElement(new Base.Credits(this, this.settings.credits));
                    }
                    window.setTimeout(function () { return Licensing.execute(_this, !!_this.settings.parentChart); }, 500);
                    this.removed = false;
                    /* build events
                    map from event names to event fields in settings.events */
                    this.EVENT_NAMES = {};
                    var name;
                    for (name in settings.events) {
                        // ignore if it does not start with on.
                        if (name.indexOf("on") === 0) {
                            var key = name.charAt(2).toLowerCase() + name.slice(3);
                            this.EVENT_NAMES[name] = key;
                            this.EVENT_NAMES[key] = key;
                        }
                    }
                    // @settings, @scene, @layers must be prepared
                    this.eventListeners = {};
                    this.assetsLoaded = false;
                    this.assetsLoader.ensureAssetsList(this.settings.advanced.assets, function () { return _this.notifyAssetsLoaded(); });
                    this.clearData();
                    this.events.addElement(new Base.KeyShortcuts(this));
                    this.title = this.events.addElement(new Base.Title(this));
                    this.events.addElement(new Base.MessagesOverlay(this));
                }
                Impl.prototype.createDomLayer = function () { return new Base.DomLayer(this); };
                Impl.prototype.updateFilters = function (dataId) {
                    // TODO: make use of dataId
                    this.events.notifySceneChanges({ filters: true });
                };
                Impl.prototype.updateStyle = function (layerId) {
                    // TODO: make use of layerId
                    this.events.notifySceneChanges({ style: true });
                };
                Impl.prototype.defaultDoubleClick = function (domEvent, args) {
                    // a virtual method
                    // TODO: could these be removed?
                };
                Impl.prototype.defaultTripleClick = function (domEvent, args) {
                    // a virtual method
                    // TODO: could these be removed?
                };
                Impl.prototype.defaultClick = function (domEvent, args) {
                    // a virtual method
                    // TODO: could these be removed?
                };
                Impl.prototype.defaultRightClick = function (domEvent, args) {
                    // a virtual method
                    // TODO: could these be removed?
                };
                Impl.prototype.finalInitialize = function () {
                    var sceneChanges = {
                        settings: true,
                        settingsChanges: this.scene.settings,
                        data: {}
                    };
                    this.processChangedSettings(sceneChanges);
                    // notify settings changed
                    this.events.notifySceneChanges(sceneChanges);
                    this.updateSize();
                    // add listeners
                    this.updateEvents(null, this.settings.events);
                };
                /** Retrieves the root chart (based on `settings.parentChart`). */
                Impl.prototype.getRootChart = function () {
                    var pc = this.settings.parentChart;
                    return pc ? pc._impl.getRootChart() : this;
                };
                Impl.prototype.processChangedSettings = function (changes) {
                    // by default this method does nothing. It is currently only used by LinearChart
                };
                Impl.prototype.updateSettings = function (newSettings, origin) {
                    var _this = this;
                    if (origin === void 0) { origin = null; }
                    if (this.removed) {
                        return;
                    }
                    var old = Base.Helpers.clone(this.settings.events);
                    var changes = this.settings.apply(newSettings);
                    var sceneChanges = {
                        settings: true,
                        settingsChanges: changes
                    };
                    this.processChangedSettings(sceneChanges);
                    if (changes.events) {
                        this.updateEvents(old, this.settings.events);
                    }
                    if (changes.advanced && changes.advanced.assets) {
                        this.assetsLoaded = false;
                        this.assetsLoader.ensureAssetsList(this.settings.advanced.assets, function () { return _this.notifyAssetsLoaded(); });
                    }
                    if (changes.data) {
                        // it is actually not correct to use BaseSettings as the "changes" - since arrays with ID values
                        // are acutally returned as dictionaries and not arrays in the change object.
                        this.dataSettingsChanged(changes.data);
                    }
                    this.shell.updateSettings(changes);
                    this.onSettingsChanged(changes);
                    if (changes.toolbar && this.assetsLoaded) {
                        this.createToolbar();
                    }
                    this.events.notifySceneChanges(sceneChanges);
                    var chArea = changes.area;
                    if (chArea && (chArea.width || chArea.height || chArea.maxWidth || chArea.minWidth || chArea.minHeight || chArea.maxHeight)) {
                        this.updateSize(true);
                    }
                    if (origin) {
                        var args = this.createEventArguments(null, origin);
                        args.changes = changes;
                        this.notifySettingsChanged(args);
                    }
                };
                Impl.prototype.getData = function (id) {
                    if (this.data[id]) {
                        return this.data[id];
                    }
                    var dataSettings = this.settings._computedDataMap[id];
                    if (dataSettings) {
                        var data = this.createDataObj(dataSettings);
                        data.applyPreloadedData();
                        this.data[id] = data;
                        return data;
                    }
                    else {
                        throw new Error("No data configured for source ID " + id);
                    }
                };
                Impl.prototype.addData = function (data, sourceId) {
                    if (this.removed) {
                        return;
                    }
                    // addData will fire events
                    this.getData(sourceId).addData(data);
                };
                Impl.prototype.reloadData = function (sourceId, deep) {
                    if (sourceId === void 0) { sourceId = null; }
                    if (deep === void 0) { deep = false; }
                    if (this.removed) {
                        return;
                    }
                    this.log("Reload data");
                    if (!sourceId) {
                        this.clearData();
                    }
                    else {
                        if (this.data[sourceId]) {
                            this.data[sourceId].remove();
                            delete this.data[sourceId];
                        }
                    }
                    this.scene.mainData = this.getData(this.settings.data[0].id);
                    var dataChanges = {};
                    for (var k in this.settings._computedDataMap)
                        dataChanges[k] = true;
                    this.events.notifySceneChanges({ data: dataChanges, dataDeep: deep });
                    if (this.navigator) {
                        // TODO: all charts should have navigator
                        this.navigator.onNewDataObject();
                    }
                };
                Impl.prototype.replaceData = function (data, sourceId) {
                    if (sourceId === void 0) { sourceId = "default"; }
                    if (sourceId == null)
                        sourceId = "default"; // ported from CoffeeScript;
                    if (this.removed) {
                        return;
                    }
                    this.events.clearSceneChanges({ dataArrived: null });
                    if (this.data[sourceId]) {
                        this.data[sourceId].remove();
                    }
                    // create new data without preloaded values
                    var dataObj = this.data[sourceId] = this.createDataObj(this.settings._computedDataMap[sourceId]);
                    dataObj.addData(data);
                    this.scene.mainData = this.getData(this.settings.data[0].id);
                    var dataChanges = {};
                    dataChanges[sourceId] = true;
                    this.events.notifySceneChanges({ data: dataChanges });
                    if (this.navigator) {
                        // TODO: all charts should have navigator
                        this.navigator.onNewDataObject();
                    }
                };
                Impl.prototype.clearData = function (final) {
                    if (final === void 0) { final = false; }
                    for (var key in this.data) {
                        var val = this.data[key];
                        val.remove();
                    }
                    this.events.clearSceneChanges({ dataArrived: null });
                    this.data = {};
                    this.scene.mainData = null;
                    if (!final) {
                        this.scene.mainData = this.getData(this.settings.data[0].id);
                    }
                };
                Impl.prototype.dataSettingsChanged = function (dataChanges) {
                    // Remove nonexistant or updated data
                    for (var key in this.data) {
                        if (dataChanges[key] || !this.settings._computedDataMap[key]) {
                            this.data[key].remove();
                            delete this.data[key];
                        }
                    }
                    // TODO: should clear only for specific data sources
                    this.events.clearSceneChanges({ dataArrived: null });
                    this.events.notifySceneChanges({ data: dataChanges, dataDeep: true });
                    this.scene.mainData = this.getData(this.settings.data[0].id);
                    if (this.navigator) {
                        // TODO: all charts should have navigator
                        this.navigator.onNewDataObject();
                    }
                };
                Impl.prototype.hasPendingRequests = function () {
                    if (!this.assetsLoaded) {
                        return true;
                    }
                    if (this.assetsLoader.hasPendingRequests()) {
                        return true;
                    }
                    for (var id in this.data) {
                        if (this.data[id].hasPendingRequests()) {
                            return true;
                        }
                    }
                    return false;
                };
                Impl.prototype.remove = function () {
                    if (this.removed) {
                        Base.Helpers.warn("Removing already removed chart");
                        return;
                    }
                    this.cancelChartUpdateNotify();
                    this.removed = true;
                    if (this.toolbar) {
                        this.toolbar.remove();
                    }
                    this.shell.remove();
                    this.clearData(true);
                    this.shell = null;
                    this.scene = null;
                    this.events = null;
                };
                Impl.prototype.setFullscreen = function (enabled) {
                    this.shell.setFullscreen(enabled);
                };
                Impl.prototype.isFullscreen = function () {
                    return this.shell.fullScreenMode;
                };
                Impl.prototype.updateSize = function (force) {
                    if (force === void 0) { force = false; }
                    if (this.removed) {
                        return;
                    }
                    this.shell.updateSize(force);
                };
                Impl.prototype.on = function (eventName, handler) {
                    var event = this.EVENT_NAMES[eventName];
                    if (!event) {
                        this.error("Unrecognized event name: " + eventName);
                        return;
                    }
                    if (!this.eventListeners[event]) {
                        this.eventListeners[event] = [];
                    }
                    this.eventListeners[event].push(handler);
                };
                Impl.prototype.off = function (eventName, handler) {
                    var event = this.EVENT_NAMES[eventName];
                    if (!event) {
                        this.error("Unrecognized event name: " + eventName);
                        return;
                    }
                    if (this.eventListeners[event]) {
                        return Base.Helpers.removeFromArray(this.eventListeners[event], handler);
                    }
                };
                Impl.prototype.updateEvents = function (oldSettings, newSettings) {
                    var o = oldSettings;
                    var n = newSettings;
                    for (var prop in this.EVENT_NAMES) {
                        var event = this.EVENT_NAMES[prop];
                        if (oldSettings && o[prop]) {
                            this.off(event, o[prop]);
                        }
                        if (n[prop]) {
                            this.on(event, n[prop]);
                        }
                    }
                };
                Impl.prototype.notifyHoverChanged = function (event, args) {
                    this.dispatchEvent("hoverChange", event, args, null);
                };
                Impl.prototype.notifyDoubleClick = function (event, args) {
                    var _this = this;
                    this.dispatchEvent("doubleClick", event, args, function (e, a) { return _this.defaultDoubleClick(e, a); });
                };
                Impl.prototype.notifyTripleClick = function (event, args) {
                    var _this = this;
                    this.dispatchEvent("tripleClick", event, args, function (e, a) { return _this.defaultTripleClick(e, a); });
                };
                Impl.prototype.notifyRightClick = function (event, args) {
                    var _this = this;
                    this.dispatchEvent("rightClick", event, args, function (e, a) { return _this.defaultRightClick(e, a); });
                };
                Impl.prototype.notifyClick = function (event, args) {
                    var _this = this;
                    this.dispatchEvent("click", event, args, function (e, a) { return _this.defaultClick(e, a); });
                };
                Impl.prototype.notifySelectionChanged = function (args) {
                    return this.dispatchEventParams("selectionChange", args, null);
                };
                Impl.prototype.notifySettingsChanged = function (args) {
                    return this.dispatchEventParams("settingsChange", args, null);
                };
                Impl.prototype.notifyPositionChange = function (args) {
                    return this.dispatchEventParams("positionChange", args, null);
                };
                /** Pushes the navigation state unto the undo stack and fires a notification event. */
                Impl.prototype.notifyChartUpdate = function (origin, force) {
                    var _this = this;
                    if (force === void 0) { force = false; }
                    var time = Base.Helpers.performanceNow();
                    if (force) {
                        this.chartUpdateForce = true;
                    }
                    if (origin) {
                        this.chartUpdateWasBack = this.goingBack;
                        this.chartUpdateOrigin = origin;
                        this.chartUpdateTime = time;
                    }
                    this.chartUpdateState = this.saveNavigation();
                    if (this.chartUpdateTimeout === null) {
                        // use setTimeout even if it is 0 so that the event handler is executed after the current frame
                        this.chartUpdateTimeout = setTimeout(function () { return _this.chartUpdateNotify(); }, this.chartUpdateTime + this.scene.settings.events.chartUpdateDelay - time);
                    }
                };
                Impl.prototype.cancelChartUpdateNotify = function () {
                    this.chartUpdateOrigin = null;
                    if (this.chartUpdateTimeout) {
                        clearTimeout(this.chartUpdateTimeout);
                        this.chartUpdateTimeout = null;
                    }
                };
                Impl.prototype.chartUpdateNotify = function () {
                    this.chartUpdateTimeout = null;
                    var origin = this.chartUpdateOrigin;
                    if (!origin) {
                        return;
                    }
                    // full navigation data not available at this moment
                    var state = this.chartUpdateState;
                    if (state && (!this.curState || JSON.stringify(state) !== JSON.stringify(this.curState))) {
                        this.chartUpdateForce = false;
                        // save state in back stack
                        if (!this.chartUpdateWasBack && this.curState) {
                            this.scene.pushBack(this.curState);
                            // this is required because the BackButton listens to onSceneChange to see if it should enable itself
                            this.events.notifySceneChanges({ requestPaint: true });
                        }
                        this.curState = state;
                        this.chartUpdateOrigin = null;
                        this.chartUpdateState = null;
                        this.doChartUpdateNotify(origin);
                    }
                    else if (this.chartUpdateForce) {
                        this.chartUpdateForce = false;
                        this.chartUpdateOrigin = null;
                        this.chartUpdateState = null;
                        this.doChartUpdateNotify(origin);
                    }
                };
                Impl.prototype.doChartUpdateNotify = function (origin) {
                    var args = this.createEventArguments(null, origin);
                    this.dispatchEventParams("chartUpdate", args, null);
                };
                Impl.prototype.back = function (animate, origin) {
                    if (animate === void 0) { animate = true; }
                    if (origin === void 0) { origin = "api"; }
                    if (this.scene.backStack.length === 0) {
                        return false;
                    }
                    var state = this.scene.backStack.pop();
                    this.goingBack = true;
                    this.restoreNavigation(state, animate, origin);
                    this.goingBack = false;
                    return true;
                };
                Impl.prototype.goHome = function (animate, origin) {
                    if (animate === void 0) { animate = true; }
                    if (origin === void 0) { origin = "api"; }
                    if (this.scene.backStack.length === 0) {
                        return false;
                    }
                    var state = this.scene.backStack[0];
                    this.restoreNavigation(state, animate, origin);
                    return true;
                };
                Impl.prototype.clearHistory = function () {
                    this.scene.backStack = [];
                    return true;
                };
                Impl.prototype.dispatchEventParams = function (name, args, defaultFunc) {
                    var event = new Base.MouseEvent(0, 0, Base.Helpers.performanceNow(), "api");
                    if (!defaultFunc && (!this.eventListeners[name] || !this.eventListeners[name].length))
                        return event;
                    this.dispatchEvent(name, event, args, defaultFunc);
                    return event;
                };
                Impl.prototype.dispatchEvent = function (name, event, args, defaultFunc) {
                    if (!(defaultFunc || (this.eventListeners[name] && this.eventListeners[name].length > 0)))
                        return;
                    // TODO: this will have to be removed in 2.0 - for now to maintain backwards compatibility, all extra properties from args are copied into event
                    for (var key in args) {
                        if (args.hasOwnProperty(key))
                            event[key] = args[key];
                    }
                    if (this.eventListeners[name]) {
                        for (var lIndex = 0; lIndex < this.eventListeners[name].length; lIndex++) {
                            var l = this.eventListeners[name][lIndex];
                            this.log("Call user event handler, " + name, event, args);
                            l.call(this.api, event, args);
                        }
                    }
                    if (!event.defaultPrevented && defaultFunc) {
                        this.log("Call default event handler, " + name);
                        defaultFunc.call(this.api, event, args);
                    }
                };
                Impl.prototype.error = function (msg, arg) {
                    var _this = this;
                    if (arg === void 0) { arg = null; }
                    var args = this.createEventArguments(null, "api");
                    args.message = msg;
                    args.arg = arg;
                    this.dispatchEventParams("error", args, function (e, a) { return _this.defaultError(e, a); });
                };
                Impl.prototype.log = function (msg) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    if (this.settings.advanced.logging) {
                        Base.Helpers.log(msg, args);
                    }
                };
                /** Logs a message informing the user that a method has been deprecated. */
                Impl.prototype.deprecated = function (oldFunctionName, newFunctionName) {
                    var str = "Deprecated: " + oldFunctionName + ".";
                    if (newFunctionName)
                        str += " Use " + newFunctionName + " instead";
                    Base.Helpers.warn(str);
                };
                Impl.prototype.defaultError = function (event, args) {
                    if (args.arg) {
                        Base.Helpers.error(args.message, args.arg);
                    }
                    else {
                        Base.Helpers.error(args.message);
                    }
                };
                Impl.prototype.createToolbar = function () {
                    if (this.toolbar)
                        this.toolbar.remove();
                    if (this.assetsLoaded) {
                        this.toolbar = new Base.Toolbar(this, this.settings.toolbar);
                    }
                };
                /** Called whenever the assets defined in the settings are loaded. Note that this can happen
                multiple times if the assets are updated with `updateSettings()`. */
                Impl.prototype.notifyAssetsLoaded = function () {
                    if (this.removed)
                        return;
                    this.assetsLoaded = true;
                    this.createToolbar();
                    this.updateSize(true);
                    this.events.notifySceneChanges({ assets: true, style: true });
                };
                return Impl;
            }());
            Base.Impl = Impl;
            var LicensingChartType;
            (function (LicensingChartType) {
                LicensingChartType[LicensingChartType["FacetChart"] = 1] = "FacetChart";
                LicensingChartType[LicensingChartType["GeoChart"] = 2] = "GeoChart";
                LicensingChartType[LicensingChartType["NetChart"] = 4] = "NetChart";
                LicensingChartType[LicensingChartType["PieChart"] = 8] = "PieChart";
                LicensingChartType[LicensingChartType["TimeChart"] = 16] = "TimeChart";
            })(LicensingChartType || (LicensingChartType = {}));
            var _licenseWrittenToConsole = false;
            var _licenseVerification = {};
            var Licensing = (function () {
                function Licensing() {
                }
                /** Verifies if the license allows the use of the specified chart type. */
                Licensing.checkChartType = function (typeName, license) {
                    var i = license.lastIndexOf("-", license.indexOf(":"));
                    // if the license does not specify the valid chart types, it includes all chart types.
                    if (i === -1 || i === license.indexOf("-"))
                        return true;
                    var c;
                    var valid = 0;
                    i++;
                    while ((c = license.charCodeAt(i)) > 47 && c < 58) {
                        valid = valid * 10 + c - 48;
                        i++;
                    }
                    // see https://github.com/Microsoft/TypeScript/issues/592 why <any> is required here
                    var current = LicensingChartType[typeName];
                    /* tslint:disable:no-bitwise-smart */
                    return current > 0 && (valid & current) === current;
                    /* tslint:enable:no-bitwise-smart */
                };
                Licensing.execute = function (chart, nestedChart) {
                    var _this = this;
                    var license = window.ZoomChartsLicense;
                    var key = window.ZoomChartsLicenseKey;
                    var typeName = chart.api.typeName;
                    var verificationKey = license + Base.Helpers.SeparatorChar + typeName;
                    var verification = _licenseVerification[verificationKey];
                    if (verification) {
                        if (verification.result) {
                            // the license check was issued before
                            this.handleServerResponse([chart], verification.result);
                        }
                        else {
                            // the license check is in progress.
                            verification.charts.push(chart);
                        }
                        return;
                    }
                    // the license is being verified for the first time
                    _licenseVerification[verificationKey] = verification = { charts: [chart], result: null };
                    var zcv = "ZoomCharts " + ZoomCharts.PackageInfo.Version;
                    if (!license || !key) {
                        Base.Helpers.error(zcv + " license key was not found on the page. " +
                            "Please make sure ZoomChartsLicense and ZoomChartsLicenseKey variables are correctly set before initializing the chart.");
                        license = key = "---:";
                    }
                    else if (!Base.RsaCrypto.verifySignature(license, key)) {
                        Base.Helpers.error(zcv + (" license key for license '" + license + "' is invalid. Please configure the correct key in order to use the charts."));
                    }
                    else if (!_licenseWrittenToConsole) {
                        Base.Helpers.log(zcv + " license verified: " + license);
                        _licenseWrittenToConsole = true;
                    }
                    var upgradeNotice = ". Please upgrade your license on https://zoomcharts.com";
                    var mode = license.charAt(2);
                    if (!this.checkChartType(typeName, license)) {
                        Base.Helpers.error("ZoomCharts license used on this page does not allow use of " + typeName + upgradeNotice);
                        mode = "-";
                        if (nestedChart) {
                            this.displayBanner(chart, "builtin://logo-development");
                            return;
                        }
                    }
                    /*
                    Possible license modes:
                     F - full/unlimited license, no requests to the API
                     O - OEM license, same as F, no requests to the API
                     S - sandbox (development and QA only), always shows a banner
                     P - paid subscription, banner only if returned from the server
                     X - free license (always a banner - supported by ZC)
                     B - paid subscription, without server request, must contain a valid-until date.
                    */
                    var dateRegex = /(\d\d\d\d-\d\d-\d\d)$/;
                    var fallbackShowBanner = "builtin://logo-supported-by";
                    /** The banner that will be shown if an error is detected that looks like the page is preventing license
                    checks on purpose (for example, by setting Content-Security-Policy). */
                    var securityErrorShowBanner = fallbackShowBanner;
                    switch (mode) {
                        case "F":
                        case "O":
                            var licenseValidUntil = license.match(dateRegex);
                            var pb = ZoomCharts.PackageInfo.Built;
                            if (licenseValidUntil && licenseValidUntil[1] < pb) {
                                verification.result = {
                                    status: 2,
                                    bannerImage: fallbackShowBanner,
                                    consoleMessages: [{
                                            level: "error",
                                            text: "ZoomCharts license is not valid for this library version which was released on " + pb + upgradeNotice
                                        }]
                                };
                                this.handleServerResponse(verification.charts, verification.result);
                            }
                            else {
                                verification.result = { status: 1 };
                                verification.charts = [];
                            }
                            // full license does not perform ping requests to the server
                            return;
                        case "B":
                            var validUntil = license.match(dateRegex);
                            var bTarget = "https://zoomcharts.com/en/renew-licence/";
                            if (validUntil && validUntil[1] < new Date().toISOString()) {
                                verification.result = {
                                    status: 2,
                                    bannerImage: "builtin://logo-license-expired",
                                    consoleMessages: [{
                                            level: "error",
                                            text: "ZoomCharts license has expired on " + validUntil[1] + ". Please renew the license at " + bTarget
                                        }],
                                    bannerTarget: bTarget
                                };
                                this.handleServerResponse(verification.charts, verification.result);
                            }
                            else {
                                verification.result = { status: 1 };
                                verification.charts = [];
                            }
                            // B licences also do not perform the ping request.
                            return;
                        case "-":
                        case "S":
                            // if license key is not provided, assume development license
                            fallbackShowBanner = "builtin://logo-development";
                            break;
                        case "X":
                            // using "builtin://logo-supported-by" set by default
                            break;
                        default:
                        case "P":
                            fallbackShowBanner = null;
                            break;
                    }
                    var msg = JSON.stringify({
                        protocol: 1,
                        version: ZoomCharts.PackageInfo.Version,
                        revision: ZoomCharts.PackageInfo.Revision,
                        libraryName: ZoomCharts.PackageInfo.LibraryName,
                        assetsDomain: this.parseUriDomain(chart.assetsLoader.getAssetUrl("assets://")),
                        pageDomain: location.hostname,
                        chartType: typeName,
                        license: license.substring(0, license.indexOf(":")),
                        licenseKeyHash: Base.RsaCrypto.hash(key)
                    }, null, " ");
                    Base.Helpers.doPostRequest(chart.assetsLoader.getAssetUrl("https://api.zoomcharts-cloud.com/lc/v1/"), 30000, msg, function (result) {
                        try {
                            var data = JSON.parse(result);
                            if (data.protocol !== 1)
                                throw "Server response contains invalid protocol.";
                            var verificationInner = _licenseVerification[verificationKey];
                            verificationInner.result = data;
                            _this.handleServerResponse(verificationInner.charts, verificationInner.result);
                        }
                        catch (ex) {
                            _this.handleServerError(chart, "Unable to parse licensing server response: " + ex);
                            if (fallbackShowBanner)
                                _this.displayBanner(chart, fallbackShowBanner);
                            // reset the aggregated verification status
                            delete _licenseVerification[verificationKey];
                        }
                    }, function (result) {
                        result = result || "";
                        // reset the aggregated verification status
                        delete _licenseVerification[verificationKey];
                        _this.handleServerError(chart, "Unable to contact licensing server: " + result);
                        // 0x805E0006 - the result code on Firefox for the security errors
                        if ((result.result === 0x805E0006) ||
                            (result instanceof DOMException
                                && result.code === DOMException.SECURITY_ERR
                                || result.name === "SecurityError")) {
                            fallbackShowBanner = securityErrorShowBanner;
                        }
                        if (fallbackShowBanner)
                            _this.displayBanner(chart, fallbackShowBanner);
                    });
                };
                Licensing.displayBanner = function (chart, image, target) {
                    if (chart.removed)
                        return;
                    var settings = new Base.SettingsCredits();
                    if (target)
                        settings.url = target;
                    settings.imageScaling = 0.5;
                    settings.image = image;
                    settings.enabled = true;
                    settings.enabledOnExport = true;
                    settings.location = "inside";
                    chart.events.addElement(new Base.Credits(chart, settings));
                    chart.events.notifySceneChanges({ settings: true, settingsChanges: { credits: { enabled: settings.enabled } } });
                };
                Licensing.handleServerError = function (chart, error) {
                    chart.error(error);
                };
                Licensing.handleServerResponse = function (charts, data) {
                    if (data === null)
                        return;
                    if (data.consoleMessages) {
                        for (var i = 0; i < data.consoleMessages.length; i++) {
                            var cm = data.consoleMessages[i];
                            switch (cm.level) {
                                case "error":
                                    Base.Helpers.error(cm.text);
                                    break;
                                case "warn":
                                    Base.Helpers.warn(cm.text);
                                    break;
                                default:
                                case "info":
                                    Base.Helpers.log(cm.text);
                                    break;
                            }
                        }
                    }
                    for (var i = 0; i < charts.length; i++) {
                        var chart = charts[i];
                        if (chart.removed)
                            continue;
                        if (data.status === 1) {
                        }
                        else if (data.status === 2) {
                            this.displayBanner(chart, data.bannerImage, data.bannerTarget);
                        }
                        else if (data.status === 3) {
                            // block the chart
                            this.blockChart(chart, "<a href=\"" + data.bannerTarget + "\"><img src=\"" + data.bannerImage + "\" title=\"Problem with the license\"/></a>");
                        }
                        else {
                            Base.Helpers.warn("Licensing server returned unknown status code " + data.status);
                            break;
                        }
                    }
                    // clear the collected charts to avoid memory leak
                    charts.length = 0;
                };
                Licensing.parseUriDomain = function (uri) {
                    var a = document.createElement("a");
                    a.href = uri;
                    // special case for relative URIs
                    if (!a.hostname)
                        a.href = a.href;
                    return a.hostname;
                };
                Licensing.blockChart = function (chart, message) {
                    var container = chart.settings.container;
                    chart.remove();
                    container.innerHTML = "<strong>Unable to use ZoomCharts library because of a licensing issue:</strong><br/>" + message;
                };
                return Licensing;
            }());
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Export.ts" />
/// <reference path="Impl.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var Api = (function () {
                function Api() {
                }
                /** Applies one of the built-in themes to the chart. This is an alternative to calling
                `updateSettings({ theme: ZoomCharts.$this.themes.dark })`. */
                Api.prototype.customize = function (
                    /**The name of the theme to be applied, must be one of the values defined in the `$this.themes` static property. */ name) {
                    var themes = this.constructor.themes;
                    if (!themes.hasOwnProperty(name)) {
                        throw new Error("The chart does not contain a predefined theme named `" + name + "`.");
                    }
                    return this.updateSettings(themes[name]);
                };
                Api.prototype.saveState = function () {
                    return this._impl.save();
                };
                Api.prototype.restoreState = function (state, animate) {
                    if (animate === void 0) { animate = false; }
                    if (animate == null)
                        animate = false; // ported from CoffeeScript;
                    this._impl.restore(state, animate);
                };
                Api.prototype.fullscreen = function (isFullscreen) {
                    if (isFullscreen === true) {
                        this._impl.setFullscreen(true);
                    }
                    else if (isFullscreen === false) {
                        this._impl.setFullscreen(false);
                    }
                    return this._impl.isFullscreen();
                };
                /** Updates the chart settings. Only the settings that have to be changed should be passed. Note that some arrays
                and dictionaries (such as `data`) are merged by the ID values - if instead they should be replaced, use
                [`replaceSettings()`](#doc_replaceSettings) method. */
                Api.prototype.updateSettings = function (changes) {
                    if (changes)
                        this._impl.updateSettings(changes, "api");
                    return this;
                };
                /** Updates the chart settings but instead of merging some settings that are arrays or dictionaries (such as `data`)
                these collections are replaced completely. For example, this allows removal of series or value axis within TimeChart.
                @version !important 1.10.0 */
                Api.prototype.replaceSettings = function (changes) {
                    if (changes) {
                        var sh = Internal.Base.SettingsHelper;
                        try {
                            sh.replacingSettings = true;
                            this._impl.updateSettings(changes, "api");
                        }
                        finally {
                            sh.replacingSettings = false;
                        }
                    }
                    return this;
                };
                /**
                 * Re-evaluate data filters on next paint.
                 */
                Api.prototype.updateFilters = function () {
                    this._impl.updateFilters(null);
                };
                /**
                 * Re-evaluate style for all objects on next paint.
                 */
                Api.prototype.updateStyle = function () {
                    this._impl.updateStyle(null);
                };
                Api.prototype.on = function (name, listener) {
                    this._impl.on(name, listener);
                };
                /** Removes an event listener that was added by a call to `on` or by specifying it in settings.
                Note that the listener must be the exact same reference, which means that anonymous functions should not be used in call to `on`.
                @param name - the type of the event. Please see the documentation for `on` about valid values.
                @returns `true` if the listener was removed, `false` if the listener was not previously registered. */
                Api.prototype.off = function (name, listener) {
                    return this._impl.off(name, listener);
                };
                /** Call when the container size has been changed to update the chart. */
                Api.prototype.updateSize = function () {
                    this._impl.updateSize(true);
                    return this;
                };
                /** Clears data cache and loads new data. The current view is preserved. */
                Api.prototype.reloadData = function (sourceId) {
                    if (sourceId === void 0) { sourceId = null; }
                    return this._impl.reloadData(sourceId);
                };
                /** Removes chart from DOM. This method is automatically called when you create a new chart within the same container element.
        
                This method should always be called when the chart HTML element is removed as otherwise there might be additional resources such
                as event handlers remaining that will prevent the browser from properly releasing memory. */
                Api.prototype.remove = function () {
                    return this._impl.remove();
                };
                /** Saves the current chart state as an image.
                @returns A base64 encoded data-URI that contains the image data. This URI can be used as the image source in `<img src="">`.
                @deprecated - use `exportAsString` instead*/
                Api.prototype.saveAsImage = function (type, dimensions, transparent) {
                    this._impl.deprecated("saveAsImage", "exportAsString");
                    return this.exportImageAsString(type, dimensions, transparent);
                };
                /** Returns the dimensions for the image exported with `exportImageAsString`.
                @deprecated - use `exportImageGetDimensions` instead */
                Api.prototype.exportGetDimensions = function (dimensions) {
                    this._impl.deprecated("exportGetDimensions", "exportImageGetDimensions");
                    return this.exportImageGetDimensions(dimensions);
                };
                /** Saves the current chart state as an image.
        
                Note that this method does not support custom DPI setting, for that `exportAsString` method has to be used.
                @returns A base64 encoded data-URI that contains the image data. This URI can be used as the image source in `<img src="">`.
                @deprecated - use `exportAsString` instead.
                */
                Api.prototype.exportImageAsString = function (type, dimensions, transparent) {
                    this._impl.deprecated("exportImageAsString", "exportAsString");
                    return Base.Export.export(this._impl, type, dimensions, transparent, function () { });
                };
                /** Returns the dimensions for the image exported with `exportImageAsString`. */
                Api.prototype.exportImageGetDimensions = function (dimensions) {
                    /* returns export image dimensions: [width, height, scale]
                    params the same as saveAsImage
                    scale is upscaling factor from currently displayed image */
                    return Base.Export.getDimensions(this._impl, dimensions);
                };
                /** Saves the current chart state as a data-URI.
        
                If image type is specified, the URI can be used as the image source in `<img src="">`.
        
                Note that some output settings might require sending the data to a proxy. When handling sensitive data you should install the proxy
                on your own server, see `advanced.exportProxyURL` setting.
                */
                Api.prototype.exportAsString = function (
                    /** The format in which the data will be exported. */
                    type, 
                    /** The callback that will be invoked once the result is generated. */
                    callback, 
                    /** Specifies the dimensions for the image formats. */
                    dimensions, 
                    /** Specifies if the resulting image should have transparent background. This setting is only valid for `png` image format. Default is `false`.
                    
                    Note that if `area.style.fillColor` is set, this will have no effect. */
                    transparent) {
                    if (transparent === void 0) { transparent = false; }
                    if (!callback)
                        throw new Error("`callback` argument is mandatory.");
                    Base.Export.export(this._impl, type, dimensions, transparent, callback);
                };
                /** Launches a file download that contains an image or the data of the current state of the chart.
                
                Note that in some browsers calling this method will send the data to a proxy. When handling sensitive data you should install the proxy
                on your own server, see `advanced.exportProxyURL` setting. */
                Api.prototype.export = function (
                    /** The format in which the data will be exported. */
                    type, 
                    /** Specifies the dimensions for the image formats. */
                    dimensions, 
                    /** Specifies if the resulting image should have transparent background. This setting is only valid for `png` image format. Default is `false`.
        
                    Note that if `area.style.fillColor` is set, this will have no effect.
                    @version 1.12.0 - default changed to `false` */
                    transparent) {
                    if (transparent === void 0) { transparent = false; }
                    Base.Export.download(this._impl, type, dimensions, transparent);
                };
                /**
                 * @deprecated use settings.parentChart instead.
                 */
                Api.prototype.addSubchartContainer = function (container) {
                    this._impl.shell.interactiveContainer.appendChild(container);
                };
                /**
                 * Suspends the animation of the chart until `resumePaint()` is called.
                 *
                 * This should be used when the chart element is hidden from the user to conserve browser resources.
                 *
                 * Note that if `suspendPaint()` is called multiple time then `resumePaint()` has to be called the same number of times.
                 * @experimental
                 */
                Api.prototype.suspendPaint = function () {
                    this._impl.events.suspendPaint();
                };
                /**
                 * Decrements the suspend counter that was set using `suspendPaint()` method.
                 *
                 * This method also automatically schedules an async repaint.
                 * @experimental
                 */
                Api.prototype.resumePaint = function () {
                    this._impl.events.resumePaint();
                };
                /** Does immediate repaint. Use to sync updates between multiple charts. */
                Api.prototype.paintNow = function (force) {
                    if (force === void 0) { force = false; }
                    this._impl.events.paintNow(force);
                    return this;
                };
                Api.prototype.back = function () {
                    this._impl.back();
                    return this;
                };
                Api.prototype.home = function () {
                    return this._impl.goHome();
                };
                Api.prototype.clearHistory = function () {
                    this._impl.clearHistory();
                    return this;
                };
                Api.prototype.profiler = function () {
                    return this._impl.shell.profiler;
                };
                /**
                @deprecated
                @ignore*/
                Api.prototype.measureFps = function (iters, callback) {
                    this._impl.deprecated("measureFps");
                    this.profiler().measureFps(iters, callback);
                };
                /** Lists the predefined themes for the chart. These can be used within the settings objects or via the `customize()` method:
                
                ```javascript
                var chart = new ZoomCharts.$this({ theme: ZoomCharts.$this.themes.dark });
                chart.updateSettings({ theme: ZoomChart.$this.themes.dark });
                chart.customize("dark");
                ```*/
                Api.themes = {};
                return Api;
            }());
            Base.Api = Api;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Toolbar.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var Bar;
            (function (Bar) {
                var BackButton = (function (_super) {
                    __extends(BackButton, _super);
                    function BackButton() {
                        _super.apply(this, arguments);
                    }
                    BackButton.prototype.onSceneChange = function (changes) {
                        _super.prototype.onSceneChange.call(this, changes);
                        var enabled = this.chart.scene.backStack.length > 0;
                        var opt = this.options;
                        if (opt.enabled !== enabled) {
                            opt.enabled = enabled;
                            this.updateSettings();
                        }
                    };
                    return BackButton;
                }(Bar.Button));
                Bar.ToolbarItemNames["back"] = function (chart, options) {
                    var localization = chart.settings.localization.toolbar;
                    options.label = options.label || localization.backButton;
                    options.title = options.title || localization.backTitle;
                    options.cssClass = options.cssClass || "DVSL-bar-btn-back";
                    var userClick = options.onClick;
                    options.onClick = function (ev, api) {
                        chart.back(true, "user");
                        if (userClick)
                            userClick(ev, api);
                    };
                    return new BackButton(chart, options);
                };
            })(Bar = Base.Bar || (Base.Bar = {}));
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Toolbar.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var Bar;
            (function (Bar) {
                Bar.ToolbarItemNames["fullscreen"] = function (chart, options) {
                    var localization = chart.settings.localization.toolbar;
                    return new Base.Bar.ToggleButton(chart, options, {
                        labelDisabled: options.label || localization.fullscreenButton,
                        titleDisabled: options.title || localization.fullscreenTitle,
                        cssClassEnabled: "DVSL-bar-btn-fullscreen-active",
                        cssClassDisabled: options.cssClass || "DVSL-bar-btn-fullscreen",
                        onEnable: function () { return chart.setFullscreen(true); },
                        onDisable: function () { return chart.setFullscreen(false); },
                        getChartState: function () { return chart.isFullscreen(); }
                    });
                };
            })(Bar = Base.Bar || (Base.Bar = {}));
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Toolbar.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var Bar;
            (function (Bar) {
                var ZoomOutButton = (function (_super) {
                    __extends(ZoomOutButton, _super);
                    function ZoomOutButton() {
                        _super.apply(this, arguments);
                    }
                    ZoomOutButton.prototype.onSceneChange = function (changes) {
                        _super.prototype.onSceneChange.call(this, changes);
                        var enabled = this.chart.zoomOutPossible();
                        var opt = this.options;
                        if (opt.enabled !== enabled) {
                            opt.enabled = enabled;
                            this.updateSettings();
                        }
                    };
                    return ZoomOutButton;
                }(Bar.Button));
                Bar.ToolbarItemNames["zoomOut"] = function (chart, options) {
                    var localization = chart.settings.localization.toolbar;
                    options.label = options.label || localization.zoomoutButton;
                    options.title = options.title || localization.zoomoutTitle;
                    options.cssClass = options.cssClass || "DVSL-bar-btn-zoomout";
                    var userClick = options.onClick;
                    options.onClick = function (ev, api) {
                        chart.zoomOut(true, "user");
                        if (userClick)
                            userClick(ev, api);
                    };
                    return new ZoomOutButton(chart, options);
                };
            })(Bar = Base.Bar || (Base.Bar = {}));
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var pi2 = Math.PI * 2;
            var Geometry = (function () {
                function Geometry() {
                }
                Geometry.distanceToSegmentSq = function (x1, y1, x2, y2, x, y) {
                    // code from http://stackoverflow.com/a/6853926/1711598
                    var A = x - x1;
                    var B = y - y1;
                    var C = x2 - x1;
                    var D = y2 - y1;
                    var dot = A * C + B * D;
                    var len_sq = C * C + D * D;
                    var param = -1;
                    if (len_sq !== 0)
                        param = dot / len_sq;
                    var xx;
                    var yy;
                    if (param < 0) {
                        xx = x1;
                        yy = y1;
                    }
                    else if (param > 1) {
                        xx = x2;
                        yy = y2;
                    }
                    else {
                        xx = x1 + param * C;
                        yy = y1 + param * D;
                    }
                    var dx = x - xx;
                    var dy = y - yy;
                    return dx * dx + dy * dy;
                };
                /**
                 * returns coefficient along rdx,rdy to intersect the line
                 * @param rx - X coordinate of starting point of ray
                 * @param ry - Y coordinate of starting point of ray
                 * @param rdx - X projection of the ray direction vector
                 * @param rdy - Y projection of the ray direction vector
                 * @param lx - X coordinate of the line starting point
                 * @param ly - Y coordinate of the line starting point
                 * @param lx1 - X coordinate of the line ending point
                 * @param ly1 - Y coordinate of the line ending point
                 * @returns {number} - The distance traveled from the starting point until intersection, expressed as a fraction of the direction vector length
                 */
                Geometry.rayIntersectsSegment = function (rx, ry, rdx, rdy, lx, ly, lx1, ly1) {
                    var coef = Infinity;
                    var ldx = lx1 - lx;
                    var ldy = ly1 - ly;
                    var div = rdx * ldy - rdy * ldx;
                    if (div !== 0) {
                        var tr = (ry * ldx - rx * ldy + lx * ldy - ly * ldx) / div;
                        var tl = void 0;
                        if (Math.abs(ldx) > Math.abs(ldy)) {
                            tl = (rx + rdx * tr - lx) / ldx;
                        }
                        else {
                            tl = (ry + rdy * tr - ly) / ldy;
                        }
                        if (tl >= 0 && tl <= 1 && tr >= 0) {
                            coef = tr;
                        }
                    }
                    return coef;
                };
                /** returns coefficeint along rdx,rdy to intersect the line */
                Geometry.lineIntersectsSegment = function (rx, ry, rdx, rdy, lx, ly, lx1, ly1) {
                    var coef = Infinity;
                    var ldx = lx1 - lx;
                    var ldy = ly1 - ly;
                    var div = rdx * ldy - rdy * ldx;
                    if (div !== 0) {
                        var tr = (ry * ldx - rx * ldy + lx * ldy - ly * ldx) / div;
                        var tl = void 0;
                        if (Math.abs(ldx) > Math.abs(ldy)) {
                            tl = (rx + rdx * tr - lx) / ldx;
                        }
                        else {
                            tl = (ry + rdy * tr - ly) / ldy;
                        }
                        if (tl >= 0 && tl <= 1) {
                            coef = tr;
                        }
                    }
                    return coef;
                };
                /**
                 * Line - line intersection. Each line is infinite length and defined by 2 points on it.
                 * Compute intersection point:
                 *    ix = l0x0 + (l0x1-l0x0) * coefficeint
                 *    iy = l0y0 + (l0y1-l0y0) * coefficeint
                 * @param l0x0 First point on l0.
                 * @param l0y0 First point on l0.
                 * @param l0x1 Second point on l0.
                 * @param l0y1 Second point on l0.
                 * @param l1x0 First point on l1.
                 * @param l1y0 First point on l1.
                 * @param l1x1 Second point on l1.
                 * @param l1y1 Second point on l1.
                 * @returns coefficeint along l0 to intersect the l1. Infinity if lines are parralel
                 * */
                Geometry.lineIntersectsLine = function (l0x0, l0y0, l0x1, l0y1, l1x0, l1y0, l1x1, l1y1) {
                    var coef = Infinity;
                    var l0dx = l0x1 - l0x0;
                    var l0dy = l0y1 - l0y0;
                    var l1dx = l1x1 - l1x0;
                    var l1dy = l1y1 - l1y0;
                    var div = l0dx * l1dy - l0dy * l1dx;
                    if (div !== 0) {
                        var tr = (l0y0 * l1dx - l0x0 * l1dy + l1x0 * l1dy - l1y0 * l1dx) / div;
                        var tl = void 0;
                        if (Math.abs(l1dx) > Math.abs(l1dy)) {
                            tl = (l0x0 + l0dx * tr - l1x0) / l1dx;
                        }
                        else {
                            tl = (l0y0 + l0dy * tr - l1y0) / l1dy;
                        }
                        coef = tr;
                    }
                    return coef;
                };
                /** first intersection between ray  (rx,ry, rds,rdy) and circle (0,0,r) */
                Geometry.rayIntersectsCircle = function (rx, ry, rdx, rdy, r) {
                    // solve quadratic equation
                    var a = rdx * rdx + rdy * rdy;
                    var b = rx * rdx + ry * rdy;
                    var c = rx * rx + ry * ry - r * r;
                    var d = b * b - a * c;
                    var coef = Infinity;
                    if (d > 0) {
                        d = Math.sqrt(d);
                        var t0 = (-b - d) / a;
                        var t1 = (-b + d) / a;
                        if (t0 >= 0) {
                            coef = t0;
                        }
                        if (t1 >= 0) {
                            coef = Math.min(coef, t1);
                        }
                    }
                    return coef;
                };
                /** first intersection between segment (rx,ry, rds,rdy) and rect (left, top, right, bottom) */
                Geometry.clipSegmentToRect = function (rx, ry, rdx, rdy, left, top, right, bottom) {
                    var t0 = 0;
                    var t1 = 1;
                    // Top X, Bottom X
                    if (rdy !== 0) {
                        var invdy = 1 / rdy;
                        var tTop = (top - ry) * invdy;
                        var tBottom = (bottom - ry) * invdy;
                        t0 = Math.min(tTop, tBottom);
                        t1 = Math.max(tTop, tBottom);
                        if (t0 > 1 || t1 < 0) {
                            return null;
                        }
                    }
                    else if (ry < top || ry > bottom) {
                        return null;
                    }
                    // Left Y, right Y
                    if (rdx !== 0) {
                        var invdx = 1 / rdx;
                        var tLeft = (left - rx) * invdx;
                        var tRight = (right - rx) * invdx;
                        var t2 = Math.min(tLeft, tRight);
                        var t3 = Math.max(tLeft, tRight);
                        t0 = Math.max(t0, t2);
                        t1 = Math.min(t1, t3);
                        if (t0 > 1 || t1 < 0 || t0 > t1) {
                            return null;
                        }
                    }
                    else if (rx < left || rx > right) {
                        return null;
                    }
                    return [t0, t1];
                };
                /** first intersection between ray  (rx,ry, rds,rdy) and circle (0,0,r) */
                Geometry.rayIntersectsCircleOuter = function (rx, ry, rdx, rdy, r) {
                    // solve quadratic equation
                    var a = rdx * rdx + rdy * rdy;
                    var b = rx * rdx + ry * rdy;
                    var c = rx * rx + ry * ry - r * r;
                    var d = b * b - a * c;
                    d = Math.sqrt(d);
                    return Math.max((-b + d) / a, (-b - d) / a);
                };
                /** finds line (rx,ry) -> (x,y) so that it touches circle (0,0,r), (x,y) is on circle and is closest to (xt,yt) */
                Geometry.lineTouchingCircle = function (rx, ry, xt, yt, r) {
                    // solve this as a right angle triangle problem
                    var a = Math.sqrt(rx * rx + ry * ry);
                    if (!(a > r)) {
                        return null;
                    }
                    var b = Math.sqrt(a * a - r * r);
                    var h = r * b / a;
                    var xx = r * r / a;
                    var dx = rx / a;
                    var dy = ry / a;
                    var angle = rx * yt - ry * xt;
                    if (angle < 0) {
                        h = -h;
                    }
                    return {
                        x: dx * xx - dy * h,
                        y: dy * xx + dx * h
                    };
                };
                Geometry.distanceToPolygonSq = function (x, y, polygonLines) {
                    if (Geometry.isInsidePolygon(x, y, polygonLines)) {
                        return 0;
                    }
                    var dist = Infinity;
                    for (var lineIndex = 0; lineIndex < polygonLines.length; lineIndex++) {
                        var line = polygonLines[lineIndex];
                        var len = line.length;
                        var x0 = line[len - 2];
                        var y0 = line[len - 1];
                        for (var i = 0; i <= len - 2; i += 2) {
                            var x1 = line[i];
                            var y1 = line[i + 1];
                            dist = Math.min(dist, Geometry.distanceToSegmentSq(x0, y0, x1, y1, x, y));
                            x0 = x1;
                            y0 = y1;
                        }
                    }
                    return dist;
                };
                Geometry.distanceToLinesSq = function (x, y, polygonLines) {
                    var dist = Infinity;
                    for (var lineIndex = 0; lineIndex < polygonLines.length; lineIndex++) {
                        var line = polygonLines[lineIndex];
                        var len = line.length;
                        if (len === 2) {
                            dist = Math.min(dist, (x - line[0]) * (x - line[0]) + (y - line[1]) * (y - line[1]));
                        }
                        else if (len > 2) {
                            var x0 = line[0];
                            var y0 = line[1];
                            for (var i = 2; i <= len - 2; i += 2) {
                                var x1 = line[i];
                                var y1 = line[i + 1];
                                dist = Math.min(dist, Geometry.distanceToSegmentSq(x0, y0, x1, y1, x, y));
                                x0 = x1;
                                y0 = y1;
                            }
                        }
                    }
                    return dist;
                };
                Geometry.isInsidePolygon = function (x, y, polygonLines) {
                    // ray casting algorithm to test if is inside
                    var inside = false;
                    for (var lineIndex = 0; lineIndex < polygonLines.length; lineIndex++) {
                        var line = polygonLines[lineIndex];
                        var len = line.length;
                        var x0 = line[len - 2];
                        var y0 = line[len - 1];
                        for (var i = 0; i <= len - 2; i += 2) {
                            var x1 = line[i];
                            var y1 = line[i + 1];
                            if ((y1 > y) !== (y0 > y) && (x < (x1 - x0) * (y - y0) / (y1 - y0) + x0)) {
                                inside = !inside;
                            }
                            x0 = x1;
                            y0 = y1;
                        }
                    }
                    return inside;
                };
                Geometry.distanceToBalloon = function (r, w, ddx, ddy) {
                    var t0;
                    if (r >= w) {
                        t0 = r;
                    }
                    else if (ddy === 0) {
                        t0 = w;
                    }
                    else {
                        var ysign = Base.Helpers.sign(ddy);
                        // clip to horizontal line
                        t0 = r / ddy * ysign;
                        if (Math.abs(ddx * t0) > w - r) {
                            // clip to circle
                            t0 = Geometry.rayIntersectsCircleOuter(-(w - r), 0, Math.abs(ddx), ddy, r);
                        }
                    }
                    return t0;
                };
                Geometry.distanceToRect = function (x, y, x0_rect, y0_returnSquared, x1, y1, returnSquared) {
                    if (returnSquared === void 0) { returnSquared = false; }
                    var x0;
                    var y0;
                    if (x0_rect instanceof Base.Rect) {
                        returnSquared = y0_returnSquared;
                        x0 = x0_rect.x0;
                        y0 = x0_rect.y0;
                        x1 = x0_rect.x1;
                        y1 = x0_rect.y1;
                    }
                    else {
                        x0 = x0_rect;
                        y0 = y0_returnSquared;
                    }
                    var dx;
                    var dy;
                    if (x < x0) {
                        dx = x0 - x;
                    }
                    else if (x > x1) {
                        dx = x - x1;
                    }
                    else {
                        dx = 0;
                    }
                    if (y < y0) {
                        dy = y0 - y;
                    }
                    else if (y > y1) {
                        dy = y - y1;
                    }
                    else {
                        dy = 0;
                    }
                    if (returnSquared) {
                        return dx * dx + dy * dy;
                    }
                    else {
                        return Math.sqrt(dx * dx + dy * dy);
                    }
                };
                Geometry.clipSegmentToBounds = function (sx0, sy0, sx1, sy1, r0, r1, left, top, right, bottom) {
                    var inc = Math.max(r0, r1);
                    var dx = sx1 - sx0;
                    var dy = sy1 - sy0;
                    var r = Geometry.clipSegmentToRect(sx0, sy0, dx, dy, left - inc, top - inc, right + inc, bottom + inc);
                    if (r === null) {
                        return null;
                    }
                    else {
                        var t0 = Math.max(0, r[0]);
                        var t1 = Math.min(1, r[1]);
                        return [sx0 + dx * t0, sy0 + dy * t0, sx0 + dx * t1, sy0 + dy * t1];
                    }
                };
                /**
                 * Computes a very approximate shape size based on bounding rectangle
                 * @param points - array of [x, y, x, y, ...]
                 * @returns - approx shape size
                 */
                Geometry.computeBoundsSize = function (points) {
                    var left = Infinity;
                    var right = -Infinity;
                    var top = Infinity;
                    var bottom = -Infinity;
                    var len = points.length;
                    for (var i = 0; i < len; i += 2) {
                        var x = points[i];
                        var y = points[i + 1];
                        left = Math.min(x, left);
                        right = Math.max(x, right);
                        top = Math.min(y, top);
                        bottom = Math.max(y, bottom);
                    }
                    return Math.max((right - left), (bottom - top));
                };
                /** Simplify polyline with vertex reduction and Douglas-Peucker simplification.
                points - array of [x, y, x, y, ...] */
                Geometry.simplify = function (points, tolerance) {
                    if (!tolerance || !points.length) {
                        return points;
                    }
                    var sqTolerance = tolerance * tolerance;
                    // stage 1: vertex reduction
                    points = Geometry.reducePoints(points, sqTolerance);
                    // stage 2: Douglas-Peucker simplification
                    points = Geometry.simplifyDP(points, sqTolerance);
                    return points;
                };
                /** Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm */
                Geometry.simplifyDP = function (points, sqTolerance) {
                    var len = points.length;
                    var markers;
                    if (typeof Uint8Array !== "undefined") {
                        markers = new Uint8Array(len);
                    }
                    else {
                        markers = new Array(len);
                    }
                    markers[0] = markers[len - 2] = 1;
                    Geometry.simplifyDPStep(points, markers, sqTolerance, 0, len - 2);
                    var newPoints = [];
                    for (var i = 0; i < len; i += 2) {
                        if (markers[i]) {
                            newPoints.push(points[i]);
                            newPoints.push(points[i + 1]);
                        }
                    }
                    return newPoints;
                };
                Geometry.simplifyDPStep = function (points, markers, sqTolerance, first, last) {
                    var maxSqDist = 0;
                    var index = 0;
                    var x0 = points[first];
                    var y0 = points[first + 1];
                    var x1 = points[last];
                    var y1 = points[last + 1];
                    for (var i = first + 2; i <= last - 2; i += 2) {
                        var sqDist = Geometry.distanceToSegmentSq(x0, y0, x1, y1, points[i], points[i + 1]);
                        if (sqDist > maxSqDist) {
                            index = i;
                            maxSqDist = sqDist;
                        }
                    }
                    if (maxSqDist > sqTolerance) {
                        markers[index] = 1;
                        Geometry.simplifyDPStep(points, markers, sqTolerance, first, index);
                        Geometry.simplifyDPStep(points, markers, sqTolerance, index, last);
                    }
                };
                /** reduce points that are too close to each other to a single point */
                Geometry.reducePoints = function (points, sqTolerance) {
                    var x = points[0];
                    var y = points[1];
                    var reducedPoints = [x, y];
                    var len = points.length;
                    var xx;
                    var yy;
                    for (var i = 2; i < len; i += 2) {
                        xx = points[i];
                        yy = points[i + 1];
                        if ((x - xx) * (x - xx) + (y - yy) * (y - yy) > sqTolerance) {
                            reducedPoints.push(xx);
                            reducedPoints.push(yy);
                            x = xx;
                            y = yy;
                        }
                    }
                    if (x !== xx && y !== yy) {
                        reducedPoints.push(xx, yy);
                    }
                    return reducedPoints;
                };
                /**
                 * Translates and scales a given polyline by the given multiplicative and additive parts
                 * @param p - The polyLine to be translated
                 * @param txm - X multiplicative part
                 * @param txa - X additive part
                 * @param tym - Y multiplicative part
                 * @param tya - Y additive part
                 * @returns {number[]} - A transformed poly
                 */
                Geometry.transformPolyline = function (p, txm, txa, tym, tya) {
                    var result = [];
                    for (var i = 0; i < p.length; i += 2) {
                        result.push(p[i] * txm + txa, p[i + 1] * tym + tya);
                    }
                    return result;
                };
                /**
                 * Creates an outline for a given polyline, given the outline offset amount
                 * @param polyLine - The polyline to be outlined
                 * @param offsetVectors - An array of unit vectors, perpendicular to the line segments of the given polyline
                 * @param amount - Amount of offset
                 * @returns {number[]} - A new polyline that is the outline of the given polyline
                 */
                Geometry.outlinePolylineByVectors = function (polyLine, offsetVectors, amount) {
                    var s = []; // offsetSegments
                    var o = []; // The resulting polyline
                    var l = polyLine.length - 2;
                    for (var i = 0; i < l; i += 2) {
                        var xOffset = offsetVectors[i] * amount;
                        var yOffset = offsetVectors[i + 1] * amount;
                        var startX = polyLine[i] + xOffset;
                        var startY = polyLine[i + 1] + yOffset;
                        var endX = polyLine[i + 2] + xOffset;
                        var endY = polyLine[i + 3] + yOffset;
                        s.push(startX, startY, endX, endY);
                    }
                    // calculate the intersections of the offset lines
                    o = s.slice(0, 2); // the two starting points
                    l = s.length - 4;
                    for (var i = 0; i < l; i += 4) {
                        var coef = Base.Geometry.lineIntersectsLine(s[i], s[i + 1], s[i + 2], s[i + 3], s[i + 4], s[i + 5], s[i + 6], s[i + 7]);
                        if (coef === Infinity) {
                            o.push(s[i + 2], s[i + 3]);
                        }
                        else {
                            o.push(s[i] + (s[i + 2] - s[i]) * coef, s[i + 1] + (s[i + 3] - s[i + 1]) * coef);
                        }
                    }
                    o.push.apply(o, s.slice(-2)); // the ending points of the offsetPoly
                    return o;
                };
                /**
                 * Calculates the area of a given polygon
                 * @param polyline
                 * @returns {number} - The area
                 */
                Geometry.calculatePolyArea = function (poly) {
                    var area = 0;
                    var p = poly;
                    var l = poly.length - 2;
                    for (var i = 0; i < l; i += 2) {
                        area += p[i] * p[i + 3] - p[i + 2] * p[i + 1];
                    }
                    return area / 2;
                };
                /**
                 * Given a polygon and its area, calculates the X and Y coordinates of the center of mass of the given polygon
                 * @param p - the polygon
                 * @param area - area of the polygon
                 * @returns {{x: number, y: number}} - The centroid coordinates
                 */
                Geometry.calculatePolyCentroid = function (p, area) {
                    var cx = 0;
                    var cy = 0;
                    var l = p.length - 2;
                    var a;
                    area *= 6;
                    for (var i = 0; i < l; i += 2) {
                        a = (p[i] * p[i + 3] - p[i + 2] * p[i + 1]);
                        cx += (p[i] + p[i + 2]) * a;
                        cy += (p[i + 1] + p[i + 3]) * a;
                    }
                    return { x: cx / area, y: cy / area };
                };
                /**
                 * Makes sure that after continuous rotation (clockwise or anticlockwise) a value of an angle stays in the bounds of [0..2*pi)
                 * @param angle
                 * @returns {number} - The same angle as given, however the numeric value is corrected to be within the bounds
                 */
                Geometry.normalizeAngle = function (angle) {
                    if (angle < 0) {
                        angle %= pi2;
                        angle += pi2;
                    }
                    else if (angle >= pi2) {
                        angle %= pi2;
                    }
                    return angle;
                };
                /**
                 * Returns the sector between 2 angles
                 * Helps in cases where you may want to find the angle between 7/4 pi and 1/4 pi
                 * (simple subtraction would return 6/4 pi, where the expected answer is 1/2 pi)
                 * @param a1 - 1st angle
                 * @param a2 - 2nd angle
                 * @returns {number} - the sector between the given angles (going clockwise from the 1st angle)
                 */
                Geometry.sectorBetweenAngles = function (a1, a2) {
                    while (a2 < a1) {
                        a2 += pi2;
                    }
                    return a2 - a1;
                };
                /**
                 * Returns the difference between the given angles, via the shortest direction
                 * @param a1 - The angle from which a2 will be subtracted
                 * @param a2 - The angle that will be subtracted from the a1
                 * @returns the difference between angles. If a2 is clockwise to a1, the value is positive,
                 * if a2 is anticlockwise to a1, the value is negative
                 */
                Geometry.subtractAngle = function (a1, a2) {
                    var v = a1 - a2;
                    if (v > Math.PI) {
                        v -= pi2;
                    }
                    else if (v < -Math.PI) {
                        v += pi2;
                    }
                    return v;
                };
                Geometry.rotateVector = function (x, y, sin, cos) {
                    return {
                        x: x * cos - y * sin,
                        y: x * sin + y * cos
                    };
                };
                return Geometry;
            }());
            Base.Geometry = Geometry;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="core/ChartEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            (function (InfoPopupPosition) {
                InfoPopupPosition[InfoPopupPosition["inside"] = 0] = "inside";
                InfoPopupPosition[InfoPopupPosition["outside"] = 1] = "outside";
            })(Base.InfoPopupPosition || (Base.InfoPopupPosition = {}));
            var InfoPopupPosition = Base.InfoPopupPosition;
            /** The base class for info popup. This class only handles the positioning of the popup, everything else is in the
            specific classes within each chart type. */
            var InfoPopup = (function () {
                function InfoPopup(chart) {
                    this.chart = chart;
                    this.container = chart.shell.interactiveContainer;
                    this.events = chart.events;
                    this.popup = null;
                    this.visible = false;
                    this.x0 = null;
                    this.x1 = null;
                    this.y = null;
                    this.contentsChanged = false;
                }
                InfoPopup.prototype.hide = function () {
                    if (!this.visible || !this.popup) {
                        return false;
                    }
                    this.visible = false;
                    this.popup.style.display = "none";
                    return true;
                };
                InfoPopup.prototype.ensurePopup = function () {
                    if (this.popup)
                        return;
                    this.popup = Base.Helpers.createDom("div", "DVSL-info-center", null, this.container);
                    Base.Helpers.createDom("em", null, null, this.popup);
                    this.popup.style.position = "absolute";
                    this.popup.style.display = "none";
                };
                /**
                @param x0 - the left side of the selection for which the info popup is being shown
                @param x1 - the right side of the selection for which the info popup is being shown
                @param y - the intended Y position of the top of the info popup if `position` is `inside`.
                @param contents - the HTML contents of the info popup. If `null` the popup is hidden.
                @param position - where to position the info popup. */
                InfoPopup.prototype.show = function (x0, x1, y, contents, position) {
                    if (position === void 0) { position = InfoPopupPosition.inside; }
                    this.ensurePopup();
                    var popup = this.popup;
                    if (contents) {
                        // no HTML, let's add some markup
                        if (contents.indexOf("<") === -1 && contents.indexOf(">") === -1) {
                            contents = ("<b>" + contents + "</b>");
                        }
                        this.visible = true;
                        popup.style.display = "block";
                        if (contents !== popup.innerHTML) {
                            popup.innerHTML = contents;
                            this.postProcessHtml(popup);
                            this.contentsChanged = true;
                        }
                        this.updateXY(x0, x1, y, position);
                    }
                    else {
                        popup.style.display = "none";
                    }
                };
                InfoPopup.prototype.postProcessHtml = function (element) {
                    if (element instanceof HTMLElement) {
                        var color = element.getAttribute("data-color");
                        if (color) {
                            element.style.color = color;
                            if (null != element.getAttribute("data-selected"))
                                element.style.borderColor = color;
                        }
                    }
                    var c = element.firstElementChild;
                    while (c) {
                        this.postProcessHtml(c);
                        c = c.nextElementSibling;
                    }
                };
                InfoPopup.prototype.updateContents = function (contents) {
                    if (contents === null) {
                        this.hide();
                    }
                    else {
                        this.show(this.x0, this.x1, this.y, contents, this.position);
                    }
                };
                /**
                @param x0 - the left side of the selection for which the info popup is being shown
                @param x1 - the right side of the selection for which the info popup is being shown
                @param y - the intended Y position of the top of the info popup if `position` is `inside`.
                @param position - where to position the info popup. */
                InfoPopup.prototype.updateXY = function (x0, x1, y, position) {
                    if (position === void 0) { position = InfoPopupPosition.inside; }
                    if (!this.visible || (!this.contentsChanged
                        && this.x0 === x0 && this.x1 === x1
                        && this.y === y && this.position === position)) {
                        return;
                    }
                    this.ensurePopup();
                    if (this.contentsChanged) {
                        this.contentsChanged = false;
                        this.popup.style.right = null;
                        this.width = this.popup.offsetWidth;
                        this.height = this.popup.offsetHeight;
                    }
                    this.x0 = x0;
                    this.x1 = x1;
                    this.y = y;
                    this.position = position;
                    var margin = 12;
                    var arrowWidth = 10;
                    var w = this.width;
                    var h = this.height;
                    var xl = null;
                    var cl;
                    var style = this.popup.style;
                    var localScene = this.chart.scene;
                    if (x0 > localScene.x0 + localScene.width || x1 < localScene.x0) {
                        // this check uses the current chart scene and not the topmost
                        // if the selection moves out of the visible area, the popup is temporarily hidden.
                        // this is done because it will be shown again if the selection moves back into view.
                        style.top = "-10000px";
                        return;
                    }
                    // for chart-on-charts the info popup is positioned within the main chart so find the main scene object.
                    var scene = this.chart.getRootChart().scene;
                    switch (position) {
                        default:
                        case InfoPopupPosition.inside:
                            if (scene.x0 <= x0 - w - arrowWidth) {
                                xl = x0 - w - arrowWidth;
                                cl = "DVSL-info-left";
                            }
                            else if (scene.x0 + scene.width >= x1 + w + arrowWidth) {
                                xl = x1 + arrowWidth;
                                cl = "DVSL-info-right";
                            }
                            else {
                                xl = (Math.max(x0, scene.x0) + Math.min(x1, scene.x0 + scene.width) - w) / 2;
                                cl = "DVSL-info-center";
                            }
                            y = Math.min(Math.max(scene.y0 + margin, y - h / 2), scene.y0 + scene.height - h);
                            // move the info popup down if it overlaps the top toolbars
                            y = Math.max(this.chart.shell.getChartInnerArea().findTopPosition(xl, xl + w), y);
                            break;
                        case InfoPopupPosition.outside: {
                            cl = "DVSL-info-center";
                            xl = Math.min(scene.x0 + scene.width - w, Math.max(0, (x0 + x1 - w) / 2)); // center against the selection but maintain the width
                            var chartTop = this.chart.shell.container.offsetTop;
                            y = (chartTop > h)
                                ? (scene.y0 - h) // above the chart
                                : (scene.y0 + scene.height); // below the chart
                            break;
                        }
                    }
                    // to mitigate the chance that the popup contents will be wrapped, position it against the right side when it is close to that
                    var xr = null;
                    if (w >= scene.chartWidth) {
                        xr = 0;
                        xl = 0;
                    }
                    else if (xl + w > scene.chartWidth - 20) {
                        if (xl + w > scene.chartWidth) {
                            xr = 0;
                            xl = null;
                        }
                        else {
                            xr = scene.chartWidth - xl - w;
                            xl = null;
                        }
                    }
                    style.right = xr !== null ? xr + "px" : null;
                    style.left = xl !== null ? xl + "px" : null;
                    style.top = y + "px";
                    if (this.popupClass !== cl) {
                        this.popupClass = cl;
                        this.popup.className = cl;
                    }
                };
                return InfoPopup;
            }());
            Base.InfoPopup = InfoPopup;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Rect.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            /** Layer interface for all chart layers */
            var Layer = (function () {
                function Layer(scene) {
                    this.scene = scene;
                    this.bounds = null;
                }
                Layer.prototype.setBounds = function (left, top, right, bottom) {
                    this.bounds = new Base.Rect(left, top, right, bottom);
                };
                Layer.prototype.findObjectAt = function (displayX, displayY, tolerance) {
                    return null;
                };
                Layer.prototype.remove = function () {
                    // a virtual method
                };
                return Layer;
            }());
            Base.Layer = Layer;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var MonotoneCurve = (function () {
                /** by George MacKerron, mackerron.com
                adapted from:
                http://sourceforge.net/mailarchive/forum.php?thread_name=
                EC90C5C6-C982-4F49-8D46-A64F270C5247%40gmail.com&forum_name=matplotlib-users
                (easier to read at http://old.nabble.com/%22Piecewise-Cubic-Hermite-Interpolating-
                Polynomial%22-in-python-td25204843.html)
                with help from:
                F N Fritsch & R E Carlson (1980) 'Monotone Piecewise Cubic Interpolation',
                SIAM Journal of Numerical Analysis 17(2), 238 - 246.
                http://en.wikipedia.org/wiki/Monotone_cubic_interpolation
                http://en.wikipedia.org/wiki/Cubic_Hermite_spline */
                function MonotoneCurve(x, y, n0, n1) {
                    if (n0 === void 0) { n0 = 0; }
                    if (n1 === void 0) { n1 = x.length; }
                    if (n1 == null)
                        n1 = x.length; // ported from CoffeeScript;
                    if (n0 == null)
                        n0 = 0; // ported from CoffeeScript;
                    this.n0 = n0;
                    var m = [];
                    m.length = n1 - n0;
                    var mi0 = 0;
                    m[n1 - n0 - 1] = (y[n1 - 1] - y[n1 - 2]) / (x[n1 - 1] - x[n1 - 2]);
                    var deltai0 = (y[n0 + 1] - y[n0]) / (x[n0 + 1] - x[n0]);
                    var i;
                    for (i = n0 + 1; i < (n1 - 1); i++) {
                        var deltai = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);
                        var mi = void 0;
                        if (deltai0 === 0) {
                            mi = mi0 = 0;
                        }
                        else {
                            mi = (deltai0 + deltai) / 2;
                            var disti = (mi0 * mi0 + mi * mi) / (deltai0 * deltai0);
                            if (disti > 9) {
                                var taui = 3 / Math.sqrt(disti);
                                mi0 = taui * mi0;
                                mi = taui * mi;
                            }
                        }
                        m[i - n0 - 1] = mi0;
                        mi0 = mi;
                        deltai0 = deltai;
                    }
                    m[i - n0 - 1] = mi0;
                    this.x = x;
                    this.y = y;
                    this.m = m;
                }
                MonotoneCurve.prototype.interpolate = function (i, x) {
                    var h = this.x[i + 1] - this.x[i];
                    var t = (x - this.x[i]) / h;
                    var t2 = t * t;
                    var t3 = t2 * t;
                    var h00 = 2 * t3 - 3 * t2 + 1;
                    var h10 = t3 - 2 * t2 + t;
                    var h01 = -2 * t3 + 3 * t2;
                    var h11 = t3 - t2;
                    var y = h00 * this.y[i] + h10 * h * this.m[i - this.n0] + h01 * this.y[i + 1] + h11 * h * this.m[i - this.n0 + 1];
                    return y;
                };
                MonotoneCurve.prototype.interpolateArray = function (i, xarray, xfrom, xto, resultArray) {
                    var xi = this.x[i];
                    var yi = this.y[i];
                    var mi = this.m[i - this.n0];
                    var yi1 = this.y[i + 1];
                    var mi1 = this.m[i - this.n0 + 1];
                    var h = this.x[i + 1] - xi;
                    var invh = 1 / h;
                    for (var j = xfrom; j < xto; j++) {
                        var t = (xarray[j] - xi) * invh;
                        var t2 = t * t;
                        var t3 = t2 * t;
                        var h00 = 2 * t3 - 3 * t2 + 1;
                        var h10 = t3 - 2 * t2 + t;
                        var h01 = -2 * t3 + 3 * t2;
                        var h11 = t3 - t2;
                        var y = h00 * yi + h10 * h * mi + h01 * yi1 + h11 * h * mi1;
                        resultArray.push(y);
                    }
                };
                MonotoneCurve.prototype.clear = function () {
                    this.m.length = 0;
                };
                return MonotoneCurve;
            }());
            Base.MonotoneCurve = MonotoneCurve;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/core/ChartElement.ts" />
/// <reference path="../base/core/ChartEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var Navigator = (function (_super) {
                __extends(Navigator, _super);
                function Navigator() {
                    _super.apply(this, arguments);
                }
                return Navigator;
            }(Base.ChartElement));
            Base.Navigator = Navigator;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var Random = (function () {
                function Random(seed) {
                    this.seed = seed;
                    this.A = 48271;
                    this.M = 2147483647;
                    this.Q = this.M / this.A;
                    this.R = this.M % this.A;
                    this.oneOverM = 1.0 / this.M;
                }
                /** in range (0..1) (non inclusive) */
                Random.prototype.get = function () {
                    var hi = this.seed / this.Q;
                    var lo = this.seed % this.Q;
                    var test = this.A * lo - this.R * hi;
                    if (test > 0) {
                        this.seed = test;
                    }
                    else {
                        this.seed = test + this.M;
                    }
                    return this.seed * this.oneOverM;
                };
                Random.prototype.getArrayElement = function (array) {
                    return array[(array.length * this.get()) | 0];
                };
                return Random;
            }());
            Base.Random = Random;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Helpers.ts" />
/// <reference path="Rect.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var SceneMessage = (function () {
                function SceneMessage(msg, pri) {
                    this.msg = msg;
                    this.pri = pri;
                }
                return SceneMessage;
            }());
            var Scene = (function () {
                function Scene() {
                    this.settings = null;
                    this.assetsLoader = null;
                    this.isActive = true; // if true the chart is in active mode - with DOM elements and stuff. If false the chart is in passive mode - no DOM, just canvas.
                    this.mainData = null; // Main data object
                    /** Chart overall bounds on canvas and HTML containers */
                    this.chartLeft = 0;
                    /** Chart overall bounds on canvas and HTML containers */
                    this.chartTop = 0;
                    /** Chart overall bounds on canvas and HTML containers */
                    this.chartWidth = 1;
                    /** Chart overall bounds on canvas and HTML containers */
                    this.chartHeight = 1;
                    /** rendering area location, excludes any toolbars and stuff */
                    this.x0 = 0;
                    /** rendering area location, excludes any toolbars and stuff */
                    this.y0 = 0;
                    /** The height of the chart area excluding toolbars, axis etc. For example, on TimeChart this is the area where the series are drawn. */
                    this.height = 0;
                    /** The width of the chart area excluding toolbars, axis etc. For example, on TimeChart this is the area where the series are drawn. */
                    this.width = 0;
                    // extra space around active bounds [x0, y0, width, height] is rendered
                    this.leftMargin = 0;
                    this.rightMargin = 0;
                    this.topMargin = 0;
                    this.bottomMargin = 0;
                    this.loading = true; // if true, loading animation is shown
                    this.messages = {}; // fields for MessagesOverlay
                    this.backStack = []; // undo stack
                }
                Scene.prototype.setMessage = function (origin, msg, pri) {
                    if (pri === void 0) { pri = 0; }
                    var changed;
                    if (msg) {
                        changed = !this.messages[origin] || this.messages[origin].msg !== msg || this.messages[origin].pri !== pri;
                        this.messages[origin] = new SceneMessage(msg, pri);
                    }
                    else {
                        changed = this.messages.hasOwnProperty(origin);
                        delete this.messages[origin];
                    }
                    return changed;
                };
                Scene.prototype.getMessage = function () {
                    var m = null;
                    var pri = 0;
                    for (var k in this.messages) {
                        var mm = this.messages[k];
                        if (mm.pri > pri) {
                            m = mm.msg;
                            pri = mm.pri;
                        }
                    }
                    return m;
                };
                Scene.prototype.pushBack = function (state) {
                    this.backStack.push(state);
                    // limit stack size
                    if (this.backStack.length > 1000) {
                        this.backStack = this.backStack.slice(200);
                    }
                };
                return Scene;
            }());
            Base.Scene = Scene;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var Gestures;
            (function (Gestures) {
                /** A single type of gesture, done with one or more pointers. */
                var Gesture = (function () {
                    /**
                     * Creates a new instance of the gesture.
                     * @param manager Gesture manager
                     */
                    function Gesture(manager) {
                        /** A list of pointers currently assigned to the gesture. */
                        this.pointers = [];
                        this.manager = manager;
                    }
                    /**
                     * Adds a pointer to the gesture.
                     * @param event PointerDown event which started this gesture.
                     * @param item If the pointer is over a node or a link, this will contain it. Note that even if not, this object will non-null,
                                   and instead the contents of it will be null.
                     */
                    Gesture.prototype.addPointer = function (event, item) {
                        this.pointers.push(event.identifier);
                        event.consumed = true;
                    };
                    /**
                     * Removes a pointer from the gesture and ends it.
                     * @param event The event which terminated the gesture
                     */
                    Gesture.prototype.removePointer = function (event) {
                        Internal.Base.Helpers.removeFromArrayHasty(this.pointers, event.identifier);
                        event.consumed = true;
                    };
                    /**
                     * Performs the gesture.
                     * @param event PointerMove event.
                     */
                    Gesture.prototype.movePointer = function (event) {
                        event.consumed = true;
                    };
                    return Gesture;
                }());
                Gestures.Gesture = Gesture;
            })(Gestures = NetChart.Gestures || (NetChart.Gestures = {}));
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Gesture.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var Gestures;
            (function (Gestures) {
                var MultiSelectGesture = (function (_super) {
                    __extends(MultiSelectGesture, _super);
                    function MultiSelectGesture() {
                        _super.apply(this, arguments);
                        this.startX = 0;
                        this.startY = 0;
                        this.lastX = 0;
                        this.lastY = 0;
                        this.selectedNodes = null;
                    }
                    MultiSelectGesture.prototype.addPointer = function (event, item) {
                        _super.prototype.addPointer.call(this, event, item);
                        this.startX = this.lastX = event.x;
                        this.startY = this.lastY = event.y;
                        this.selectedNodes = new Object(null);
                        event.cursor = "crosshair";
                        var scene = this.manager.chart.scene;
                        scene.disableSelectionChangeNotification();
                        var filteredSelection = scene.selection.filter(function (x) { return x.dragging; });
                        if (filteredSelection.length !== scene.selection.length)
                            scene.setSelection(filteredSelection);
                        this.manager.chart.events.requestPaint();
                    };
                    MultiSelectGesture.prototype.movePointer = function (event) {
                        _super.prototype.movePointer.call(this, event);
                        this.lastX = event.x;
                        this.lastY = event.y;
                        this.manager.chart.events.requestPaint();
                        event.cursor = "crosshair";
                        this.updateSelection();
                    };
                    MultiSelectGesture.prototype.removePointer = function (event) {
                        _super.prototype.removePointer.call(this, event);
                        for (var i in this.selectedNodes)
                            this.selectedNodes[i].selectionLock = false;
                        this.manager.chart.scene.enableSelectionChangeNotification();
                        this.manager.chart.scene.notifySelectionChangesIfNeeded(this.manager.chart, "user");
                        this.manager.chart.events.requestPaint();
                    };
                    MultiSelectGesture.prototype.doAnimations = function (event) {
                        if (this.pointers.length > 0 && (event.changes.position || event.changes.selection || this.manager.chart.layer.hasTopologyChanges()))
                            this.updateSelection();
                    };
                    MultiSelectGesture.prototype.updateSelection = function () {
                        var nodes = this.manager.chart.layer.nodes();
                        var scene = this.manager.chart.scene;
                        var start = scene.fromDisplay(this.startX, this.startY);
                        var end = scene.fromDisplay(this.lastX, this.lastY);
                        var x0 = Math.min(start.x, end.x);
                        var y0 = Math.min(start.y, end.y);
                        var x1 = Math.max(start.x, end.x);
                        var y1 = Math.max(start.y, end.y);
                        for (var i = 0; i < nodes.length; i++) {
                            var node = nodes[i];
                            // If node is being removed, also remove it from our selection.
                            if (node.removed) {
                                if (this.selectedNodes[node.id])
                                    delete this.selectedNodes[node.id];
                                continue;
                            }
                            // Ignore nodes that are being dragged. They live their own life.
                            if (node.dragging)
                                continue;
                            // Node is up for grabs, check if inside the box.
                            if (node.x >= x0 && node.x <= x1 && node.y >= y0 && node.y <= y1) {
                                if (!this.selectedNodes[node.id]) {
                                    // Yes, the node is inside, and we haven't added it yet to our collection. Do so now.
                                    this.selectedNodes[node.id] = node;
                                    node.selectionLock = true;
                                    if (!node.selected)
                                        scene.addToSelection(node);
                                }
                            }
                            else if (this.selectedNodes[node.id]) {
                                // No, the node isn't inside the selection, but it used to be. Remove if from our collection, and deselect if needed.
                                delete this.selectedNodes[node.id];
                                node.selectionLock = false;
                                if (node.selected)
                                    scene.removeFromSelection(node);
                            }
                        }
                    };
                    MultiSelectGesture.prototype.paintScene = function (event) {
                        if (this.pointers.length > 0) {
                            var style = this.manager.chart.settings.style.dragSelection;
                            var ctxt = Internal.Base.Graphics.beginStrokeAndFill(event.context, style);
                            ctxt.rect(this.startX - 0.5, this.startY - 0.5, this.lastX - this.startX, this.lastY - this.startY);
                            Internal.Base.Graphics.endStrokeAndFill(event.context, ctxt, style);
                        }
                    };
                    return MultiSelectGesture;
                }(Gestures.Gesture));
                Gestures.MultiSelectGesture = MultiSelectGesture;
            })(Gestures = NetChart.Gestures || (NetChart.Gestures = {}));
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Gesture.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var Gestures;
            (function (Gestures) {
                /**
                 * The two-finger gesture. A combination of pan, drag and rotate, depending on which are enabled. The manager will always assign
                 * exactly two pointers to it, and both will be assigned/removed together.
                 */
                var TwoFingerGesture = (function (_super) {
                    __extends(TwoFingerGesture, _super);
                    function TwoFingerGesture() {
                        _super.apply(this, arguments);
                        this.x1 = 0;
                        this.y1 = 0;
                        this.x2 = 0;
                        this.y2 = 0;
                        this.centerX = 0;
                        this.centerY = 0;
                        this.centerDistance = 0;
                    }
                    TwoFingerGesture.prototype.addPointer = function (event, item) {
                        _super.prototype.addPointer.call(this, event, item);
                        if (this.pointers.length === 1) {
                            this.x1 = event.x;
                            this.y1 = event.y;
                        }
                        else {
                            this.x2 = event.x;
                            this.y2 = event.y;
                            var scene = this.manager.chart.scene;
                            var fromDisplayResult = scene.fromDisplay((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2);
                            this.centerX = fromDisplayResult.x;
                            this.centerY = fromDisplayResult.y;
                            var dx = this.x1 - this.x2;
                            var dy = this.y1 - this.y2;
                            var len = Math.sqrt(dx * dx + dy * dy);
                            this.centerDistance = len / scene.zoom;
                        }
                    };
                    TwoFingerGesture.prototype.movePointer = function (event) {
                        _super.prototype.movePointer.call(this, event);
                        if (event.identifier === this.pointers[0]) {
                            this.twoFingerDrag(event.x, event.y, this.x2, this.y2);
                            this.x1 = event.x;
                            this.y1 = event.y;
                        }
                        else {
                            this.twoFingerDrag(this.x1, this.y1, event.x, event.y);
                            this.x2 = event.x;
                            this.y2 = event.y;
                        }
                        event.changes.position = true;
                    };
                    TwoFingerGesture.prototype.twoFingerDrag = function (x1, y1, x2, y2) {
                        var settings = this.manager.chart.settings.interaction;
                        var scene = this.manager.chart.scene;
                        scene.autoZoomMode = false;
                        var sx1 = (x2 - x1);
                        var sy1 = (y2 - y1);
                        var mode = this.manager.chart.settings.layout.mode;
                        if (settings.rotation.fingers && (mode === "static" || mode === "dynamic")) {
                            // rotation is not supported in the hierarchy and radial layout modes
                            this._twoFingerRotation(x1, y1, x2, y2);
                        }
                        var newLen = Math.sqrt(sx1 * sx1 + sy1 * sy1) / scene.zoom;
                        var cx = (x2 + x1) / 2;
                        var cy = (y2 + y1) / 2;
                        if (!settings.rotation.fingers && settings.panning.enabled) {
                            var fromDisplayResult = scene.fromDisplay(cx, cy);
                            scene.centerX += this.centerX - fromDisplayResult.x;
                            scene.centerY += this.centerY - fromDisplayResult.y;
                        }
                        if (settings.zooming.fingers) {
                            var dz = newLen / this.centerDistance;
                            this.manager.chart.autoZoom.manualZoom(dz, cx, cy);
                        }
                    };
                    /**
                     * during 2 finger drag, determines the rotation pivot, and rotates the nodes around that pivot
                     * @param x1
                     * @param y1
                     * @param x2
                     * @param y2
                     * @returns {boolean} - Returns boolean whether rotation has occurred, if no, the pan logic needs to be called instead
                     * @private
                     */
                    TwoFingerGesture.prototype._twoFingerRotation = function (x1, y1, x2, y2) {
                        var lx = (x2 - x1);
                        var ly = (y2 - y1);
                        // find the angle of rotation
                        var a2 = Math.atan2(ly, lx);
                        var a1 = Math.atan2(this.y2 - this.y1, this.x2 - this.x1);
                        var angle = a2 - a1;
                        if (angle === 0) {
                            return false;
                        }
                        // find which of the pointers has moved furthest
                        var mx1 = x1 - this.x1;
                        var my1 = y1 - this.y1;
                        var mx2 = x2 - this.x2;
                        var my2 = y2 - this.y2;
                        var m1 = mx1 * mx1 + my1 * my1;
                        var m2 = mx2 * mx2 + my2 * my2;
                        // the movement coordinates of the furthest moved pointer
                        var v1x;
                        var v1y;
                        var v2x;
                        var v2y;
                        var vlen;
                        if (m1 >= m2) {
                            // using 1st pointer
                            v1x = this.x1;
                            v1y = this.y1;
                            v2x = x1;
                            v2y = y1;
                            vlen = Math.sqrt(m1);
                        }
                        else {
                            // using 2nd pointer
                            v1x = this.x2;
                            v1y = this.y2;
                            v2x = x2;
                            v2y = y2;
                            vlen = Math.sqrt(m2);
                        }
                        var vx = v2x - v1x;
                        var vy = v2y - v1y;
                        // the direction of the movement vector
                        var vdx = vx / vlen;
                        var vdy = vy / vlen;
                        // the rays toward the pivot
                        var r2a = (Math.PI + angle) / 2;
                        var r1a = Math.PI - r2a;
                        var r1 = Internal.Base.Geometry.rotateVector(vdx, vdy, Math.sin(r1a), Math.cos(r1a));
                        var r2 = Internal.Base.Geometry.rotateVector(vdx, vdy, Math.sin(r2a), Math.cos(r2a));
                        // Find the rotation pivot (ray intersection)
                        var c = Internal.Base.Geometry.lineIntersectsLine(0, 0, r1.x, r1.y, vx, vy, vx + r2.x, vy + r2.y);
                        if (c === Infinity) {
                            return false;
                        }
                        var px = v1x + r1.x * c;
                        var py = v1y + r1.y * c;
                        var fromDisplay = this.manager.chart.scene.fromDisplay(px, py);
                        var cx = fromDisplay.x;
                        var cy = fromDisplay.y;
                        var nodes = this.manager.chart.layer.nodes();
                        var rotatedVect;
                        var sin = Math.sin(angle);
                        var cos = Math.cos(angle);
                        for (var i = 0; i < nodes.length; i++) {
                            var n = nodes[i];
                            if (n.dragging)
                                continue;
                            // get the node position relative to the given center
                            rotatedVect = Internal.Base.Geometry.rotateVector(n.x - cx, n.y - cy, sin, cos);
                            n.x = cx + rotatedVect.x;
                            n.y = cy + rotatedVect.y;
                        }
                        return true;
                    };
                    return TwoFingerGesture;
                }(Gestures.Gesture));
                Gestures.TwoFingerGesture = TwoFingerGesture;
            })(Gestures = NetChart.Gestures || (NetChart.Gestures = {}));
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Gesture.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var Gestures;
            (function (Gestures) {
                /**
                 * A single-pointer pan gesture. The manager will ever only assign at most one pointer to this gesture.
                 */
                var PanGesture = (function (_super) {
                    __extends(PanGesture, _super);
                    function PanGesture() {
                        _super.apply(this, arguments);
                        this.pinnedSceneX = 0;
                        this.pinnedSceneY = 0;
                    }
                    PanGesture.prototype.addPointer = function (event, item) {
                        _super.prototype.addPointer.call(this, event, item);
                        var fromDisplayResult = this.manager.chart.scene.fromDisplay(event.x, event.y);
                        this.pinnedSceneX = fromDisplayResult.x;
                        this.pinnedSceneY = fromDisplayResult.y;
                    };
                    PanGesture.prototype.movePointer = function (event) {
                        _super.prototype.movePointer.call(this, event);
                        var scene = this.manager.chart.scene;
                        scene.autoZoomMode = false;
                        var fromDisplayResult = scene.fromDisplay(event.x, event.y);
                        scene.centerX += this.pinnedSceneX - fromDisplayResult.x;
                        scene.centerY += this.pinnedSceneY - fromDisplayResult.y;
                        event.changes.position = true;
                    };
                    return PanGesture;
                }(Gestures.Gesture));
                Gestures.PanGesture = PanGesture;
            })(Gestures = NetChart.Gestures || (NetChart.Gestures = {}));
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Gesture.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var Gestures;
            (function (Gestures) {
                /**
                 * A gesture which drags nodes around. The manager can assign multiple pointers, each for a different set of nodes.
                 */
                var NodeDragGesture = (function (_super) {
                    __extends(NodeDragGesture, _super);
                    function NodeDragGesture() {
                        _super.apply(this, arguments);
                        this.dragPointers = {};
                    }
                    NodeDragGesture.prototype.addPointer = function (event, item) {
                        _super.prototype.addPointer.call(this, event, item);
                        // In addition to the node being dragged, also drag any selected links/nodes that are not already being dragged
                        // Links are not actually moved, but they are marked as "dragging" so they do not lose selection.
                        var allObjects = this.manager.chart.scene.selection.filter(function (x) { return !x.dragging; });
                        if (allObjects.indexOf(item.object) < 0)
                            allObjects.push(item.object);
                        var nodes = allObjects.filter(function (x) { return x instanceof Internal.ItemsChart.Node; });
                        for (var i = 0; i < nodes.length; i++) {
                            nodes[i].locks++;
                        }
                        for (var i = 0; i < allObjects.length; i++) {
                            allObjects[i].dragging = true;
                        }
                        var sceneCoords = this.manager.chart.scene.fromDisplay(event.x, event.y);
                        this.dragPointers[event.identifier] = {
                            nodes: nodes,
                            all: allObjects,
                            mainNode: item.object,
                            startPointerX: event.x,
                            startPointerY: event.y,
                            lastPointerX: event.x,
                            lastPointerY: event.y,
                            lastSceneX: sceneCoords.x,
                            lastSceneY: sceneCoords.y
                        };
                    };
                    NodeDragGesture.prototype.removePointer = function (event) {
                        _super.prototype.removePointer.call(this, event);
                        var pointerInfo = this.dragPointers[event.identifier];
                        delete this.dragPointers[event.identifier];
                        for (var i = 0; i < pointerInfo.nodes.length; i++) {
                            pointerInfo.nodes[i].locks--;
                        }
                        for (var i = 0; i < pointerInfo.all.length; i++) {
                            pointerInfo.all[i].dragging = false;
                        }
                        this.manager.autoZoomIn(event, pointerInfo.mainNode);
                    };
                    NodeDragGesture.prototype.movePointer = function (event) {
                        _super.prototype.movePointer.call(this, event);
                        var p = this.dragPointers[event.identifier];
                        p.lastPointerX = event.x;
                        p.lastPointerY = event.y;
                        var settings = this.manager.chart.settings.interaction.selection;
                        var scene = this.manager.chart.scene;
                        var sceneCoords = scene.fromDisplay(event.x, event.y);
                        var dx = sceneCoords.x - p.lastSceneX;
                        var dy = sceneCoords.y - p.lastSceneY;
                        if (dx === 0 && dy === 0)
                            return;
                        p.lastSceneX = sceneCoords.x;
                        p.lastSceneY = sceneCoords.y;
                        var lockNodes = settings.lockNodesOnMove;
                        if (lockNodes) {
                            // Only lock nodes if they have moved a larger amount of pixels than could be considered a tap.
                            var pdx = event.x - p.startPointerX;
                            var pdy = event.y - p.startPointerY;
                            var pointerSettings = this.manager.chart.settings.advanced.pointer;
                            var maxSensitivity = Math.max(pointerSettings.clickSensitivity, pointerSettings.longPressSensitivity);
                            lockNodes = pdx * pdx + pdy * pdy > maxSensitivity * maxSensitivity;
                        }
                        this.moveNodes(p.nodes, dx, dy, lockNodes);
                        this.manager.chart.events.notifySceneChanges({ coordinates: true });
                    };
                    NodeDragGesture.prototype.moveNodes = function (nodes, dx, dy, lockNodes) {
                        var scene = this.manager.chart.scene;
                        var bounds = scene.getVisibleBounds();
                        var zoom = scene.zoom;
                        var allowOffscreen = this.manager.chart.settings.interaction.selection.allowMoveNodesOffscreen;
                        for (var i = 0; i < nodes.length; i++) {
                            var node = nodes[i];
                            node.x += dx;
                            node.y += dy;
                            if (lockNodes)
                                node.userLock = true;
                            if (!allowOffscreen) {
                                var sizeX = node.renderHwidth * 1.2 / zoom;
                                var sizeY = node.renderHheight * 1.2 / zoom;
                                node.x = Math.min(Math.max(node.x, bounds.x0 + sizeX), bounds.x1 - sizeX);
                                node.y = Math.min(Math.max(node.y, bounds.y0 + sizeY), bounds.y1 - sizeY);
                            }
                        }
                    };
                    NodeDragGesture.prototype.doAnimations = function (event) {
                        var scene = this.manager.chart.scene;
                        // keep dragged nodes pinned to pointer positions
                        for (var i = 0; i < this.pointers.length; i++) {
                            var p = this.dragPointers[this.pointers[i]];
                            var sceneCoords = scene.fromDisplay(p.lastPointerX, p.lastPointerY);
                            var dx = sceneCoords.x - p.lastSceneX;
                            var dy = sceneCoords.y - p.lastSceneY;
                            if (dx !== 0 || dy !== 0) {
                                p.lastSceneX = sceneCoords.x;
                                p.lastSceneY = sceneCoords.y;
                                this.moveNodes(p.nodes, dx, dy, false);
                                event.changes.coordinates = true;
                            }
                        }
                    };
                    return NodeDragGesture;
                }(Gestures.Gesture));
                Gestures.NodeDragGesture = NodeDragGesture;
            })(Gestures = NetChart.Gestures || (NetChart.Gestures = {}));
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="MultiSelectGesture.ts" />
/// <reference path="NodeDragGesture.ts" />
/// <reference path="PanGesture.ts" />
/// <reference path="TwoFingerGesture.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var Gestures;
            (function (Gestures) {
                var emptyFindObject = { object: null, details: null };
                /*
                    This is where the complicated magic happens.
            
                    Available gestures:
            
                    1 finger:
                        a) On a node, if not holding still at first: drag node.
                        b) On link or empty area, if not holding still at first: pan.
                        c) On empty area, after holding still at first: multiselect.
                        d) On a node or link, after holding still at first: ignore pointer (right-click will happen independantly)
                    2 finger:
                        e) One or both in empty area - pan+zoom+rotate
            
                    Rules:
            
                    - From (a), after a second finger appears not on a node, transtion to (e).
                    - From (b), after a second finger appears anywhere, transition to (e).
                    - From (c) and (d) there are no transtions.
                    - From (e), after 1 finger is lifted, transition to (b).
            
                    - From (a), if node disappears, ignore pointer.
                    - If waiting for (d) and node disappears, ignore pointer.
                    - If waiting for (b)/(c) to trigger and node appears beneath the pointer, ignore the node and continue waiting.
            
                    - Only (a) can have multiple simultaneous instances. When reassigning, take any one.
                    - If (e) is in progress, disallow (b).
                    - If a pointer tries to drag a node which is already dragged, ignore that pointer, but keep it in mind for a transition to (e) later.
            
                    - If a pointer cannot be assigned to any gesture, ignore it.
                    - If a pointer is ignored, it will never participate in any gesture until it's lifted.
            
                */
                var GestureManager = (function (_super) {
                    __extends(GestureManager, _super);
                    function GestureManager(chart) {
                        _super.call(this);
                        this.animationOrder = 2000;
                        this.updateOrder = 1100;
                        this.paintOrder = 37;
                        this.hoverPointer = null;
                        this.ignoreGesture = new Gestures.Gesture(this); // Pointers in this gesture will be ignored until lifted.
                        this.postponeGesture = new Gestures.Gesture(this); // Pointers in this gesture will be ignored, but can become part of the two-finger gesture.
                        this.multiSelectGesture = new Gestures.MultiSelectGesture(this); // This gesture will contain at most 1 pointer and perform the drag-select
                        this.nodeDragGesture = new Gestures.NodeDragGesture(this); // This gesture can contain many pointers and each will drag one or more nodes.
                        this.panGesture = new Gestures.PanGesture(this); // This gesture can contain at most 1 pointer and will perform a pan
                        this.twoFingerGesture = new Gestures.TwoFingerGesture(this); // This gesture can contain 0 or 2 pointers and will perform the 2-finger rotate/pan/zoom gesture
                        this.pointerMap = {};
                        this.chart = chart;
                    }
                    GestureManager.prototype.findObject = function (event) {
                        var n = this.chart.renderer.findObjectAt(event.x, event.y, this.chart.settings.interaction.selection.tolerance);
                        return n ? n : emptyFindObject;
                    };
                    // ------------------------- Gesture events -------------------------
                    GestureManager.prototype.assignPointer = function (event, item, gesture) {
                        var info = this.pointerMap[event.identifier];
                        if (info) {
                            info.gesture.removePointer(event);
                            info.gesture = gesture;
                        }
                        else {
                            info = this.pointerMap[event.identifier] = {
                                gesture: gesture,
                                lastX: event.x,
                                lastY: event.y,
                                longPressGesture: null
                            };
                        }
                        gesture.addPointer(event, item);
                        return info;
                    };
                    GestureManager.prototype.reassignToTwoFinger = function (existingPointerId, event, item) {
                        var info = this.pointerMap[existingPointerId];
                        var fakeEvent = new Internal.Base.MouseEvent(info.lastX, info.lastY, event.timeStamp, existingPointerId);
                        info.longPressGesture = null;
                        this.assignPointer(fakeEvent, emptyFindObject, this.twoFingerGesture); // Reassign existing pointer
                        this.assignPointer(event, item, this.twoFingerGesture); // Add new pointer
                    };
                    GestureManager.prototype.assignUnknownPointer = function (event, item) {
                        if (item.object instanceof Internal.ItemsChart.Node && this.chart.settings.interaction.nodesMovable) {
                            this.assignNodePointer(event, item);
                        }
                        else {
                            this.assignEmptyPointer(event, item);
                        }
                    };
                    GestureManager.prototype.assignEmptyPointer = function (event, item) {
                        var settings = this.chart.settings.interaction;
                        var canTwoFinger = settings.rotation.fingers || settings.zooming.fingers;
                        var canDragSelect = settings.selection.enabled && settings.selection.dragSelect;
                        // Empty area. This can result in either single-finger pan, two-finger gesture, or multiselect.
                        if (this.twoFingerGesture.pointers.length > 0) {
                            // OK, we already have a two-finger gesture in progress. That means that we can only use this finger for multiselect at best.
                            var info = this.assignPointer(event, item, this.ignoreGesture);
                            if (canDragSelect)
                                info.longPressGesture = this.multiSelectGesture;
                        }
                        else if (canTwoFinger && this.panGesture.pointers.length > 0) {
                            // We don't have a two-finger gesture, but we do have a single-finger pan. Reassign both to the two-finger.
                            this.reassignToTwoFinger(this.panGesture.pointers[0], event, item);
                        }
                        else if (canTwoFinger && this.postponeGesture.pointers.length > 0) {
                            // We don't have a two-finger gesture, or a single-finger pan gesture, but we do have some postponed pointers. Take one
                            // of those pointers and reassign them to the two-finger gesture.
                            this.reassignToTwoFinger(this.postponeGesture.pointers[0], event, item);
                        }
                        else if (canTwoFinger && this.nodeDragGesture.pointers.length > 0) {
                            // We don't have a two-finger gesture, or a single-finger pan gesture, or postponed pointers, but we do have some dragged nodes. Take one
                            // of those pointers and reassign them to the two-finger gesture.
                            this.reassignToTwoFinger(this.nodeDragGesture.pointers[0], event, item);
                        }
                        else {
                            // Well, if we don't have ANYTHING else to tag this finger along, then add this to the single-finger gesture, with the option
                            // of becoming a drag gesture later on.
                            var info = this.assignPointer(event, item, settings.panning.enabled && this.panGesture.pointers.length < 1 ? this.panGesture : this.postponeGesture);
                            if (canDragSelect)
                                info.longPressGesture = this.multiSelectGesture;
                        }
                    };
                    GestureManager.prototype.assignNodePointer = function (event, item) {
                        // The pointer is over a node. This most likely means that we will need to drag the node, but there are a few exceptions
                        // to check first.
                        var settings = this.chart.settings.interaction;
                        var canTwoFinger = settings.rotation.fingers || settings.zooming.fingers;
                        if (canTwoFinger && this.panGesture.pointers.length > 0) {
                            // First, check if perhaps this is a part of the two-finger gesture. One case is if there is a pointer in the pan
                            // gesture. That also means that there is no two-finger gesture already in progress, since the two-finger gesture
                            // and the pan gesture are mutually exclusive.
                            this.reassignToTwoFinger(this.panGesture.pointers[0], event, item);
                        }
                        else if (canTwoFinger && this.postponeGesture.pointers.length > 0 && this.twoFingerGesture.pointers.length < 1) {
                            // Another case is if there is a pointer in the storage, but for this we need to explicitly check that a two-finger
                            // gesture isn't in progress and that a two-finger gesture is allowed at all.
                            this.reassignToTwoFinger(this.postponeGesture.pointers[0], event, item);
                        }
                        else if (item.object.dragging) {
                            // OK, this is not a part of a two-finger gesture. Then check if the node in question is already being dragged.
                            // If so, store this pointer for a potential two-finger gesture later. Don't treat it as an empty space gesture,
                            // because starting a pan/multiselect on a node would be weird. For the same reason, on longpress switch to ignore.
                            var info = this.assignPointer(event, item, this.postponeGesture);
                            info.longPressGesture = this.ignoreGesture;
                        }
                        else {
                            // Yessss, all checks clear, proceed to drag node. Also, on longpress, cancel the drag because the popup menu opened.
                            var info = this.assignPointer(event, item, this.nodeDragGesture);
                            info.longPressGesture = this.ignoreGesture;
                        }
                    };
                    GestureManager.prototype.updateSelection = function (event, obj) {
                        var settings = this.chart.settings.interaction.selection;
                        if (!settings.enabled)
                            return;
                        // If selection is enabled, update it. The rules:
                        //  1. NEVER touch nodes/links that are dragged or being box-selected. They stay in the selection, period. For all else:
                        //  2. In a nodes/links cannot be selected (settings.interaction.selection.linksSelectable/nodesSelectable), treat them as empty space.
                        //  3. If was clicked on a node/link:
                        //      a) If shift/ctrl is held down, then toggle selection status (add or remove to selection)
                        //      b) Otherwise, if it was selected, do nothing.
                        //      c) Otherwise, select it and deselect everything else.
                        //  4. If was clicked in empty space - do nothing here, this will be handled in OnInstantClick.
                        if (((obj.object instanceof Internal.ItemsChart.Node && settings.nodesSelectable) || (obj.object instanceof Internal.ItemsChart.Link && settings.linksSelectable))
                            && !obj.object.selectionLock && !obj.object.dragging) {
                            var hasChanges = false;
                            if (event.shiftKey || event.ctrlKey) {
                                // Clicked on something, while holding the shift/ctrl key. Toggle selection;
                                if (obj.object.selected) {
                                    hasChanges = this.chart.scene.removeFromSelection(obj.object);
                                }
                                else {
                                    hasChanges = this.chart.scene.addToSelection(obj.object);
                                }
                            }
                            else if (!obj.object.selected) {
                                // Clicked on something without holding the shift/ctrl key. If the object is not selected, deselect all that are not dragged, and select this one.
                                var newSelection = this.chart.scene.selection.filter(function (x) { return x.dragging || x.selectionLock; });
                                newSelection.push(obj.object);
                                hasChanges = this.chart.scene.setSelection(newSelection);
                            }
                            if (hasChanges) {
                                this.chart.scene.notifySelectionChangesIfNeeded(this.chart, "user");
                            }
                        }
                    };
                    GestureManager.prototype.onPointerDown = function (event) {
                        var item = this.findObject(event);
                        // First of all, update the selection. This always happens on pointer down only.
                        this.updateSelection(event, item);
                        // Selection up to date, now figure out what to do with the new pointer.
                        this.assignUnknownPointer(event, item);
                    };
                    GestureManager.prototype.onPointerUp = function (event) {
                        var info = this.pointerMap[event.identifier];
                        info.gesture.removePointer(event);
                        delete this.pointerMap[event.identifier];
                        if (info.gesture === this.twoFingerGesture) {
                            var id = this.twoFingerGesture.pointers[0];
                            var info2 = this.pointerMap[id];
                            delete this.pointerMap[id];
                            var fakeEvent = new Internal.Base.MouseEvent(info2.lastX, info2.lastY, event.timeStamp, id);
                            this.twoFingerGesture.removePointer(fakeEvent);
                            this.assignPointer(fakeEvent, emptyFindObject, this.chart.settings.interaction.panning.enabled ? this.panGesture : this.postponeGesture);
                        }
                    };
                    GestureManager.prototype.onPointerDrag = function (event) {
                        var info = this.pointerMap[event.identifier];
                        info.lastX = event.x;
                        info.lastY = event.y;
                        info.gesture.movePointer(event);
                    };
                    GestureManager.prototype.onPointerCancel = function (event) {
                        this.onPointerUp(event);
                    };
                    GestureManager.prototype.onInstantClick = function (event) {
                        // Selection update - deselect everything not dragged if clicked in empty space. This "deselect-all" is done here
                        // instead of with the rest of updateSelection(), because we do not want this deselection behavior if an empty-space
                        // gesture was started (like pan or multiselect).
                        if (!event.shiftKey && !event.ctrlKey && !this.findObject(event).object) {
                            var filteredSelection = this.chart.scene.selection.filter(function (x) { return x.dragging || x.selectionLock; });
                            if (filteredSelection.length !== this.chart.scene.selection.length) {
                                this.chart.scene.setSelection(filteredSelection);
                                this.chart.scene.notifySelectionChangesIfNeeded(this.chart, "user");
                            }
                        }
                    };
                    GestureManager.prototype.doAnimations = function (event) {
                        this.nodeDragGesture.doAnimations(event);
                        this.multiSelectGesture.doAnimations(event);
                    };
                    GestureManager.prototype.paintScene = function (event) {
                        this.multiSelectGesture.paintScene(event);
                    };
                    // ------------------------- Mundane click/wheel events -------------------------
                    GestureManager.prototype.buildClickEventArgs = function (event) {
                        var args = this.chart.createEventArguments(event, "user");
                        var n = this.findObject(event);
                        args.clickItem = n.details;
                        var obj = n.object;
                        if (obj instanceof Internal.ItemsChart.Node) {
                            args.clickNode = obj;
                            this.autoZoomIn(event, obj);
                        }
                        else {
                            args.clickLink = obj;
                        }
                        return args;
                    };
                    GestureManager.prototype.updateHover = function (event, n) {
                        event.cursor = n.object && n.object.cursor ? n.object.cursor : "default";
                        event.changes.current = true;
                        this.chart.scene.setActiveObject(n.object, n.details);
                        this.chart.notifyHoverChanged(event, this.chart.createEventArguments(null, "api"));
                    };
                    GestureManager.prototype.autoZoomIn = function (event, node) {
                        this.chart.scene.lastClickedNode = node;
                        if (this.chart.settings.interaction.zooming.autoZoomAfterClick) {
                            this.chart.scene.autoZoomMode = true;
                            event.changes.zoom = true;
                        }
                    };
                    /** Update the currently hovered object (link or node). */
                    GestureManager.prototype.onPointerMove = function (event) {
                        if (!this.chart.scene.xyInChart(event.x, event.y)) {
                            this.onPointerOut(event);
                            return;
                        }
                        this.hoverPointer = event.identifier;
                        var n = this.findObject(event);
                        if (n.object === (this.chart.scene.hoverLink || this.chart.scene.hoverNode) && n.details === this.chart.scene.hoverItem)
                            return;
                        this.updateHover(event, n);
                    };
                    /** If the currently hovered pointer goes out, remove hover. */
                    GestureManager.prototype.onPointerOut = function (event) {
                        if (this.hoverPointer === event.identifier) {
                            this.hoverPointer = null;
                            this.updateHover(event, emptyFindObject);
                        }
                        if (this.pointerMap[event.identifier]) {
                            this.onPointerUp(event);
                        }
                    };
                    /** Zoom in or out */
                    GestureManager.prototype.onWheel = function (event) {
                        if (!(this.chart.scene.xyInChart(event.x, event.y) && this.chart.settings.interaction.zooming.wheel)) {
                            return;
                        }
                        var zoomChange = Math.pow(1 + this.chart.settings.interaction.zooming.sensitivity, event.wheely * 0.004);
                        this.chart.autoZoom.manualZoom(zoomChange, event.x, event.y);
                        event.consumed = true;
                        event.changes.position = true;
                    };
                    GestureManager.prototype.onClick = function (event) {
                        if (!this.chart.scene.xyInChart(event.x, event.y)) {
                            return;
                        }
                        this.chart.notifyClick(event, this.buildClickEventArgs(event));
                        if (event.defaultPrevented) {
                            event.consumed = true;
                        }
                    };
                    GestureManager.prototype.onRightClick = function (event) {
                        if (!this.chart.scene.xyInChart(event.x, event.y)) {
                            return;
                        }
                        this.chart.notifyRightClick(event, this.buildClickEventArgs(event));
                        if (event.defaultPrevented) {
                            event.consumed = true;
                        }
                    };
                    GestureManager.prototype.onLongPress = function (event) {
                        if (!this.chart.scene.xyInChart(event.x, event.y)) {
                            return;
                        }
                        var info = this.pointerMap[event.identifier];
                        if (!info)
                            return;
                        if (info.longPressGesture) {
                            // Also, make sure that the multiSelectGesture only has one pointer assigned to it.
                            if (info.longPressGesture === this.multiSelectGesture && this.multiSelectGesture.pointers.length > 0)
                                info.longPressGesture = this.ignoreGesture;
                            this.assignPointer(event, emptyFindObject, info.longPressGesture);
                            info.longPressGesture = null;
                        }
                        // If this pointer is a part of some gesture, don't raise the normal right-click event.
                        event.consumed = (info.gesture !== this.ignoreGesture);
                    };
                    /** Raise click notification and zoom in if it wasn't cancelled. */
                    GestureManager.prototype.onDoubleClick = function (event) {
                        if (!this.chart.scene.xyInChart(event.x, event.y)) {
                            return;
                        }
                        this.chart.notifyDoubleClick(event, this.buildClickEventArgs(event));
                        if (event.defaultPrevented) {
                            event.consumed = true;
                        }
                        else {
                            var z = this.chart.settings.interaction.zooming.doubleClickZoom;
                            if (z && this.chart.settings.interaction.zooming.zoomInOnDoubleClick) {
                                this.chart.autoZoom.manualZoom(z, event.x, event.y);
                                event.changes.position = true;
                                event.consumed = true;
                            }
                        }
                    };
                    return GestureManager;
                }(Internal.Base.ChartElement));
                Gestures.GestureManager = GestureManager;
            })(Gestures = NetChart.Gestures || (NetChart.Gestures = {}));
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="moment.d.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var TimeChart;
        (function (TimeChart) {
            var FULL_DAY = 86400000;
            var TimeStep = (function () {
                function TimeStep(unit, count, name) {
                    this.count = count;
                    var u = TimeStep.parsingMap[unit];
                    if (!u)
                        throw new Error("Time unit `" + unit + "` is not recognized.");
                    this.unit = unit;
                    this.name = name === void 0 ? (this.count + " " + this.unit) : name;
                }
                TimeStep.isGoodUnit = function (unit) {
                    return TimeStep.parsingMap.hasOwnProperty(unit);
                };
                TimeStep.parse = function (input, name, throwErrors) {
                    if (throwErrors === void 0) { throwErrors = true; }
                    if (input == null) {
                        return null;
                    }
                    if (!Internal.Base.Helpers.isString(input)) {
                        if (input instanceof TimeStep)
                            return input;
                        if (throwErrors)
                            throw new Error("Cannot parse the unit text because it is not a string: " + input);
                        return null;
                    }
                    else {
                        var count = 1;
                        var unit = void 0;
                        var l = input.split(" ");
                        if (l.length === 2) {
                            count = Internal.Base.Helpers.tryParseFloat(l[0], null);
                            if (count === null || (count | 0) !== count) {
                                if (throwErrors)
                                    throw new Error("Cannot parse the time unit - the correct format is `1 s`: " + input);
                                return null;
                            }
                            unit = l[1];
                        }
                        else if (l.length === 1) {
                            count = 1;
                            unit = l[0];
                        }
                        else {
                            if (throwErrors)
                                throw new Error("Cannot parse the time unit - the correct format is `1 s`: " + input);
                            return null;
                        }
                        unit = TimeStep.parsingMap[unit];
                        if (unit == null) {
                            if (throwErrors)
                                throw new Error("Cannot parse the time unit - unrecognized time unit: " + input);
                            return null;
                        }
                        return new TimeStep(unit, count, name || input);
                    }
                };
                TimeStep.prototype.clone = function () {
                    return new TimeStep(this.unit, this.count, this.name);
                };
                TimeStep.prototype.add = function (time, times) {
                    if (times === void 0) { times = 1; }
                    var unit = this.unit;
                    var count = this.count * times;
                    if (unit === "ms") {
                        time += count;
                    }
                    else if (unit === "s") {
                        time += count * 1000;
                    }
                    else if (unit === "m") {
                        time += count * 60000;
                    }
                    else if (unit === "h") {
                        time += count * 3600000;
                    }
                    else if (unit === "d") {
                        time += count * FULL_DAY;
                    }
                    else if (unit === "w") {
                        time += count * FULL_DAY * 7;
                    }
                    else {
                        var t = new Date(time);
                        if (unit === "y") {
                            t.setUTCFullYear(t.getUTCFullYear() + count);
                        }
                        else if (unit === "M") {
                            t.setUTCMonth(t.getUTCMonth() + count);
                        }
                        time = t.getTime();
                    }
                    return time;
                };
                TimeStep.prototype.sub = function (time, times) {
                    if (times === void 0) { times = 1; }
                    return this.add(time, -1 * times);
                };
                TimeStep.prototype.numberOfUnits = function (from, to) {
                    return Math.round(TimeChart.moment(to).utc().diff(TimeChart.moment(from).utc(), TimeStep.unitsTranslation[this.unit], true) / this.count);
                };
                /** Returns the string representation of the unit (for example `5 m`) with the exception that when the count
                is 1, the function returns just the unit (so instead of `1 m` it returns `m`). */
                TimeStep.prototype.toShortString = function () {
                    if (this.count === 1) {
                        return this.unit;
                    }
                    else {
                        return this.toString();
                    }
                };
                TimeStep.prototype.toString = function () {
                    return this.count + " " + this.unit;
                };
                TimeStep.prototype.approxTime = function () {
                    return TimeStep.timeUnitDiffs[this.unit] * this.count;
                };
                TimeStep.prototype.isSmallerOrEqual = function (bigger) {
                    return this.approxTime() <= bigger.approxTime();
                };
                TimeStep.prototype.isSmaller = function (bigger) {
                    return this.approxTime() < bigger.approxTime();
                };
                TimeStep.prototype.isBigger = function (smaller) {
                    return this.approxTime() > smaller.approxTime();
                };
                TimeStep.prototype.isEqual = function (step) {
                    if (!step)
                        return false;
                    return this.approxTime() === step.approxTime();
                };
                TimeStep.prototype.getBigger = function () {
                    if (this.unit === "y") {
                        return new TimeStep(this.unit, this.count * 10);
                    }
                    else {
                        return new TimeStep(TimeStep.toBiggerUnit[this.unit], 1);
                    }
                };
                TimeStep.prototype.roundTimeDown = function (time, settings) {
                    if (time == null)
                        return null;
                    // round to specific units
                    time = Math.round(time);
                    var times = this.count;
                    var unit = this.unit;
                    if (unit === "ms") {
                        return Math.floor(time / times) * times;
                    }
                    if (unit === "s") {
                        return Math.floor(time / 1000 / times) * times * 1000;
                    }
                    if (unit === "m") {
                        return Math.floor(time / 60000 / times) * times * 60000;
                    }
                    if (unit === "h") {
                        return Math.floor(time / 3600000 / times) * times * 3600000;
                    }
                    if (unit === "d") {
                        if (times % 7 === 0) {
                            // if the unit is whole weeks but specified in days, use the same rounding as weeks would (so that they start on monday always).
                            unit = "w";
                            times = times / 7;
                        }
                        else {
                            return Math.floor(time / FULL_DAY / times) * times * FULL_DAY;
                        }
                    }
                    if (unit === "w") {
                        var c = settings.week.dow + 3;
                        var otime = time;
                        time = (time / FULL_DAY - c) / 7 + 1;
                        time = (Math.floor(time / times) * times * 7 + c) * FULL_DAY;
                        // an easy workaround for all the cases when the simple algorithm above produces error by 1 week.
                        if (time > otime)
                            time -= FULL_DAY * 7; // 1 week
                        return time;
                    }
                    // first round down to day
                    var t = new Date(Math.floor(time / FULL_DAY) * FULL_DAY);
                    if (unit === "y") {
                        t.setUTCFullYear(Math.floor(t.getUTCFullYear() / times) * times, 0, 1);
                        return t.getTime();
                    }
                    if (unit === "M") {
                        var currentMonth = t.getUTCFullYear() * 12 + t.getUTCMonth();
                        t.setUTCMonth(t.getUTCMonth() + Math.floor(currentMonth / times) * times - currentMonth, 1);
                        return t.getTime();
                    }
                    throw new Error("Unrecognized unit: `" + this.unit + "`");
                };
                TimeStep.prototype.roundTimeUp = function (time, settings) {
                    if (time == null)
                        return null;
                    return this.roundTimeDown(this.add(time) - 1, settings);
                };
                TimeStep.prototype.roundTimeRound = function (time, settings) {
                    if (time == null)
                        return null;
                    return this.roundTimeDown((this.add(time) + time - 1) / 2, settings);
                };
                /**
                 * Tests if a time period represented by this instance can be created by adding together multiple smaller
                 * time periods.
                 * For example, `2 d` is multiple of `6 h` but `1 w` is not multiple of `3 d`.
                 */
                TimeStep.prototype.isMultipleOf = function (candidate) {
                    var reqU = this.unit;
                    var candU = candidate.unit;
                    var reqSize = this.approxTime();
                    var candSize = candidate.approxTime();
                    var prop = reqSize / candSize;
                    // for example, if the required unit is 2 days but the candidate is 5 hours, it cannot be used
                    // since the ratio is 9.6, not a whole number.
                    // this also filters out candidates that are larger than the required unit.
                    if (prop < 1 || (prop | 0) !== prop)
                        return false;
                    // the units match and the proportion was already verified.
                    if (reqU === candU)
                        return true;
                    // if the candidate unit is not a multiple, it can make up any larger unit. The exception is weeks
                    // as the start of a month of a year can be in the middle of the week.
                    if (candidate.count === 1 && candU !== "w")
                        return true;
                    var oneDay = 86400000;
                    var dayProp = oneDay / candSize;
                    if (dayProp >= 1 && (dayProp | 0) === dayProp) {
                        // if a single day is the multiple of the candidate then all units (y/M/w) are ok.
                        return true;
                    }
                    if (reqU === "y") {
                        // since the number of weeks and days are different from year to year, they cannot be used for
                        // automatic aggregation.
                        return candU === "M";
                    }
                    else if (reqU === "M" || reqU === "w") {
                        // number of days changes between months so the start of a X-day period might not match the start
                        // of the month.
                        // weeks are not automatically aggregated because of start-of-the-week handling which might not
                        // match the start of the X-day period
                        return false;
                    }
                    else {
                        // any smaller units can safely be aggregated.
                        return true;
                    }
                };
                TimeStep.parsingMap = {
                    milliseconds: "ms",
                    millisecond: "ms",
                    sec: "s",
                    second: "s",
                    seconds: "s",
                    min: "m",
                    minute: "m",
                    minutes: "m",
                    hour: "h",
                    hours: "h",
                    day: "d",
                    days: "d",
                    week: "w",
                    weeks: "w",
                    mon: "M",
                    month: "M",
                    months: "M",
                    year: "y",
                    years: "y",
                    ms: "ms",
                    s: "s",
                    m: "m",
                    h: "h",
                    d: "d",
                    D: "d",
                    w: "w",
                    W: "w",
                    M: "M",
                    y: "y",
                    Y: "y"
                };
                TimeStep.knownUnits = [
                    "ms",
                    "s",
                    "m",
                    "h",
                    "d",
                    "w",
                    "M",
                    "y"
                ];
                /** approximate to take care of any irregularities. This is mainly used by calling TimeStep.approxTime() which in turn is mostly used
                to compare two units to see which is larger or if they are equal. Note that a very important is TimeStep.isMultipleOf() - because of this method
                the year must be 12xMonth instead of 365xDay. */
                TimeStep.timeUnitDiffs = {
                    "ms": 1,
                    "s": 1000,
                    "m": 60 * 1000,
                    "h": 60 * 60 * 1000,
                    "d": 24 * 60 * 60 * 1000,
                    "w": 7 * 24 * 60 * 60 * 1000,
                    "M": 30 * 24 * 60 * 60 * 1000,
                    "y": 12 * 30 * 24 * 60 * 60 * 1000
                };
                TimeStep.unitsTranslation = {
                    s: "second",
                    m: "minute",
                    h: "hour",
                    d: "day",
                    w: "week",
                    M: "month",
                    y: "year"
                };
                TimeStep.toBiggerUnit = {
                    ms: "s",
                    s: "m",
                    m: "h",
                    h: "d",
                    d: "w",
                    w: "M",
                    M: "y",
                    y: null
                };
                TimeStep.toSmallerUnit = {
                    ms: null,
                    s: "ms",
                    m: "s",
                    h: "m",
                    d: "h",
                    w: "d",
                    M: "d",
                    y: "M"
                };
                return TimeStep;
            }());
            TimeChart.TimeStep = TimeStep;
        })(TimeChart = Internal.TimeChart || (Internal.TimeChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Legend.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var LinearChart;
        (function (LinearChart) {
            var SettingsLegend = (function (_super) {
                __extends(SettingsLegend, _super);
                function SettingsLegend() {
                    _super.apply(this, arguments);
                    this.panel = new Internal.Base.SettingsLegendPanel("bottom", "left", void 0, 95);
                    this.advanced = new SettingsLegendAdvanced();
                    this.marker = new SettingsLegendMarker();
                }
                return SettingsLegend;
            }(Internal.Base.SettingsLegend));
            LinearChart.SettingsLegend = SettingsLegend;
            var SettingsLegendMarker = (function (_super) {
                __extends(SettingsLegendMarker, _super);
                function SettingsLegendMarker() {
                    _super.apply(this, arguments);
                    /** Specifies the shape for markers in the legend. If the value is `null` then the small icon representing the series is drawn.
            
                    @type enum
                    @value circle - draws circles
                    @value square - draws rectangles
                    @value rhombus - draws rhombus (diamonds)
                    @value triangle - draws triangles, pointing up
                    @value triangle2 - draws triangles, pointing down
            
                    @version 1.13.2*/
                    this.shape = null;
                }
                return SettingsLegendMarker;
            }(Internal.Base.SettingsLegendMarker));
            LinearChart.SettingsLegendMarker = SettingsLegendMarker;
            var SettingsLegendAdvanced = (function (_super) {
                __extends(SettingsLegendAdvanced, _super);
                function SettingsLegendAdvanced() {
                    _super.apply(this, arguments);
                    /** Style for legend entry when a disabled series is displayed. */
                    this.disabledSeries = {
                        fillColor: "rgba(191,187,185,0.3)",
                        lineColor: "rgba(64,62,62,0.3)",
                        textColor: "rgba(64,62,62,0.3)"
                    };
                }
                return SettingsLegendAdvanced;
            }(Internal.Base.SettingsLegendAdvanced));
            LinearChart.SettingsLegendAdvanced = SettingsLegendAdvanced;
            var LegendEntry = (function (_super) {
                __extends(LegendEntry, _super);
                function LegendEntry(series, label, textColor, textColorDisabled, groupId, enabled, disabledSeries) {
                    _super.call(this, label, textColor, textColorDisabled, groupId);
                    this.seriesHovered = false;
                    this.disabledSeries = disabledSeries;
                    this.series = series;
                    this.enabled = enabled;
                }
                LegendEntry.prototype.isHovered = function () {
                    return this.hoverCount > 0 || this.seriesHovered;
                };
                return LegendEntry;
            }(Internal.Base.LegendEntry));
            var Legend = (function (_super) {
                __extends(Legend, _super);
                function Legend(chart) {
                    _super.call(this, chart);
                    // Event order
                    this.paintOrder = 75;
                    this.updateOrder = 100;
                }
                Legend.prototype.notifyHoveredSeries = function (series) {
                    for (var i = 0; i < this.entries.length; i++) {
                        var entry = this.entries[i];
                        entry.seriesHovered = entry.series.indexOf(series) >= 0;
                    }
                };
                Legend.prototype.getLastHoveredSeries = function () {
                    var entry = this.getLastHoveredEntry();
                    return entry ? entry.series[0] : null;
                };
                Legend.prototype.onSceneChange = function (event) {
                    _super.prototype.onSceneChange.call(this, event);
                    var ch = event.changes;
                    if (ch.linearChartSeries) {
                        this.rebuildItems(event);
                        ch.bounds = true;
                    }
                };
                Legend.prototype.paintMarker = function (event, cx, cy, radius, item) {
                    var context = event.context;
                    var series = item.isEnabled() ? item.series[0] : item.disabledSeries;
                    var config = this.settings.marker;
                    var seriesConfig = series.style.legend.marker;
                    var shape = seriesConfig.shape || config.shape;
                    context.beginPath();
                    if (shape) {
                        var markerStyle = {
                            fillColor: seriesConfig.fillColor || series.style.fillColor || series.style.lineColor,
                            lineColor: seriesConfig.lineColor || config.lineColor,
                            lineWidth: seriesConfig.lineWidth || 1
                        };
                        if (seriesConfig.width != null)
                            radius = seriesConfig.width / 2;
                        Internal.Base.Graphics.strokeMarker(context, shape, cx, cy, radius);
                        Internal.Base.Graphics.paint(context, markerStyle);
                    }
                    else {
                        var size = config.size;
                        var px1 = cx - size / 2;
                        var px2 = cx;
                        var px3 = cx + size / 2;
                        var py1 = size / 2.1;
                        var py2 = size / 2;
                        var py3 = (size * 3) / 4;
                        var zeroY = cy + size / 2;
                        if (series instanceof LinearChart.SettingsSeriesLines) {
                            var origMarkerWidth = series.style.marker.width;
                            series.style.marker.width *= 0.8;
                            var yStack = [[py1, py2, py3]];
                            var centers = [px1, px2, px3];
                            var segments = [centers, [zeroY - py1, zeroY - py2, zeroY - py3]];
                            var pos = zeroY - py2;
                            var renderer = new LinearChart.Renderers.Line(null, [series]);
                            renderer.paintLines(context, [series], [{ markerY: null, segments: segments }], centers, [null], yStack, zeroY);
                            renderer.paintMarkers(context, series, [px2], [py2], [pos]);
                            series.style.marker.width = origMarkerWidth;
                        }
                        else if (series instanceof LinearChart.SettingsSeriesColumns) {
                            var yStack = [size, size];
                            var renderer2 = new LinearChart.Renderers.Columns(this.chart.scene, [series]);
                            renderer2.paintStack(event, [cx], [size / 2], [yStack], [null], zeroY);
                        }
                        else if (series instanceof LinearChart.SettingsSeriesCandleStick) {
                            var candleRenderer = new LinearChart.Renderers.Candlestick(this.chart.scene, [series]);
                            var yStacks = [
                                [0],
                                [size / 3],
                                [(size * 2) / 3],
                                [size]
                            ];
                            candleRenderer.paintStack(event, [cx], [size / 2], yStacks, [null], zeroY);
                        }
                    }
                };
                Legend.prototype.rebuildItems = function (event) {
                    var items = [];
                    var seriesArray = this.chart.scene.settings._computedSeries;
                    var disabledSeriesSettings = this.settings.advanced.disabledSeries;
                    var candleStacks = {};
                    var baseTextColor = this.settings.text.fillColor;
                    for (var seriesIndex = 0; seriesIndex < seriesArray.length; seriesIndex++) {
                        var series = seriesArray[seriesIndex];
                        if (!series.showInLegend)
                            continue;
                        var entrySeries = void 0;
                        if (series instanceof LinearChart.SettingsSeriesCandleStick) {
                            if (Internal.Base.Helpers.hasProperty(candleStacks, series.stack)) {
                                candleStacks[series.stack].push(series);
                                continue;
                            }
                            entrySeries = [series];
                            candleStacks[series.stack] = entrySeries;
                        }
                        else {
                            entrySeries = [series];
                        }
                        var name = series.nameLegend || series.name || this.chart.settings.localization.unnamedSeries;
                        var disabledSeries = Internal.Base.Helpers.realClone(series);
                        var disabledSeriesStyle = disabledSeries.style;
                        // disabled series color set. Only overwrite color if there alredy is a color set. No colors (transparent) stay transparent.
                        disabledSeriesStyle.fillColor = disabledSeriesStyle._currentFillStyle = disabledSeriesStyle.fillColor && disabledSeriesSettings.fillColor;
                        disabledSeriesStyle._currentFillStyleKey = null;
                        if (disabledSeriesStyle.fillPattern) {
                            // apply the pattern on top of the disabled fillColor set above
                            disabledSeriesStyle._fillPatternOpacity = 0.3;
                            LinearChart.Series.Stack.computeFillPattern(this.chart, event.context, disabledSeriesStyle);
                        }
                        disabledSeriesStyle.lineColor = disabledSeriesSettings.lineColor;
                        var ms = disabledSeriesStyle.legend.marker;
                        ms.fillColor = ms.fillColor && disabledSeriesSettings.fillColor;
                        ms.lineColor = ms.lineColor && disabledSeriesSettings.lineColor;
                        items.push(new LegendEntry(entrySeries, name, series.style.legend.textColor || baseTextColor, disabledSeriesSettings.textColor, series.legendGroupId, series.enabled, disabledSeries));
                    }
                    this.resetEntries(items);
                };
                Legend.prototype.itemClicked = function (event, item) {
                    _super.prototype.itemClicked.call(this, event, item);
                    for (var i = 0; i < this.entries.length; i++) {
                        var entry = this.entries[i];
                        for (var j = 0; j < entry.series.length; j++)
                            entry.series[j].enabled = entry.enabled;
                    }
                    this.chart.events.notifySceneChanges({
                        linearChartSeries: true
                    });
                };
                return Legend;
            }(Internal.Base.Legend));
            LinearChart.Legend = Legend;
        })(LinearChart = Internal.LinearChart || (Internal.LinearChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var LinearChart;
        (function (LinearChart) {
            var SettingsValueAxis = (function () {
                function SettingsValueAxis() {
                    /** Show/hide value axis. */
                    this.enabled = true;
                    /** Whether to use logarithmic scale. */
                    this.logScale = false;
                    /** Location of the value axis.
                    @type enum
                    @value inside - on the left side, outside of the chart
                    @value outside - on the left side, inside of the chart */
                    this.position = "outside";
                    /** Value axis side in chart. Possible values: "left" or "right". */
                    this.side = "left";
                    /** Title text for the value axis. */
                    this.title = null;
                    /** Fixed minimum value for value axis. If not set it will be computed automatically from visible data and zeroLine settings.
                    @type float */
                    this.minValue = null;
                    /** Fixed maximum value for value axis. If not set it will be computed automatically from visible data and zeroLine settings.
                    @type float */
                    this.maxValue = null;
                    /** Fixed width of the value axis. If not set it will be computed automatically from font size.
                    @type integer
                    @units pixels */
                    this.size = null;
                    /** Whether to show horizontal grid lines. Specifying `null` means that only the first value axis will show the horizontal lines,
                    all other axis will not. */
                    this.hgrid = null;
                    /** Whether to show vertical line along value axis */
                    this.axisLine = false;
                    /** This tolerance specifies how big that part is as fraction of total chart height. When part of the vertical space
                    is not used chart scale is automatically adjusted.
                    @type float */
                    this.scaleAdjustmentTolerance = 0.3;
                    /** Scale adjustment animation duration.
                    @type integer
                    @units milliseconds */
                    this.scaleAdjustmentAnimationDelay = 200;
                    /** The animation easing function.
                    @type enum
                    @value = - linear animation
                    @value <> - quadratic easing */
                    this.scaleAdjustmentAnimation = "=";
                    /** Difference between two values on the axis. If not set (default), will be automatically calculated from chart height, min,
                    max value and style.labelSpacing.
                    @type float
                    @units scale */
                    this.scaleStep = null;
                    /** Smallest difference between two labels. For example, use 1 to disallow the labels to go into fractions.
                    @type float
                    @units scale */
                    this.scaleMinStep = 0;
                    /** Zero line.
                    @type enum
                    @value visible - adjusts position accordingly to the min/max values
                    @value center - always centered
                    @value floating - can be outside the visible chart - shown only range between min-max values. */
                    this.zeroLine = "visible";
                    /** Prepare custom format values to display in value axis. If using this, consider also setting the `size` parameter to
                    accommodate your label size.
            
                    @returns string to display at the value
                    @version 1.15.7 - the callback is invoked to get the size of the axis if `size` is not specified. */
                    this.valueFormatterFunction = null;
                    /** Style for parts of value axis. */
                    this.style = {
                        /** Title text for the value axis.
                        @version 1.15.0 - moved `font`, `fillColor` properties to under `textStyle`. */
                        title: {
                            textStyle: {
                                fillColor: "#000000",
                                font: "13px Arial",
                            },
                            reverseDirection: false,
                            align: "center",
                            margin: 5
                        },
                        /** Value axis tick lines style. */
                        tick: { lineColor: "#AAAAAA" },
                        /** Rendering style for the vertical line along value axis. */
                        axisLine: {
                            lineColor: "rgba(127,127,127,0.5)",
                            lineWidth: 1
                        },
                        /** Value axis label rendering settings.
                        @version 1.15.0 - moved `font`, `fillColor` properties to under `textStyle`. */
                        valueLabel: {
                            textStyle: {
                                fillColor: "#000000",
                                font: "11px Arial",
                            },
                            margin: 0
                        },
                        /** Distance between value axis labels.
                        @type float
                        @units pixels */
                        labelSpacing: 25,
                        /** Base line settings. It is the horizontal line showing zero value. */
                        baseLine: {
                            lineColor: "rgba(127,127,127,0.5)",
                            depthColor: "rgba(127,127,127,0.5)",
                            lineWidth: 1,
                            lineDepth: 0,
                            showLabel: 1 /* auto */
                        },
                        /** Horizontal grid lines. */
                        hgrid: {
                            lineColor: "rgba(255,255,255,0.2)"
                        }
                    };
                    /** Provides the ability to draw threshold guidelines and fill background areas for certain values. For example, this can be used
                        to highlight an area that exceeds certain limit. */
                    this.thresholds = [];
                }
                return SettingsValueAxis;
            }());
            LinearChart.SettingsValueAxis = SettingsValueAxis;
            var SettingsValueAxisThreshold = (function () {
                function SettingsValueAxisThreshold() {
                    /** Specifies the bottom bound of the threshold area. */
                    this.from = -Infinity;
                    /** Specifies the upper bound of the threshold area. */
                    this.to = Infinity;
                    /** Threshold placement in relation to series data.
                     @type enum
                     @value above - denote threshold location over series data
                     @value under - denote threshold location under series data
                     **/
                    this.position = "under";
                    /** Describes the visual style for the threshold guidelines and area. */
                    this.style = {
                        /** Specifies the fill color for the threshold area. If multiple areas overlap, this should specify an `rgba()` color with transparency.
                            If 'null' fill color will not be applied.
                        @type color */
                        fillColor: "rgba(255,133,152,0.2)",
                        /** Specifies the line color for the upper and lower bounds. If `null`, the lines will not be drawn.
                        @type color */
                        lineColor: "rgba(255,0,0,0.5)",
                        /** Specifies the width of the boundary lines. */
                        lineWidth: 1,
                        /** Array of line dash pattern to have a dashed line. The array contains length of dash followed by length of space in pixels.
                        A sequence of multiple dash-space values is supported. */
                        lineDash: null
                    };
                }
                return SettingsValueAxisThreshold;
            }());
            LinearChart.SettingsValueAxisThreshold = SettingsValueAxisThreshold;
            var ValueAxis = (function () {
                function ValueAxis(chart, options) {
                    var _this = this;
                    this.locations = [];
                    this.values = [];
                    this.labels = [];
                    this.title = null;
                    this.cachedUnits = {
                        lin: [],
                        log: []
                    };
                    /** Specifies if this instance is considered to be the primary axis when multiple are being used on the same chart. */
                    this.isPrimary = false;
                    this._chart = chart;
                    this.options = options;
                    this.events = chart.events;
                    this.scene = chart.scene;
                    this.isLogScale = this.options.logScale;
                    this.isInside = this.options.position === "inside";
                    this.panel = new Internal.Base.ChartPanel();
                    // after bottom axis
                    this.panel.packingOrder = 110;
                    this.panel.computeSize = function (aw, ah, g, lr) { return _this.computePanelSize(aw, ah, g, lr); };
                    // series min value from last paint
                    this.lastMaxValue = 0;
                    // series max value from last paint
                    this.lastMinValue = 0;
                    // current min value - corresponds to y = y0
                    this.minValue = 0;
                    // current max value - corresponds to y = y1
                    this.maxValue = 0;
                    this.scale = 0;
                    this.zeroY = 0;
                    this.logOffset = 1;
                    this.minValueAnimation = null;
                    this.maxValueAnimation = null;
                    // is set to true if the transform is changed.
                    this.axisChanged = false;
                    this.seriesDepth = 0;
                    this.seriesMinValue = null;
                    this.seriesMaxValue = null;
                    // number of assoc series
                    this.series = 0;
                    this.createTitle();
                }
                ValueAxis.prototype.createTitle = function () {
                    var config = this.options;
                    var styleConfig = config.style.title;
                    var title = this.title = new Internal.Base.Label(styleConfig);
                    title.text = config.title;
                    title.allowCache = false; // cached rotated labels lose some of their quality.
                    var angle = title.style.angle;
                    if (angle == null)
                        angle = (config.side === "right") ? 90 : (-90);
                    if (styleConfig.reverseDirection)
                        angle = -angle;
                    title.style.angle = angle;
                };
                ValueAxis.prototype.getPanel = function () {
                    var config = this.options;
                    if (!config.enabled) {
                        return null;
                    }
                    this.panel.location = config.position;
                    this.panel.side = config.side;
                    return this.panel;
                };
                ValueAxis.prototype.setPanel = function (panel) {
                    if (panel != null)
                        this.panel = panel;
                };
                ValueAxis.prototype.computePanelSize = function (availableWidth, availableHeight, context, labelRenderer) {
                    if (!this._chart.assetsLoaded)
                        return { width: 0, height: 0 };
                    // magic number 8 - the width that will be taken by the horizontal "ticks" next to the labels.
                    var size = 8;
                    var title = this.title;
                    if (title) {
                        title.style.maxWidth = availableHeight;
                    }
                    var options = this.options;
                    if (options.size) {
                        size = options.size;
                    }
                    else {
                        var style = options.style.valueLabel;
                        var maxWidthString = "9999 M";
                        if (options.valueFormatterFunction) {
                            maxWidthString = options.valueFormatterFunction(1e7 - 1 - 2e-4, "M", 1e6, maxWidthString) || maxWidthString;
                        }
                        else {
                            // ugly hack so that the default axis size match the one before the changes - mainly so that
                            // the test baselines are still correct.
                            size++;
                        }
                        size += 2 * style.margin + Internal.Base.Graphics.getTextWidth(context, style.textStyle, maxWidthString);
                        if (title && title.text) {
                            labelRenderer.measure(context, title);
                            size += 2 * (title.style.margin + title.hheight);
                        }
                    }
                    return {
                        width: Math.ceil(size),
                        height: availableHeight
                    };
                };
                /** 1 - gets min max and depth from series during series.process */
                ValueAxis.prototype.receiveSeriesGeometry = function (min, max, depth) {
                    if (this.options.minValue !== null) {
                        this.seriesMinValue = this.options.minValue;
                    }
                    else if (min !== void 0) {
                        if (this.seriesMinValue !== null) {
                            this.seriesMinValue = Math.min(min, this.seriesMinValue);
                        }
                        else {
                            this.seriesMinValue = min;
                        }
                    }
                    if (this.options.maxValue !== null) {
                        this.seriesMaxValue = this.options.maxValue;
                    }
                    else if (max !== void 0) {
                        if (this.seriesMaxValue !== null) {
                            this.seriesMaxValue = Math.max(max, this.seriesMaxValue);
                        }
                        else {
                            this.seriesMaxValue = max;
                        }
                    }
                    this.seriesDepth = Math.max(depth, this.seriesDepth);
                };
                /** 2 - computes scale - if min, max changes or bounds changes. */
                ValueAxis.prototype.updateMinMax = function (event) {
                    // update scale if needed
                    var changes = event.changes;
                    var hasChanges = changes.bounds || changes.assets || this.locations.length === 0;
                    if (changes.settings) {
                        this.isLogScale = this.options.logScale;
                        this.isInside = this.options.position === "inside";
                        hasChanges = true;
                    }
                    if (this.shouldChangeScale()) {
                        if (this.seriesMinValue !== this.lastMinValue) {
                            hasChanges = true;
                            if (this.lastMinValue === null || changes.displayUnit || this.minValue === this.maxValue) {
                                // no animation
                                this.minValueAnimation = null;
                            }
                            else {
                                // with animation
                                if (this.minValueAnimation) {
                                    this.minValueAnimation.retarget(this.seriesMinValue, event.timeStamp);
                                }
                                else {
                                    this.minValueAnimation = new Internal.Base.Animator(this.lastMinValue, this.seriesMinValue, this.options.scaleAdjustmentAnimationDelay, this.options.scaleAdjustmentAnimation, event.timeStamp);
                                }
                            }
                            this.lastMinValue = this.seriesMinValue;
                        }
                        if (this.seriesMaxValue !== this.lastMaxValue) {
                            hasChanges = true;
                            if (this.lastMaxValue === null || changes.displayUnit || this.minValue === this.maxValue) {
                                // no animation
                                this.maxValueAnimation = null;
                            }
                            else {
                                // with animation
                                if (this.maxValueAnimation) {
                                    this.maxValueAnimation.retarget(this.seriesMaxValue, event.timeStamp);
                                }
                                else {
                                    this.maxValueAnimation = new Internal.Base.Animator(this.lastMaxValue, this.seriesMaxValue, this.options.scaleAdjustmentAnimationDelay, this.options.scaleAdjustmentAnimation, event.timeStamp);
                                }
                            }
                            this.lastMaxValue = this.seriesMaxValue;
                        }
                    }
                    // clear series min, max for next frame
                    this.seriesMaxValue = this.options.minValue;
                    this.seriesMinValue = this.options.maxValue;
                    var min;
                    var max;
                    // do animations
                    if (this.minValueAnimation) {
                        hasChanges = true;
                        min = this.minValueAnimation.get(event.timeStamp);
                        if (this.minValueAnimation.finished(event.timeStamp)) {
                            this.minValueAnimation = null;
                        }
                    }
                    else {
                        min = this.lastMinValue;
                    }
                    if (this.maxValueAnimation) {
                        hasChanges = true;
                        max = this.maxValueAnimation.get(event.timeStamp);
                        if (this.maxValueAnimation.finished(event.timeStamp)) {
                            this.maxValueAnimation = null;
                        }
                    }
                    else {
                        max = this.lastMaxValue;
                    }
                    this.axisChanged = hasChanges;
                    if (hasChanges) {
                        this.computeNewScale(min, max);
                    }
                    if (this.minValueAnimation || this.maxValueAnimation) {
                        event.animating = true;
                    }
                };
                /** 3 - prepares label locations for paint - if axis scale changes */
                ValueAxis.prototype.doAnimations = function (event) {
                    if (!this.axisChanged || !this._chart.assetsLoaded) {
                        return;
                    }
                    this.axisChanged = false;
                    var config = this.options;
                    if (!config.enabled) {
                        return;
                    }
                    this.locations = [];
                    this.values = [];
                    // half of the font size * 1.5
                    // TODO: only supports font sizes in pixels!
                    var isRightSide = config.side === "right";
                    var y0 = this.scene.y0;
                    var y1 = y0 + this.scene.height;
                    var valuePerLine;
                    // dummy scale when no data
                    if (this.scale <= 0) {
                        if (config.scaleStep) {
                            valuePerLine = config.scaleStep;
                        }
                        else {
                            valuePerLine = 100;
                        }
                        var vstep = config.style.labelSpacing;
                        var y = y1 - vstep;
                        var v = 1;
                        if (!config.logScale) {
                            v = valuePerLine;
                        }
                        while (y > y0) {
                            this.locations.push(y);
                            // some dummy values
                            this.values.push(v);
                            if (config.logScale) {
                                v *= 10;
                            }
                            else {
                                v += valuePerLine;
                            }
                            y -= vstep;
                        }
                    }
                    else {
                        if (!this.fontHeight)
                            this.fontHeight = (Internal.Base.Graphics.getTextHeight(event.context, config.style.valueLabel.textStyle.font) * 1.4) || 0;
                        // make sure the labels are not drawn outside the canvas
                        if (y0 === 0)
                            y0 += this.fontHeight / 2;
                        if (this.scene.bottomAxisSize < this.fontHeight)
                            y1 -= this.fontHeight / 2;
                        // normal data
                        if (!this.isLogScale) {
                            valuePerLine = this.calcLinearValuePerLine();
                            var value = 0;
                            if (config.scaleStep) {
                                valuePerLine = Math.max(valuePerLine, this.fontHeight / this.scale);
                            }
                            while (true) {
                                value += valuePerLine;
                                var valueY = this.zeroY - this.valueToRelativeY(value);
                                if (valueY <= y0)
                                    break;
                                if (valueY >= y1)
                                    continue;
                                this.locations.push((valueY | 0));
                                this.values.push(value);
                            }
                            value = 0;
                            while (true) {
                                value -= valuePerLine;
                                var valueY = this.zeroY - this.valueToRelativeY(value);
                                if (valueY >= y1) {
                                    break;
                                }
                                this.locations.push(valueY | 0);
                                this.values.push(value);
                            }
                        }
                        else {
                            var calcExpValuePerLineResult = this.calcExpValuePerLine();
                            var logUnit = calcExpValuePerLineResult.unit;
                            var logMul = calcExpValuePerLineResult.valueMultiplier;
                            var value = 1 / logUnit;
                            while (true) {
                                value *= logMul;
                                var valueY = this.zeroY - this.valueToRelativeY(value);
                                if (valueY <= y0)
                                    break;
                                if (valueY >= y1)
                                    continue;
                                this.locations.push((valueY | 0) - 0.5);
                                this.values.push(value);
                            }
                            value = -1 / logUnit;
                            while (true) {
                                value *= logMul;
                                var valueY = this.zeroY - this.valueToRelativeY(value);
                                if (valueY >= y1) {
                                    break;
                                }
                                this.locations.push((valueY | 0) - 0.5);
                                this.values.push(value);
                            }
                        }
                        var minV = this.minValue;
                        var maxV = this.maxValue;
                        if (minV <= 0 && maxV >= 0) {
                            var mode = config.style.baseLine.showLabel;
                            if (mode === 2 /* always */
                                || (mode === 1 /* auto */ && (minV < 0 || !this.isInside && minV === 0))) {
                                this.locations.push(this.zeroY | 0);
                                this.values.push(0);
                            }
                        }
                    }
                    // compute string values
                    var valueFunction = config.valueFormatterFunction;
                    var unitMultiplier;
                    var fractionDigits;
                    var unitName;
                    if (!this.isLogScale) {
                        var getUnitAndNameResult = this.getUnitAndName(valuePerLine, this.scene.settings);
                        unitMultiplier = getUnitAndNameResult.unit;
                        fractionDigits = getUnitAndNameResult.digitsAfterComma;
                        unitName = getUnitAndNameResult.name;
                    }
                    for (var i = 0; i < this.values.length; i++) {
                        var value = this.values[i];
                        if (this.isLogScale) {
                            var getUnitAndNameResult = this.getUnitAndName(value, this.scene.settings);
                            unitMultiplier = getUnitAndNameResult.unit;
                            fractionDigits = getUnitAndNameResult.digitsAfterComma;
                            unitName = getUnitAndNameResult.name;
                        }
                        var name = (value / unitMultiplier).toFixed(fractionDigits);
                        if (value) {
                            name = name + " " + unitName;
                        }
                        if (valueFunction) {
                            name = valueFunction(value, unitName, unitMultiplier, name);
                        }
                        // format string values to labels
                        var valLabel = new Internal.Base.Label(config.style.valueLabel);
                        valLabel.text = name.toString();
                        if (!this.isInside)
                            valLabel.style.align = isRightSide ? "left" : "right";
                        this.labels[i] = valLabel;
                    }
                };
                /** 4 - does the painting below series data - on every frame */
                ValueAxis.prototype.paintUnder = function (event) {
                    var o = this.options;
                    if (!o.enabled)
                        return;
                    var context = event.context;
                    if (o.thresholds) {
                        for (var i = 0; i < o.thresholds.length; i++) {
                            var t = o.thresholds[i];
                            if (t.position === "under")
                                this.paintThreshold(context, t);
                        }
                    }
                    this.paintZeroLineDepth(context);
                };
                /** 5 - does the painting above series data - on every frame */
                ValueAxis.prototype.paint = function (event) {
                    var o = this.options;
                    if (!o.enabled)
                        return;
                    var context = event.context;
                    if (o.thresholds) {
                        for (var i = 0; i < o.thresholds.length; i++) {
                            var t = o.thresholds[i];
                            if (t.position === "above")
                                this.paintThreshold(context, t);
                        }
                    }
                    if (this.locations.length > 0) {
                        this.paintGrid(context);
                        this.paintZeroLine(context);
                        this.paintLabels(context, event.labelRenderer);
                    }
                    if (o.axisLine) {
                        var g = Internal.Base.Graphics.beginStrokeAndFill(context, o.style.axisLine);
                        this.paintAxisLine(g);
                        Internal.Base.Graphics.endStrokeAndFill(context, g, o.style.axisLine);
                    }
                };
                ValueAxis.prototype.shouldChangeScale = function () {
                    var seriesMin = this.seriesMinValue;
                    var seriesMax = this.seriesMaxValue;
                    if (seriesMin === null || seriesMax === null) {
                        return false;
                    }
                    if (this.lastMinValue === null || this.lastMaxValue === null || !(this.lastMinValue < this.lastMaxValue)) {
                        return true;
                    }
                    // extend min and max to incude zero line
                    if (this.options.zeroLine === "center") {
                        seriesMax = Math.max(seriesMax, -seriesMin);
                        seriesMin = -seriesMax;
                    }
                    else if (this.options.zeroLine === "visible") {
                        // force zero to be visible
                        seriesMin = Math.min(seriesMin, 0);
                        seriesMax = Math.max(seriesMax, 0);
                    }
                    // always update if out of bounds
                    if (seriesMin < this.minValue || seriesMax > this.maxValue) {
                        return true;
                    }
                    // change scale if data fills only part of the visible area
                    var tolerance = (this.lastMaxValue - this.lastMinValue) * this.options.scaleAdjustmentTolerance;
                    if (seriesMin > this.lastMinValue + tolerance || seriesMax < this.lastMaxValue - tolerance) {
                        return true;
                    }
                    return false;
                };
                /** computes scale and mid point */
                ValueAxis.prototype.computeNewScale = function (min, max) {
                    var height = this.scene.height;
                    var y0 = this.scene.y0;
                    // extend min and max to incude zero line
                    if (this.options.zeroLine === "center") {
                        max = Math.max(max, -min);
                        min = -max;
                    }
                    else if (this.options.zeroLine === "visible") {
                        // force zero to be visible
                        min = Math.min(min, 0);
                        max = Math.max(max, 0);
                    }
                    if (this.options.minValue !== null) {
                        min = this.options.minValue;
                    }
                    if (this.options.maxValue !== null) {
                        max = this.options.maxValue;
                    }
                    // default transform for extreme cases
                    if (!(height > 0) || !(min < max)) {
                        this.minValue = 0;
                        this.maxValue = 0;
                        this.logOffset = 1;
                        this.scale = 0;
                        this.zeroY = y0 + height;
                        return;
                    }
                    // round up to full minimum step
                    var minStep = 0;
                    if (this.options.scaleStep > 0) {
                        minStep = this.options.scaleStep;
                    }
                    else if (this.options.scaleMinStep > 0) {
                        minStep = this.options.scaleMinStep;
                    }
                    if (minStep > 0) {
                        if (min < 0) {
                            min = Math.floor(min / minStep) * minStep;
                        }
                        if (max > 0) {
                            max = Math.ceil(max / minStep) * minStep;
                        }
                    }
                    // add some extra padding, special case for 100% scale
                    var diff = max - min;
                    if (min !== 0 && min !== -100) {
                        if (this.isLogScale) {
                            min = Internal.Base.Helpers.sign(min) * Math.pow(Math.abs(min), 1 - Internal.Base.Helpers.sign(min) * this.options.scaleAdjustmentTolerance);
                        }
                        else {
                            var min2 = min - diff * this.options.scaleAdjustmentTolerance;
                            if (min > 0) {
                                min = Math.max(0, min2);
                            }
                            else if (min < 0) {
                                min = Math.min(0, min2);
                            }
                        }
                    }
                    if (max !== 0 && max !== 100) {
                        if (this.isLogScale) {
                            max = Internal.Base.Helpers.sign(max) * Math.pow(Math.abs(max), 1 + Internal.Base.Helpers.sign(max) * this.options.scaleAdjustmentTolerance);
                        }
                        else {
                            var max2 = max + diff * this.options.scaleAdjustmentTolerance;
                            if (max > 0) {
                                max = Math.max(0, max2);
                            }
                            else if (max < 0) {
                                max = Math.min(0, max2);
                            }
                        }
                    }
                    if (this.options.minValue !== null) {
                        min = this.options.minValue;
                    }
                    if (this.options.maxValue !== null) {
                        max = this.options.maxValue;
                    }
                    this.minValue = min;
                    this.maxValue = max;
                    var range;
                    if (!this.isLogScale) {
                        range = max - min;
                    }
                    else {
                        if (min <= 0 && max >= 0) {
                            // touches zero
                            this.logOffset = 1;
                            range = Math.log(max + this.logOffset) + Math.log(-min + this.logOffset);
                        }
                        else if (min < 0) {
                            /* positive
                            log(min+logOffset) = 0 */
                            this.logOffset = (1 - min);
                            range = Math.log(-min + this.logOffset);
                        }
                        else if (max > 0) {
                            /* negative
                            log(max-logOffset) = 0 */
                            this.logOffset = (1 + max);
                            range = Math.log(max + this.logOffset);
                        }
                    }
                    this.scale = height / range;
                    var topPos = this.valueToRelativeY(min);
                    this.zeroY = y0 + height + topPos;
                };
                /** fast and does no checks */
                ValueAxis.prototype.valueToRelativeY = function (value) {
                    if (!this.isLogScale) {
                        return this.scale * value;
                    }
                    else {
                        /* simulate fake log scale for negative values
                        two domains: negative..1px, 1px..positive, */
                        if (value > 0) {
                            return this.scale * Math.log(value + this.logOffset);
                        }
                        else if (value < 0) {
                            return -this.scale * Math.log(-value + this.logOffset);
                        }
                        else {
                            return 0;
                        }
                    }
                };
                ValueAxis.prototype.calcLinearValuePerLine = function () {
                    // find a reasonable step between lines, snaps to multiples of 2,5,10.
                    if (this.options.scaleStep) {
                        // fixed step
                        return this.options.scaleStep;
                    }
                    var desired = this.options.style.labelSpacing / this.scale;
                    var orderOfMagnitude = Math.log(desired) / Math.log(10);
                    var base = Math.pow(10, Math.floor(orderOfMagnitude - 1));
                    base = Math.max(base, this.options.scaleMinStep);
                    while ((base < desired)) {
                        if (base * 2 >= desired) {
                            return base * 2;
                        }
                        if (base > 10 && base * 2.5 >= desired) {
                            return base * 2.5;
                        }
                        if (base * 5 >= desired) {
                            return base * 5;
                        }
                        base *= 10;
                    }
                    return base;
                };
                ValueAxis.prototype.calcExpValuePerLine = function () {
                    var pixelsPer10Times = this.valueToRelativeY(10) - this.valueToRelativeY(1);
                    var valueMultiplier = 10;
                    var unit = 10;
                    var stepSize = pixelsPer10Times;
                    if (stepSize > this.options.style.labelSpacing * 4) {
                        return {
                            unit: 2,
                            valueMultiplier: 2
                        };
                    }
                    while (stepSize < this.options.style.labelSpacing) {
                        valueMultiplier *= 10;
                        stepSize += pixelsPer10Times;
                    }
                    return {
                        unit: unit,
                        valueMultiplier: valueMultiplier
                    };
                };
                ValueAxis.prototype.getUnitAndName = function (base, settings) {
                    base = Math.abs(base);
                    var cache = this.isLogScale ? this.cachedUnits.log : this.cachedUnits.lin;
                    var unit = 1;
                    var name = "";
                    if (cache[base]) {
                        return cache[base];
                    }
                    for (var u in settings.localization.valueUnits) {
                        var m = settings.localization.valueUnits[u];
                        var s = Math.abs(base / m);
                        if (!this.isLogScale) {
                            if (s < 1000 && s >= 1) {
                                unit = m;
                                name = u;
                                break;
                            }
                        }
                        else {
                            if (base === Math.round(base / m) * m && unit < m) {
                                unit = m;
                                name = u;
                            }
                        }
                    }
                    var digitsAfterComma = 0;
                    if (base > 0) {
                        var x = 1;
                        while (base < x) {
                            digitsAfterComma += 1;
                            x /= 10;
                        }
                    }
                    return cache[base] = { unit: unit, digitsAfterComma: digitsAfterComma, name: name };
                };
                ValueAxis.prototype.paintGrid = function (g) {
                    // by default, the horizonal axis is only rendered on the first axis
                    if (this.options.hgrid === false || (this.options.hgrid == null && !this.isPrimary)) {
                        return;
                    }
                    var hgrid = this.options.style.hgrid.lineColor;
                    this.options.style.hgrid.lineWidth = 1;
                    Internal.Base.Graphics.clearShadow(g);
                    var gr = Internal.Base.Graphics.beginStrokeAndFill(g, this.options.style.hgrid);
                    var x1 = this.scene.x0;
                    var x2 = this.scene.x0 + this.scene.width;
                    for (var i = 0; i < this.locations.length; i++) {
                        var y = this.locations[i];
                        if (this.values[i] === 0) {
                            continue;
                        }
                        gr.moveTo(x1, y + 0.5);
                        gr.lineTo(x2, y + 0.5);
                    }
                    Internal.Base.Graphics.endStrokeAndFill(g, gr, this.options.style.hgrid);
                    var tone = Internal.Base.Colors.colorTone(hgrid, 0.5, 0.5);
                    if (tone.opacity < 0.3) {
                        this.options.style.hgrid.lineColor = tone.color;
                        gr = Internal.Base.Graphics.beginStrokeAndFill(g, this.options.style.hgrid);
                        for (var i = 0; i < this.locations.length; i++) {
                            var y = this.locations[i];
                            if (this.values[i] === 0) {
                                continue;
                            }
                            gr.moveTo(x1, y - .5);
                            gr.lineTo(x2, y - .5);
                        }
                        Internal.Base.Graphics.endStrokeAndFill(g, gr, this.options.style.hgrid);
                        this.options.style.hgrid.lineColor = hgrid;
                    }
                };
                ValueAxis.prototype.paintAxisLine = function (g) {
                    var side = this.options.side;
                    var x0 = this.panel.left;
                    var x1 = this.panel.right;
                    var yt = this.scene.y0 + this.scene.height;
                    var xt;
                    if (this.isInside) {
                        if (side === "right") {
                            xt = x0;
                        }
                        if (side === "left") {
                            xt = x1;
                        }
                    }
                    else if (side === "right") {
                        xt = x0 - 0.5;
                    }
                    else {
                        xt = x1 + 0.5;
                    }
                    g.moveTo(xt, this.scene.y0);
                    g.lineTo(xt, yt);
                };
                ValueAxis.prototype.paintZeroLineDepth = function (context) {
                    if (this.zeroY > this.scene.chartHeight)
                        return;
                    var conf = this.options.style.baseLine;
                    var d = Math.max(conf.lineDepth, this.seriesDepth);
                    if (d > 0) {
                        var g = Internal.Base.Graphics.beginStroke(context, this.options.style.baseLine);
                        var x1 = this.scene.x0;
                        var x2 = x1 + this.scene.width;
                        var z = Math.round(this.zeroY) - (conf.lineWidth || 1) * 0.5;
                        g.moveTo(x1, z);
                        g.lineTo(x1 + d, z - d);
                        g.lineTo(x2, z - d);
                        g.lineTo(x2, z);
                        context.fillStyle = conf.depthColor;
                        context.fill();
                        Internal.Base.Graphics.endStroke(context, g, conf);
                    }
                };
                ValueAxis.prototype.paintZeroLine = function (context) {
                    if (this.zeroY > this.scene.chartHeight)
                        return;
                    var conf = this.options.style.baseLine;
                    var x1 = this.scene.x0;
                    var x2 = x1 + this.scene.width;
                    var z = Math.round(this.zeroY) - (conf.lineWidth || 1) * 0.5;
                    var g = Internal.Base.Graphics.beginStroke(context, conf);
                    g.moveTo(x1, z);
                    g.lineTo(x2, z);
                    Internal.Base.Graphics.endStroke(context, g, conf);
                };
                ValueAxis.prototype.paintThreshold = function (context, threshold) {
                    if (this.scale === 0)
                        return;
                    var x0 = this.scene.x0;
                    var x1 = this.scene.x0 + this.scene.width;
                    var y0 = this.scene.y0;
                    var y1 = y0 + this.scene.height;
                    var fromY = (this.zeroY - this.valueToRelativeY(threshold.from));
                    var toY = (this.zeroY - this.valueToRelativeY(threshold.to));
                    if (fromY >= y1 - 0.5) {
                        fromY = (y1 | 0) + 0.5;
                    }
                    else {
                        fromY = (this.zeroY - this.valueToRelativeY(threshold.from) | 0) - 0.5;
                    }
                    if (toY <= y0 - 0.5) {
                        toY = (y0 | 0) + 0.5;
                    }
                    else {
                        toY = (this.zeroY - this.valueToRelativeY(threshold.to) | 0) - 0.5;
                    }
                    // fill rectangle
                    if (threshold.style.fillColor) {
                        context.fillStyle = threshold.style.fillColor;
                        context.beginPath();
                        context.rect(x0, toY, this.scene.width, fromY - toY);
                        context.fill();
                        context.closePath();
                    }
                    // Stroke border lines
                    var g = Internal.Base.Graphics.beginStroke(context, threshold.style);
                    if (fromY - 0.5 !== y1) {
                        g.moveTo(x0, fromY);
                        g.lineTo(x1, fromY);
                    }
                    if (toY - 0.5 !== y0) {
                        g.moveTo(x0, toY);
                        g.lineTo(x1, toY);
                    }
                    Internal.Base.Graphics.endStroke(context, g, threshold.style);
                };
                ValueAxis.prototype.paintLabels = function (g, labelRenderer) {
                    // without loaded assets the font height detection does not work.
                    if (!this._chart.assetsLoaded)
                        return;
                    var scene = this.scene;
                    var x0 = this.panel.left;
                    var x1 = this.panel.right;
                    var isRightSide = this.options.side === "right";
                    // paint axis title
                    var title = this.title;
                    if (this.options.title && title) {
                        var y0 = scene.y0;
                        var height = scene.height;
                        var hHeight = title.hheight;
                        var margin = title.style.margin || 0;
                        var centerY = y0 + height * 0.5;
                        var centerX = void 0;
                        if (isRightSide) {
                            centerX = x1 - margin - hHeight;
                            x1 -= hHeight + margin * 2;
                        }
                        else {
                            centerX = x0 + margin + hHeight;
                            x0 += hHeight + margin * 2;
                        }
                        labelRenderer.paint(g, centerX, centerY, 1, title);
                    }
                    // Labels and ticks
                    var midX = (x0 + x1) / 2;
                    var tickx;
                    if (isRightSide) {
                        tickx = x0;
                    }
                    else {
                        tickx = x1 - 4;
                    }
                    if (!this.isInside) {
                        // Label ticks
                        g.beginPath();
                        for (var yIndex = 0; yIndex < this.locations.length; yIndex++) {
                            var y = this.locations[yIndex];
                            g.moveTo(tickx, y);
                            g.lineTo(tickx + 4, y);
                        }
                        Internal.Base.Graphics.stroke(g, this.options.style.tick);
                    }
                    for (var i = 0; i < this.locations.length; i++) {
                        var valueY = this.locations[i];
                        var label = this.labels[i];
                        var labelX = void 0;
                        labelRenderer.measure(g, label);
                        if (this.isInside) {
                            labelX = midX;
                        }
                        else if (isRightSide) {
                            labelX = tickx + label.hwidth + 7;
                        }
                        else {
                            labelX = tickx - label.hwidth - 3;
                        }
                        // if the label goes outside the chart area, better move it to overlap the chart
                        labelX = Math.min(labelX, scene.chartLeft + scene.chartWidth - label.hwidth);
                        labelX = Math.max(labelX, scene.chartLeft + label.hwidth);
                        labelRenderer.paint(g, labelX, valueY, 1, label);
                    }
                };
                return ValueAxis;
            }());
            LinearChart.ValueAxis = ValueAxis;
        })(LinearChart = Internal.LinearChart || (Internal.LinearChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../base/Graphics.ts" />
/// <reference path="../../base/Geometry.ts" />
/// <reference path="Base.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var LinearChart;
        (function (LinearChart) {
            var Renderers;
            (function (Renderers) {
                var Columns = (function () {
                    function Columns(scene, series) {
                        this.series = series;
                        this.scene = scene;
                        this.prevy = [];
                    }
                    Columns.prototype.paintStack = function (event, centers, radii, ystack, styles, zeroY, previewData) {
                        this.zeroY = zeroY;
                        if (!(centers.length > 0)) {
                            return;
                        }
                        var series = this.series;
                        var prevy = this.prevy;
                        if (prevy.length < centers.length) {
                            prevy = this.prevy = new Array(centers.length);
                        }
                        for (var i = 0; i <= centers.length - 1; i++) {
                            prevy[i] = zeroY;
                        }
                        for (var j = 0; j < series.length; j++) {
                            var ser = series[j];
                            var style = styles[j];
                            var preview = (previewData && previewData.length) ? previewData[j] : null;
                            this.plainColumns(event, ser.style, centers, radii, prevy, ystack, style, j, preview);
                        }
                    };
                    Columns.prototype.hitTest = function (centers, radii, ystack, styles, zeroY, x, y, tolerance) {
                        var len = centers.length;
                        if (!(len > 1)) {
                            return {
                                result: null,
                                distance: Infinity
                            };
                        }
                        var series = this.series;
                        var xind = Internal.Base.Helpers.binSearch(centers, x);
                        var x0 = centers[xind] - radii[xind];
                        var x1 = centers[xind] + radii[xind];
                        if (x0 > x && xind > 0) {
                            var x0a = centers[xind - 1] - radii[xind - 1];
                            var x1a = centers[xind - 1] + radii[xind - 1];
                            if (x1a > x || Math.abs(x1a - x) < Math.abs(x0 - x)) {
                                xind -= 1;
                                x0 = x0a;
                                x1 = x1a;
                            }
                        }
                        var result = null;
                        var distance = Infinity;
                        var y0 = zeroY;
                        for (var i = 0; i < series.length; i++) {
                            var yy = ystack[i][xind];
                            if (Internal.Base.Helpers.isNumber(yy)) {
                                var y1 = y0 - yy;
                                var y00 = Math.min(y0, y1);
                                var y11 = Math.max(y0, y1);
                                var d = Internal.Base.Geometry.distanceToRect(x, y, x0, y00, x1, y11);
                                if (d < distance) {
                                    distance = d;
                                    result = {
                                        x0: x0,
                                        y0: y00,
                                        x1: x1,
                                        y1: y11,
                                        seriesIndex: i,
                                        isMarker: false
                                    };
                                }
                                y0 = y1;
                            }
                        }
                        return {
                            result: result,
                            distance: distance
                        };
                    };
                    Columns.prototype.plainColumns = function (event, style, centers, radii, ybase, yvaluesAll, styles, yindex, previewData) {
                        var context = event.context;
                        var top = this.scene.y0;
                        var h = this.scene.height;
                        var minHeight = style.minHeight;
                        var bottom = top + h;
                        var yvalues = yvaluesAll[yindex];
                        // init common  style
                        var curStyle = null;
                        var depth;
                        var shadowColor;
                        var fillStyle;
                        var depthColor;
                        var strokeWidth;
                        for (var i = 0; i < centers.length; i++) {
                            var center = centers[i];
                            var y = yvalues[i];
                            if (!Internal.Base.Helpers.isNumber(y)) {
                                continue;
                            }
                            var r = radii[i];
                            var y0 = ybase[i];
                            var y1 = y0 - y;
                            ybase[i] = y1;
                            var cleft = center - r;
                            var cwidth = r + r;
                            var cheight = void 0;
                            var ctop = void 0;
                            var paintTop = void 0;
                            if (y0 < y1) {
                                // negative column
                                cheight = Math.max(y1 - y0, minHeight);
                                ctop = y0;
                                // test if this is first value to paint
                                var isFirst = true;
                                var j = yindex - 1;
                                while (j > 0) {
                                    if (yvaluesAll[j][i] !== null) {
                                        isFirst = false;
                                        break;
                                    }
                                    j--;
                                }
                                paintTop = isFirst;
                            }
                            else if (y0 > y1) {
                                // positive column
                                cheight = Math.max(y0 - y1, minHeight);
                                ctop = y0 - cheight;
                                // test if this is last value to paint
                                var isLast = true;
                                var j = yindex + 1;
                                while (j < yvaluesAll.length) {
                                    if (yvaluesAll[j][i] !== null) {
                                        isLast = false;
                                        break;
                                    }
                                    j++;
                                }
                                paintTop = isLast;
                            }
                            else {
                                continue;
                            }
                            // figure out item style
                            var newStyle = styles ? (styles[i] || style) : style;
                            if (curStyle !== newStyle) {
                                curStyle = newStyle;
                                strokeWidth = curStyle.lineColor ? curStyle.lineWidth : 0;
                                shadowColor = curStyle.shadowColor;
                                depth = curStyle.depth;
                                fillStyle = curStyle._currentFillStyle;
                                var gradient = curStyle.gradient;
                                var isPlainColor = Internal.Base.Helpers.isString(fillStyle);
                                if (isPlainColor && depth) {
                                    depthColor = curStyle.fillColor;
                                    if (Internal.Base.Helpers.isNumber(curStyle.depthBrightness)) {
                                        depthColor = Internal.Base.Colors.derive(depthColor, curStyle.depthBrightness, 1);
                                    }
                                }
                                else {
                                    depthColor = null;
                                }
                                if (gradient && gradient !== 1 && isPlainColor) {
                                    var g = context.createLinearGradient(0, bottom, 0, bottom - h * 2 / 3);
                                    g.addColorStop(0, Internal.Base.Colors.derive(fillStyle, gradient, 1));
                                    g.addColorStop(1, fillStyle);
                                    fillStyle = g;
                                }
                                context.fillStyle = fillStyle;
                            }
                            // paint depth shade
                            if (depthColor) {
                                context.beginPath();
                                Internal.Base.Graphics.applyShadow(context, curStyle);
                                if (!paintTop) {
                                    context.moveTo(cleft + cwidth, ctop);
                                    context.lineTo(cleft + cwidth + depth, ctop - depth);
                                    context.lineTo(cleft + cwidth + depth, ctop + cheight - depth);
                                    context.lineTo(cleft + cwidth, ctop + cheight);
                                    context.lineTo(cleft + cwidth, ctop);
                                }
                                else {
                                    context.moveTo(cleft + depth, ctop - depth);
                                    context.lineTo(cleft + cwidth + depth, ctop - depth);
                                    context.lineTo(cleft + cwidth + depth, ctop + cheight - depth);
                                    context.lineTo(cleft + cwidth, ctop + cheight);
                                    context.lineTo(cleft + cwidth, ctop);
                                    context.lineTo(cleft, ctop);
                                }
                                context.closePath();
                                context.fillStyle = depthColor;
                                context.fill();
                                Internal.Base.Graphics.clearShadow(context);
                                context.fillStyle = fillStyle;
                            }
                            // paint the actual column
                            if (!depthColor && shadowColor) {
                                Internal.Base.Graphics.applyShadow(context, curStyle);
                            }
                            // fill
                            if (fillStyle) {
                                context.fillRect(cleft, ctop, cwidth, cheight);
                                if (!depthColor && shadowColor) {
                                    Internal.Base.Graphics.clearShadow(context);
                                }
                            }
                            // stroke
                            if (strokeWidth > 0) {
                                ctop += strokeWidth / 2;
                                cleft += strokeWidth / 2;
                                cwidth -= strokeWidth;
                                cheight -= strokeWidth;
                                var dashContext = Internal.Base.Graphics.beginStroke(context, curStyle);
                                if (cwidth > 0) {
                                    if (cheight > 0) {
                                        dashContext.moveTo(cleft, ctop);
                                        dashContext.lineTo(cleft + cwidth, ctop);
                                        dashContext.lineTo(cleft + cwidth, ctop + cheight);
                                        dashContext.lineTo(cleft, ctop + cheight);
                                        dashContext.lineTo(cleft, ctop);
                                    }
                                    else if (strokeWidth > 0) {
                                        // paint just a horizontal line
                                        context.moveTo(cleft, y0);
                                        context.lineTo(cleft + cwidth, y0);
                                    }
                                }
                                else if (strokeWidth > 0) {
                                    // paint just a vertical line
                                    context.moveTo(center, ctop);
                                    context.lineTo(center, ctop + cheight);
                                }
                                Internal.Base.Graphics.endStroke(context, dashContext, curStyle);
                            }
                            if (!fillStyle && !depthColor && shadowColor) {
                                Internal.Base.Graphics.clearShadow(context);
                            }
                            // TODO: type soup here, previewData and previewLineColor are defined on far away unrelated types.
                            var previewLineColor = curStyle.previewLineColor;
                            // paint preview
                            if (previewData && previewData[i]) {
                                context.beginPath();
                                var frac = 0;
                                var diff = y1 - y0;
                                var p = previewData[i];
                                for (var vIndex = 0; vIndex < p.length; vIndex++) {
                                    var v = p[vIndex];
                                    frac += v;
                                    y = y0 + frac * diff;
                                    context.moveTo(cleft, y);
                                    context.lineTo(cleft + cwidth, y);
                                }
                                context.lineWidth = 1;
                                context.strokeStyle = previewLineColor;
                                context.stroke();
                            }
                        }
                    };
                    return Columns;
                }());
                Renderers.Columns = Columns;
            })(Renderers = LinearChart.Renderers || (LinearChart.Renderers = {}));
        })(LinearChart = Internal.LinearChart || (Internal.LinearChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../base/Graphics.ts" />
/// <reference path="../../base/MonotoneCurve.ts" />
/// <reference path="../../base/Geometry.ts" />
/// <reference path="Base.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var LinearChart;
        (function (LinearChart) {
            var Renderers;
            (function (Renderers) {
                var Line = (function () {
                    function Line(stack, series) {
                        this.stack = stack;
                        this.series = series;
                        this.seriesData = [];
                        for (var sIndex = 0; sIndex < series.length; sIndex++) {
                            this.seriesData.push({ markerY: [], segments: [] });
                        }
                        this.prevyL = [];
                        this.prevyR = [];
                    }
                    Line.prototype.paintStack = function (event, centers, radii, ystack, styles, zeroY) {
                        if (centers.length === 0) {
                            return;
                        }
                        var context = event.context;
                        this.paintLines(context, this.series, this.seriesData, centers, radii, ystack, zeroY);
                        for (var i = 0; i < this.series.length; i++) {
                            var ser = this.series[i];
                            if (ser.style.markerStyleFunction) {
                                this.paintCustomMarkers(context, ser, centers, ystack[i], this.seriesData[i].markerY);
                            }
                            else {
                                this.paintMarkers(context, ser, centers, ystack[i], this.seriesData[i].markerY);
                            }
                        }
                    };
                    Line.prototype.paintLines = function (context, series, seriesData, centers, radii, ystack, zeroY) {
                        this.computeLineSegments(centers, radii, zeroY, ystack);
                        // use the zero line as the initial baseline.
                        var prevSegments = [[-Infinity, 0, Infinity], [zeroY, zeroY, zeroY]];
                        for (var i = 0; i < series.length; i++) {
                            var ser = series[i];
                            this.paintLine(context, ser.style, prevSegments, seriesData[i].segments, zeroY);
                            if (i < series.length - 1)
                                prevSegments = this.mergePreviousSegments(prevSegments, this.seriesData[i].segments);
                        }
                    };
                    Line.prototype.mergePreviousSegments = function (previous, current) {
                        var resultXes = [];
                        var resultYes = [];
                        var prevIndex = 0;
                        var prevXes = previous[0];
                        var prevYes = previous[1];
                        for (var i = 0; i < current.length; i += 2) {
                            var curXes = current[i];
                            var curYes = current[i + 1];
                            // everything to the left of the current segment comes from the previous line
                            while (prevXes[prevIndex] <= curXes[0]) {
                                resultXes.push(prevXes[prevIndex]);
                                resultYes.push(prevYes[prevIndex]);
                                prevIndex++;
                            }
                            // the segment starts - connect the previous line up to the current line
                            if (prevXes[prevIndex - 1] !== curXes[0]) {
                                resultXes.push(curXes[0]);
                                resultYes.push(prevYes[prevIndex - 1]);
                            }
                            // add the current segment
                            resultXes.push.apply(resultXes, curXes);
                            resultYes.push.apply(resultYes, curYes);
                            // ignore everything from the previous line that is below the current line
                            while (prevXes[prevIndex] < curXes[curXes.length - 1]) {
                                prevIndex++;
                            }
                            // the segment ends - connect the current line down to the previous line
                            if (curXes[curXes.length - 1] !== prevXes[prevIndex]) {
                                resultXes.push(curXes[curXes.length - 1]);
                                resultYes.push(prevYes[prevIndex]);
                            }
                        }
                        // the segments are finished, add everything remaining from the previous line
                        while (prevIndex < prevXes.length) {
                            resultXes.push(prevXes[prevIndex]);
                            resultYes.push(prevYes[prevIndex]);
                            prevIndex++;
                        }
                        return [resultXes, resultYes];
                    };
                    Line.prototype.paintCustomMarkers = function (context, series, centers, yvalues, ycoords) {
                        var markers = series.style.markerStyleFunction(this.stack.externalItems(), yvalues);
                        if (!markers || markers.length !== yvalues.length) {
                            Internal.Base.Helpers.error("markerStyleFunction() must return an array with the same number of elements as the input arrays.");
                            return;
                        }
                        var defaultStyle = series.style.marker;
                        for (var j = 0; j < yvalues.length; j++) {
                            var m = markers[j];
                            if (m && m.shape) {
                                if (!m.fillColor)
                                    m.fillColor = defaultStyle.fillColor || series.style.lineColor || series.style.fillColor;
                                if (!m.width)
                                    m.width = defaultStyle.width || 10;
                                context.beginPath();
                                Internal.Base.Graphics.strokeMarker(context, m.shape, centers[j], ycoords[j], m.width / 2);
                                Internal.Base.Graphics.paint(context, m);
                            }
                        }
                    };
                    Line.prototype.paintMarkers = function (context, series, centers, yvalues, ycoords) {
                        var marker = series.style.marker;
                        if (!marker.shape) {
                            return;
                        }
                        var markerStyle = {
                            fillColor: marker.fillColor || series.style.lineColor || series.style.fillColor,
                            lineColor: marker.lineColor,
                            lineWidth: marker.lineWidth
                        };
                        var r = marker.width / 2;
                        var shape = marker.shape;
                        context.beginPath();
                        for (var j = 0; j < yvalues.length; j++) {
                            var v = yvalues[j];
                            if (v === null) {
                                continue;
                            }
                            Internal.Base.Graphics.strokeMarker(context, shape, centers[j], ycoords[j], r);
                        }
                        // all markers are painted at once for better performance.
                        Internal.Base.Graphics.paint(context, markerStyle);
                    };
                    Line.prototype.hitTest = function (centers, radii, ystack, styles, zeroY, x, y, tolerance) {
                        var series = this.series;
                        var len = centers.length;
                        if (len === 0) {
                            return {
                                result: null,
                                distance: Infinity
                            };
                        }
                        // find xind under cursor
                        var xind = Math.min(Internal.Base.Helpers.binSearch(centers, x), len - 2);
                        var bestResult = null;
                        var bestDistance = Infinity;
                        var distToPrevSeries = zeroY - y;
                        // test for markers
                        for (var serInd = 0; serInd < series.length; serInd++) {
                            var ser = series[serInd];
                            var style = ser.style;
                            var data = this.seriesData[serInd];
                            for (var i = Math.max(0, xind - 2); i < Math.min(len, xind + 3); i++) {
                                var v = ystack[serInd][i];
                                if (v !== null && style.marker) {
                                    var xx = centers[i];
                                    var yy = data.markerY[i];
                                    var radius = style.marker.width / 2;
                                    var dx = x - xx;
                                    var dy = y - yy;
                                    var markerDistance = Math.sqrt(dx * dx + dy * dy);
                                    if (markerDistance < radius + tolerance && bestDistance > markerDistance - radius) {
                                        bestDistance = markerDistance - radius;
                                        bestResult = {
                                            x0: xx,
                                            y0: yy,
                                            x1: xx,
                                            y1: yy,
                                            seriesIndex: serInd,
                                            isMarker: true
                                        };
                                    }
                                }
                            }
                            // test for lines/areas
                            var distanceToSegments = null;
                            var segments = data.segments;
                            for (var i = 0; i < segments.length; i += 2) {
                                var xlist = segments[i];
                                var ylist = segments[i + 1];
                                var x0 = xlist[0];
                                for (var j = 1; j < xlist.length; j++) {
                                    var x1 = xlist[j];
                                    // distance to line
                                    if (x0 <= x + tolerance && x1 >= x - tolerance) {
                                        var y0 = ylist[j - 1];
                                        var y1 = ylist[j];
                                        var dist = Math.sqrt(Internal.Base.Geometry.distanceToSegmentSq(x0, y0, x1, y1, x, y));
                                        if (dist < tolerance && dist <= bestDistance) {
                                            bestDistance = dist;
                                            bestResult = {
                                                x0: x0,
                                                y0: y0,
                                                x1: x1,
                                                y1: y1,
                                                seriesIndex: serInd,
                                                isMarker: false
                                            };
                                        }
                                    }
                                    // distance to area
                                    if (x0 <= x && x1 >= x) {
                                        var y0 = ylist[j - 1];
                                        var y1 = ylist[j];
                                        var dd = Internal.Base.Geometry.lineIntersectsSegment(x, y, 0, 1, x0, y0, x1, y1);
                                        if (dd !== Infinity) {
                                            distanceToSegments = dd;
                                        }
                                    }
                                    x0 = x1;
                                }
                            }
                            if (distanceToSegments !== null) {
                                if (Internal.Base.Helpers.sign(distanceToSegments) !== Internal.Base.Helpers.sign(distToPrevSeries) && (style.fillColor || style.fillGradient)) {
                                    // we have area
                                    if (bestDistance >= 0) {
                                        bestDistance = 0;
                                        bestResult = {
                                            x0: 0,
                                            y0: 0,
                                            x1: 1,
                                            y1: 1,
                                            seriesIndex: serInd,
                                            isMarker: false
                                        };
                                    }
                                }
                                distToPrevSeries = distanceToSegments;
                            }
                        }
                        return {
                            result: bestResult,
                            distance: Math.max(bestDistance, 0)
                        };
                        // Section: computation
                    };
                    Line.prototype.computeLineSegments = function (centers, radii, zeroY, ystack) {
                        var len = centers.length;
                        var prevyL = this.prevyL;
                        var prevyR = this.prevyR;
                        if (prevyL.length < len) {
                            prevyL.length = len;
                            prevyR.length = len;
                        }
                        for (var k = 0; k < len; k++) {
                            prevyL[k] = zeroY;
                            prevyR[k] = zeroY;
                        }
                        var prevMarkerY = prevyL;
                        for (var i = 0; i < this.series.length; i++) {
                            var ser = this.series[i];
                            var data = this.seriesData[i];
                            data.segments.length = 0;
                            if (data.markerY.length < len) {
                                data.markerY.length = len;
                            }
                            // build values and segments
                            if (ser.style.steps) {
                                var buildStepSegmentsResult = this.buildStepSegments(centers, radii, zeroY, prevyL, prevyR, prevMarkerY, ystack[i], ser.data.noDataPolicy);
                                data.segments = buildStepSegmentsResult.segments;
                                data.markerY = buildStepSegmentsResult.markerY;
                            }
                            else {
                                var buildLineSegmentsResult = this.buildLineSegments(centers, zeroY, prevyL, prevyR, prevMarkerY, ystack[i], ser.data.noDataPolicy);
                                data.segments = buildLineSegmentsResult.segments;
                                data.markerY = buildLineSegmentsResult.markerY;
                                if (ser.style.smoothing) {
                                    for (var j = 0; j < data.segments.length; j += 2) {
                                        var smoothLineResult = this.smoothLine(data.segments[j], data.segments[j + 1]);
                                        data.segments[j] = smoothLineResult.x;
                                        data.segments[j + 1] = smoothLineResult.y;
                                    }
                                }
                            }
                            prevMarkerY = data.markerY;
                        }
                    };
                    /** builds a list of [segement1x,segment1y, segment2s,segment2y,..], each element is an array of values */
                    Line.prototype.buildLineSegments = function (centers, zeroY, prevYL, prevYR, prevMarker, newY, nodataPolicy) {
                        var markerY = [];
                        var xe = [];
                        var ye = [];
                        if (nodataPolicy === "zero") {
                            for (var i = 0; i < centers.length; i++) {
                                var x = centers[i];
                                var yinc = newY[i];
                                var pyL = prevYL[i];
                                var pyR = prevYR[i];
                                if (yinc !== null) {
                                    markerY.push(prevMarker[i] - yinc);
                                    xe.push(x);
                                    ye.push(pyL - yinc);
                                    if (pyL !== pyR) {
                                        xe.push(x);
                                        ye.push(pyR - yinc);
                                    }
                                    prevYL[i] -= yinc;
                                    prevYR[i] -= yinc;
                                }
                                else {
                                    // yinc == null - follow prev
                                    markerY.push(prevMarker[i]);
                                    if (pyL !== pyR) {
                                        ye.push(pyL);
                                        ye.push(pyR);
                                        xe.push(x);
                                        xe.push(x);
                                    }
                                    else {
                                        ye.push(pyL);
                                        xe.push(x);
                                    }
                                }
                            }
                            return {
                                segments: [xe, ye],
                                markerY: markerY
                            };
                        }
                        else if (nodataPolicy === "join") {
                            var lastInd = null;
                            for (var i = 0; i < centers.length; i++) {
                                var x = centers[i];
                                var yinc = newY[i];
                                var pyL = prevYL[i];
                                var pyR = prevYR[i];
                                if (yinc !== null) {
                                    if (lastInd === null) {
                                        // this is the first point
                                        markerY.push(prevMarker[i] - yinc);
                                        xe.push(x);
                                        ye.push(pyR - yinc);
                                        prevYR[i] -= yinc;
                                    }
                                    else {
                                        // extrapolate over intermediate points
                                        if (lastInd < i - 1) {
                                            var yinc0 = newY[lastInd];
                                            var x0 = centers[lastInd];
                                            var coef = (yinc - yinc0) / (x - x0);
                                            for (var j = lastInd + 1; j < i; j++) {
                                                var xx = centers[j];
                                                var yyinc = yinc0 + coef * (xx - x0);
                                                markerY.push(prevMarker[j] - yyinc);
                                                var ppyL = prevYL[j];
                                                var ppyR = prevYR[j];
                                                xe.push(xx);
                                                ye.push(ppyL - yyinc);
                                                if (ppyL !== ppyR) {
                                                    xe.push(xx);
                                                    ye.push(ppyR - yyinc);
                                                }
                                                prevYL[j] -= yyinc;
                                                prevYR[j] -= yyinc;
                                            }
                                        }
                                        // join with current point
                                        markerY.push(prevMarker[i] - yinc);
                                        xe.push(x);
                                        ye.push(pyL - yinc);
                                        if (pyL !== pyR) {
                                            xe.push(x);
                                            ye.push(pyR - yinc);
                                        }
                                        prevYL[i] -= yinc;
                                        prevYR[i] -= yinc;
                                    }
                                    lastInd = i;
                                }
                                else {
                                    // no value - skip ahead
                                    if (lastInd === null) {
                                        markerY.push(prevMarker[i]);
                                    }
                                }
                            }
                            // the last point might be a break point, remove the break if so
                            if (xe.length > 2 && (xe[xe.length - 1] === xe[xe.length - 2])) {
                                xe.pop();
                                ye.pop();
                            }
                            return {
                                segments: [xe, ye],
                                markerY: markerY
                            };
                        }
                        else {
                            // skip
                            var hasPrev = false;
                            var segments = [];
                            for (var i = 0; i < centers.length; i++) {
                                var x = centers[i];
                                var yinc = newY[i];
                                var pyL = prevYL[i];
                                var pyR = prevYR[i];
                                if (yinc !== null) {
                                    markerY.push(prevMarker[i] - yinc);
                                    if (hasPrev) {
                                        // has prev and value - regular stuff
                                        if (xe.length > 1 && prevYL[i - 1] !== prevYR[i - 1]) {
                                            xe.push(centers[i - 1]);
                                            ye.push(prevYR[i - 1]);
                                        }
                                        xe.push(x);
                                        ye.push(pyL - yinc);
                                        prevYL[i] -= yinc;
                                        prevYR[i] -= yinc;
                                    }
                                    else {
                                        // no prev and has value - start new sequence
                                        xe.push(x);
                                        ye.push(pyR - yinc);
                                        prevYR[i] -= yinc;
                                    }
                                    hasPrev = true;
                                }
                                else {
                                    markerY.push(prevMarker[i]);
                                    if (hasPrev) {
                                        // has prev but no value - terminate the sequence
                                        if (xe.length > 0) {
                                            if (xe.length === 1) {
                                                xe.push(xe[0]);
                                                ye.push(ye[0]);
                                            }
                                            segments.push(xe, ye);
                                            xe = [];
                                            ye = [];
                                        }
                                        // revert right side addition on previous segment
                                        prevYR[i - 1] += newY[i - 1];
                                    }
                                    else {
                                    }
                                    hasPrev = false;
                                }
                            }
                            if (xe.length > 0) {
                                if (xe.length === 1) {
                                    xe.push(xe[0]);
                                    ye.push(ye[0]);
                                }
                                segments.push(xe, ye);
                            }
                            return {
                                segments: segments,
                                markerY: markerY
                            };
                        }
                    };
                    /** builds a list of [segement1x,segment1y, segment2s,segment2y,..], each element is an array of values */
                    Line.prototype.buildStepSegments = function (centers, radii, zeroY, prevYL, prevYR, prevMarkerY, newY, nodataPolicy) {
                        var segments = [];
                        var markerY = [];
                        var xe = [];
                        var ye = [];
                        var y0 = null;
                        var x0 = 0;
                        for (var i = 0; i < centers.length; i++) {
                            var x = centers[i] - radii[i];
                            var y = newY[i];
                            if (y !== null) {
                                if (y0 !== null) {
                                    xe.push(x);
                                    ye.push(y0);
                                }
                                var mv = prevMarkerY[i] - y;
                                xe.push(x);
                                ye.push(mv);
                                y0 = mv;
                                x0 = x + radii[i] * 2;
                                markerY.push(mv);
                                prevYL[i] = prevYR[i] = mv;
                            }
                            else {
                                // y = null
                                if (nodataPolicy === "zero") {
                                    var mv = prevMarkerY[i];
                                    markerY.push(mv);
                                    prevYR[i] = prevYL[i] = mv;
                                    if (y0 !== null) {
                                        xe.push(x0);
                                        ye.push(y0);
                                    }
                                    xe.push(x);
                                    ye.push(mv);
                                    y0 = mv;
                                    x0 = x + radii[i] * 2;
                                }
                                else if (nodataPolicy === "join") {
                                    var mv = (y0 !== null) ? y0 : prevMarkerY[i];
                                    markerY.push(mv);
                                    prevYR[i] = prevYL[i] = mv;
                                }
                                else {
                                    // skip
                                    var mv = prevMarkerY[i];
                                    markerY.push(mv);
                                    prevYR[i] = prevYL[i] = mv;
                                    if (xe.length > 0) {
                                        // start new section
                                        if (y0 !== null) {
                                            xe.push(x0);
                                            ye.push(y0);
                                        }
                                        y0 = null;
                                        segments.push(xe, ye);
                                        xe = [];
                                        ye = [];
                                    }
                                }
                            }
                        }
                        if (xe.length > 0) {
                            if (y0 !== null) {
                                xe.push(x0);
                                ye.push(y0);
                            }
                            segments.push(xe, ye);
                        }
                        return {
                            segments: segments,
                            markerY: markerY
                        };
                    };
                    Line.prototype.smoothLine = function (xlist, ylist) {
                        var x = xlist[0];
                        var x1 = xlist[xlist.length - 1];
                        var pointDistance = (x1 - x) / xlist.length;
                        // no smoothing for dense lines
                        if (pointDistance < 2) {
                            return { x: xlist, y: ylist };
                        }
                        // make a point every 2 pixels
                        var newx = [];
                        var newy = [];
                        newx.push(x);
                        newy.push(ylist[0]);
                        var i0 = 0;
                        while (i0 + 1 < xlist.length) {
                            var i1 = i0 + 1;
                            if (xlist[i0] !== xlist[i1]) {
                                while (i1 + 1 < xlist.length && xlist[i1] !== xlist[i1 + 1]) {
                                    i1 += 1;
                                }
                            }
                            if (i1 - i0 === 1) {
                                newx.push(xlist[i1]);
                                newy.push(ylist[i1]);
                            }
                            else {
                                // apply curve
                                var c = new Internal.Base.MonotoneCurve(xlist, ylist, i0, i1 + 1);
                                x1 = xlist[i0];
                                for (var i = i0 + 1; i <= i1; i++) {
                                    x = x1;
                                    x1 = xlist[i];
                                    var y1 = ylist[i];
                                    pointDistance = (x1 - x);
                                    var intermediatePoints = Math.ceil(Math.min(50, Math.max(2, pointDistance / 3)));
                                    var dx = pointDistance / intermediatePoints;
                                    var ist = newx.length;
                                    while ((x += dx) < x1) {
                                        newx.push(x);
                                    }
                                    c.interpolateArray(i - 1, newx, ist, newx.length, newy);
                                    newx.push(x1);
                                    newy.push(y1);
                                }
                                c.clear();
                            }
                            i0 = i1;
                        }
                        xlist.length = 0;
                        ylist.length = 0;
                        return { x: newx, y: newy };
                        // Paint operations
                    };
                    Line.prototype.paintLine = function (context, style, prevSegments, segments, zeroY) {
                        if (style._currentFillStyle) {
                            if (style.shadowColor) {
                                Internal.Base.Graphics.applyShadow(context, style);
                            }
                            context.fillStyle = style._currentFillStyle;
                            context.beginPath();
                            for (var i = 0; i < segments.length; i += 2) {
                                this.paintArea(context, segments[i], segments[i + 1], prevSegments, zeroY);
                            }
                            context.fill();
                            if (style.shadowColor) {
                                Internal.Base.Graphics.clearShadow(context);
                            }
                        }
                        if (style.lineColor) {
                            if (!style.fillColor && style.shadowColor) {
                                Internal.Base.Graphics.applyShadow(context, style);
                            }
                            var strokeContext = Internal.Base.Graphics.beginStroke(context, style);
                            for (var i = 0; i < segments.length; i += 2) {
                                var xlist = segments[i];
                                var ylist = segments[i + 1];
                                strokeContext.moveTo(xlist[0], ylist[0]);
                                for (var j = 1; j < xlist.length; j++) {
                                    strokeContext.lineTo(xlist[j], ylist[j]);
                                }
                            }
                            Internal.Base.Graphics.endStroke(context, strokeContext, style);
                            if (!style.fillColor && style.shadowColor) {
                                Internal.Base.Graphics.clearShadow(context);
                            }
                        }
                    };
                    Line.prototype.paintArea = function (context, xlist, ylist, previousSegments, zeroY) {
                        context.moveTo(xlist[0], ylist[0]);
                        for (var i = 1; i < xlist.length; i++) {
                            context.lineTo(xlist[i], ylist[i]);
                        }
                        var x0 = xlist[0];
                        var x1 = xlist[xlist.length - 1];
                        var yz = zeroY;
                        var x = x1;
                        // trace previous segments backwards
                        for (var j = previousSegments.length - 2; j >= 0; j += -2) {
                            var xx = previousSegments[j];
                            var yy = previousSegments[j + 1];
                            if (xx.length < 2 || xx[0] > x || xx[xx.length - 1] < x0) {
                                continue;
                            }
                            var l = xx.length - 1;
                            var prevx = xx[l];
                            // at this point this segment is relevant and we are definitely adding some points from it
                            if (prevx < x) {
                                // no segment at X, paint down to zero and connect to beginning
                                context.lineTo(x, yz);
                                context.lineTo(prevx, yz);
                                x = prevx;
                            }
                            var i = void 0;
                            var curx = void 0;
                            for (i = l; i >= 0; i--) {
                                curx = xx[i];
                                if (x === prevx) {
                                    context.lineTo(prevx, yy[i + 1]);
                                    x = curx;
                                }
                                else if (x < prevx && x > curx) {
                                    // x is between segments - compute middle point
                                    var curY = yy[i];
                                    var prevY = yy[i + 1];
                                    var prop = (x - curx) / (prevx - curx);
                                    var y = curY + prop * (prevY - curY);
                                    context.lineTo(x, y);
                                    x = curx;
                                }
                                if (x <= x0) {
                                    // final point found, if x is between segments - compute middle point
                                    x = x0;
                                    var curY = yy[i];
                                    var prevY = yy[i + 1];
                                    var prop = (x - curx) / (prevx - curx);
                                    var y = curY + prop * (prevY - curY);
                                    context.lineTo(x, y);
                                    break;
                                }
                                prevx = curx;
                            }
                            if (i === -1 && x === curx) {
                                // final point of prevSegment - connect to it
                                context.lineTo(x, yy[0]);
                            }
                        }
                        if (x !== x0) {
                            // draw to zero and finish the area
                            context.lineTo(x, yz);
                            context.lineTo(x0, yz);
                        }
                        context.closePath();
                    };
                    return Line;
                }());
                Renderers.Line = Line;
            })(Renderers = LinearChart.Renderers || (LinearChart.Renderers = {}));
        })(LinearChart = Internal.LinearChart || (Internal.LinearChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../base/Graphics.ts" />
/// <reference path="../../base/Geometry.ts" />
/// <reference path="Base.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var LinearChart;
        (function (LinearChart) {
            var Renderers;
            (function (Renderers) {
                var Candlestick = (function () {
                    function Candlestick(scene, series) {
                        this.series = series;
                        this.scene = scene;
                        this.prevy = [];
                    }
                    Candlestick.prototype.paintStack = function (event, centers, radii, ystack, styles, zeroY) {
                        if (!(centers.length > 0)) {
                            return;
                        }
                        var s = this.series[0];
                        this.seriesEnabled = s.enabled;
                        var prevy = this.prevy;
                        if (prevy.length < centers.length) {
                            prevy = this.prevy = new Array(centers.length);
                        }
                        for (var i = 0; i <= centers.length - 1; i++) {
                            prevy[i] = zeroY;
                        }
                        this.plainBar(event.context, s.style, centers, radii, prevy, ystack);
                    };
                    Candlestick.prototype.hitTest = function (centers, radii, ystack, styles, zeroY, x, y, tolerance) {
                        // Stuck on interaction if leaved empty
                        var len = centers.length;
                        if (!(len > 1)) {
                            return {
                                result: null,
                                distance: Infinity
                            };
                        }
                        var series = this.series;
                        var xind = Internal.Base.Helpers.binSearch(centers, x);
                        var x0 = centers[xind] - radii[xind];
                        var x1 = centers[xind] + radii[xind];
                        if (x0 > x && xind > 0) {
                            var x0a = centers[xind - 1] - radii[xind - 1];
                            var x1a = centers[xind - 1] + radii[xind - 1];
                            if (x1a > x || Math.abs(x1a - x) < Math.abs(x0 - x)) {
                                xind -= 1;
                                x0 = x0a;
                                x1 = x1a;
                            }
                        }
                        var result = null;
                        var distance = Infinity;
                        var y0 = zeroY;
                        for (var i = 0; i < series.length; i++) {
                            var yy = ystack[i][xind];
                            if (yy !== null) {
                                var y1 = y0 - yy;
                                var y00 = Math.min(y0, y1);
                                var y11 = Math.max(y0, y1);
                                var d = Internal.Base.Geometry.distanceToRect(x, y, x0, y00, x1, y11);
                                if (d < distance) {
                                    distance = d;
                                    result = {
                                        x0: x0,
                                        y0: y00,
                                        x1: x1,
                                        y1: y11,
                                        seriesIndex: i,
                                        isMarker: false
                                    };
                                }
                                y0 = y1;
                            }
                        }
                        return {
                            result: result,
                            distance: distance
                        };
                    };
                    Candlestick.prototype.plainBar = function (context, style, centers, radii, ybase, yvaluesAll) {
                        for (var i = 0; i < centers.length; i++) {
                            var center = centers[i];
                            var y0 = ybase[i];
                            var yh = yvaluesAll[0][i];
                            var yo = yvaluesAll[1][i];
                            var yc = yvaluesAll[2][i];
                            var yl = yvaluesAll[3][i];
                            if ((yl === void 0 || yl === null) &&
                                (yh === void 0 || yh === null) &&
                                (yo === void 0 || yo === null) &&
                                (yc === void 0 || yc === null)) {
                                continue;
                            }
                            var oleft = (center - radii[i] || 0) + 0.5;
                            var oright = (center + radii[i] || 0) + 0.5;
                            var ylow = (y0 - yl || 0) + 0.5;
                            var yhigh = (y0 - yh || 0) + 0.5;
                            var yopen = (y0 - yo || 0) + 0.5;
                            var yclose = (y0 - yc || 0) + 0.5;
                            var curStyle = this.applyPatternStyle(context, style, yopen, yclose);
                            if (style.pattern === "bar") {
                                var strokeContext = Internal.Base.Graphics.beginStroke(context, curStyle);
                                // all bar with the same style
                                strokeContext.moveTo(center, yhigh);
                                strokeContext.lineTo(center, ylow);
                                strokeContext.moveTo(oleft, yopen);
                                strokeContext.lineTo(center, yopen);
                                strokeContext.moveTo(oright, yclose);
                                strokeContext.lineTo(center, yclose);
                                Internal.Base.Graphics.endStroke(context, strokeContext, curStyle);
                            }
                            else {
                                var strokeContext = Internal.Base.Graphics.beginStroke(context, curStyle);
                                // min max lines
                                strokeContext.moveTo(center, yhigh);
                                strokeContext.lineTo(center, yopen);
                                strokeContext.moveTo(center, yclose);
                                strokeContext.lineTo(center, ylow);
                                Internal.Base.Graphics.endStroke(context, strokeContext, curStyle);
                                // body 
                                strokeContext = Internal.Base.Graphics.beginStroke(context, curStyle, true);
                                strokeContext.moveTo(oleft, yopen);
                                strokeContext.lineTo(oright, yopen);
                                strokeContext.lineTo(oright, yclose);
                                strokeContext.lineTo(oleft, yclose);
                                strokeContext.closePath();
                                Internal.Base.Graphics.endStroke(context, strokeContext, curStyle, true);
                            }
                            if (style.shadowColor) {
                                Internal.Base.Graphics.clearShadow(context);
                            }
                        }
                    };
                    Candlestick.prototype.applyPatternStyle = function (context, style, open, close) {
                        var trend = open >= close ? style.increase : style.decrease;
                        var pattern = style.pattern === "candlestick" ? trend.candlestick : trend.bar;
                        var s = pattern;
                        if (!this.seriesEnabled) {
                            s = Internal.Base.Helpers.realClone(pattern);
                            var disabledSeries = this.scene.settings.legend.advanced.disabledSeries;
                            s.lineColor = disabledSeries.lineColor;
                            if (s.fillColor !== void 0)
                                s.fillColor = disabledSeries.fillColor;
                        }
                        if (style.lineColor && style.shadowColor) {
                            Internal.Base.Graphics.applyShadow(context, style);
                        }
                        return s;
                    };
                    return Candlestick;
                }());
                Renderers.Candlestick = Candlestick;
            })(Renderers = LinearChart.Renderers || (LinearChart.Renderers = {}));
        })(LinearChart = Internal.LinearChart || (Internal.LinearChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var LinearChart;
        (function (LinearChart) {
            var ValueLabels = (function () {
                function ValueLabels(chart, scene, valueAxis) {
                    this.scene = scene;
                    this.chart = chart;
                    this.valueAxis = valueAxis;
                }
                ValueLabels.prototype.setSeriesFont = function (context, event, series, radii, vstack) {
                    var md = this.scene.dataLabels.metaData;
                    var availableWidth = radii[0] * 2;
                    // set styles for each individual series
                    if (md.styles === null)
                        md.styles = {};
                    for (var confIndex = 0; confIndex < series.length; confIndex++) {
                        var curs = series[confIndex];
                        var max = this.getLongestNumber(vstack[confIndex]);
                        // formatings and delegate
                        md.styles[curs.id] = null;
                        if (max === -Infinity)
                            break;
                        // setup formatings
                        var content = this.createContent(max, curs.valueLabels.contentsFunction) || "";
                        var curFont = this.reduceFontWidth(context, event, curs.id, curs.valueLabels, availableWidth, content);
                        if (!curFont)
                            continue; // the size should be checked for each stacked series specific length
                        md.styles[curs.id] = curFont;
                    }
                };
                ValueLabels.prototype.scanValueLabels = function (context, event, radii, centers, series, ystack, ystackNegative, vstack) {
                    var chartInnerArea = this.chart.shell.getChartInnerArea();
                    var bottomEdge = this.chart.getBottomHeight();
                    for (var tIndex = 0; tIndex < 2; tIndex++) {
                        var currentStack = tIndex === 0 ? ystack : ystackNegative;
                        if (currentStack === null)
                            continue;
                        for (var cIndex = 0; cIndex < centers.length - 1; cIndex++) {
                            var center = centers[cIndex];
                            var base = this.valueAxis.zeroY;
                            var stackedValue = 0;
                            for (var yIndex = 0; yIndex < currentStack.length; yIndex++) {
                                var value = vstack[yIndex][cIndex];
                                var height = currentStack[yIndex][cIndex];
                                if (height === null || value === null)
                                    continue;
                                stackedValue += value;
                                base -= height;
                                var s = series[yIndex];
                                if (!s.valueLabels || !s.valueLabels.enabled)
                                    continue;
                                var useStackedValue = s.valueLabels.useStackedValue;
                                var stack = this.chart.settings._computedStacks[s.stack];
                                var isBasedStack = stack && stack.type === "based";
                                if (useStackedValue === null) {
                                    useStackedValue = !isBasedStack;
                                }
                                if (isBasedStack && height === 0 && stackedValue !== 0) {
                                    // ignore values for based stacks that are hidden behind larger values
                                    // the columns themselves will also not be shown.
                                    continue;
                                }
                                if (s instanceof LinearChart.SettingsSeriesColumns) {
                                    var sign = (height >= 0) ? 1 : -1;
                                    var minHeight = s.style.minHeight;
                                    if (minHeight) {
                                        height = height * sign < minHeight ? minHeight * sign : height;
                                    }
                                }
                                this.createDrawingSpots(context, chartInnerArea, height, base + height, center, s, useStackedValue ? stackedValue : value, bottomEdge, radii[0]);
                            }
                        }
                    }
                    this.paintDataLabels(context, event, radii[0], series.length);
                };
                ValueLabels.prototype.createDrawingSpots = function (context, chartInnerArea, height, y, center, series, value, top, baseWidth) {
                    var id = series.id;
                    var position = series.valueLabels.position;
                    var labels = this.scene.dataLabels;
                    var centerAprox = center.toFixed(1);
                    var spots = this.scene.dataLabels.spots[centerAprox];
                    if (labels.metaData.styles[id] === null)
                        return;
                    var formatedContent = this.createContent(value, series.valueLabels.contentsFunction);
                    if (formatedContent == null) {
                        return;
                    }
                    var padding = new Internal.Base.LabelLayoutBase().totalPadding(series.valueLabels.style);
                    height = Math.abs(height);
                    // verify hot spots
                    var ys = this.getPositionVerticalDimensions(context, value, y, height, labels.metaData.styles[id], series.valueLabels.minFontSize, position, padding);
                    if (ys === null)
                        return;
                    var mn = ys.min;
                    var mx = ys.max;
                    // verify toolbar
                    var topY = chartInnerArea.findTopPosition(center, Math.min(center + baseWidth, this.scene.x0 + this.scene.width));
                    if (topY > mn) {
                        // temp solution - move the spot downwards so that it is visible.
                        // the correct solution would be to leave enough space when calculating the Y values
                        mx = mx - mn + topY;
                        mn = topY;
                    }
                    // verify bottoms
                    var maxYValue = this.scene.chartTop + this.scene.chartHeight - this.scene.bottomAxisSize;
                    if (mx > maxYValue) {
                        // temp solution - move the spot upwards so that it is visible.
                        // the correct solution would be to leave enough space when calculating the Y values
                        mn = mn - mx + maxYValue;
                        mx = maxYValue;
                    }
                    if (spots) {
                        for (var sIndex = 0; sIndex < spots.length; sIndex++) {
                            var spot = spots[sIndex];
                            if (spot == null) {
                                continue;
                            }
                            var y0 = spot.edges[0];
                            var y1 = spot.edges[1];
                            if (mn < y1 && mx > y0) {
                                if (series.type === spot.type && value > spot.value) {
                                    spots[sIndex] = null;
                                }
                                else {
                                    return; // region overlap, no spot should be crated
                                }
                            }
                        }
                    }
                    if (!spots)
                        spots = this.scene.dataLabels.spots[centerAprox] = [];
                    // create spot as potential label
                    spots.push({
                        value: value,
                        type: series.type,
                        edges: [mn, mx],
                        x: parseInt(centerAprox, 10),
                        y: (mn + ys.fontHeight / 2),
                        font: ys.font,
                        id: id,
                        style: series.valueLabels.style,
                        function: series.valueLabels.contentsFunction
                    });
                };
                ValueLabels.prototype.reduceFontSize = function (context, font, minFontSize, calc, limit) {
                    // TODO: show error if the font cannot be parsed this way.
                    var fmatch = font.match(/^([^\"\d]*)(\d+\.?\d*)(.*)$/i);
                    if (!fmatch) {
                        Internal.Base.Helpers.warn("Could not parse the font size from the value `" + font + "`.");
                        return { font: font, value: calc(font) };
                    }
                    var fs = fmatch[2];
                    var fn1 = fmatch[1];
                    var fn2 = fmatch[3];
                    var sc = parseFloat(fs);
                    while (sc >= minFontSize) {
                        var f = fn1 + sc + fn2;
                        var x = calc(f);
                        if (x <= limit)
                            return { font: f, value: x };
                        if (sc === minFontSize)
                            break;
                        // reduce the size of the font based on a guess that the font sizes will be proportional.
                        sc = Math.round((sc - 1) * limit / x * 100) / 100;
                        if (sc < minFontSize)
                            sc = minFontSize;
                    }
                    return null;
                };
                /** Get 2 y values of potential spot - up and down side */
                ValueLabels.prototype.getPositionVerticalDimensions = function (context, value, y, height, font, minFontSize, position, padding) {
                    var sign = (value >= 0) ? -1 : 1;
                    var e1 = null;
                    var e2 = null;
                    var signedh = (sign) * height;
                    // +4 is there because that is the difference in html between the border box and the font height.
                    var fontHeight = Internal.Base.Graphics.getTextHeight(context, font) + padding * 2 + 4;
                    var fitsInside = fontHeight < height;
                    if (!fitsInside && (position === "insideTop" || position === "insideCenter" || position === "insideBase")) {
                        var fr = this.reduceFontSize(context, font, minFontSize, function (f) { return Internal.Base.Graphics.getTextHeight(context, f); }, height);
                        if (!fr) {
                            return null;
                        }
                        font = fr.font;
                        fontHeight = fr.value + padding * 2 + 4;
                    }
                    switch (position) {
                        case "outside":
                            e1 = y + signedh;
                            e2 = e1 + sign * fontHeight;
                            break;
                        case "insideTop":
                            e1 = y + signedh;
                            e2 = e1 - sign * fontHeight;
                            break;
                        case "insideCenter":
                            e1 = y + signedh / 2 + fontHeight / 2;
                            e2 = e1 - fontHeight;
                            break;
                        case "insideBase":
                            e1 = y + sign * fontHeight;
                            e2 = y;
                            break;
                        case "aboveValue":
                            e1 = y + signedh;
                            e2 = e1 - fontHeight;
                            break;
                        case "belowValue":
                            e1 = y + signedh;
                            e2 = e1 + fontHeight;
                            break;
                        case "insideTopAuto":
                            if (fitsInside) {
                                e1 = y + signedh;
                                e2 = e1 - sign * fontHeight;
                            }
                            else {
                                e1 = y + signedh;
                                e2 = e1 + sign * fontHeight;
                            }
                            break;
                        case "value":
                            if (fitsInside) {
                                e1 = y + signedh - fontHeight / 2;
                                e2 = e1 + fontHeight;
                            }
                            break;
                        default:
                            Internal.Base.Helpers.warn("Invalid position: '" + position
                                + "'. Possible values: outside, insideTop, insideCenter, insideBase, aboveValue, belowValue, belowValueAuto, value.");
                            // default - outside
                            e1 = y + signedh;
                            e2 = e1 + sign * fontHeight;
                            break;
                    }
                    if (e1 === null) {
                        return null;
                    }
                    else if (e1 > e2) {
                        return { min: e2, max: e1, font: font, fontHeight: fontHeight };
                    }
                    else {
                        return { min: e1, max: e2, font: font, fontHeight: fontHeight };
                    }
                };
                ValueLabels.prototype.reduceFontWidth = function (context, event, id, label, availableWidth, content) {
                    // check normal state as first
                    var fontWidths = this.scene.dataLabels.fontWidths;
                    var style = label.style.textStyle;
                    content = content.replace(/\d/g, "9");
                    if ((fontWidths[style.font + ";" + content] || Infinity) <= availableWidth) {
                        // the default font fits.
                        return style.font;
                    }
                    var l = new Internal.Base.Label(label.style);
                    var textStyle = l.style.textStyle;
                    var f = textStyle.font;
                    l.text = content;
                    var reduceResult = this.reduceFontSize(context, f, label.minFontSize, function (x) {
                        var lw = fontWidths[x + ";" + content];
                        if (!lw) {
                            textStyle.font = x;
                            event.labelRenderer.measure(context, l);
                            fontWidths[x + ";" + content] = lw = l.hwidth * 2;
                        }
                        return lw;
                    }, availableWidth);
                    if (reduceResult)
                        return reduceResult.font;
                    // nothing fits
                    return null;
                };
                ValueLabels.prototype.getLongestNumber = function (values) {
                    var maxAbs = 0;
                    var maxIndex = -1;
                    for (var i = 0; i < values.length; i++) {
                        var v = values[i];
                        if (v < 0)
                            v *= -10; // "-1" has the same length as "10"
                        if (maxAbs <= v) {
                            maxAbs = v;
                            maxIndex = i;
                        }
                    }
                    return (maxIndex === -1 || values[maxIndex] === null) ? -Infinity : values[maxIndex];
                };
                ValueLabels.prototype.createContent = function (value, callback) {
                    if (callback) {
                        var v = callback.call(this.chart.api, value) || null;
                        if (v != null && typeof v !== "string") {
                            Internal.Base.Helpers.warn("`valueLabels.contentsFunction` has to return `null` or a string value.");
                            return;
                        }
                        return v;
                    }
                    else {
                        return (value === (value | 0)) ? value.toFixed(0) : value.toFixed(2);
                    }
                };
                ValueLabels.prototype.paintDataLabels = function (context, event, baseWidth, length) {
                    var s = this.scene;
                    var md = s.dataLabels.metaData;
                    var availableWidth = baseWidth * 2;
                    var resized = md.availableWidth !== availableWidth;
                    md.processed += length;
                    if (md.processed >= s.seriesWithLabels) {
                        md.processed = 0;
                        var spots = s.dataLabels.spots;
                        var keys = Object.keys(spots);
                        for (var i = 0, l = keys.length; i < l; i++) {
                            var spotsByX = spots[keys[i]];
                            if (spotsByX) {
                                for (var spIndex = 0; spIndex < spotsByX.length; spIndex++) {
                                    // directly draw
                                    var spot = spotsByX[spIndex];
                                    if (spot == null) {
                                        continue;
                                    }
                                    var l_1 = new Internal.Base.Label(spot.style);
                                    l_1.text = this.createContent(spot.value, spot.function);
                                    l_1.style.textStyle.font = spot.font;
                                    event.labelRenderer.paint(context, spot.x, spot.y, 1, l_1);
                                }
                            }
                        }
                        s.dataLabels.spots = {};
                        if (resized) {
                            md.availableWidth = availableWidth;
                        }
                    }
                };
                return ValueLabels;
            }());
            LinearChart.ValueLabels = ValueLabels;
        })(LinearChart = Internal.LinearChart || (Internal.LinearChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../Renderer/Columns.ts" />
/// <reference path="../Renderer/Line.ts" />
/// <reference path="../Renderer/CandleStick.ts" />
/// <reference path="../../base/Geometry.ts" />
/// <reference path="../ValueLabels.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var LinearChart;
        (function (LinearChart) {
            var Series;
            (function (Series) {
                var Stack = (function () {
                    function Stack(chart, scene, cluster, options, va) {
                        this.series = [];
                        this.seriesId = [];
                        this.min = 0;
                        this.max = 0;
                        this.renderingType = null;
                        this.needsAfterProcess = false;
                        this.paddingLeft = 0;
                        this.paddingRight = 0;
                        this.centers = [];
                        this.radii = [];
                        this.vstack = [];
                        /** Contains the number of aggregated data points for each value. */
                        this.countStack = [];
                        this.ystack = [];
                        this.xes = [];
                        /** The timestamps for each display unit. Note that this array should be immutable as its reference is used to cache calculations. */
                        this.times = [];
                        this.styles = [];
                        this.previewData = [];
                        this.calculatedDepth = 0;
                        this.ystackNegative = null;
                        this.valueLabels = null;
                        /** The lazily initialized external items that are passed to any configuration callback. */
                        this.externalItems = null;
                        this.externalItemsCache = null;
                        this.va = va;
                        this.options = options;
                        this.cluster = cluster;
                        this.scene = scene;
                        this.chart = chart;
                        this.va.series++;
                    }
                    Stack.prototype.addSeries = function (seriesId, seriesOptions) {
                        if (!this.renderingType) {
                            this.renderingType = seriesOptions.type;
                        }
                        this.series.push(seriesOptions);
                        this.seriesId.push(seriesId);
                        var columnOptions = seriesOptions;
                        this.calculatedDepth = Math.max(this.calculatedDepth, columnOptions.style.depth);
                        if (this.renderingType === "columns") {
                            this.paddingLeft = Math.max(this.paddingLeft, columnOptions.style.padding[0]);
                            this.paddingRight = Math.max(this.paddingRight, columnOptions.style.padding[1]);
                        }
                    };
                    Stack.prototype.afterInit = function () {
                        if (this.renderingType === "line") {
                            this.renderer = new LinearChart.Renderers.Line(this, this.series);
                        }
                        else if (this.renderingType === "columns") {
                            this.renderer = new LinearChart.Renderers.Columns(this.scene, this.series);
                        }
                        else if (this.renderingType === "candlestick") {
                            this.candleStacks = true;
                            this.renderer = new LinearChart.Renderers.Candlestick(this.scene, this.series);
                        }
                    };
                    /** computes min and max for value axis, prepares data for rendering
                    series data is {id:valueObj}
                    ValueObj contains: {times:array, xes:array, values:array, fromIndex, toIndex, leadIn: obj, leadOut:obj, style: array or null}
                    leads contain: {xes: array, times:array, values:array} */
                    Stack.prototype.process = function (seriesData) {
                        this.processData(seriesData);
                        this.computeMinMax();
                        this.addLeads(seriesData);
                        this.needsAfterProcess = true;
                    };
                    /** value axis now have the correct scale - compute on screen positions */
                    Stack.prototype.afterProcess = function () {
                        if (this.needsAfterProcess || this.va.axisChanged) {
                            this.needsAfterProcess = false;
                            return this.computeY();
                        }
                    };
                    Stack.prototype.paint = function (event, context) {
                        if (this.ystack.length === 0 || isNaN(this.radii[0]))
                            return;
                        for (var sIndex = 0; sIndex < this.series.length; sIndex++) {
                            var series = this.series[sIndex];
                            this.computeFillStyle(context, series.style);
                            if (series.valueLabels && series.valueLabels.enabled) {
                                // create series dataLabels
                                if (this.valueLabels === null)
                                    this.valueLabels = new LinearChart.ValueLabels(this.chart, this.scene, this.va);
                                this.valueLabels.setSeriesFont(context, event, this.series, this.radii, this.vstack);
                            }
                        }
                        var customStyles = this.styles;
                        if (customStyles) {
                            for (var a = 0; a < customStyles.length; a++) {
                                var seriesCustomStyles = customStyles[a];
                                if (seriesCustomStyles) {
                                    for (var x = 0; x < seriesCustomStyles.length; x++) {
                                        this.computeFillStyle(context, seriesCustomStyles[x]);
                                    }
                                }
                            }
                        }
                        if (this.ystackNegative) {
                            this.renderer.paintStack(event, this.centers, this.radii, this.ystackNegative, this.styles, this.va.zeroY, this.previewData);
                        }
                        this.renderer.paintStack(event, this.centers, this.radii, this.ystack, this.styles, this.va.zeroY, this.previewData);
                        if (this.valueLabels !== null) {
                            this.valueLabels.scanValueLabels(context, event, this.radii, this.centers, this.series, this.ystack, this.ystackNegative, this.vstack);
                        }
                    };
                    Stack.prototype.hitTestStack = function (x, y) {
                        var xind = Internal.Base.Helpers.binSearch(this.centers, x);
                        var x0 = this.centers[xind] - this.radii[xind];
                        var x1 = this.centers[xind] + this.radii[xind];
                        if (x0 > x && xind > 0) {
                            var x0a = this.centers[xind - 1] - this.radii[xind - 1];
                            var x1a = this.centers[xind - 1] + this.radii[xind - 1];
                            if (x1a > x || Math.abs(x1a - x) < Math.abs(x0 - x)) {
                                xind -= 1;
                                x0 = x0a;
                                x1 = x1a;
                            }
                        }
                        return {
                            result: {
                                x0: x0,
                                y0: 0,
                                x1: x1,
                                y1: 0,
                                seriesIndex: null,
                                isMarker: false,
                                stack: this
                            },
                            distance: Internal.Base.Geometry.distanceToRect(x, 0, x0, 0, x1, 0)
                        };
                    };
                    Stack.prototype.hitTest = function (x, y, tolerance) {
                        var hitTestResult = this.renderer.hitTest(this.centers, this.radii, this.ystack, this.styles, this.va.zeroY, x, y, tolerance);
                        var item = hitTestResult.result;
                        var distance = hitTestResult.distance;
                        if (this.ystackNegative) {
                            hitTestResult = this.renderer.hitTest(this.centers, this.radii, this.ystackNegative, this.styles, this.va.zeroY, x, y, tolerance);
                            if (hitTestResult.distance < distance) {
                                item = hitTestResult.result;
                                distance = hitTestResult.distance;
                            }
                        }
                        if (item !== null) {
                            item.seriesIndex = this.seriesId[item.seriesIndex];
                            item.stack = this;
                        }
                        return {
                            result: item,
                            distance: distance
                        };
                    };
                    Stack.prototype.computeFillStyle = function (context, style) {
                        if (style) {
                            if (style.fillPattern) {
                                Stack.computeFillPattern(this.chart, context, style);
                            }
                            else if (style.fillGradient) {
                                this.computeFillGradient(context, style);
                                return;
                            }
                            else {
                                style._currentFillStyle = style.fillColor || null;
                                style._currentFillStyleKey = null;
                            }
                        }
                    };
                    Stack.computeFillPattern = function (chart, context, style) {
                        var pattern = style.fillPattern;
                        var key = style._currentFillStyleKey;
                        var color = style.fillColor;
                        var cacheKey = color + "|" + pattern;
                        if (key && key.pattern === cacheKey)
                            return;
                        var currentFillStyle;
                        var currentFillStyleKey;
                        var img = chart.assetsLoader.getAssetImage(style.fillPattern);
                        if (img) {
                            var opacity = style._fillPatternOpacity;
                            if (color || opacity) {
                                // use the color as the background for the pattern.
                                var canvas = document.createElement("canvas");
                                canvas.width = img.width;
                                canvas.height = img.height;
                                var cntx = canvas.getContext("2d");
                                if (color) {
                                    cntx.fillStyle = color;
                                    cntx.fillRect(0, 0, img.width, img.height);
                                }
                                cntx.globalAlpha = style._fillPatternOpacity;
                                cntx.drawImage(img, 0, 0);
                                img = canvas;
                            }
                            currentFillStyle = context.createPattern(img, "repeat");
                            currentFillStyleKey = { pattern: cacheKey };
                        }
                        else {
                            currentFillStyle = color || null;
                            currentFillStyleKey = null;
                        }
                        style._currentFillStyle = currentFillStyle;
                        style._currentFillStyleKey = currentFillStyleKey;
                    };
                    Stack.prototype.computeFillGradient = function (context, style) {
                        var gradientArray = style.fillGradient;
                        var valueAxis = this.va;
                        var zeroY = valueAxis.zeroY;
                        var y0 = this.scene.y0;
                        var x0 = this.scene.x0;
                        var height = this.scene.height;
                        // verify if the existing gradient is not good enough.
                        var key = style._currentFillStyleKey;
                        var gradientHash = valueAxis.scale + "|" + zeroY + "|" + y0 + "|" + x0 + "|" + height + "|" + zeroY;
                        if (key && style._currentFillStyle && gradientArray === key.gradient && gradientHash === key.hash)
                            return;
                        // keep linear gradient on screen only, linear gradients for large visible ranges results in loss of fidelity
                        var stops = [];
                        for (var stopAIndex = 0; stopAIndex < gradientArray.length; stopAIndex++) {
                            var stopA = gradientArray[stopAIndex];
                            var ypos = zeroY - valueAxis.valueToRelativeY(stopA[0]);
                            var fraction = (ypos - y0) / height;
                            stops.push([fraction, stopA[1]]);
                        }
                        stops.sort(function (a, b) { return a[0] - b[0]; });
                        var g = context.createLinearGradient(x0, y0, x0, y0 + height);
                        var prev = null;
                        for (var stopIndex = 0; stopIndex < stops.length; stopIndex++) {
                            var stop = stops[stopIndex];
                            var pos = stop[0];
                            var col = stop[1];
                            if (pos > 0) {
                                if (prev && prev[0] < 0) {
                                    // create color for 0 pos
                                    g.addColorStop(0, Internal.Base.Colors.blend(prev[1], col, (0 - prev[0]) / (pos - prev[0]), false));
                                }
                                if (pos > 1) {
                                    // create color stop for 1 pos
                                    if (prev) {
                                        g.addColorStop(1, Internal.Base.Colors.blend(prev[1], col, (1 - prev[0]) / (pos - prev[0]), false));
                                    }
                                    break;
                                }
                                else {
                                    g.addColorStop(pos, col);
                                }
                            }
                            prev = stop;
                        }
                        style._currentFillStyle = g;
                        style._currentFillStyleKey = { hash: gradientHash, gradient: gradientArray };
                    };
                    Stack.prototype.processData = function (dataMap) {
                        var _this = this;
                        this.vstack = [];
                        this.countStack = [];
                        this.styles = [];
                        var slice = dataMap[this.seriesId[0]];
                        if (slice.times.length === 0) {
                            return;
                        }
                        this.xes = slice.xes.slice(slice.fromIndex, slice.toIndex);
                        this.times = slice.times.slice(slice.fromIndex, slice.toIndex);
                        this.centers = new Array(this.xes.length - 1);
                        this.radii = new Array(this.xes.length - 1);
                        this.cluster.computeStackCenterRadius(this, this.xes, this.centers, this.radii);
                        this.externalItemsCache = null;
                        this.externalItems = function () {
                            var c = _this.externalItemsCache;
                            if (c === null) {
                                c = _this.externalItemsCache = slice.externalItems(slice.fromIndex, slice.toIndex - 1);
                            }
                            return c;
                        };
                        this.previewData = [];
                        for (var i = 0; i < this.seriesId.length; i++) {
                            var seriesId = this.seriesId[i];
                            slice = dataMap[seriesId];
                            this.vstack.push(slice.values.slice(slice.fromIndex, slice.toIndex - 1));
                            this.countStack.push(slice.counts.slice(slice.fromIndex, slice.toIndex - 1));
                            if (slice.config) {
                                var styles = [];
                                var preview = [];
                                for (var j = slice.fromIndex; j < slice.toIndex - 1; j++) {
                                    var item = slice.config[j];
                                    if (item) {
                                        styles.push(item.style);
                                        preview.push(item.previewData);
                                    }
                                }
                                this.styles.push(styles);
                                this.previewData.push(preview);
                            }
                            else {
                                this.styles.push(null);
                            }
                        }
                    };
                    Stack.prototype.addLeads = function (dataMap) {
                        for (var i = 0; i < this.seriesId.length; i++) {
                            var id = this.seriesId[i];
                            var slice = dataMap[id];
                            if (slice.leadIn) {
                                this.injectLead(slice.leadIn, i);
                            }
                            if (slice.leadOut) {
                                this.injectLead(slice.leadOut, i);
                            }
                        }
                    };
                    Stack.prototype.injectLead = function (lead, dataIndex) {
                        var count = this.series.length;
                        var val = lead.values[0];
                        var t0 = lead.times[0];
                        var centerArr = [0];
                        var radArr = [0];
                        this.cluster.computeStackCenterRadius(this, lead.xes, centerArr, radArr);
                        var center = centerArr[0];
                        var rad = radArr[0];
                        // fix approx location
                        var i = 0;
                        while (i < this.centers.length && this.centers[i] < center) {
                            i++;
                        }
                        if (i === this.centers.length || this.centers[i] > center) {
                            // insert new point
                            this.centers.splice(i, 0, center);
                            this.radii.splice(i, 0, rad);
                            this.times.splice(i, 0, t0);
                            for (var j = 0; j <= count - 1; j++) {
                                this.vstack[j].splice(i, 0, null);
                                this.countStack[j].splice(i, 0, null);
                                if (this.styles[j]) {
                                    this.styles[j].splice(i, 0, null);
                                }
                            }
                        }
                        this.vstack[dataIndex][i] = val;
                        this.countStack[dataIndex][i] = lead.counts[0];
                    };
                    Stack.prototype.getSeparateNegative = function () {
                        var v = this.options.separateNegativeValues;
                        if (v === null) {
                            v = this.renderingType !== "line";
                        }
                        return v;
                    };
                    Stack.prototype.computeMinMax = function () {
                        var min = Infinity;
                        var max = -Infinity;
                        if (this.vstack.length > 0) {
                            var vstack = this.vstack;
                            var len = vstack[0].length;
                            var stacks = vstack.length;
                            var type = this.options.type;
                            var separateNegativeValues = this.getSeparateNegative();
                            // figure out first and last item
                            var left = this.scene.x0;
                            var right = left + this.scene.width;
                            var from = 0;
                            var to = len - 1;
                            while (from < len && this.centers[from] + this.radii[from] < left) {
                                from += 1;
                            }
                            while (to >= from && this.centers[to] - this.radii[to] > right) {
                                to -= 1;
                            }
                            if (type === "proportional") {
                                min = 0;
                                max = 100;
                            }
                            else if (this.candleStacks) {
                                for (var i = from; i <= to; i++) {
                                    for (var j = 0; j <= stacks - 1; j++) {
                                        var v = vstack[j][i];
                                        if (Internal.Base.Helpers.isNumber(v)) {
                                            min = Math.min(min, v);
                                            max = Math.max(max, v);
                                        }
                                    }
                                }
                            }
                            else if (stacks === 1) {
                                // optimized for singe series
                                var values = vstack[0];
                                for (var i = from; i <= to; i++) {
                                    var v = values[i];
                                    if (Internal.Base.Helpers.isNumber(v)) {
                                        min = Math.min(min, v);
                                        max = Math.max(max, v);
                                    }
                                }
                            }
                            else if (type === "based") {
                                for (var i = from; i <= to; i++) {
                                    for (var j = 0; j <= stacks - 1; j++) {
                                        var v = vstack[j][i];
                                        if (Internal.Base.Helpers.isNumber(v)) {
                                            min = Math.min(min, v);
                                            max = Math.max(max, v);
                                        }
                                    }
                                }
                            }
                            else if (type === "normal" && !separateNegativeValues) {
                                for (var i = from; i <= to; i++) {
                                    var s = 0;
                                    for (var j = 0; j <= stacks - 1; j++) {
                                        var v = vstack[j][i];
                                        if (!Internal.Base.Helpers.isNumber(v))
                                            continue;
                                        if (v !== null) {
                                            s += v;
                                        }
                                        min = Math.min(min, s);
                                        max = Math.max(max, s);
                                    }
                                }
                            }
                            else if (type === "normal") {
                                // separate negative and positive stacks.
                                for (var i = from; i <= to; i++) {
                                    var mins = 0;
                                    var maxs = 0;
                                    for (var j = 0; j <= stacks - 1; j++) {
                                        var v = vstack[j][i];
                                        if (!Internal.Base.Helpers.isNumber(v))
                                            continue;
                                        if (v > 0) {
                                            maxs += v;
                                        }
                                        else if (v < 0) {
                                            mins += v;
                                        }
                                        min = Math.min(min, mins);
                                        max = Math.max(max, maxs);
                                    }
                                }
                            }
                            else {
                                throw ("stack.type unknown value: " + type);
                            }
                        }
                        this.min = min;
                        this.max = max;
                        if (min <= max) {
                            this.va.receiveSeriesGeometry(min, max, this.calculatedDepth);
                        }
                        else {
                            this.va.receiveSeriesGeometry(void 0, void 0, this.calculatedDepth);
                        }
                    };
                    Stack.prototype.computeY = function () {
                        var vstack = this.vstack;
                        var stacks = vstack.length;
                        if (stacks === 0) {
                            return;
                        }
                        var type = this.options.type;
                        var separateNegativeValues = this.getSeparateNegative();
                        var count = vstack[0].length;
                        var va = this.va;
                        var ystackNeg = null;
                        var ystack;
                        if (type === "proportional") {
                            // convert to percent
                            ystack = vstack.map(function () { return []; });
                            for (var i = 0; i <= count - 1; i++) {
                                var sum = 0;
                                for (var j = 0; j <= stacks - 1; j++) {
                                    var v = vstack[j][i];
                                    if (v !== null) {
                                        sum += Math.abs(v);
                                    }
                                }
                                if (sum > 0) {
                                    sum *= 0.01;
                                    for (var j = 0; j <= stacks - 1; j++) {
                                        var v = vstack[j][i];
                                        if (v !== null) {
                                            ystack[j].push(va.valueToRelativeY(Math.abs(v) / sum));
                                        }
                                        else {
                                            ystack[j].push(null);
                                        }
                                    }
                                }
                                else {
                                    for (var j = 0; j <= stacks - 1; j++) {
                                        ystack[j].push(null);
                                    }
                                }
                            }
                        }
                        else if (type === "based" || stacks === 1) {
                            ystack = [];
                            var prevY = vstack[0].map(function () { return 0; });
                            for (var jv = 0; jv < vstack.length; jv++) {
                                var values = vstack[jv];
                                var ys = new Array(count);
                                for (var iv = 0; iv < values.length; iv++) {
                                    var v = values[iv];
                                    if (v !== null) {
                                        var y = va.valueToRelativeY(v);
                                        var pY = prevY[iv];
                                        if ((v >= 0 && y <= pY) || (v < 0 && y >= pY)) {
                                            // this prevents based columns being drawn over previous columns.
                                            // see https://forum.zoomcharts.com/t/stack-type-based/532/
                                            ys[iv] = 0;
                                        }
                                        else {
                                            ys[iv] = y - pY;
                                            prevY[iv] = y;
                                        }
                                    }
                                    else {
                                        ys[iv] = null;
                                    }
                                }
                                ystack.push(ys);
                            }
                        }
                        else if (type === "normal" && separateNegativeValues && (this.min < 0 && this.max > 0)) {
                            // separate negative and positive stacks.
                            ystack = vstack.map(function () { return []; });
                            ystackNeg = vstack.map(function () { return []; });
                            for (var i = 0; i <= count - 1; i++) {
                                for (var j = 0; j <= stacks - 1; j++) {
                                    var v = vstack[j][i];
                                    if (v > 0) {
                                        ystack[j].push(va.valueToRelativeY(v));
                                        ystackNeg[j].push(null);
                                    }
                                    else if (v < 0) {
                                        ystack[j].push(null);
                                        ystackNeg[j].push(va.valueToRelativeY(v));
                                    }
                                    else {
                                        ystack[j].push(null);
                                        ystackNeg[j].push(null);
                                    }
                                }
                            }
                        }
                        else if (this.renderingType === "candlestick") {
                            ystack = vstack.map(function () { return []; });
                            for (var i = 0; i <= count - 1; i++) {
                                for (var j = 0; j <= stacks - 1; j++) {
                                    var v = vstack[j][i];
                                    if (v !== null) {
                                        ystack[j].push(va.valueToRelativeY(v));
                                    }
                                    else {
                                        ystack[j].push(null);
                                    }
                                }
                            }
                        }
                        else if (type === "normal") {
                            var diff = 0;
                            var effective = 0;
                            var lastRelativeY = 0;
                            ystack = vstack.map(function () { return []; });
                            for (var i = 0; i <= count - 1; i++) {
                                for (var j = 0; j <= stacks - 1; j++) {
                                    var v = vstack[j][i];
                                    if (j === 0)
                                        diff = effective = lastRelativeY = 0;
                                    if (v !== null) {
                                        effective += v;
                                        var valRelativeY = va.valueToRelativeY(effective);
                                        ystack[j].push(valRelativeY - lastRelativeY);
                                        lastRelativeY = valRelativeY;
                                    }
                                    else {
                                        ystack[j].push(null);
                                    }
                                }
                            }
                        }
                        else {
                            throw ("stack.type unknown value: " + type);
                        }
                        this.ystackNegative = ystackNeg;
                        this.ystack = ystack;
                    };
                    /** Exports data for info popup.
                    TODO: this only exports from visible data, no use if asked about data outside, e.g. selection
                    Params: fromTime, toTime
                    Result: {name:stackName, config:stackConfig, data:seriesVal}, seriesVal = [{name, values, config}], values = {sum, count, first, last, min,max, avg, change}] */
                    Stack.prototype.exportData = function (from, to) {
                        var results;
                        if (this.times && this.vstack) {
                            var times = this.times;
                            // by 1 smaller than times.len
                            var count = this.centers.length;
                            /* get from/to index
                            stupid, linear search */
                            var fromIndex = 0;
                            while (fromIndex < count && times[fromIndex + 1] <= from) {
                                fromIndex++;
                            }
                            var toIndex = fromIndex;
                            while (toIndex < count && times[toIndex + 1] < to) {
                                toIndex++;
                            }
                            // compute the stats
                            results = [];
                            for (var valuesIndex = 0; valuesIndex < this.vstack.length; valuesIndex++) {
                                var values = this.vstack[valuesIndex];
                                var counts = this.countStack[valuesIndex];
                                var sum = 0;
                                var max = -Infinity;
                                var min = Infinity;
                                var first = null;
                                var last = null;
                                count = 0;
                                var aggr = this.series[valuesIndex].data.aggregation;
                                var avgMultiply = false;
                                var avgAvailable = false;
                                if (aggr === "sum") {
                                    avgMultiply = false;
                                    avgAvailable = true;
                                }
                                else if (aggr === "avg") {
                                    avgMultiply = true;
                                    avgAvailable = true;
                                }
                                for (var i = fromIndex; i <= toIndex; i++) {
                                    var v = values[i];
                                    var c = counts[i] | 0;
                                    if (v != null && !isNaN(v)) {
                                        sum += avgMultiply ? v * c : v;
                                        max = Math.max(max, v);
                                        min = Math.min(min, v);
                                        if (first === null)
                                            first = v;
                                        last = v;
                                        count += c;
                                    }
                                }
                                if (count > 0) {
                                    results.push({
                                        sum: sum,
                                        max: max,
                                        min: min,
                                        first: first,
                                        last: last,
                                        count: count,
                                        avg: avgAvailable ? sum / count : null,
                                        change: last - first
                                    });
                                }
                                else {
                                    results.push(null);
                                }
                            }
                        }
                        else {
                            results = this.series.map(function () { return null; });
                        }
                        // prepare result
                        var data = [];
                        for (var k = this.series.length - 1; k >= 0; k--) {
                            var config = this.series[k];
                            data.push({
                                name: config.name || "",
                                values: results[k],
                                config: config
                            });
                        }
                        return {
                            name: this.options.name,
                            stack: this,
                            config: this.options,
                            data: data
                        };
                    };
                    return Stack;
                }());
                Series.Stack = Stack;
            })(Series = LinearChart.Series || (LinearChart.Series = {}));
        })(LinearChart = Internal.LinearChart || (Internal.LinearChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Settings.ts" />
/// <reference path="../base/Helpers.ts" />
/// <reference path="Legend.ts" />
/// <reference path="ValueAxis.ts" />
/// <reference path="Series/Stack.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var LinearChart;
        (function (LinearChart) {
            var Settings = (function (_super) {
                __extends(Settings, _super);
                function Settings() {
                    _super.apply(this, arguments);
                    //#region Computed properties
                    this._computedValueAxisList = [];
                    this._computedValueAxis = {};
                    // computed from series and chartTypes, structure the same as series
                    this._computedSeries = [];
                    this._computedStacks = {};
                    //#endregion
                    this.area = new SettingsArea();
                    this.legend = new LinearChart.SettingsLegend();
                    /** The default settings inherited by all value axis. */
                    this.valueAxisDefault = new LinearChart.SettingsValueAxis();
                    /** Configures one or more value axis. If no axis are defined, `valueAxisDefault` settings are used to automatically create a single value axis. */
                    this.valueAxis = {};
                    /** Default series settings for each series rendering type. Use this to configure all series of specific type to get line
                    or column chart or combination of them. */
                    this.chartTypes = {
                        /** Series type to render values as vertical bars. */
                        columns: { type: "columns" },
                        /** Series type to connect value points by lines. */
                        line: { type: "line" },
                        /** Series type to show an opening and closing value on top of a total variance. */
                        candlestick: { type: "candlestick" }
                    };
                    /** Defines stack settings to use in series. Each property is a stack name and value is stack settings.
                        Values stack of each series on top of each other in the specified series order. Those, stacked bars help
                        to visualize data that is a sum of parts, each of which is in a series. */
                    this.stacks = {};
                    /** The default series used as the chart dominant data. Use settings.series array to specify actual series. */
                    this.seriesDefault = { type: "columns" };
                    /** Array of series in the chart. Each of the series can be different type, can use different data source and
                        aggregation. Additionally, series can be clustered and stacked.
                    @update mergeByID*/
                    this.series = [];
                    /** Info popup when hovering over columns or lines. Content returned in a form of html and is relevant to context of series hovered. */
                    this.info = new SettingsInfoPopup();
                    this.events = new SettingsEvents();
                    /** A variety of interaction options that includes scrolling, zooming and swipe. */
                    this.interaction = new SettingsInteraction();
                    this.localization = new SettingsLocalization();
                    /** The default style settings for series. */
                    this.style = {
                        /** The default colors applied to the series with `type: "columns"`. The colors are applied in order to all series that do not specify an explicit style. */
                        columnColors: [
                            "#32CD32",
                            "#36BEFF",
                            "#FBBD30",
                            "#EE3431",
                            "#894BBC",
                            "#0EC9AC",
                            "#524BBC"
                        ],
                        /** The default colors applied to the series with `type: "line"`. The colors are applied in order to all series that do not specify an explicit style. */
                        lineColors: [
                            "#32CD32",
                            "#36BEFF",
                            "#FBBD30",
                            "#EE3431",
                            "#894BBC",
                            "#0EC9AC",
                            "#524BBC"
                        ],
                    };
                }
                Settings.addSeparateSeries = function (seriesEntry, name, index, aggregation, stackId, id, seriesList) {
                    var separateSeries = Internal.Base.Helpers.extendCopy({}, seriesEntry);
                    separateSeries.stack = stackId;
                    separateSeries.id = "series" + Internal.Base.Helpers.SeparatorChar + id;
                    separateSeries.name = name;
                    separateSeries.data = {
                        aggregation: aggregation,
                        index: index
                    };
                    separateSeries.style = seriesEntry.style;
                    seriesList.push(separateSeries);
                };
                Settings._hasSeriesSettingsChanged = function (changes) {
                    return changes.series || changes.chartTypes || changes.seriesDefault || changes.stacks || changes.style;
                };
                Settings.prototype.apply = function (settings, seriesType) {
                    var valueAxis = settings.valueAxis;
                    if (valueAxis) {
                        var compat = [
                            { from: "style.baseLineColor", to: "style.baseLine.lineColor" },
                            { from: "style.baseLineWidth", to: "style.baseLine.lineWidth" },
                            { from: "style.hgridLineColor", to: "style.hgrid.lineColor" },
                            { from: "style.title.alignment", to: "style.title.align" },
                            { from: "style.title.font", to: "style.title.textStyle.font" },
                            { from: "style.title.fillColor", to: "style.title.textStyle.fillColor" },
                            { from: "style.valueLabel.font", to: "style.valueLabel.textStyle.font" },
                            { from: "style.valueLabel.fillColor", to: "style.valueLabel.textStyle.fillColor" },
                        ];
                        for (var vkey in valueAxis) {
                            this.applyCompatibility(valueAxis[vkey], compat, "valueAxis[" + vkey + "]");
                        }
                    }
                    this.applyCompatibility(settings, [
                        { from: "valueAxis.default", to: "valueAxisDefault" },
                        { from: "valueAxisDefault.style.baseLineColor", to: "valueAxisDefault.style.baseLine.lineColor" },
                        { from: "valueAxisDefault.style.baseLineWidth", to: "valueAxisDefault.style.baseLine.lineWidth" },
                        { from: "valueAxisDefault.style.hgridLineColor", to: "valueAxisDefault.style.hgrid.lineColor" },
                        { from: "valueAxisDefault.style.title.alignment", to: "valueAxisDefault.style.title.align" },
                        { from: "valueAxisDefault.style.title.font", to: "valueAxisDefault.style.title.textStyle.font" },
                        { from: "valueAxisDefault.style.title.fillColor", to: "valueAxisDefault.style.title.textStyle.fillColor" },
                        { from: "valueAxisDefault.style.valueLabel.font", to: "valueAxisDefault.style.valueLabel.textStyle.font" },
                        { from: "valueAxisDefault.style.valueLabel.fillColor", to: "valueAxisDefault.style.valueLabel.textStyle.fillColor" },
                    ]);
                    var changes = _super.prototype.apply.call(this, settings);
                    if (this._initializing || Settings._hasSeriesSettingsChanged(changes)) {
                        // so that Impl.processSettingsChanges correctly sets its values.
                        if (this._initializing && !changes.series)
                            changes.series = [];
                        var series = this.series;
                        // separate candlesticks
                        var seriesList = [];
                        var stackId = null;
                        var nextId = 0;
                        this._computedStacks = Internal.Base.Helpers.clone(this.stacks);
                        for (var sKey = 0; sKey < series.length; sKey++) {
                            var seriesEntry = series[sKey];
                            if (seriesEntry.valueAxis && seriesEntry.valueAxis !== "default" && !this.valueAxis[seriesEntry.valueAxis]) {
                                Internal.Base.Helpers.error("The series reference a non-existant value axis `" + seriesEntry.valueAxis + "`.");
                                continue;
                            }
                            if (seriesEntry.data && seriesEntry.data.index === 0) {
                                Internal.Base.Helpers.error("Value `0` references the timestamp and cannot be used when specifying `series.data.index`.");
                                continue;
                            }
                            if (seriesEntry.data && seriesEntry.data.countIndex === 0) {
                                Internal.Base.Helpers.error("Value `0` references the timestamp and cannot be used when specifying `series.data.countIndex`.");
                                continue;
                            }
                            if (seriesEntry.type === "candlestick" && (!seriesEntry.data || !seriesEntry.data.index)) {
                                // check stack settings
                                if (seriesEntry.stack === void 0 || seriesEntry.stack === null) {
                                    stackId = "default" + Internal.Base.Helpers.SeparatorChar + (nextId++);
                                    var stack = new SettingsStack();
                                    stack.name = seriesEntry.name;
                                    this._computedStacks[stackId] = stack;
                                }
                                // check if all data fields are present
                                var data = seriesEntry.data;
                                if (data == null || data.high == null || data.low == null || data.open == null || data.close == null) {
                                    Internal.Base.Helpers.error("Each candlestick series should define four data properties: low, high, open, close");
                                    continue;
                                }
                                var localization = seriesEntry.localization;
                                if (!localization)
                                    localization = this.chartTypes.candlestick.localization;
                                if (!localization)
                                    localization = (new SettingsSeriesCandleStick()).localization;
                                // All checks pass requirements. Create series objects
                                Settings.addSeparateSeries(seriesEntry, localization.high || "high", data.high, "max", stackId, nextId++, seriesList);
                                Settings.addSeparateSeries(seriesEntry, localization.open || "open", data.open, "first", stackId, nextId++, seriesList);
                                Settings.addSeparateSeries(seriesEntry, localization.close || "close", data.close, "last", stackId, nextId++, seriesList);
                                Settings.addSeparateSeries(seriesEntry, localization.low || "low", data.low, "min", stackId, nextId++, seriesList);
                            }
                            else {
                                seriesList.push(seriesEntry);
                            }
                        }
                        this._computedSeries = Internal.Base.SettingsHelper.mergeDefaultValues(seriesList, this.seriesDefault, this.chartTypes, seriesType.createInstance, seriesType.getMapping, "series");
                        this.applySeriesColor(this._computedSeries);
                    }
                    // generate value axis
                    if (this._initializing || changes.valueAxis || changes.valueAxisDefault || !this._computedValueAxisList.length) {
                        // so that Impl.processSettingsChanges correctly sets its values.
                        if (this._initializing && !changes.valueAxis)
                            changes.valueAxis = {};
                        var defaultUsed = false;
                        for (var sIndex = 0; sIndex < this._computedSeries.length; sIndex++) {
                            var s = this._computedSeries[sIndex];
                            defaultUsed = defaultUsed || (s.valueAxis === "default");
                        }
                        this._computedValueAxisList = [];
                        this._computedValueAxis = {};
                        var defV = this.valueAxisDefault;
                        for (var id in this.valueAxis) {
                            var vAxis = new LinearChart.SettingsValueAxis();
                            var stngsAxis = this.valueAxis[id];
                            this.applyCompatibility(stngsAxis, [
                                { from: "style.baseLineColor", to: "style.baseLine.lineColor" },
                                { from: "style.baseLineWidth", to: "style.baseLine.lineWidth" },
                                { from: "style.hgridLineColor", to: "style.hgrid.lineColor" }
                            ]);
                            Internal.Base.SettingsHelper.updateRecursive(vAxis, defV, Internal.Base.SettingsMapping.LinearChartSettingsValueAxis, {}, "valueAxisDefault");
                            Internal.Base.SettingsHelper.updateRecursive(vAxis, stngsAxis, Internal.Base.SettingsMapping.LinearChartSettingsValueAxis, {}, "valueAxis[" + id + "]");
                            vAxis.id = id;
                            this._computedValueAxis[id] = vAxis;
                            this._computedValueAxisList.push(vAxis);
                        }
                        // add default axis
                        if (defaultUsed && !this.valueAxis["default"]) {
                            var v = Internal.Base.Helpers.realClone(defV);
                            v.id = "default";
                            this._computedValueAxis[v.id] = v;
                            this._computedValueAxisList.push(v);
                        }
                        this._computedValueAxisList.sort(function (a, b) { return a.id.localeCompare(b.id); });
                    }
                    return changes;
                };
                Settings.prototype.applySeriesColor = function (series) {
                    var cci = 0;
                    var lci = 0;
                    var colCol = this.style.columnColors;
                    var lineCol = this.style.lineColors;
                    for (var sKey = 0; sKey < series.length; sKey++) {
                        var e = series[sKey];
                        if (e.type === "columns" && e.style.fillColor == null) {
                            e.style.fillColor = colCol[cci];
                            cci = (cci + 1) % colCol.length;
                        }
                        else if (e.type === "line" && e.style.lineColor == null) {
                            e.style.lineColor = lineCol[lci];
                            lci = (lci + 1) % lineCol.length;
                        }
                    }
                };
                return Settings;
            }(Internal.Base.Settings));
            LinearChart.Settings = Settings;
            var SettingsEvents = (function (_super) {
                __extends(SettingsEvents, _super);
                function SettingsEvents() {
                    _super.apply(this, arguments);
                    /** Function called when chart scrolling animation is finished. */
                    this.onAnimationDone = null;
                }
                return SettingsEvents;
            }(Internal.Base.SettingsEvents));
            LinearChart.SettingsEvents = SettingsEvents;
            var SettingsStack = (function () {
                function SettingsStack() {
                    /** The display name in info popup. */
                    this.name = "";
                    /** Different representation of stacked series values.
                    @type enum
                    @value normal - a regular stack, values of series are added up
                    @value proportional - absolute values shown as percentage of from sum of given stack
                    @value based - all series are aligned to zero line; note that the order of the series is important - larger values might hide smaller that come after them.
            
                    @version 1.14.4 - larger series values in `based` stacks now hide smaller values that come after them. */
                    this.type = "normal";
                    /** Whether to separate negative values.
            
                    The default is `false` for line series but `true` for other series types. */
                    this.separateNegativeValues = null;
                }
                return SettingsStack;
            }());
            LinearChart.SettingsStack = SettingsStack;
            var SettingsSeries = (function () {
                function SettingsSeries() {
                    this.id = null;
                    /** Enable/disable series. */
                    this.enabled = true;
                    /** Data manipulation settings used for default series. */
                    this.data = new SettingsSeriesData();
                    /** Series type.
                    @type enum
                     @value candlestick
                     @value columns
                     @value line */
                    this.type = "columns";
                    /** ID of value axis that this series will use.
                    Maps to a configuration specified in [valueAxis](full-reference/LinearChartSettings.html#doc_valueAxis) property. */
                    this.valueAxis = "default";
                    /** Name to show in the info popup. The same value is also used in the legend unless `nameLegend` is also set. */
                    this.name = null;
                    /** Name to show in the legend. If not specified, value from the `name` property is shown. */
                    this.nameLegend = null;
                    /** Whether to show the series name in legend and info popup. */
                    this.showInLegend = true;
                    /** Group ID for legend. Items in the same group have a different toggle behavior. When all the items in a group are enabled,
                        clicking an item causes that item to stay enabled and all other items are disabled. Clicking it again enables all items
                        again. Consequently, at least one item in each group is always enabled. The exception to this is if the group ID is null
                        (no group) or the group contains only one item. Then the item is toggled on/off individually.
                        @version 1.15.0
                     */
                    this.legendGroupId = null;
                    /** Stack identifier. Series with same stack ID are placed in the same stack. Define a stack with the same identifier to tune the stack. */
                    this.stack = null;
                    /** Cluster identifier. Columns with the same cluster id will be placed in same cluster. */
                    this.cluster = null;
                    /** Custom style based on series type. See the documentation of the derived classes for available properties. */
                    this.style = new SettingsSeriesStyle();
                }
                /** Used dynamically by SettingsHelper to determine the correct mapping based on the type. */
                SettingsSeries.getMapping = function (target, source) {
                    throw new Error("This method is abstract.");
                };
                SettingsSeries.createInstance = function (source, type) {
                    throw new Error("This method is abstract.");
                };
                return SettingsSeries;
            }());
            LinearChart.SettingsSeries = SettingsSeries;
            var SettingsSeriesStyle = (function () {
                function SettingsSeriesStyle() {
                    /** Fill color.
                    @type color */
                    this.fillColor = null;
                    this.lineColor = null;
                    /** Fill gradient. Allows building a gradient fill, bound to values. Contains array of value-color pairs.
                    For example: [[-20, 'rgba(0,0,255,0.4)'],[30,'rgba(255,0,0,0.7)']].*/
                    this.fillGradient = null;
                    /** Specifies the URL to the image that will be used as the repeated fill pattern for the series.
            
                    When `fillPattern` is specified, `fillGradient` is ignored. If `fillColor` is specified together with `fillPattern`, it will be
                    used as the background color for the pattern.
                    @version 1.16.0
                    */
                    this.fillPattern = null;
                    /** Currently only used by the legend to force some sort of disabled look on the pattern. */
                    this._fillPatternOpacity = 1;
                    /** The key by which the code determines if _currentFillStyle is up to date. */
                    this._currentFillStyleKey = null;
                    /** Array of line dash pattern to have a dashed line. The array contains length of dash followed by length of space in pixels.
                    A sequence of multiple dash-space values is supported. */
                    this.lineDash = null;
                    /** Width of the line.
                    @type float
                    @units pixels */
                    this.lineWidth = 1;
                    /** Shadow direction, x component.
                    @type integer */
                    this.shadowOffsetX = 1;
                    /** Shadow direction, y component.
                    @type integer */
                    this.shadowOffsetY = -1;
                    /** Shadow color of column. If undefined, no shadow will be applied. Leave empty to use default shadow or set your own shadow color.
                    @type color */
                    this.shadowColor = null;
                    /** Style settings for the legend item that is rendered for the series.
                    @version 1.13.1 */
                    this.legend = {
                        /** The color used for the label of the legend item. Note that for disabled series [`advanced.disabledSeries.textColor`][1] takes precedence.
            
                        [1]: time-chart/api-reference/settings/legend/advanced/disabledSeries/textColor.html
                        @type color
                        @version 1.13.1 */
                        textColor: null,
                        /** Configures the marker that is shown in the legend. Note that the default (`shape: null`) means that instead of the
                        plain marker, an icon representing the series visual style will be used.
                        @version 1.13.2 */
                        marker: {
                            shape: null
                        }
                    };
                    this.depth = 0;
                }
                return SettingsSeriesStyle;
            }());
            LinearChart.SettingsSeriesStyle = SettingsSeriesStyle;
            var SettingsSeriesData = (function () {
                function SettingsSeriesData() {
                    /** Data source to use if multiple data sources are available. */
                    this.source = "default";
                    /** Retrieves the individual value used for calculations from the data array. This is an alternative for specifying `index`.
                    @returns value to pass to aggregation */
                    this.valueFunction = null;
                    /** Aggregation function to use. Used when data source does not provide data in needed display unit.
                    Note that when `avg` is used, you should provide `countIndex` so that the calculation is correct even across multiple units.
                    @type enum
                    @value sum
                    @value min
                    @value max
                    @value first
                    @value last
                    @value avg
                    @value count - counts non-null values. If `countIndex` is specified, uses that number for each value, otherwise counts each value as 1. */
                    this.aggregation = "sum";
                    /** Prepare displaying value after data aggregation.
                    @param value - .
                    @param time - .
                    @param units - .
                    @returns the value to display. */
                    this.aggregatedValueFunction = null;
                    /** Method used to fill in time intervals that have no data. Used only for line series.
                    @type enum
                    @value join - links data points with straight line
                    @value skip - do not draw in this interval.
                    @value zero - draw as the value is zero. */
                    this.noDataPolicy = "join";
                }
                return SettingsSeriesData;
            }());
            LinearChart.SettingsSeriesData = SettingsSeriesData;
            var SettingsSeriesColumns = (function (_super) {
                __extends(SettingsSeriesColumns, _super);
                function SettingsSeriesColumns() {
                    _super.call(this);
                    /** Controls if and how the value labels for each column is displayed on the chart.
                    @version 1.11.0 */
                    this.valueLabels = {
                        enabled: false,
                        style: {
                            padding: 1,
                            margin: 0,
                            aspectRatio: 3,
                            align: "center",
                            textStyle: {
                                fillColor: "black",
                                font: "12px Arial"
                            },
                            backgroundStyle: {
                                lineColor: "rgba(255,255,255,0.4)",
                                fillColor: "rgba(255,255,255,0.4)"
                            }
                        },
                        position: "insideTopAuto",
                        minFontSize: 7,
                        contentsFunction: null,
                        useStackedValue: null
                    };
                    /** Default column style. */
                    this.style = new SettingsSeriesColumnsStyle();
                    this.type = "columns";
                }
                return SettingsSeriesColumns;
            }(SettingsSeries));
            LinearChart.SettingsSeriesColumns = SettingsSeriesColumns;
            var SettingsSeriesLines = (function (_super) {
                __extends(SettingsSeriesLines, _super);
                function SettingsSeriesLines() {
                    _super.call(this);
                    /** Controls if and how the value labels for each line is displayed on the chart.
                    @version 1.11.0 */
                    this.valueLabels = {
                        enabled: false,
                        style: {
                            padding: 2,
                            margin: 0,
                            aspectRatio: 3,
                            align: "center",
                            textStyle: {
                                fillColor: "black",
                                font: "12px Arial"
                            },
                            backgroundStyle: {
                                lineColor: "rgba(255,255,255,0.4)",
                                fillColor: "rgba(255,255,255,0.4)"
                            }
                        },
                        position: "value",
                        minFontSize: 7,
                        contentsFunction: null,
                        useStackedValue: null
                    };
                    /** Default style for line type series. */
                    this.style = new SettingsSeriesLinesStyle();
                    this.type = "line";
                }
                return SettingsSeriesLines;
            }(SettingsSeries));
            LinearChart.SettingsSeriesLines = SettingsSeriesLines;
            var SettingsSeriesCandleStick = (function (_super) {
                __extends(SettingsSeriesCandleStick, _super);
                function SettingsSeriesCandleStick() {
                    _super.call(this);
                    this.style = new SettingsSeriesCandleStickStyle();
                    /** Info popup localizeable strings */
                    this.localization = {
                        high: "high",
                        low: "low",
                        open: "open",
                        close: "close"
                    };
                    this.type = "candlestick";
                }
                return SettingsSeriesCandleStick;
            }(SettingsSeries));
            LinearChart.SettingsSeriesCandleStick = SettingsSeriesCandleStick;
            var SettingsSeriesColumnsStyle = (function (_super) {
                __extends(SettingsSeriesColumnsStyle, _super);
                function SettingsSeriesColumnsStyle() {
                    _super.apply(this, arguments);
                    /** Minimum height of a column in px.
                    @type integer */
                    this.minHeight = 4;
                    /** A linear gradient for color change along a line between the column bottom and upper side.
                    Specify "1" for no gradiend. Values 0..` will make the bottom part of columns slightly darker.
                    @type float*/
                    this.gradient = 0.8;
                    /** Outline color.
                    @type color */
                    this.lineColor = "";
                    /** Padding for column. 0th element - left padding, 1st element - right padding.
                    @baseType integer
                    @units pixels */
                    this.padding = [3, 3];
                    /** Shadow blur effect range.
                    @type integer */
                    this.shadowBlur = 3;
                    /** Depth for column. Use it to achieve 3D effect.
                    @type float
                    @units pixels */
                    this.depth = 0;
                    /** Brightness applied to depth components.
                    @type float */
                    this.depthBrightness = 0.5;
                }
                return SettingsSeriesColumnsStyle;
            }(SettingsSeriesStyle));
            LinearChart.SettingsSeriesColumnsStyle = SettingsSeriesColumnsStyle;
            var SettingsSeriesLinesStyle = (function (_super) {
                __extends(SettingsSeriesLinesStyle, _super);
                function SettingsSeriesLinesStyle() {
                    _super.apply(this, arguments);
                    /** Shadow blur radius.
                    @type integer */
                    this.shadowBlur = 5;
                    /** Whether to draw smoothed line. */
                    this.smoothing = false;
                    /** Whether to draw the line using horizontal segments instead of oblique. */
                    this.steps = false;
                    /** Marker highlight data points on line. They can be in different sizes, shapes and colors. */
                    this.marker = {
                        shape: null,
                        width: 10,
                        fillColor: null,
                        lineColor: null,
                        lineWidth: 1
                    };
                    /** Enables customizing the marker for each particular data point. The function receives an array of all horizontal indices that are being painted and
                    an array of vertical positions for each marker. Both arrays have the same length.
            
                    The output has to be an array of the same length where each entry represents a marker that will be drawn for that value. If the array contains a `null` value
                    that specific marker is not drawn.
            
                    Note that this method is not used when the marker is drawn for the legend entry.
            
                    This method will be invoked on each frame so it is important that it is optimized for performance.
                    @version 1.13.2 */
                    this.markerStyleFunction = null;
                }
                return SettingsSeriesLinesStyle;
            }(SettingsSeriesStyle));
            LinearChart.SettingsSeriesLinesStyle = SettingsSeriesLinesStyle;
            var SettingsSeriesCandleStickStyle = (function (_super) {
                __extends(SettingsSeriesCandleStickStyle, _super);
                function SettingsSeriesCandleStickStyle() {
                    _super.apply(this, arguments);
                    /** Candlestick item representation pattern where difference is wethter to show body part
                        @type enum
                        @value candlestick - item body part included.
                        @value bar - item body part excluded. */
                    this.pattern = "candlestick";
                    /** Item left and right padding
                        @baseType integer */
                    this.padding = [1, 1];
                    /** Item style when open is smaller than close */
                    this.increase = {
                        bar: {
                            lineColor: "green",
                            shadowColor: null,
                            lineDash: null,
                            lineWidth: 1,
                            shadowOffsetX: 1,
                            shadowOffsetY: -1,
                            shadowBlur: 0
                        },
                        candlestick: {
                            lineColor: "#000",
                            shadowColor: null,
                            lineDash: null,
                            lineWidth: 1,
                            shadowOffsetX: 1,
                            shadowOffsetY: -1,
                            shadowBlur: 0,
                            fillColor: "yellow"
                        }
                    };
                    /** Item style when open is higher than close */
                    this.decrease = {
                        bar: {
                            lineColor: "red",
                            shadowColor: null,
                            lineDash: null,
                            lineWidth: 1,
                            shadowOffsetX: 1,
                            shadowOffsetY: -1,
                            shadowBlur: 0
                        },
                        candlestick: {
                            lineColor: "#000",
                            shadowColor: null,
                            lineDash: null,
                            lineWidth: 1,
                            shadowOffsetX: 1,
                            shadowOffsetY: -1,
                            shadowBlur: 0,
                            fillColor: "black"
                        }
                    };
                }
                return SettingsSeriesCandleStickStyle;
            }(SettingsSeriesStyle));
            LinearChart.SettingsSeriesCandleStickStyle = SettingsSeriesCandleStickStyle;
            var SettingsInfoPopup = (function () {
                function SettingsInfoPopup() {
                    /** Show/hide info popup */
                    this.enabled = true;
                    /** Whether to show series with no data in hovered time period. */
                    this.showNoData = true;
                    /** Specifies the position of the info popup.
                    @see Example - [minimized TimeChart](time-chart/examples/gallery/time-chart-minimized.html)
                    @version 1.11.0
                    @type enum
                    @value inside - Displays the info popup inside the chart area right below the toolbars. This is the default behavior which is well suited for larger charts.
                    @value outside - Displays the info popup above the chart area. This mode is intended for very small charts where the info popup would overlap the whole chart.
                    */
                    this.position = "inside";
                    /** Prepare custom format values to display in info popup.
                    @see Example: [TimeChart info popup](time-chart/examples/info-popup/info-popup.html)
                    @returns HTML text to place as the value. */
                    this.valueFormatterFunction = null;
                    /** List of aggregations that will be shown in the info popup for each series. If none are specified, info popup displays the aggregation
                    that is specified in the series data configuration.
                    Available aggregations: sum (default), count, first, last, min, max, avg, change
                    @baseType enum
                    @value sum - Default aggregation.The sum of data values
                    @value count - The count of data values
                    @value first - The first one of data values
                    @value last - The last one of data values
                    @value min - The min of data values
                    @value max - The max of data values
                    @value avg - The average of data values
                    @value change - The difference between first and last */
                    this.aggregations = null;
                    /** Info popup style. */
                    this.style = {
                        /** Style used to highlight the values that are shown in the info popup. */
                        highlight: {
                            fillColor: "rgba(30,160,220,0.15)",
                            fadeIn: 200,
                            fadeOut: 200
                        }
                    };
                    /** Advanced settings relevant to info popup appearance. */
                    this.advanced = {
                        /** Create custom info contents to display in info popup.
                        @see Example: [TimeChart info popup](time-chart/examples/info-popup/contents-function.html)
                        @returns HTML code that will be displayed in the info popup instead of the default.
                        @version 1.16.0 - added support for `data-color` and `data-selected` attributes on the HTML elements*/
                        contentsFunction: null,
                        /** Whether to show only the series under cursor in info popup. If `scope` is set to `value` then the info popup will be empty unless the pointer
                         hovers over the value bar/line.*/
                        showOnlyHoveredSeries: false,
                        /** Controls how the selection for the info popup is created and what data is displayed.
                         @type enum
                         @value stack - all stacks for the minimum time period (for example, multiple columns for the same day) are selected when hovering.
                         @value value - only a single stack (for example, a column) is selected when hovering.
                         @value auto - acts as `stack` when hovering over the empty area but `value` if the bar/line is directly under the pointer. */
                        scope: null,
                        /** Specifies if the default header should be included. If set to `false`, the `contentsFunction` should be used to return the header as well. */
                        showHeader: true
                    };
                }
                return SettingsInfoPopup;
            }());
            LinearChart.SettingsInfoPopup = SettingsInfoPopup;
            var SettingsLocalization = (function (_super) {
                __extends(SettingsLocalization, _super);
                function SettingsLocalization() {
                    _super.apply(this, arguments);
                    /** Map from unit prefix to multiplier. Used for value axis formatting.
                    @baseType integer */
                    this.valueUnits = {
                        "K": 1e3,
                        "M": 1e6,
                        "B": 1e9,
                        "T": 1e12,
                        "P": 1e15
                    };
                    /** Text to show on the info popup when there is no data in the selected range. */
                    this.noDataLabel = "No data";
                    /** Default name for series shown in info popup and legend. Note that info popup will not use it if only a single series is being used. */
                    this.unnamedSeries = "Unnamed";
                    this.toolbar = new SettingsLocalizationToolbar();
                }
                return SettingsLocalization;
            }(Internal.Base.SettingsLocalization));
            LinearChart.SettingsLocalization = SettingsLocalization;
            var SettingsLocalizationToolbar = (function (_super) {
                __extends(SettingsLocalizationToolbar, _super);
                function SettingsLocalizationToolbar() {
                    _super.apply(this, arguments);
                    /** Linear mode button text. */
                    this.linButton = "Lin";
                    /** Logarithmic mode button text. */
                    this.logButton = "Log";
                    /** Lin/Log button title. */
                    this.linLogTitle = "Switch lin/log scale";
                }
                return SettingsLocalizationToolbar;
            }(Internal.Base.SettingsLocalizationToolbar));
            LinearChart.SettingsLocalizationToolbar = SettingsLocalizationToolbar;
            var SettingsInteraction = (function (_super) {
                __extends(SettingsInteraction, _super);
                function SettingsInteraction() {
                    _super.apply(this, arguments);
                    /** Sensitivity of Left/Right/Up/Down swipes. Note that `scrolling.swipePageFlipping` must be `true` for this to have any effect.
                    @type float
                    @min 0
                    @max 1 */
                    this.swipeSensitivity = 0.6;
                    /** Specifies if the bottom axis should be completely ignored for all interaction mouse and touch events.
                    @version 1.12.0 */
                    this.ignoreBottomAxis = false;
                    /** Configurable settings to manage scroll interaction. */
                    this.scrolling = new SettingsInteractionScrolling();
                    /** Configurable settings to enhance and alleviate zoom interaction. */
                    this.zooming = new SettingsInteractionZooming();
                }
                return SettingsInteraction;
            }(Internal.Base.SettingsInteraction));
            LinearChart.SettingsInteraction = SettingsInteraction;
            var SettingsInteractionZooming = (function () {
                function SettingsInteractionZooming() {
                    /** If set to `false`, all zoom gestures will be disabled, irrespective of how the other properties are configured.
                     Note that the user will still be able to zoom by drill-down (clicking on values) and by using toolbar. */
                    this.enabled = true;
                    /** Whether to zoom by mouse wheel. */
                    this.wheel = false;
                    /** Whether to zoom by swiping up or down. */
                    this.swipe = true;
                    /** Whether to zoom by two finger pinch. */
                    this.fingers = true;
                    // numberOf times to zoom in/out by fingers
                    /** Max zoom difference when using pinch gesture.
                    @type float */
                    this.fingersMaxZoom = 10;
                    /** Zooming sensitivity for swipe gestures. Bigger values correspond to faster zooming.
                    @type float
                    @version 1.13.0 - default value changed from `1` to `2`*/
                    this.sensitivity = 2;
                    /** Zooming sensitivity for mouse wheel. Bigger values correspond to faster zooming. Must be `>= 1.1`
                    @version 1.14.0 */
                    this.wheelSensitivity = 1.5;
                    /** Chart is zoomed in or out by this factor when pressing Up or Down keys.
                    @type float
                    @ignore */
                    this.keyboardFactor = 2;
                    /** How far pointer must be moved up or down in pixels before zooming activates.
                    @type float */
                    this.upDownTreshold = 10;
                    // rescaling amount to trigger zoom highlight display # ***
                    /** Zoomed area is highlighted if zoom is changed more number of times than this.
                    @type float */
                    this.zoomHighlightThreshold = 1.5;
                }
                return SettingsInteractionZooming;
            }());
            LinearChart.SettingsInteractionZooming = SettingsInteractionZooming;
            var SettingsInteractionScrolling = (function () {
                function SettingsInteractionScrolling() {
                    /** Enables/Disables scrolling. */
                    this.enabled = true;
                    /** Whether to use scrolling by full page instead of kinetic scrolling when using swipes (instead of dragging the chart). */
                    this.swipePageFlipping = true;
                    /** How far to scroll when Left or Right keys are pressed. Multiples of chart width.
                    @type float
                    @ignore */
                    this.keyboardScrollingFactor = 1;
                    // next property should be advanced
                    /** Scrolling friction coefficient (chartWidth/ms^2).
                    @type float */
                    this.kineticFriction = 1e-6;
                    /** The maximum time the scroll animation can run, in milliseconds. This does not apply when the user swipes the chart to start
                    the animation, for that use `kineticFriction` instead. This setting however applies when the visible range is changed by using the toolbar
                    or API methods.
            
                    Set to `null` to disable the limit.
                    @version 1.13.0
                    @type integer */
                    this.maxAnimationLength = 1500;
                }
                return SettingsInteractionScrolling;
            }());
            LinearChart.SettingsInteractionScrolling = SettingsInteractionScrolling;
            var SettingsArea = (function (_super) {
                __extends(SettingsArea, _super);
                function SettingsArea() {
                    _super.apply(this, arguments);
                    this.style = new SettingsAreaStyle();
                }
                return SettingsArea;
            }(Internal.Base.SettingsArea));
            LinearChart.SettingsArea = SettingsArea;
            var SettingsAreaStyle = (function (_super) {
                __extends(SettingsAreaStyle, _super);
                function SettingsAreaStyle() {
                    _super.apply(this, arguments);
                    /** Style settings when there is no data to display. */
                    this.noData = {
                        fillColor: "#888",
                        /** Image to show when there is no data to display.
                        @type url */
                        image: null
                    };
                    /** Zoom In/Zoom Out animation highlight settings. */
                    this.zoomHighlight = {
                        fillColor: "rgba(30,160,220,0.15)",
                        /** Fade in duration.
                        @type integer */
                        fadeIn: 100,
                        /** Fade in duration.
                        @type integer */
                        fadeOut: 500,
                    };
                    /** Zoom highlight style after zoom animation is finished. */
                    this.zoomHighlightInactive = {
                        fillColor: "rgba(30,160,220,0.08)"
                    };
                }
                return SettingsAreaStyle;
            }(Internal.Base.SettingsAreaStyle));
            LinearChart.SettingsAreaStyle = SettingsAreaStyle;
        })(LinearChart = Internal.LinearChart || (Internal.LinearChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Data.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var PieChart;
        (function (PieChart) {
            var SettingsData = (function (_super) {
                __extends(SettingsData, _super);
                function SettingsData() {
                    _super.apply(this, arguments);
                    /** Number of slices to request from server.
                    @type integer */
                    this.itemsToLoad = 50;
                    /** Enables/Disables partial load. Items will be loaded on demand but is not compatible with sortField or autoCategories. */
                    this.partialLoad = true;
                    /** An array of fields for auto-categorization. For each field a new drilldown sub-level will be created, separated by the values of that field. */
                    this.autoCategories = null;
                    /** If set, items will be sorted in descending order using values from this field. You can either specify a single field or an array
                    of fields.
            
                    To sort the values ascending, prefix the field name with `-`, for example, `-value` (without any spaces).
            
                    The default value `null` means that the chart does not reorder the data and it is displayed in the order it is given in the
                    data source.
            
                    The callback receives two data objects every iteration, return `0` for equal values, `1` if the first value should be before the other
                    and `-1` otherwise.
            
                    ```javascript
                    sortField: function (a, b) {
                        // handle null and undefined values as zeroes
                        var v1 = a.val || 0;
                        var v2 = b.val || 0;
                        if (v1 === v2) return 0;
                        if (v1 < v2) return 1;
                        return -1;
                    }
                    ```
            
                    @version 1.12.0 - added the ability to specify ascending sort order
                    @version 1.13.0 - added the ability to specify multiple fields in an array
                    @version 1.14.0 - added the ability to specify a custom sort delegate */
                    this.sortField = null;
                    /** Load more chart data. */
                    this.dataFunction = null;
                    this.preloaded = null;
                }
                return SettingsData;
            }(Internal.Base.SettingsData));
            PieChart.SettingsData = SettingsData;
            var builtinKeys = {
                "values": 1,
                "id": 1,
                "offset": 1,
                "limit": 1,
                "afterSum": 1,
                "beforeSum": 1,
                "subvalues": 1,
                "sum": 1,
                "extra": 1,
                "name": 1,
                "totalCount": 1,
                "total": 1,
                "valuesSum": 1,
                "done": 1,
                "afterFraction": 1,
                "beforeFraction": 1
            };
            /** A cache of raw data. This might contain only a subset of all potentially available values, with more values loaded on demand.
                The already loaded values will be a contiguous subset of all potentially available values.
            */
            var PieData = (function () {
                function PieData() {
                    this.name = null;
                    /** Array of already loaded values */
                    this.values = [];
                    /** Index in the list of all potentially available values, where the already loaded values start. */
                    this.offset = 0;
                    /** Count of all potentially available values. Only set after the end has been reached. */
                    this.totalCount = null;
                    /** Sum of all potentially available values. Not used for FacetChart */
                    this.total = 0;
                    /** Sum of already loaded values. Not used for FacetChart. */
                    this.valuesSum = 0;
                    /** Sum of not yet loaded values which come before the already loaded values. Not used for FacetChart. */
                    this.beforeSum = 0;
                    /** Sum of not yet loaded values which come after the already loaded values. Not used for FacetChart. */
                    this.afterSum = 0;
                    /** Whether the already loaded data includes the final slice. Note that it might still not include the first slice. */
                    this.done = false;
                    /** Additional data that was specified in the data object. */
                    this.extra = null;
                }
                return PieData;
            }());
            PieChart.PieData = PieData;
            var Data = (function (_super) {
                __extends(Data, _super);
                function Data(chart, dataSettings, isFacetChart) {
                    _super.call(this, chart, dataSettings);
                    this.pies = {};
                    this.pendingPies = {};
                    this.requestedPies = {};
                    this.nextId = 0;
                    this._isFacetChart = isFacetChart;
                }
                /** Exports the data from the values as a two-dimensional array. This array is used to export data as Excel or CSV. */
                Data.exportValues = function (pie) {
                    var headers = ["id", "name", "value"];
                    var columnMap = { id: 0, name: 1, value: 2 };
                    var columnCount = 3;
                    var values = pie.values;
                    var result = new Array(values.length + 1);
                    result[0] = headers;
                    for (var i = 0; i < values.length; i++) {
                        var v = values[i];
                        var row = new Array(columnCount);
                        result[i + 1] = row;
                        var keys = Object.keys(v);
                        for (var j = 0; j < keys.length; j++) {
                            var k = keys[j];
                            if (k.charAt(0) === "_" || k === "fraction")
                                continue;
                            var val = v[k];
                            if (Array.isArray(val)) {
                                val = val.length;
                            }
                            else if (Internal.Base.Helpers.isObjectOrArray(val)) {
                                continue;
                            }
                            var resIndex = columnMap[k];
                            if (resIndex === void 0) {
                                columnMap[k] = resIndex = columnCount++;
                                headers.push(k);
                            }
                            row[resIndex] = val;
                        }
                    }
                    return result;
                };
                Data.prototype.hasDataFunc = function () {
                    return !!this.dataSettings.dataFunction || !!this.dataSettings.url;
                };
                Data.prototype.applyPreloadedData = function () {
                    _super.prototype.applyPreloadedData.call(this);
                    if (!this.hasDataFunc()) {
                        // mark all done if no data function.
                        var keys = Object.keys(this.pies);
                        for (var i = 0; i < keys.length; i++) {
                            var pie = this.pies[keys[i]];
                            if (!pie.done) {
                                pie.done = true;
                                pie.afterSum = 0;
                                pie.totalCount = pie.offset + pie.values.length;
                            }
                        }
                        this.chart.scene.loading = false;
                    }
                };
                Data.prototype.getRootId = function () {
                    return this.settings.navigation.initialDrilldown && this.settings.navigation.initialDrilldown.length > 0 ?
                        this.settings.navigation.initialDrilldown[0] :
                        "";
                };
                Data.prototype.canExpand = function (id) {
                    if (Internal.Base.Helpers.hasProperty(this.pies, id))
                        return true;
                    // special case for preloaded data and autoCategories - if the data is not there, disable expansion
                    if (!this.hasDataFunc() || this.dataSettings.autoCategories)
                        return false;
                    if (id && id[0] !== Internal.Base.Helpers.SeparatorChar)
                        return true;
                    return false;
                };
                Data.prototype.getPieData = function (id) {
                    if (!Internal.Base.Helpers.hasProperty(this.pies, id)) {
                        return null;
                    }
                    var data = this.pies[id];
                    if (this.needPostprocessing()) {
                        data = this.filterAndSortData(data);
                    }
                    return data;
                };
                Data.prototype.requestMorePieData = function (id, count) {
                    if (count === void 0) { count = this.dataSettings.itemsToLoad; }
                    if (count == null)
                        count = this.dataSettings.itemsToLoad; // ported from CoffeeScript;
                    if (!Internal.Base.Helpers.hasProperty(this.pies, id) || this.pies[id].done)
                        return false;
                    this.requestPieData(id, this.pies[id].offset + this.pies[id].values.length, count);
                    return true;
                };
                Data.prototype.requestLessPieData = function (id, count) {
                    if (count === void 0) { count = this.dataSettings.itemsToLoad; }
                    if (!Internal.Base.Helpers.hasProperty(this.pies, id))
                        return false;
                    var pie = this.pies[id];
                    if (pie.offset === 0 && (pie.done || pie.values.length > 1))
                        return false;
                    this.requestPieData(id, Math.max(pie.offset - this.dataSettings.itemsToLoad, 0), count);
                    return true;
                };
                Data.prototype.requestPieData = function (pieId, offset, count) {
                    if (count === void 0) { count = this.dataSettings.itemsToLoad; }
                    if (this.dataSettings.autoCategories) {
                        if (Internal.Base.Helpers.hasProperties(this.pies)) {
                            throw new Error("Cannot request additional data when autoCategories is in use!");
                        }
                        else {
                            pieId = "";
                        }
                    }
                    if (pieId[0] === Internal.Base.Helpers.SeparatorChar) {
                        throw new Error("Invalid Id: " + pieId);
                    }
                    // offset is just a hint how many slices to request
                    // figure out the real range to request
                    if (Internal.Base.Helpers.hasProperty(this.pies, pieId)) {
                        var data = this.pies[pieId];
                        var start = data.offset;
                        var end = start + data.values.length;
                        if (offset < start) {
                            count = start - offset;
                        }
                        else if (offset + count > end) {
                            count = offset + count - end;
                            offset = end;
                        }
                        else {
                            // nothing to request
                            return;
                        }
                    }
                    else if (this.needPostprocessing() || !this.dataSettings.partialLoad || this.dataSettings.autoCategories) {
                        count = 2147483647;
                        offset = 0;
                    }
                    if (Internal.Base.Helpers.hasProperty(this.requestedPies, pieId)) {
                        return;
                    }
                    if (Internal.Base.Helpers.hasProperty(this.pendingPies, pieId)) {
                        // update a pending request
                        var request = this.pendingPies[pieId];
                        var newOffset = Math.min(request.offset, offset);
                        var newMax = Math.max(request.offset + request.limit, offset + count);
                        request.offset = newOffset;
                        request.limit = newMax - newOffset;
                    }
                    else if (this.dataFunc) {
                        this.pendingPies[pieId] = {
                            id: pieId,
                            offset: offset,
                            limit: count
                        };
                        this.scheduleRequests();
                    }
                };
                Data.prototype.autoCategorize = function (data, categoriesFields) {
                    if (categoriesFields.length === 0) {
                        return data;
                    }
                    // Perform a shallow clone of the root object so that the original is not modified and can be reused.
                    var newRoot = Internal.Base.Helpers.clone(data);
                    var collectedCategories = [newRoot];
                    for (var catFieldIndex = 0; catFieldIndex < categoriesFields.length; catFieldIndex++) {
                        var catField = categoriesFields[catFieldIndex];
                        var newCollectedCategories = [];
                        for (var baseCategoryIndex = 0; baseCategoryIndex < collectedCategories.length; baseCategoryIndex++) {
                            var baseCategory = collectedCategories[baseCategoryIndex];
                            var categoriesList = [];
                            var categories = {};
                            for (var vIndex = 0; vIndex < baseCategory.subvalues.length; vIndex++) {
                                var v = baseCategory.subvalues[vIndex];
                                var prop = void 0;
                                if (Internal.Base.Helpers.isFunction(catField)) {
                                    prop = catField(v);
                                }
                                else {
                                    prop = v[catField];
                                }
                                if (prop === void 0 || prop === null) {
                                    prop = "None";
                                }
                                else {
                                    prop = prop.toString();
                                }
                                var category = void 0;
                                if (Internal.Base.Helpers.hasProperty(categories, prop)) {
                                    category = categories[prop];
                                }
                                else {
                                    category = {
                                        id: baseCategory.id + Internal.Base.Helpers.SeparatorChar + prop,
                                        __id: baseCategory.id + Internal.Base.Helpers.SeparatorChar + prop,
                                        value: 0,
                                        subvalues: [],
                                        name: prop,
                                        __category: catField,
                                    };
                                    categories[prop] = category;
                                    categoriesList.push(category);
                                    newCollectedCategories.push(category);
                                }
                                category.subvalues.push(v);
                                // merge fields, only value for now
                                category.value += Internal.Base.Helpers.tryParseFloat(v.value, 0);
                            }
                            baseCategory.subvalues = categoriesList;
                        }
                        collectedCategories = newCollectedCategories;
                    }
                    return newRoot;
                };
                Data.prototype.valueSum = function (values) {
                    if (this._isFacetChart)
                        return 0;
                    var sum = 0;
                    for (var i = 0; i < values.length; i++)
                        sum += values[i].value;
                    return sum;
                };
                Data.prototype.addDataInt = function (id, values, offset, limit, afterValue, beforeValue, sum, dataObj, newIds) {
                    var pie;
                    // add values to pie
                    if (Internal.Base.Helpers.hasProperty(this.pies, id)) {
                        pie = this.pies[id];
                    }
                    else {
                        pie = this.pies[id] = new PieData();
                    }
                    var oldEnd = pie.offset + pie.values.length;
                    var newEnd = offset + values.length;
                    // On first load or if holes are found, discard old data.
                    if (pie.values.length === 0 || newEnd < pie.offset || oldEnd < offset) {
                        pie.offset = offset;
                        pie.done = limit > values.length;
                        pie.values = values.slice();
                        pie.valuesSum = this.valueSum(values);
                        pie.totalCount = pie.done ? pie.values.length + pie.offset : null;
                        pie.afterSum = pie.done ? 0 : afterValue;
                        pie.beforeSum = pie.offset === 0 ? 0 : beforeValue;
                        pie.total = pie.done && pie.offset === 0 ? pie.valuesSum : sum;
                    }
                    else {
                        var oldValuesBefore = null;
                        var oldValuesAfter = null;
                        var oldValuesBeforeSum = 0;
                        var oldValuesAfterSum = 0;
                        if (pie.offset < offset) {
                            if (offset === oldEnd) {
                                oldValuesBefore = pie.values;
                                oldValuesBeforeSum = pie.valuesSum;
                            }
                            else {
                                oldValuesBefore = pie.values.slice(0, offset - pie.offset);
                                oldValuesBeforeSum = this.valueSum(oldValuesBefore);
                            }
                        }
                        if (oldEnd > newEnd && values.length >= limit) {
                            if (pie.offset === newEnd) {
                                oldValuesAfter = pie.values;
                                oldValuesAfterSum = pie.valuesSum;
                            }
                            else {
                                oldValuesAfter = pie.values.slice(newEnd - pie.offset);
                                oldValuesAfterSum = this.valueSum(oldValuesAfter);
                            }
                        }
                        if (oldValuesAfter) {
                            pie.values = oldValuesBefore ? oldValuesBefore.concat(values, oldValuesAfter) : values.concat(oldValuesAfter);
                        }
                        else {
                            pie.values = oldValuesBefore ? oldValuesBefore.concat(values) : values.slice();
                        }
                        pie.offset = Math.min(pie.offset, offset);
                        pie.valuesSum = this.valueSum(values) + oldValuesBeforeSum + oldValuesAfterSum;
                        // mark done
                        if (values.length < limit) {
                            pie.done = true;
                        }
                        if (!oldValuesBefore)
                            pie.beforeSum = beforeValue;
                        if (!oldValuesAfter)
                            pie.afterSum = afterValue;
                        pie.total = sum;
                        if (pie.done)
                            pie.afterSum = 0;
                        if (pie.offset === 0)
                            pie.beforeSum = 0;
                        if (pie.done && pie.offset === 0)
                            pie.total = pie.valuesSum;
                    }
                    pie.extra = dataObj.extra;
                    pie.name = dataObj.name;
                    // copy custom fields
                    if (dataObj) {
                        for (var key in dataObj) {
                            // TODO: in v2 this assignment should be removed and instead only explicit fields should be set.
                            if (!Internal.Base.Helpers.hasProperty(builtinKeys, key))
                                pie[key] = dataObj[key];
                        }
                    }
                    // Add subvalues recursively.
                    for (var i = 0; i < values.length; i++) {
                        var v = values[i];
                        if (v.subvalues) {
                            newIds[v.__id] = true;
                            this.addDataInt(v.__id, v.subvalues, 0, Infinity, null, null, null, v, newIds);
                        }
                    }
                };
                Data.prototype.needPostprocessing = function () {
                    var filters = this.chart.settings.filters;
                    return !!filters.sliceFilter || !filters.allowZeroValues || !!this.dataSettings.sortField;
                };
                Data.prototype.filterAndSortData = function (pieData) {
                    var filters = this.chart.settings.filters;
                    var zero = filters.allowZeroValues;
                    var sliceFilter = filters.sliceFilter;
                    if (!zero || sliceFilter) {
                        var total = pieData.total || 0;
                        var values = [];
                        for (var sliceIndex = 0; sliceIndex < pieData.values.length; sliceIndex++) {
                            var slice = pieData.values[sliceIndex];
                            if ((!sliceFilter || filters.sliceFilter(slice)) && (zero || slice.value !== 0)) {
                                values.push(slice);
                            }
                            else {
                                total -= slice.value;
                            }
                        }
                        var newData = new PieData();
                        newData.values = values;
                        newData.done = pieData.done;
                        newData.beforeSum = pieData.beforeSum;
                        newData.afterSum = pieData.afterSum;
                        newData.total = pieData.total || null;
                        newData.totalCount = pieData.totalCount || null;
                        newData.extra = pieData.extra;
                        pieData = newData;
                    }
                    if (this.dataSettings.sortField) {
                        this.sortData(pieData);
                    }
                    return pieData;
                };
                Data.prototype.sortData = function (pieData) {
                    var f = this.dataSettings.sortField;
                    if (Internal.Base.Helpers.isFunction(f)) {
                        pieData.values.sort(f);
                        return;
                    }
                    var fnames;
                    if (!Array.isArray(f)) {
                        fnames = [f];
                    }
                    else {
                        fnames = f.slice();
                    }
                    var asc = new Array(fnames.length);
                    for (var i = 0; i < fnames.length; i++) {
                        var x = fnames[i];
                        if (x.charAt(0) === "-") {
                            fnames[i] = x.substr(1);
                            asc[i] = -1;
                        }
                        else {
                            asc[i] = 1;
                        }
                    }
                    var comparer = function (x, y) {
                        for (var i = 0; i < fnames.length; i++) {
                            var xv = x[fnames[i]];
                            var yv = y[fnames[i]];
                            var delta = void 0;
                            if (xv == null) {
                                delta = yv == null ? 0 : (yv < 0 ? -1 : 1);
                            }
                            else if (yv == null) {
                                delta = xv < 0 ? 1 : -1;
                            }
                            else {
                                delta = yv - xv;
                                if (isNaN(delta))
                                    delta = ("" + yv).localeCompare(xv);
                            }
                            if (delta !== 0) {
                                return asc[i] * delta;
                            }
                        }
                        return 0;
                    };
                    pieData.values.sort(comparer);
                };
                Data.prototype.buildRequest = function () {
                    // builds a new request or returns null
                    if (!Internal.Base.Helpers.hasProperties(this.pendingPies)) {
                        return null;
                    }
                    var removePropertyValueResult = Internal.Base.Helpers.removePropertyValue(this.pendingPies);
                    var id = removePropertyValueResult.key;
                    var request = removePropertyValueResult.value;
                    this.requestedPies[id] = request;
                    return request;
                };
                Data.prototype.dataFunc = function (request, success, fail) {
                    /* calls data loading, return true or data
                    TODO: refactor to have only addDataParams, check with geo chart if compatible */
                    var config = this.dataSettings;
                    if (config.dataFunction) {
                        config.dataFunction(request.id, request.limit, request.offset, success, fail);
                    }
                    else if (config.url) {
                        var params = [];
                        if (request.id) {
                            params.push(["id", request.id]);
                        }
                        params.push(["limit", request.limit.toString(10)]);
                        params.push(["offset", request.offset.toString(10)]);
                        Internal.Base.Data.doRequest(config.url, config, params, success, fail);
                    }
                    else {
                        fail({ error: "Chart configuration does not define data retrieval function" });
                    }
                };
                Data.prototype.verifySlices = function (values, seenIds) {
                    var allOK = true;
                    for (var i = 0; i < values.length; i++) {
                        var v = values[i];
                        var slicePrettyName = v.id ? " Slice id: `" + v.id + "`" : "";
                        if (!Internal.Base.Helpers.isObjectOrArray(v)) {
                            this.chart.error("Slices must be objects!");
                            allOK = false;
                            continue;
                        }
                        if (!this._isFacetChart) {
                            v.value = Internal.Base.Helpers.tryParseFloat(v.value, null);
                            if (v.value === null) {
                                this.chart.error("Slices must have a numeric `value` property!" + slicePrettyName);
                                allOK = false;
                            }
                            else if (v.value < 0) {
                                this.chart.error("Slice values cannot be negative." + slicePrettyName);
                                allOK = false;
                            }
                        }
                        if (Internal.Base.Helpers.hasProperty(v, "id")) {
                            v.__id = "" + v.id;
                            // check for duplicate IDs
                            if (Internal.Base.Helpers.hasProperty(seenIds, v.__id)) {
                                this.chart.error("Multiple slices with the same ID." + slicePrettyName);
                                allOK = false;
                            }
                            seenIds[v.__id] = true;
                        }
                        else {
                            v.__id = Internal.Base.Helpers.SeparatorChar + this.nextId;
                            this.nextId++;
                        }
                        if (Internal.Base.Helpers.hasProperty(v, "subvalues")) {
                            if (!Array.isArray(v.subvalues)) {
                                this.chart.error("Field `subvalues` is not an array!" + slicePrettyName);
                                allOK = false;
                            }
                            else if (!this.verifySlices(v.subvalues, seenIds)) {
                                allOK = false;
                            }
                        }
                    }
                    return allOK;
                };
                Data.prototype.verifyData = function (request, data) {
                    // Determine proper ID.
                    if (!Internal.Base.Helpers.hasProperty(data, "id"))
                        data.id = request ? request.id : this.getRootId();
                    if (request && data.id && data.id !== request.id) {
                        this.chart.error("Requested data for ID `" + request.id + "` but got data with ID `" + data.id + "`. Consider specifying `navigation.initialDrilldown`.");
                        return false; // Return immediately, because this makes all other validation useless.
                    }
                    delete this.requestedPies[data.id];
                    // Normalize properties
                    data.limit = Internal.Base.Helpers.tryParseInt(data.limit, Infinity);
                    data.offset = Internal.Base.Helpers.tryParseInt(data.offset, 0);
                    data.beforeSum = Internal.Base.Helpers.tryParseFloat(data.beforeSum, null);
                    data.afterSum = Internal.Base.Helpers.tryParseFloat(data.afterSum, null);
                    data.sum = Internal.Base.Helpers.tryParseFloat(data.sum, null);
                    // Validate and normalize mandatory properties - subvalues and value.
                    if (!Internal.Base.Helpers.hasProperty(data, "subvalues")) {
                        if (Internal.Base.Helpers.hasProperty(data, "values")) {
                            Internal.Base.Helpers.warn("Use of property `values` within PieChart data object is being deprecated. Please use `subvalues` instead.", null, true);
                            data.subvalues = data.values;
                        }
                        else {
                            this.chart.error("Field `subvalues` not set in root data object");
                            return false; // Return immediately, because this makes all other validation useless.
                        }
                    }
                    if (!Array.isArray(data.subvalues)) {
                        this.chart.error("Field `subvalues` is not an array!");
                        return false; // Return immediately, because this makes all other validation useless.
                    }
                    else if (!this.verifySlices(data.subvalues, {})) {
                        return false; // Return immediately, because this makes all other validation useless.
                    }
                    var allOk = true;
                    // Validate offset and limit.
                    if (data.offset < 0) {
                        this.chart.error("Data `offset` must be greater or equal to 0.");
                        allOk = false;
                    }
                    if (data.limit < 1) {
                        this.chart.error("Data `limit` must be greater than 0.");
                        allOk = false;
                    }
                    var isTailResponse = data.limit > data.subvalues.length;
                    var isPartialResponse = data.offset > 0 || data.limit <= data.subvalues.length;
                    var dataEnd = data.offset + data.subvalues.length;
                    // Overlap check - if there was a request, we need to see that the response at least made a reasonable effort of
                    // satisfying it. We fail if the returned data starts beyond the requested data, or ends before the requested data.
                    //
                    // One exception is that if it ends before the requested data, it might be that it's because there's no more data to
                    // return. Allow it through in this case and reset the cache. Without this exception, the chart will enter an infinite
                    // request loop, because data requests will fail, and navigation-replay will issue them anew.
                    if (request && (data.offset >= request.offset + request.limit || (request.offset >= dataEnd && !isTailResponse))) {
                        this.chart.error("Response and request do not overlap. Requested " + request.limit +
                            " items starting at " + request.offset + ". Received " + data.subvalues.length + " items starting at " + data.offset);
                        allOk = false;
                    }
                    // Check that appending is possible.
                    if (Internal.Base.Helpers.hasProperty(this.pies, data.id)) {
                        var pie = this.pies[data.id];
                        if (pie.values.length > 0) {
                            var oldEnd = pie.offset + pie.values.length;
                            if (oldEnd < data.offset || (dataEnd < pie.offset && !isTailResponse)) {
                                this.chart.error("Data cannot be merged - there is a gap between old data and new data! Old data spans slices from " +
                                    pie.offset + " to " + (oldEnd - 1) + "; new data spans slices from " +
                                    data.offset + " to " + (dataEnd - 1) + ".");
                                allOk = false;
                            }
                        }
                    }
                    // Check for autocategories and deny partial data for autoCategories.
                    if (isPartialResponse && this.dataSettings.autoCategories) {
                        this.chart.error("Cannot auto categorize partial data");
                        allOk = false;
                    }
                    // Sums need to be checked only for PieChart. And even then, only if it's a partial response.
                    if (!this._isFacetChart && isPartialResponse) {
                        var setCount = (data.beforeSum == null ? 0 : 1) + (data.afterSum == null ? 0 : 1) + (data.sum == null ? 0 : 1);
                        if (setCount < 2) {
                            this.chart.error("For partial loading, at least 2 of the following need to be set: beforeSum, afterSum, sum.");
                            allOk = false;
                        }
                        else {
                            data.__valuesSum = this.valueSum(data.subvalues);
                            if (data.beforeSum == null) {
                                data.beforeSum = data.sum - data.afterSum - data.__valuesSum;
                            }
                            else if (data.afterSum == null) {
                                data.afterSum = data.sum - data.beforeSum - data.__valuesSum;
                            }
                            else if (data.sum == null) {
                                data.sum = data.beforeSum + data.afterSum + data.__valuesSum;
                            }
                            if (data.sum !== data.beforeSum + data.afterSum + data.__valuesSum) {
                                this.chart.error("For partial loading, beforeSum + sum + afterSum must equal the sum of subvalues!");
                                allOk = false;
                            }
                            if (!this._isFacetChart) {
                                if (data.beforeSum < 0) {
                                    this.chart.error("beforeSum cannot be negative!");
                                    allOk = false;
                                }
                                if (data.afterSum < 0) {
                                    this.chart.error("afterSum cannot be negative!");
                                    allOk = false;
                                }
                                if (data.sum < 0) {
                                    this.chart.error("sum cannot be negative!");
                                    allOk = false;
                                }
                            }
                        }
                    }
                    return allOk;
                };
                Data.prototype.addVerifiedData = function (request, data) {
                    this.chart.scene.loading = this.hasPendingRequests();
                    // add data, return scene changes object
                    var id = data.id;
                    var newIds = {};
                    newIds[id] = true;
                    if (request) {
                        this.chart.log(("Data arrived, id=" + id + ", offset=" + request.offset + ", len=" + data.subvalues.length + " of " + (request.limit || "unset")));
                    }
                    else {
                        this.chart.log(("Data arrived, id=" + id + ", offset=" + data.offset + ", len=" + data.subvalues.length + " of " + (data.limit || "unset")));
                    }
                    if (this.dataSettings.autoCategories) {
                        data = this.autoCategorize(data, this.dataSettings.autoCategories);
                    }
                    this.addDataInt(id, data.subvalues, data.offset, data.limit, data.afterSum, data.beforeSum, data.sum, data, newIds);
                    return {
                        pieChartPieIds: newIds
                    };
                };
                Data.prototype.requestFailedPermanently = function (request) {
                    this.chart.scene.loading = this.hasPendingRequests();
                    if (request) {
                        var p = new PieData();
                        p.done = true;
                        this.pies[request.id] = p;
                        this.chart.error("Data request failed for pie with ID `" + request.id + "`.");
                        delete this.requestedPies[request.id];
                    }
                    else {
                        this.chart.error("Data request failed.");
                    }
                };
                return Data;
            }(Internal.Base.Data));
            PieChart.Data = Data;
        })(PieChart = Internal.PieChart || (Internal.PieChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Label.ts" />
/// <reference path="../base/Graphics.ts" />
/// <reference path="../base/core/ChartEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var FacetChart;
        (function (FacetChart) {
            var SettingsFacetAxis = (function () {
                function SettingsFacetAxis() {
                    /** Show/hide facet axis. */
                    this.enabled = true;
                    /** Height of the x axis.
                    @type float
                    @units pixels */
                    this.size = 40;
                    /** Default width of one item. Used to calculate initial view.
                    @type float
                    @units pixels */
                    this.defaultUnitWidth = 50;
                    /** Maximum width of one item.
                    @version 1.10.0
                    @type float
                    @units pixels */
                    this.maxUnitWidth = 400;
                    /** The width of a single unit that will trigger a zoom-out action when the user swipes up.
            
                    Note that the other trigger for zoomout is to swipe up until all the bars fit in half the width of the chart. In this case this unit width
                    might not have been reached.
                    @version 1.13.0
                    @type float
                    @units pixels */
                    this.zoomOutUnitWidth = 20;
                    /** Facet axis name settings. */
                    this.labels = {
                        enabled: true,
                        angle: 0,
                        lineSpacing: 0.2,
                        interLabelSpacing: 0.6,
                        textStyle: {
                            fillColor: "#000",
                            font: "12px Arial"
                        },
                        margin: 4,
                        padding: 0,
                        aspectRatio: 3,
                        allowOverflow: false
                    };
                    /** Configures the title for the facet axis.
            
                    Note that the title shares space with the facet axis labels. You might need to increase the value of `facetAxis.size`
                    property so that the labels are not hidden by the title.
                    @version 1.12.2 */
                    this.title = {
                        enabled: false,
                        aspectRatio: 0,
                        align: "center",
                        useFacetName: true,
                        textStyle: {
                            font: "13px Arial",
                            fillColor: "#000"
                        }
                    };
                }
                return SettingsFacetAxis;
            }());
            FacetChart.SettingsFacetAxis = SettingsFacetAxis;
            var FacetAxis = (function () {
                function FacetAxis(chart, facet) {
                    this.title = null;
                    this.titleHeight = null;
                    this.facet = facet;
                    this.chart = chart;
                    this.scene = this.chart.scene;
                    this.options = this.scene.settings.facetAxis;
                    this.currentItemWidth = 1;
                    this.currentItemHeight = 1;
                    this.panel = new Internal.Base.ChartPanel();
                    this.panel.side = "bottom";
                    this.createTitle();
                    // after value axis
                    this.panel.packingOrder = 100;
                }
                FacetAxis.prototype.getPanel = function () {
                    var config = this.options;
                    var panel = this.panel;
                    if (config.enabled && config.size > 0) {
                        panel.desiredHeight = config.size;
                        panel.visible = true;
                        this.scene.bottomAxisSize = config.size;
                    }
                    else {
                        panel.desiredHeight = 0;
                        panel.visible = false;
                        this.scene.bottomAxisSize = 0;
                    }
                    panel.enableClipping = !config.labels.allowOverflow;
                    return panel;
                };
                FacetAxis.prototype.createTitle = function () {
                    if (this.options.title.enabled) {
                        this.title = new Internal.Base.Label(this.options.title);
                    }
                    else {
                        this.title = null;
                        this.titleHeight = 0;
                    }
                };
                FacetAxis.prototype.updateTitle = function (g, labelRenderer) {
                    var title = this.title;
                    var config = this.options.title;
                    var facetName = this.facet.data ? this.facet.data.name : "";
                    var text = (config.useFacetName ? (facetName || config.text) : config.text) || "";
                    if (title) {
                        title.text = text;
                        labelRenderer.measure(g, title);
                        if (text) {
                            this.titleHeight = 2 * ((title.style.margin || 0) + title.hheight);
                        }
                        else {
                            this.titleHeight = 0;
                        }
                    }
                };
                FacetAxis.prototype.paintTitle = function (g, labelRenderer) {
                    var title = this.title;
                    if (!title)
                        return;
                    this.updateTitle(g, labelRenderer);
                    var titleHeight = this.titleHeight;
                    if (titleHeight) {
                        var xl = this.panel.left;
                        var xr = this.panel.right;
                        var y0 = this.scene.y0;
                        var height = this.scene.height;
                        var centerY = y0 + height + this.scene.bottomAxisSize - titleHeight / 2;
                        var centerX = void 0;
                        var align = title.style.align;
                        centerX = (xl + xr) / 2;
                        if (align === "left") {
                            centerX = xl + title.hwidth;
                        }
                        if (align === "right") {
                            centerX = xr - title.hwidth;
                        }
                        labelRenderer.paint(g, centerX, centerY, 1, title);
                    }
                };
                FacetAxis.prototype.paint = function (event, boundsLeft, boundsWidth, xes) {
                    var config = this.options.labels;
                    if (!(xes.length > 1 && this.panel.visible)) {
                        return;
                    }
                    if (!config.enabled || !this.chart.assetsLoaded)
                        return;
                    var g = event.context;
                    var labelRenderer = event.labelRenderer;
                    var itemWidth = xes[1] - xes[0];
                    var top = this.panel.top;
                    var mostRightPosition = xes[0];
                    // note that this also updates this.titleHeight
                    this.paintTitle(g, labelRenderer);
                    var itemHeight = this.panel.bottom - this.panel.top - this.titleHeight;
                    var rebuildLabels = false;
                    if (Math.abs(1 - this.currentItemWidth / itemWidth) > 0.01 || Math.abs(1 - this.currentItemHeight / itemHeight) > 0.01) {
                        this.currentItemWidth = itemWidth;
                        this.currentItemHeight = itemHeight;
                        rebuildLabels = true;
                    }
                    if (event.changes && event.changes.settings) {
                        rebuildLabels = true;
                    }
                    this.layout = new Internal.Base.LabelLayoutBase();
                    var items = this.facet.items;
                    var angle = (config.angle || 0) * Math.PI / 180;
                    var sina = Math.abs(Math.sin(angle));
                    this.panel.pushClip(event);
                    for (var i = 0; i < items.length; i++) {
                        var x0 = xes[i];
                        if (mostRightPosition > x0)
                            continue;
                        var item = items[i];
                        var label = item.currentLabel;
                        var text = this.htmlDecodeLabel(item.label || item.data.name || config.text, this.layout, g);
                        item.currentLabel = null;
                        if (text) {
                            if (item.currentLabel === null || rebuildLabels || item.currentLabel.text !== text) {
                                label = this.buildLabel(g, text, itemWidth, itemHeight);
                                item.currentLabel = label;
                            }
                            // omit rotated labels that overlaps
                            var longest = Math.max.apply(Math, label.rows.rowWidths);
                            mostRightPosition = x0 + label.x + (longest / 2);
                            if (angle !== 0) {
                                var j = 1;
                                var height = sina * (xes[i + 1] - xes[i]); // distance between strait lines
                                while (height < label.lineHeight + (config.margin || 0) + (config.padding || 0)) {
                                    j++;
                                    height = sina * (xes[i + j] - xes[i]);
                                }
                                mostRightPosition = xes[i + j];
                                if (xes[i + j] === void 0)
                                    mostRightPosition = Infinity;
                            }
                            labelRenderer.paint(g, x0 + label.x, top + label.y, 1, label);
                        }
                    }
                    this.panel.popClip(event);
                };
                FacetAxis.prototype.htmlDecodeLabel = function (text, labelLayout, g) {
                    if (text == null || text.length === 0)
                        return "";
                    var parts = labelLayout.styleTagParser2(g, text, {});
                    var result = "";
                    var bri = 0;
                    var words = parts.words;
                    for (var i = 0; i < words.length; i++) {
                        var p = words[i];
                        result += p.word;
                        if (i === words.length - 1)
                            break;
                        if (parts.breaks[bri] === i + 1) {
                            result += " ";
                            bri++;
                        }
                        else if (p.spaceWidth) {
                            result += " ";
                        }
                    }
                    return result;
                };
                FacetAxis.prototype.buildLabel = function (g, text, availableWidth, availableHeight) {
                    var label = new Internal.Base.Label(this.options.labels);
                    var textStyle = label.style;
                    label.text = text;
                    // handles oblique label placing
                    var angle = (textStyle.angle || 0) * Math.PI / 180;
                    var align = textStyle.align;
                    if (!align) {
                        if (angle > 0) {
                            align = "left";
                        }
                        else if (angle < 0) {
                            align = "right";
                        }
                        else {
                            align = "center";
                        }
                        textStyle.align = align;
                    }
                    var locationFromHeight = function (halfHeight, itemWidth, maxHeight) {
                        var middleX;
                        var width;
                        var sina = 0;
                        var cosa = 1;
                        if (angle !== 0) {
                            sina = Math.sin(angle);
                            cosa = Math.cos(angle);
                            width = maxHeight / Math.abs(sina);
                            middleX = availableWidth / 2;
                        }
                        else {
                            // horizontal - use full width
                            middleX = itemWidth / 2;
                            if (halfHeight * 2 <= availableHeight) {
                                width = itemWidth;
                            }
                            else {
                                // if a single line height does not fit, hide it.
                                width = 0;
                            }
                        }
                        // compute x and y
                        var centerX;
                        var centerY;
                        if (angle > 0) {
                            // right end down - align to the left
                            centerX = middleX + width / 2 * cosa - halfHeight * 2 * cosa;
                            centerY = itemWidth / 2 * sina;
                        }
                        else if (angle < 0) {
                            // left end down - align to the right
                            centerX = middleX - width / 2 * cosa + halfHeight * 2 * cosa;
                            centerY = -itemWidth / 2 * sina;
                        }
                        else {
                            // align center
                            centerX = middleX;
                            centerY = halfHeight;
                        }
                        return {
                            x: centerX,
                            y: centerY,
                            dx: cosa,
                            dy: sina,
                            width: width
                        };
                    };
                    this.layout.getFormatedText(g, label, availableWidth, availableHeight, locationFromHeight);
                    return label;
                };
                return FacetAxis;
            }());
            FacetChart.FacetAxis = FacetAxis;
        })(FacetChart = Internal.FacetChart || (Internal.FacetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/core/ChartEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var FacetChart;
        (function (FacetChart) {
            var SettingsInteractionSelection = (function () {
                function SettingsInteractionSelection() {
                    /** Enable/disable selection */
                    this.enabled = true;
                    this.tolerance = 4;
                }
                return SettingsInteractionSelection;
            }());
            FacetChart.SettingsInteractionSelection = SettingsInteractionSelection;
            var Selection = (function (_super) {
                __extends(Selection, _super);
                function Selection(chart) {
                    _super.call(this);
                    this.animationOrder = 2000;
                    this.paintOrder = 15;
                    this.updateOrder = 1000;
                    this.scene = null;
                    this.events = null;
                    this.currentItem = null;
                    this.currentFacet = null;
                    this.hoverEvent = null;
                    this.chart = chart;
                    this.scene = chart.scene;
                    this.events = chart.events;
                }
                Selection.prototype.doAnimations = function (event) {
                    // update hover
                    if (this.hoverEvent) {
                        this.onPointerMove(this.hoverEvent);
                    }
                };
                Selection.prototype.previewPointerDrag = function (event) {
                    this.hoverEvent = event;
                };
                Selection.prototype.onPointerMove = function (event) {
                    var chart = this.chart;
                    var scene = chart.scene;
                    this.hoverEvent = event;
                    var item = scene.findItemAt(event.x, event.y);
                    if (item) {
                        event.cursor = "pointer";
                    }
                    var hoverItem = chart.renderer.hitTest(event.x, event.y);
                    if (chart.legend) {
                        if (hoverItem) {
                            chart.legend.notifyHoveredSeries(scene.settings._computedSeries[hoverItem.seriesIndex]);
                        }
                        else {
                            chart.legend.notifyHoveredSeries(null);
                            var series = chart.legend.getLastHoveredSeries();
                            if (series) {
                                hoverItem = {
                                    x0: null,
                                    y0: null,
                                    x1: null,
                                    y1: null,
                                    isMarker: false,
                                    seriesIndex: scene.settings._computedSeries.indexOf(series)
                                };
                            }
                        }
                    }
                    if ((!hoverItem !== !scene.hoverSeriesItem)
                        || (hoverItem && (hoverItem.seriesIndex !== scene.hoverSeriesItem.seriesIndex || hoverItem.x0 !== scene.hoverSeriesItem.x0))) {
                        scene.hoverSeriesItem = hoverItem;
                        event.changes.hover = true;
                    }
                    this.switchCurrentItem(item, event);
                };
                Selection.prototype.onPointerOut = function (event) {
                    this.hoverEvent = this.scene.hoverSeriesItem = null;
                    this.events.notifySceneChanges({ selection: true });
                    this.switchCurrentItem(null, event);
                };
                Selection.prototype.onClick = function (event) {
                    var n = this.scene.findItemAt(event.x, event.y);
                    var args = this.chart.createEventArguments(event, "user", n);
                    event.consumed = true;
                    if (n) {
                        event.cursor = "pointer";
                    }
                    this.chart.notifyClick(event, args);
                    if (!event.defaultPrevented) {
                        this.updateSelection(event, n, false);
                    }
                };
                Selection.prototype.onRightClick = function (event) {
                    var n = this.scene.findItemAt(event.x, event.y);
                    var args = this.chart.createEventArguments(event, "user", n);
                    this.chart.notifyRightClick(event, args);
                    if (n) {
                        event.cursor = "pointer";
                    }
                    if (event.defaultPrevented) {
                        event.consumed = true;
                    }
                };
                Selection.prototype.onDoubleClick = function (event) {
                    var n = this.scene.findItemAt(event.x, event.y);
                    var args = this.chart.createEventArguments(event, "user", n);
                    if (n) {
                        event.cursor = "pointer";
                    }
                    this.chart.notifyDoubleClick(event, args);
                    event.consumed = true;
                };
                Selection.prototype.onTripleClick = function (event) {
                    var n = this.scene.findItemAt(event.x, event.y);
                    var args = this.chart.createEventArguments(event, "user", n);
                    if (n) {
                        event.cursor = "pointer";
                    }
                    this.chart.notifyTripleClick(event, args);
                    event.consumed = true;
                };
                Selection.prototype.updateSelection = function (event, target, softDeselect) {
                    if (!this.scene.settings.interaction.selection.enabled) {
                        return;
                    }
                    if (!event.shiftKey && (!target || target.selected)) {
                        this.setSelection([]);
                    }
                    else if (target && event.shiftKey || (softDeselect && target.selected)) {
                        if (!target.selected) {
                            this.scene.selection.push(target);
                            target.selected = true;
                            this.setSelection(this.scene.selection, this.scene.selectionIds, true);
                        }
                    }
                    else if (target) {
                        this.setSelection([target]);
                    }
                };
                Selection.prototype.switchCurrentItem = function (obj, event) {
                    if (obj === this.currentItem) {
                        return;
                    }
                    var args = this.chart.createEventArguments(event, "user");
                    event.changes.current = true;
                    if (this.scene.hoverItem) {
                        this.scene.hoverItem.active = false;
                    }
                    this.scene.hoverItem = obj;
                    this.currentItem = obj;
                    this.currentFacet = null;
                    if (this.currentItem) {
                        this.scene.hoverItem.active = true;
                        args.hoverItem = this.currentItem;
                    }
                    this.events.notifySceneChanges({ items: true });
                    this.chart.notifyHoverChanged(event, args);
                };
                Selection.prototype.onSceneChange = function (event) {
                    if (event.changes.items) {
                        if (this.updateSelectionIds()) {
                            this.events.notifySceneChanges({ selection: true });
                            // TODO: previous code: @chart.notifySelectionChanged(origin). Need to determine what really should go here.
                            this.chart.notifySelectionChanged(null);
                        }
                    }
                };
                Selection.prototype.updateSelectionIds = function () {
                    /* process selectionIds
                    add to selected if seen on the main facet */
                    var itemsToSelect = [];
                    for (var idIndex = 0; idIndex < this.scene.selectionIds.length; idIndex++) {
                        var id = this.scene.selectionIds[idIndex];
                        for (var facetIndex = 0; facetIndex < this.scene.stack.length; facetIndex++) {
                            var facet = this.scene.stack[facetIndex];
                            for (var itemIndex = 0; itemIndex < facet.items.length; itemIndex++) {
                                var item = facet.items[itemIndex];
                                if (item.id === id) {
                                    itemsToSelect.push(item);
                                    break;
                                }
                            }
                        }
                    }
                    if (itemsToSelect.length > 0) {
                        for (var item2Index = 0; item2Index < itemsToSelect.length; item2Index++) {
                            var item2 = itemsToSelect[item2Index];
                            if (!item2.selected) {
                                item2.selected = true;
                                this.scene.selection.push(item2);
                            }
                            Internal.Base.Helpers.removeFromArray(this.scene.selectionIds, item2.id);
                        }
                    }
                    return itemsToSelect.length > 0;
                };
                Selection.prototype.setSelection = function (selection, selectionIds, alreadyChanged, origin) {
                    if (selectionIds === void 0) { selectionIds = []; }
                    if (alreadyChanged === void 0) { alreadyChanged = false; }
                    if (origin === void 0) { origin = "user"; }
                    this.scene.selectionIds = selectionIds;
                    var hasChanges = false;
                    if (alreadyChanged) {
                        hasChanges = true;
                    }
                    else {
                        for (var sIndex = 0; sIndex < this.scene.selection.length; sIndex++) {
                            var s = this.scene.selection[sIndex];
                            if (selection.indexOf(s) < 0) {
                                s.selected = false;
                                hasChanges = true;
                            }
                        }
                        for (var sIndex = 0; sIndex < selection.length; sIndex++) {
                            var s = selection[sIndex];
                            if (!s.selected) {
                                s.selected = true;
                                hasChanges = true;
                            }
                        }
                        this.scene.selection = selection;
                    }
                    var changedIds = this.updateSelectionIds();
                    hasChanges = hasChanges || changedIds;
                    if (hasChanges) {
                        this.events.notifySceneChanges({ selection: true });
                        this.chart.notifySelectionChanged(this.chart.createEventArguments(null, origin));
                    }
                };
                return Selection;
            }(Internal.Base.ChartElement));
            FacetChart.Selection = Selection;
        })(FacetChart = Internal.FacetChart || (Internal.FacetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/core/ChartEvents.ts" />
/// <reference path="../base/InfoPopup.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var LinearChart;
        (function (LinearChart) {
            var InfoPopup = (function (_super) {
                __extends(InfoPopup, _super);
                function InfoPopup(chart) {
                    _super.call(this);
                    /** animate before TimeMarkers */
                    this.animationOrder = 10;
                    this.t0 = 0;
                    this.t1 = 0;
                    /** the index of the last selected series */
                    this.object = null;
                    this.activePointer = null;
                    this.pointerX = 0;
                    this.pointerY = 0;
                    this.chart = chart;
                    this.container = chart.shell.interactiveContainer;
                    this.scene = chart.scene;
                    this.events = chart.events;
                    this.popup = new Internal.Base.InfoPopup(this.chart);
                    this.settings = chart.scene.settings.info;
                }
                /** ---
                Methods to override
                ---
                called when about to show popup
                Returns [t0, t1, ] or null if no info popup */
                InfoPopup.prototype.getPopupAreaMouseMoved = function (x, y) { return null; };
                InfoPopup.prototype.buildHeader = function (t0, t1) { return ""; };
                InfoPopup.prototype.show = function (event) {
                    if (!this.settings.enabled) {
                        return;
                    }
                    this.pointerX = event.x;
                    this.pointerY = event.y;
                    this.updatePopup(event);
                };
                InfoPopup.prototype.previewPointerMove = function (event) {
                    if (!(this.settings.enabled && (this.activePointer === null || this.activePointer === event.identifier))) {
                        return;
                    }
                    this.pointerX = event.x;
                    this.pointerY = event.y;
                    this.updatePopup(event);
                };
                InfoPopup.prototype.previewPointerDrag = function (event) {
                    if (!(this.settings.enabled && (this.activePointer === null || this.activePointer === event.identifier))) {
                        return;
                    }
                    this.activePointer = event.identifier;
                    this.pointerX = event.x;
                    this.pointerY = event.y;
                };
                InfoPopup.prototype.previewPointerCancel = function (event) {
                    if (this.activePointer !== null && this.activePointer === event.identifier) {
                        this.activePointer = null;
                    }
                };
                InfoPopup.prototype.previewPointerUp = function (event) {
                    if (this.activePointer !== null && this.activePointer === event.identifier) {
                        this.activePointer = null;
                    }
                };
                InfoPopup.prototype.previewPointerOut = function (event) {
                    if (!this.settings.enabled || (this.activePointer !== null && this.activePointer !== event.identifier) || event.touch) {
                        return;
                    }
                    this.activePointer = null;
                    this.pointerX = null;
                    this.pointerY = null;
                    if (!Internal.Base.Helpers.isParentOf(this.popup.popup, event.target)) {
                        this.hideInfoPopup(event);
                    }
                };
                InfoPopup.prototype.previewRightClick = function (event) {
                    if (this.settings.enabled && event.touch) {
                        this.activePointer = event.identifier;
                        this.previewPointerMove(event);
                    }
                };
                InfoPopup.prototype.previewPointerDown = function (event) {
                    if (!this.settings.enabled || this.activePointer !== null) {
                        return;
                    }
                    this.activePointer = event.identifier;
                    this.hideInfoPopup(event);
                };
                InfoPopup.prototype.updatePopup = function (event) {
                    if (!this.pointerX && !this.pointerY) {
                        this.hideInfoPopup(event);
                        return;
                    }
                    var g = this.getPopupMouseMoved(this.pointerX, this.pointerY, this.t0, this.t1, this.object, this.contents);
                    if (g) {
                        this.showInfoPopup(g.t0, g.t1, g.obj, g.contents, event);
                    }
                    else {
                        this.hideInfoPopup(event);
                    }
                };
                InfoPopup.prototype.manualShowInfoPopup = function (t0, t1, contents) {
                    this.showInfoPopup(t0, t1, null, contents || this.buildContent(t0, t1, null, null), null);
                };
                InfoPopup.prototype.showInfoPopup = function (t0, t1, object, contents, event) {
                    if (this.popup.visible && t0 === this.t0 && t1 === this.t1 && object === this.object && this.contents === contents) {
                        return;
                    }
                    var scene = this.scene;
                    var conf = this.settings;
                    this.t0 = t0;
                    this.t1 = t1;
                    this.object = object;
                    this.contents = contents;
                    scene.setHighlight("infoRange", t0, t1, conf.style.highlight);
                    this.popup.show(scene.timeToX(this.t0), scene.timeToX(this.t1), scene.y0, contents, Internal.Base.InfoPopupPosition[conf.position]);
                    this.notifyChanges(event);
                };
                InfoPopup.prototype.notifyChanges = function (event) {
                    if (event) {
                        event.changes.infoLabel = true;
                        event.changes.highlight = true;
                    }
                    else {
                        this.events.notifySceneChanges({ infoLabel: true, highlight: true });
                    }
                };
                InfoPopup.prototype.hideInfoPopup = function (event) {
                    if (!this.popup.visible) {
                        return;
                    }
                    this.popup.hide();
                    this.t0 = 0;
                    this.t1 = 0;
                    this.scene.removeHighlight("infoRange");
                    this.notifyChanges(event);
                };
                InfoPopup.prototype.paintScene = function (event) {
                    if (this.popup.visible) {
                        this.updateXY();
                    }
                };
                InfoPopup.prototype.updateXY = function () {
                    var scene = this.scene;
                    this.popup.updateXY(scene.timeToX(this.t0), scene.timeToX(this.t1), scene.y0, Internal.Base.InfoPopupPosition[scene.settings.info.position]);
                };
                /** called when about to show popup
                Returns [t0, t1, htmlContents] or null if no info popup */
                InfoPopup.prototype.getPopupMouseMoved = function (x, y, prevT0, prevT1, prevObj, prevContents) {
                    if (this.scene.displayUnit && !this.scene.xyInChartOrBottom(x, y)) {
                        return null;
                    }
                    var popupAreaMouseMoved = this.getPopupAreaMouseMoved(x, y);
                    if (!popupAreaMouseMoved) {
                        return null;
                    }
                    var t0 = popupAreaMouseMoved.t0;
                    var t1 = popupAreaMouseMoved.t1;
                    var stack = null;
                    var seriesInd = null;
                    var seriesObj = this.scene.hoverSeriesItem;
                    var scope = this.settings.advanced.scope;
                    var scopeT0 = t0;
                    var scopeT1 = t1;
                    if (seriesObj) {
                        seriesInd = seriesObj.seriesIndex;
                        if ((scope === "stack" || scope === "value") || (scope === "auto" && (seriesInd !== void 0 && seriesInd !== null))) {
                            scopeT0 = this.scene.xToTime(seriesObj.x0);
                            scopeT1 = this.scene.xToTime(seriesObj.x1);
                        }
                        stack = seriesObj.stack;
                    }
                    if (scopeT0 === null) {
                        return null;
                    }
                    if (scopeT0 === prevT0 && scopeT1 === prevT1 && seriesInd === prevObj) {
                        return {
                            t0: prevT0,
                            t1: prevT1,
                            obj: prevObj,
                            contents: prevContents
                        };
                    }
                    var content = this.buildContent(t0, t1, seriesInd, stack);
                    return {
                        t0: scopeT0,
                        t1: scopeT1,
                        obj: seriesInd,
                        contents: content
                    };
                };
                InfoPopup.prototype.getContentsFunctionRange = function (t0, t1) {
                    return [t0, t1];
                };
                InfoPopup.prototype.buildContent = function (t0, t1, activeSeriesInd, activeStack) {
                    var settings = this.settings.advanced;
                    // value
                    var info = this.chart.renderer.exportData(t0, t1);
                    var valueHtml;
                    if (settings.contentsFunction) {
                        var seriesObj = null;
                        if (activeSeriesInd !== null && this.scene.settings._computedSeries.length > activeSeriesInd) {
                            seriesObj = this.scene.settings._computedSeries[activeSeriesInd];
                        }
                        valueHtml = settings.contentsFunction.call(this.chart.api, info, seriesObj, this.getContentsFunctionRange(t0, t1));
                    }
                    else {
                        valueHtml = this.buildValues(info, activeSeriesInd, activeStack);
                    }
                    if (!settings.showHeader)
                        return valueHtml;
                    var header = this.buildHeader(t0, t1);
                    return header + valueHtml;
                };
                InfoPopup.prototype.buildValues = function (info, selectedSeriesIndex, selectedStack) {
                    // this method will build actual list, based on the info aggregated from the series
                    var config = this.chart.settings;
                    var noDataStr = config.localization.noDataLabel;
                    var valueFormattingFunction = config.info.valueFormatterFunction;
                    var scope = config.info.advanced.showOnlyHoveredSeries ? config.info.advanced.scope : null;
                    var stackOnly = (selectedStack && (scope === "stack" || scope === "value"))
                        || (scope === "auto" && selectedSeriesIndex !== void 0 && selectedSeriesIndex !== null);
                    var hoveredOnly = scope === "value";
                    var out = "";
                    var tableOpened = false;
                    // the data object contains a list of all stacks defined in the configuration.
                    // if no stacks are used, it will contain a separate stack for each series.
                    for (var groupIndex = 0; groupIndex < info.length; groupIndex++) {
                        var group = info[groupIndex];
                        if (stackOnly) {
                            var hasHovered = false;
                            for (var seriesIndex = 0; seriesIndex < group.data.length; seriesIndex++) {
                                var series = group.data[seriesIndex];
                                if (!series.config.showInLegend || (!series.values && !config.info.showNoData)) {
                                    continue;
                                }
                                hasHovered = hasHovered
                                    || (selectedSeriesIndex !== null && series.config === config._computedSeries[selectedSeriesIndex])
                                    || selectedStack === group.stack;
                            }
                            if (!hasHovered) {
                                continue;
                            }
                        }
                        // 1. add series "header" if more than one series in group
                        var defaultName = (info.length + group.data.length === 2) ? "" : config.localization.unnamedSeries;
                        if (group.name) {
                            if (tableOpened) {
                                out += "</table>";
                                tableOpened = false;
                            }
                            if (group.data.length > 1) {
                                out += "<h3>" + group.name + "</h3>";
                            }
                            else {
                                defaultName = group.name;
                            }
                        }
                        if (!tableOpened) {
                            out += "<table cellspacing=\"0\">";
                            tableOpened = true;
                        }
                        for (var seriesIndex = 0; seriesIndex < group.data.length; seriesIndex++) {
                            var series = group.data[seriesIndex];
                            var selected = selectedSeriesIndex !== null && series.config === this.scene.settings._computedSeries[selectedSeriesIndex];
                            if (!series.config.showInLegend || (!series.values && !config.info.showNoData)) {
                                continue;
                            }
                            if (hoveredOnly && !selected) {
                                continue;
                            }
                            out += "<tr><td";
                            // format the series name
                            var color = void 0;
                            var colorAlt = void 0;
                            var seriesConfig = series.config;
                            if (config instanceof LinearChart.SettingsSeriesColumns) {
                                color = seriesConfig.style.fillColor;
                                colorAlt = seriesConfig.style.lineColor;
                            }
                            else {
                                color = seriesConfig.style.lineColor;
                                colorAlt = seriesConfig.style.fillColor;
                            }
                            if (!color || color === "transparent")
                                color = colorAlt;
                            // not using inline style since those will not work if the page uses Content-Security-Policy
                            if (color)
                                out += " data-color=\"" + color + "\"";
                            if (selected)
                                out += " data-selected";
                            out += ">";
                            out += series.name || defaultName;
                            out += "</td><td>";
                            // format the value
                            if (valueFormattingFunction) {
                                out += valueFormattingFunction.call(this.chart.api, series.values, series.config);
                            }
                            else if (!series.values) {
                                out += noDataStr;
                            }
                            else if (series.values.count > 1 && config.info.aggregations && config.info.aggregations.length > 0) {
                                for (var paramIndex = 0; paramIndex < config.info.aggregations.length; paramIndex++) {
                                    var param = config.info.aggregations[paramIndex];
                                    out += "" + Internal.Base.Helpers.numberFormat(series.values[param]) + ("&nbsp;(" + param + ")");
                                }
                            }
                            else if (seriesConfig.data.aggregation) {
                                out += Internal.Base.Helpers.numberFormat(series.values[seriesConfig.data.aggregation]);
                            }
                            else {
                                out += Internal.Base.Helpers.numberFormat(series.values.sum);
                            }
                            out += "</td></tr>";
                        }
                    }
                    if (tableOpened)
                        out += "</table>";
                    return out;
                };
                return InfoPopup;
            }(Internal.Base.ChartElement));
            LinearChart.InfoPopup = InfoPopup;
        })(LinearChart = Internal.LinearChart || (Internal.LinearChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../linearchart/InfoPopup.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var FacetChart;
        (function (FacetChart) {
            var InfoPopup = (function (_super) {
                __extends(InfoPopup, _super);
                function InfoPopup(chart) {
                    _super.call(this, chart);
                    this.animationOrder = 500;
                    this.paintOrder = 25;
                    this.updateOrder = 800;
                }
                InfoPopup.prototype.doAnimations = function (event) {
                    if (event.changes.position || event.changes.navigation) {
                        this.updatePopup(event);
                    }
                };
                /** called when about to show popup
                Returns [t0, t1, ] or null if no info popup */
                InfoPopup.prototype.getPopupAreaMouseMoved = function (x, y) {
                    if (!(this.scene.xyInChartOrBottom(x, y) && this.scene.activeFacet)) {
                        return null;
                    }
                    var facet = this.scene.activeFacet;
                    var t = this.scene.xToPosition(x);
                    if (isNaN(t))
                        return null;
                    var t0 = Math.floor(t);
                    var t1 = Math.ceil(t);
                    if (t0 === t1) {
                        t1 = t0 + 1;
                    }
                    if (t0 < facet.offset || t0 >= facet.items.length + facet.offset) {
                        return null;
                    }
                    return { t0: t0, t1: t1 };
                };
                InfoPopup.prototype.buildHeader = function (t0, t1) {
                    var facet = this.scene.activeFacet;
                    var item = facet.items[t0 - facet.offset];
                    var label = item.label || item.data.name || "";
                    return "<em></em><strong>" + label + "</strong>";
                };
                return InfoPopup;
            }(Internal.LinearChart.InfoPopup));
            FacetChart.InfoPopup = InfoPopup;
        })(FacetChart = Internal.FacetChart || (Internal.FacetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/core/ChartEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var FacetChart;
        (function (FacetChart) {
            var SettingsScrollButtons = (function () {
                function SettingsScrollButtons() {
                    /** Show/hide left, right scroll buttons if additional facets available. */
                    this.enabled = true;
                    /** Whether to display title on the exported image. Note that it does not affect chart. */
                    this.enabledOnExport = false;
                    /** Button height or width.
                    @type float
                    @units pixels */
                    this.size = 28;
                    /** Scroll button style */
                    this.style = {
                        fillColor: "rgba(255,255,255,0.5)",
                        lineColor: "rgba(0,0,0,0.5)",
                        hoverFillColor: "rgba(255,255,255,0.9)",
                        hoverLineColor: "rgba(0,0,0,0.9)"
                    };
                }
                return SettingsScrollButtons;
            }());
            FacetChart.SettingsScrollButtons = SettingsScrollButtons;
            var ScrollButtons = (function (_super) {
                __extends(ScrollButtons, _super);
                function ScrollButtons(chart) {
                    _super.call(this);
                    this.paintOrder = 75;
                    this.chart = chart;
                    this.scene = chart.scene;
                    this.settings = chart.settings.scrollButtons;
                    this.panels = [];
                    for (var i = 0; i < 2; i++) {
                        var p = new Internal.Base.ChartPanel();
                        p.packingOrder = 115;
                        p.side = i === 1 ? "left" : "right";
                        p.location = "inside";
                        p.align = "center";
                        this.panels.push(p);
                    }
                }
                ScrollButtons.prototype.onSceneChange = function (event) {
                    if (!this.settings.enabled)
                        return;
                    this.activeFacet = this.chart.scene.activeFacet;
                    this.showLeft = Math.floor(this.activeFacet.from) > 0;
                    this.showRight = Math.ceil(this.activeFacet.to) < this.activeFacet.totalCount;
                };
                ScrollButtons.prototype.getPanels = function (forExport) {
                    for (var i = 0; i < 2; i++) {
                        var p = this.panels[i];
                        p.visible = forExport ? this.settings.enabledOnExport : this.settings.enabled;
                        p.desiredWidth = p.desiredHeight = this.settings.size;
                    }
                    return this.panels;
                };
                ScrollButtons.prototype.paintScene = function (event) {
                    if (!this.panels[0].visible)
                        return;
                    var style = this.settings.style;
                    var ctx = event.context;
                    ctx.fillStyle = style.fillColor;
                    ctx.strokeStyle = style.lineColor;
                    var s = this.settings.size;
                    var m = s / 2;
                    var q = s / 4;
                    var y0 = this.scene.y0 + this.scene.height / 2 - s / 2;
                    for (var i = 0; i < this.panels.length; i++) {
                        var panel = this.panels[i];
                        var x0 = panel.left;
                        if (this.showRight && panel.side === "right") {
                            if (this.rightActive) {
                                ctx.fillStyle = style.hoverFillColor;
                                ctx.strokeStyle = style.hoverLineColor;
                            }
                            ctx.beginPath();
                            ctx.fillRect(x0, y0, s, s);
                            ctx.moveTo(x0 + m - q / 2 + 2, y0 + q); // additional px to get pixel perfect
                            ctx.lineTo(x0 + m + q - 3, y0 + m);
                            ctx.lineTo(x0 + m - q / 2 + 2, y0 + s - q); // additional px to get pixel perfect
                            ctx.stroke();
                        }
                        if (this.showLeft && panel.side === "left") {
                            if (this.leftActive) {
                                ctx.fillStyle = style.hoverFillColor;
                                ctx.strokeStyle = style.hoverLineColor;
                            }
                            ctx.beginPath();
                            ctx.fillRect(x0, y0, s, s);
                            ctx.moveTo(x0 + m + q / 2 - 2, y0 + q); // additional px to get pixel perfect
                            ctx.lineTo(x0 + m - q + 3, y0 + m);
                            ctx.lineTo(x0 + m + q / 2 - 2, y0 + s - q); // additional px to get pixel perfect
                            ctx.stroke();
                        }
                        ctx.fillStyle = style.fillColor;
                        ctx.strokeStyle = style.lineColor;
                    }
                };
                ScrollButtons.prototype.findItemAt = function (x, y, event) {
                    if (!this.panels[0].visible)
                        return null;
                    var tolerance = event.touch ? 10 : 0;
                    for (var i = 0; i < 2; i++) {
                        var p = this.panels[i];
                        if (x >= p.left - tolerance && x <= p.right + tolerance &&
                            y >= p.top - tolerance && y <= p.bottom + tolerance) {
                            if ((p.side === "left" && this.showLeft) || (p.side === "right" && this.showRight))
                                return p.side;
                        }
                    }
                    return null;
                };
                ScrollButtons.prototype.onClick = function (event) {
                    if (!this.panels[0].visible)
                        return;
                    // let time = Base.Helpers.timeToPerfNow(event.timeStamp);
                    var time = Internal.Base.Helpers.performanceNow();
                    var direction = this.findItemAt(event.x, event.y, event);
                    if (direction !== null) {
                        var scrolling = this.chart.scrolling;
                        var facet = this.activeFacet;
                        var from = facet.from;
                        var to = facet.to;
                        var total = facet.totalCount;
                        var dif = to - from;
                        if (direction === "right") {
                            if (to + dif > total) {
                                to = to - dif + (total - to);
                                scrolling.goToPosition(to, total, true, time, true);
                            }
                            else {
                                scrolling.goToPosition(to, to + dif, true, time, true);
                            }
                        }
                        if (direction === "left") {
                            if (from - dif < 0) {
                                scrolling.goToPosition(0, dif, true, time, true);
                            }
                            else {
                                scrolling.goToPosition(from - dif, from, true, time, true);
                            }
                        }
                        event.consumed = true;
                    }
                };
                ScrollButtons.prototype.onPointerMove = function (event) {
                    var direction = this.findItemAt(event.x, event.y, event);
                    if (direction !== null) {
                        if (direction === "left") {
                            this.leftActive = true;
                        }
                        if (direction === "right") {
                            this.rightActive = true;
                        }
                        event.changes.hover = true;
                        event.consumed = true;
                    }
                    else {
                        this.leftActive = false;
                        this.rightActive = false;
                    }
                };
                return ScrollButtons;
            }(Internal.Base.ChartElement));
            FacetChart.ScrollButtons = ScrollButtons;
        })(FacetChart = Internal.FacetChart || (Internal.FacetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Settings.ts" />
/// <reference path="../linearchart/Settings.ts" />
/// <reference path="../piechart/Data.ts" />
/// <reference path="FacetAxis.ts" />
/// <reference path="Selection.ts" />
/// <reference path="InfoPopup.ts" />
/// <reference path="ScrollButtons.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var FacetChart;
        (function (FacetChart) {
            var darkThemeTextColor = "#A8A7A8";
            var Settings = (function (_super) {
                __extends(Settings, _super);
                function Settings(settings) {
                    _super.call(this, Internal.Base.SettingsMapping.FacetChartSettings);
                    this.data = [];
                    /** Configurable conditions to filter the raw data values for subset of drawing facets. */
                    this.filters = {
                        /** Determine whether to show item or not.
                        @returns true to show, false to not show. */
                        sliceFilter: null,
                        /** Determines if zero values are automatically filtered from the data or if they will be displayed.
                        @version 1.14.0 */
                        allowZeroValues: true
                    };
                    /** Settings to specify initial view once the page loaded. */
                    this.navigation = {
                        /** Initial facet drilldown to show. For example ['', 'Firefox', 'Firefox 2.5'] denotes to various browsers grouped by versions. */
                        initialDrilldown: [""],
                        /** Initial scroll offset, number of items from start.
                        @type integer */
                        initialOffset: 0,
                    };
                    // TODO:! items - historicaly inherited from pc slices. Should clean used/unused values.
                    /** Series cluster including name placed on facet axis. */
                    this.items = {
                        /** Facet item style. */
                        style: {
                            /** Facet item text */
                            label: null,
                            /** Whether to open series item on click */
                            expandable: true
                        },
                        /** Dynamically determine item style from data. */
                        styleFunction: null
                    };
                    this.chartTypes = {
                        /** Series type to render values as vertical bars. */
                        columns: { type: "columns" },
                        /** Series type to connect value points by lines. */
                        line: { type: "line" },
                        /** @ignore */
                        candlestick: null
                    };
                    /** Chart x-axis line rendered at the bottom horizontally to display group names under each bar. */
                    this.facetAxis = new FacetChart.SettingsFacetAxis();
                    this.interaction = new SettingsInteraction();
                    this.toolbar = new SettingsToolbar();
                    /** The chart legend by additional interactivity to change the visibility of series it corresponds. */
                    this.legend = new Internal.LinearChart.SettingsLegend();
                    /** Left, right scroll buttons if additional facets available */
                    this.scrollButtons = new FacetChart.SettingsScrollButtons();
                    this.localization.toolbar.zoomoutTitle = "Zoom-out to previous level";
                    this.apply(settings);
                    this._initializing = false;
                }
                Settings.prototype.apply = function (settings) {
                    // COMPATIBILITY:
                    this.applyCompatibility(settings, [
                        { from: "area.initialPieId", to: "navigation.initialDrilldown" },
                        { from: "area.initialPieOffset", to: "navigation.initialOffset" },
                    ]);
                    if (settings.series) {
                        for (var i = 0; i < settings.series.length; i++) {
                            var s = settings.series[i];
                            if (s && s.styleFunction !== void 0)
                                Internal.Base.Helpers.error(("Setting `series[" + i + "].styleFunction` is no longer supported. Consider using `items.styleFunction` instead.")
                                    + " See the example: https://zoomcharts.com/developers/en/facet-chart/examples/series/stacked-colored.html");
                        }
                    }
                    return _super.prototype.apply.call(this, settings, SettingsSeries);
                };
                Settings.DarkTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-dark"
                    },
                    area: {
                        style: {
                            fillColor: "rgba(28,26,28,1)"
                        }
                    },
                    title: {
                        margin: 15,
                        style: {
                            fillColor: darkThemeTextColor
                        }
                    },
                    valueAxisDefault: {
                        style: {
                            valueLabel: {
                                textStyle: {
                                    fillColor: darkThemeTextColor
                                }
                            },
                            title: {
                                textStyle: {
                                    fillColor: darkThemeTextColor
                                }
                            }
                        }
                    },
                    facetAxis: {
                        labels: {
                            textStyle: {
                                fillColor: darkThemeTextColor
                            }
                        },
                        title: {
                            textStyle: {
                                fillColor: darkThemeTextColor
                            }
                        }
                    },
                    legend: {
                        text: {
                            fillColor: darkThemeTextColor
                        },
                        advanced: {
                            disabledSeries: {
                                textColor: "rgba(168,167,168,0.5)",
                                lineColor: "rgba(117,117,117,0.3)"
                            }
                        }
                    }
                };
                return Settings;
            }(Internal.LinearChart.Settings));
            FacetChart.Settings = Settings;
            var SettingsToolbar = (function (_super) {
                __extends(SettingsToolbar, _super);
                function SettingsToolbar() {
                    _super.apply(this, arguments);
                    /** Whether to show the Lin/Log button in the toolbar.
                    @version 1.9.1 */
                    this.logScale = true;
                    this.zoomOut = true;
                    this.enabled = true;
                    this.items = [
                        new Internal.Base.SettingsToolbarItem("back", "left"),
                        new Internal.Base.SettingsToolbarItem("zoomOut", "left"),
                        new Internal.Base.SettingsToolbarItem("logScale", "right"),
                        new Internal.Base.SettingsToolbarItem("export", "right"),
                    ];
                }
                return SettingsToolbar;
            }(Internal.Base.SettingsToolbar));
            FacetChart.SettingsToolbar = SettingsToolbar;
            var SettingsInteraction = (function (_super) {
                __extends(SettingsInteraction, _super);
                function SettingsInteraction() {
                    _super.apply(this, arguments);
                    /** Configurable settings for select option. */
                    this.selection = new FacetChart.SettingsInteractionSelection();
                    /** Chart animation settings. */
                    this.animation = {
                        /** Duration of scroll animation.
                        @type integer
                        @units milliseconds */
                        scrollDuration: 500
                    };
                }
                return SettingsInteraction;
            }(Internal.LinearChart.SettingsInteraction));
            FacetChart.SettingsInteraction = SettingsInteraction;
            var SettingsSeries = (function (_super) {
                __extends(SettingsSeries, _super);
                function SettingsSeries() {
                    _super.apply(this, arguments);
                    /** Series type.
                    @type enum
                    @value columns
                    @value line */
                    this.type = "columns";
                    this.data = new SettingsSeriesData();
                }
                /** Used dynamically by SettingsHelper to determine the correct mapping based on the type. */
                SettingsSeries.getMapping = function (target, source) {
                    if (target && source.type && target.type !== source.type)
                        throw new Error("It is not possible to change the value of `type` property for an existing layer.");
                    switch (target ? target.type : source.type) {
                        case "columns":
                        case void 0:
                            return Internal.Base.SettingsMapping.FacetChartSettingsSeriesColumns;
                        case "line":
                            return Internal.Base.SettingsMapping.FacetChartSettingsSeriesLines;
                        default:
                            throw new Error("The value '" + source.type + "' is not valid for the `type` property of a series. Valid values are: columns, line.");
                    }
                };
                SettingsSeries.createInstance = function (source, type) {
                    switch (type || source.type) {
                        case "columns":
                        case void 0:
                            return new SettingsSeriesColumns();
                        case "line":
                            return new SettingsSeriesLines();
                        default:
                            throw new Error(("The value '" + (type || source.type) + "' is not valid for the `type` property of a series.")
                                + " Valid values are: columns, line.");
                    }
                };
                return SettingsSeries;
            }(Internal.LinearChart.SettingsSeries));
            FacetChart.SettingsSeries = SettingsSeries;
            var SettingsSeriesData = (function (_super) {
                __extends(SettingsSeriesData, _super);
                function SettingsSeriesData() {
                    _super.apply(this, arguments);
                    /** Object property of subvalue that will be used for series data aggregation. An alternative is to use `valueFunction`. If neither are specified
                    the field `value` is implied. */
                    this.field = null;
                    /** Retrieves the individual value used for calculations from the data array. This is an alternative for specifying `index`.
                    @returns value to pass to aggregation */
                    this.valueFunction = null;
                }
                return SettingsSeriesData;
            }(Internal.LinearChart.SettingsSeriesData));
            FacetChart.SettingsSeriesData = SettingsSeriesData;
            var SettingsSeriesColumns = (function (_super) {
                __extends(SettingsSeriesColumns, _super);
                function SettingsSeriesColumns() {
                    _super.apply(this, arguments);
                    this.style = new SettingsSeriesColumnsStyle();
                    this.data = new SettingsSeriesData();
                }
                return SettingsSeriesColumns;
            }(Internal.LinearChart.SettingsSeriesColumns));
            FacetChart.SettingsSeriesColumns = SettingsSeriesColumns;
            var SettingsSeriesLines = (function (_super) {
                __extends(SettingsSeriesLines, _super);
                function SettingsSeriesLines() {
                    _super.apply(this, arguments);
                    this.data = new SettingsSeriesData();
                    this.style = new SettingsSeriesLinesStyle();
                }
                return SettingsSeriesLines;
            }(Internal.LinearChart.SettingsSeriesLines));
            FacetChart.SettingsSeriesLines = SettingsSeriesLines;
            var SettingsSeriesLinesStyle = (function (_super) {
                __extends(SettingsSeriesLinesStyle, _super);
                function SettingsSeriesLinesStyle() {
                    _super.apply(this, arguments);
                    this.markerStyleFunction = null;
                }
                return SettingsSeriesLinesStyle;
            }(Internal.LinearChart.SettingsSeriesLinesStyle));
            FacetChart.SettingsSeriesLinesStyle = SettingsSeriesLinesStyle;
            var SettingsSeriesColumnsStyle = (function (_super) {
                __extends(SettingsSeriesColumnsStyle, _super);
                function SettingsSeriesColumnsStyle() {
                    _super.apply(this, arguments);
                    /** Set to `true` in order to display a "preview" of the value distribution in each column.
                    The line color is specified in `previewLineColor` */
                    this.previewContents = false;
                    /** The color of the line used to draw the distribution if `previewContents` is `true`. */
                    this.previewLineColor = "rgba(255,255,255,.5)";
                }
                return SettingsSeriesColumnsStyle;
            }(Internal.LinearChart.SettingsSeriesColumnsStyle));
            FacetChart.SettingsSeriesColumnsStyle = SettingsSeriesColumnsStyle;
            var SettingsFacetStyle = (function (_super) {
                __extends(SettingsFacetStyle, _super);
                function SettingsFacetStyle() {
                    _super.apply(this, arguments);
                }
                return SettingsFacetStyle;
            }(SettingsSeriesColumnsStyle));
            FacetChart.SettingsFacetStyle = SettingsFacetStyle;
        })(FacetChart = Internal.FacetChart || (Internal.FacetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Helpers.ts" />
/// <reference path="../base/core/ChartEvents.ts" />
/// <reference path="../base/Graphics.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var LinearChart;
        (function (LinearChart) {
            var Highlights = (function (_super) {
                __extends(Highlights, _super);
                function Highlights(chart) {
                    _super.call(this);
                    this.animationOrder = 2000;
                    this.paintOrder = 45;
                    this.updateOrder = 700;
                    this.scene = null;
                    this.customId = 0;
                    this.animating = false;
                    this.highlights = {};
                    this.chart = chart;
                    this.scene = chart.scene;
                }
                Highlights.prototype.doAnimations = function (event) {
                    if (event.changes.highlight) {
                        var existingHighlights = [];
                        for (var k in this.highlights) {
                            var m = this.highlights[k];
                            // mark as exiting, will check up on scene highlights in next loop
                            m.exiting = true;
                            if (m.origin.removed) {
                                delete this.highlights[k];
                                m.animator = null;
                                existingHighlights.push(m);
                            }
                        }
                        // store exiting highlights under temp ids - they will be removed once the animation ends
                        for (var mIndex = 0; mIndex < existingHighlights.length; mIndex++) {
                            var m = existingHighlights[mIndex];
                            this.highlights["__" + (++this.customId)] = m;
                        }
                        for (var k in this.scene.highlights) {
                            var mm = this.scene.highlights[k];
                            if (this.highlights[k]) {
                                // update existing highlight
                                var m = this.highlights[k];
                                m.exiting = false;
                                m.from = mm.from;
                                m.to = mm.to;
                                // if (m.style.fillColor !== mm.style.fillColor && mm.style.fadeCross > 0) {
                                //     this.animating = true;
                                //     m.animator = new Base.Animator(m.style.fillColor, mm.style.fillColor, mm.style.fadeCross, "=", event.timeStamp);
                                // } else {
                                m.style = Internal.Base.Helpers.clone(mm.style);
                            }
                            else {
                                // create new highlight
                                var m = {
                                    from: mm.from,
                                    to: mm.to,
                                    style: Internal.Base.Helpers.clone(mm.style),
                                    animator: null,
                                    exiting: false,
                                    origin: mm
                                };
                                this.highlights[k] = m;
                                if (mm.style.fadeIn > 0) {
                                    this.animating = true;
                                    m.animator = new Internal.Base.ColorAnimator(Internal.Base.Colors.derive(Internal.Base.Colors.parse(m.style.fillColor), 1, 0), m.style.fillColor, m.style.fadeIn, "=", event.timeStamp);
                                }
                            }
                        }
                        for (var k in this.highlights) {
                            var m = this.highlights[k];
                            if (m.exiting && !m.animator) {
                                var style = m.style;
                                // remove old hights
                                if (style.fadeOut > 0) {
                                    // fade out highlight to transparent and remove after
                                    this.animating = true;
                                    m.animator = new Internal.Base.ColorAnimator(style.fillColor, Internal.Base.Colors.derive(Internal.Base.Colors.parse(style.fillColor), 1, 0), style.fadeOut, "=", event.timeStamp);
                                }
                                else {
                                    delete this.highlights[k];
                                }
                            }
                        }
                    }
                    if (this.animating) {
                        var newAnimating = false;
                        var time = event.timeStamp;
                        for (var k in this.highlights) {
                            var m = this.highlights[k];
                            if (m.animator) {
                                m.style.fillColor = m.animator.get(time);
                                if (m.animator.finished(time)) {
                                    m.animator = null;
                                    if (m.exiting) {
                                        delete this.highlights[k];
                                    }
                                }
                                else {
                                    newAnimating = true;
                                }
                            }
                        }
                        this.animating = newAnimating;
                        event.animating = event.animating || newAnimating;
                    }
                };
                Highlights.prototype.paintScene = function (event) {
                    var x0 = this.scene.x0;
                    var x1 = x0 + this.scene.width;
                    var y0 = Math.round(this.scene.y0);
                    var height = this.scene.height;
                    var g = event.context;
                    // paint highlights
                    for (var k in this.highlights) {
                        var highlight = this.highlights[k];
                        var hx0 = Math.max(this.scene.timeToX(highlight.from), x0);
                        var hx1 = Math.min(this.scene.timeToX(highlight.to), x1);
                        if (hx1 < x0 || hx0 > x1) {
                            continue;
                        }
                        Internal.Base.Graphics.rectStyle(g, highlight.style);
                        g.fillRect(hx0, y0, hx1 - hx0, height);
                    }
                };
                return Highlights;
            }(Internal.Base.ChartElement));
            LinearChart.Highlights = Highlights;
        })(LinearChart = Internal.LinearChart || (Internal.LinearChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/DomLayer.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var LinearChart;
        (function (LinearChart) {
            var DomLayer = (function (_super) {
                __extends(DomLayer, _super);
                function DomLayer(chart) {
                    _super.call(this, chart);
                    this.rightAxis = null;
                    this.leftAxis = null;
                    this.timeAxisPanel = null;
                }
                DomLayer.prototype.createDom = function (shell) {
                    _super.prototype.createDom.call(this, shell);
                    this.timeAxisPanel = Internal.Base.Helpers.createDom("div", "DVSL-TC-timeAxis", null, this.backgroundContainer);
                    Internal.Base.DomLayer.setContainerStyle(this.timeAxisPanel);
                    this.leftAxis = Internal.Base.Helpers.createDom("div", "DVSL-valueAxis", null, this.backgroundContainer);
                    Internal.Base.DomLayer.setContainerStyle(this.leftAxis);
                    this.rightAxis = Internal.Base.Helpers.createDom("div", "DVSL-valueAxis", null, this.backgroundContainer);
                    Internal.Base.DomLayer.setContainerStyle(this.rightAxis);
                };
                DomLayer.prototype.doAnimations = function (event) {
                    _super.prototype.doAnimations.call(this, event);
                    if (event.changes.bounds) {
                        this.background.style.left = (this.scene.x0 + "px");
                        this.background.style.right = ((this.scene.chartWidth - (this.scene.x0 + this.scene.width)) + "px");
                        this.leftAxis.style.width = (this.scene.leftMargin + "px");
                        this.leftAxis.style.bottom = (this.scene.bottomMargin + "px");
                        this.rightAxis.style.width = (this.scene.rightMargin + "px");
                        this.rightAxis.style.bottom = (this.scene.bottomMargin + "px");
                        this.timeAxisPanel.style.top = ((this.scene.y0 + this.scene.height) + "px");
                        this.timeAxisPanel.style.left = (this.scene.x0 + "px");
                        this.timeAxisPanel.style.width = (this.scene.width + "px");
                        this.outerBorder.style.left = (this.scene.x0 + "px");
                        this.outerBorder.style.width = (this.scene.width + "px");
                    }
                };
                return DomLayer;
            }(Internal.Base.DomLayer));
            LinearChart.DomLayer = DomLayer;
        })(LinearChart = Internal.LinearChart || (Internal.LinearChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Helpers.ts" />
/// <reference path="../base/core/ChartEvents.ts" />
/// <reference path="../base/TouchMarkers.ts" />
/// <reference path="../base/MessagesOverlay.ts" />
/// <reference path="../base/Resizer.ts" />
/// <reference path="../base/Impl.ts" />
/// <reference path="Highlights.ts" />
/// <reference path="DomLayer.ts" />
/// <reference path="ValueAxis.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var LinearChart;
        (function (LinearChart) {
            var Impl = (function (_super) {
                __extends(Impl, _super);
                function Impl(settings, scene, api) {
                    _super.call(this, settings, scene, api);
                    /** Need to fill these */
                    this.scrolling = null;
                    this.renderer = null;
                }
                Impl.prototype.createDomLayer = function () { return new LinearChart.DomLayer(this); };
                Impl.prototype.notifyAnimationDone = function () {
                    var _this = this;
                    // onAnimationDone is called immediately after the the current frame finishes so that the chart
                    // state correctly represents the situation if the animation was done but there are, for example,
                    // new data requests pending.
                    //
                    // without this, when the displayUnit is switched on the toolbar, the event handler will see
                    // chart.profiler().hasPendingRequests() === false even though the request will be created during
                    // the same frame.
                    window.setTimeout(function () {
                        if (!_this.removed) {
                            _this.dispatchEventParams("animationDone", _this.createEventArguments(null, "api"), null);
                        }
                    }, 0);
                };
                Impl.prototype.processChangedSettings = function (changes) {
                    var sc = changes.settingsChanges;
                    if (sc) {
                        if (LinearChart.Settings._hasSeriesSettingsChanged(sc))
                            changes.linearChartSeries = true;
                        if (sc.valueAxis || sc.valueAxisDefault)
                            changes.linearChartValueAxis = true;
                    }
                };
                Impl.prototype.updateSettings = function (settings, origin) {
                    _super.prototype.updateSettings.call(this, settings, origin);
                };
                Impl.prototype.setLogScale = function (enabled, origin) {
                    var vaChanges = {};
                    for (var id in this.settings.valueAxis) {
                        vaChanges[id] = { logScale: enabled };
                    }
                    this.updateSettings({
                        valueAxisDefault: { logScale: enabled },
                        valueAxis: vaChanges
                    }, origin);
                };
                Impl.prototype.finalInitialize = function () {
                    _super.prototype.finalInitialize.call(this);
                    this.legend = this.events.addElement(new LinearChart.Legend(this));
                };
                Impl.prototype.getEnabledSeries = function () {
                    var ret = [];
                    var cs = this.settings._computedSeries;
                    for (var i = 0, l = cs.length; i < l; i++)
                        if (cs[i].enabled)
                            ret.push(cs[i]);
                    return ret;
                };
                return Impl;
            }(Internal.Base.Impl));
            LinearChart.Impl = Impl;
        })(LinearChart = Internal.LinearChart || (Internal.LinearChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Scene.ts" />
/// <reference path="../base/Helpers.ts" />
/// <reference path="../ZoomCharts.d.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var LinearChart;
        (function (LinearChart) {
            var Scene = (function (_super) {
                __extends(Scene, _super);
                function Scene() {
                    _super.apply(this, arguments);
                    this.highlights = {};
                    this.seriesWithLabels = 0;
                    this.dataLabels = {
                        spots: {},
                        fontWidths: Object.create(null),
                        metaData: {
                            availableWidth: 0,
                            processed: 0,
                            styles: null
                        }
                    };
                    /** height in pixels of bottom axis */
                    this.bottomAxisSize = 0;
                }
                Scene.prototype.xyInChart = function (x, y) {
                    return (x >= this.x0) && (x < this.x0 + this.width) && (y >= this.y0) && (y < this.y0 + this.height);
                };
                Scene.prototype.xyInChartOrBottom = function (x, y) {
                    var bas = this.settings.interaction.ignoreBottomAxis ? 0 : this.bottomAxisSize;
                    return (x >= this.x0) && (x < this.x0 + this.width) && (y >= this.y0) && (y < this.y0 + this.height + bas);
                };
                Scene.prototype.xyInBottom = function (x, y) {
                    if (this.settings.interaction.ignoreBottomAxis)
                        return false;
                    return x >= this.x0 && x < this.x0 + this.width && y >= this.y0 + this.height && y < this.y0 + this.height + this.bottomAxisSize;
                };
                Scene.prototype.timeToX = function (t) {
                    throw "Need to implement timeToX";
                };
                Scene.prototype.xToTime = function (t) {
                    throw "Need to implement xToTime";
                };
                Scene.prototype.setHighlight = function (name, from, to, style) {
                    var h = this.highlights[name];
                    if (!h) {
                        h = {
                            from: from,
                            to: to,
                            style: style,
                            removed: false
                        };
                        this.highlights[name] = h;
                    }
                    else {
                        h.from = from;
                        h.to = to;
                        h.style = style;
                        h.removed = false;
                    }
                    return h;
                };
                Scene.prototype.removeHighlight = function (name) {
                    var h = this.highlights[name];
                    if (h) {
                        h.removed = true;
                        delete this.highlights[name];
                    }
                };
                return Scene;
            }(Internal.Base.Scene));
            LinearChart.Scene = Scene;
        })(LinearChart = Internal.LinearChart || (Internal.LinearChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../linearchart/Scene.ts" />
/// <reference path="../base/Helpers.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var FacetChart;
        (function (FacetChart) {
            var Facet = (function () {
                function Facet() {
                    this.id = null;
                    this.data = null;
                    this.items = [];
                    this.parentItem = null;
                    this.activeItemId = null; // item that is zoomed into, one of @items
                    this.offset = 0; // offset in data array
                    this.count = 0; // number of data items displayed
                    this.totalCount = 0; // total number of items
                    this.from = 0; // left side position in data array, fraction. In sync with offset and count.
                    this.to = 0; // right side position in data array, fraction.
                    this.left = 0; // position on screen, fraction of width
                    this.right = 1; // position on screen, fraction of width
                    this.opacity = 1;
                    this.loading = null;
                    this.rebuild = true; // If true, data has cahnaged and needs to be rebuilt in Builder.
                }
                Facet.prototype.getActiveItem = function () {
                    if (!this.activeItemId) {
                        return null;
                    }
                    for (var itemIndex = 0; itemIndex < this.items.length; itemIndex++) {
                        var item = this.items[itemIndex];
                        if (item.id === this.activeItemId) {
                            return item;
                        }
                    }
                    return null;
                };
                return Facet;
            }());
            FacetChart.Facet = Facet;
            var Item = (function () {
                function Item(facet, id, index, data) {
                    this.expandable = true;
                    this.selected = false;
                    this.active = false;
                    this.url = null;
                    this.urlTarget = null;
                    this.values = [];
                    this.innerFacet = null;
                    this.label = null;
                    this.currentLabel = null;
                    this.facet = facet;
                    this.id = id;
                    // index in pie data
                    this.index = index;
                    this.data = data;
                }
                return Item;
            }());
            FacetChart.Item = Item;
            var ItemValue = (function () {
                function ItemValue(facet, id, index, data, seriesId) {
                    this.value = 0;
                    this.label = null;
                    this.currentLabel = null;
                    this.style = new FacetChart.SettingsFacetStyle();
                    /** data to preview if previewContents = true */
                    this.previewData = null;
                    this.data = data;
                    this.index = index;
                    this.id = id;
                    this.facet = facet;
                    this.seriesId = seriesId;
                }
                return ItemValue;
            }());
            FacetChart.ItemValue = ItemValue;
            var Scene = (function (_super) {
                __extends(Scene, _super);
                function Scene() {
                    _super.apply(this, arguments);
                    this.data = null;
                    this.stack = [];
                    this.activeFacet = null;
                    this.hoverItem = null;
                    this.selection = [];
                    /**array of item identifiers to be selected when they are first displayed*/
                    this.selectionIds = [];
                }
                Scene.prototype.xToPosition = function (x) {
                    var f = this.activeFacet;
                    var left = this.x0 + f.left * this.width;
                    var right = this.x0 + f.right * this.width;
                    var pos = f.from + (x - left) / (right - left) * (f.to - f.from);
                    return pos;
                };
                Scene.prototype.positionToX = function (t) {
                    var f = this.activeFacet;
                    var left = this.x0 + f.left * this.width;
                    var right = this.x0 + f.right * this.width;
                    return left + (t - f.from) * (right - left) / (f.to - f.from);
                };
                Scene.prototype.timeToX = function (t) {
                    return this.positionToX(t);
                };
                Scene.prototype.xToTime = function (x) {
                    return this.xToPosition(x);
                };
                Scene.prototype.length = function () {
                    return this.stack.length;
                };
                Scene.prototype.peek = function () {
                    if (this.stack.length === 0) {
                        return null;
                    }
                    return this.stack[this.stack.length - 1];
                };
                Scene.prototype.push = function (facet, originItem) {
                    var parent = this.peek();
                    if (parent && !originItem) {
                        // try to find origin item
                        for (var itemIndex = 0; itemIndex < parent.items.length; itemIndex++) {
                            var item = parent.items[itemIndex];
                            if (item.data.__id === facet.id) {
                                originItem = item;
                                break;
                            }
                        }
                    }
                    if (originItem) {
                        facet.parentItem = originItem;
                        originItem.innerFacet = facet;
                        var getItemPlacementResult = this.getItemPlacement(originItem);
                        facet.left = getItemPlacementResult.left;
                        facet.right = getItemPlacementResult.right;
                        parent.activeItemId = originItem.id;
                    }
                    else if (parent) {
                        parent.activeItemId = null;
                    }
                    this.stack.push(facet);
                    this.activeFacet = facet;
                };
                Scene.prototype.pop = function () {
                    if (this.stack.length > 0) {
                        var f = this.stack.pop();
                        if (f.parentItem) {
                            f.parentItem.facet.activeItemId = null;
                        }
                    }
                    if (this.stack.length > 0) {
                        this.activeFacet = this.peek();
                    }
                    else {
                        this.activeFacet = null;
                    }
                    return this.activeFacet;
                };
                Scene.prototype.getParent = function (facet) {
                    var parent = null;
                    for (var pIndex = 0; pIndex < this.stack.length; pIndex++) {
                        var p = this.stack[pIndex];
                        if (p === facet) {
                            return parent;
                        }
                        parent = p;
                    }
                    return null;
                };
                Scene.prototype.getChild = function (facet) {
                    var parent = null;
                    for (var pIndex = 0; pIndex < this.stack.length; pIndex++) {
                        var p = this.stack[pIndex];
                        if (parent === facet) {
                            return p;
                        }
                        parent = p;
                    }
                    return null;
                };
                Scene.prototype.updateLinks = function (facet) {
                    var parent = this.getParent(facet);
                    var child = this.getChild(facet);
                    if (parent && !facet.parentItem) {
                        for (var itemIndex = 0; itemIndex < parent.items.length; itemIndex++) {
                            var item = parent.items[itemIndex];
                            if (item.id === facet.id) {
                                facet.parentItem = item;
                                parent.activeItemId = item.id;
                                break;
                            }
                        }
                    }
                    if (child && !child.parentItem) {
                        for (var itemIndex = 0; itemIndex < facet.items.length; itemIndex++) {
                            var item = facet.items[itemIndex];
                            if (item.id === child.id) {
                                child.parentItem = item;
                                facet.activeItemId = item.id;
                                break;
                            }
                        }
                    }
                };
                Scene.prototype.getItemPlacement = function (item) {
                    var facet = item.facet;
                    var i = item.index;
                    var da = facet.to - facet.from;
                    var a0 = facet.from;
                    var p0 = (i - a0) / da;
                    var p1 = (i - a0 + 1) / da;
                    return {
                        left: facet.left + p0 * (facet.right - facet.left),
                        right: facet.left + p1 * (facet.right - facet.left)
                    };
                };
                Scene.prototype.getFacetPlacementFromItem = function (item, iLeft, iRight) {
                    var facet = item.facet;
                    var i0 = item.index;
                    var i1 = i0 + 1;
                    var A0 = (i0 - facet.from) / (facet.to - facet.from);
                    var A1 = (i1 - facet.from) / (facet.to - facet.from);
                    var left = iLeft - A0 * (iLeft - iRight) / (A0 - A1);
                    var right = left + (iLeft - iRight) / (A0 - A1);
                    return { left: left, right: right };
                };
                Scene.prototype.findItemAt = function (x, y) {
                    var f = this.activeFacet;
                    if (!f || !this.xyInChart(x, y)) {
                        return null;
                    }
                    var pos = Math.floor(this.xToPosition(x));
                    if (pos >= f.offset && pos < f.offset + f.count) {
                        return f.items[pos - f.offset];
                    }
                    return null;
                };
                return Scene;
            }(Internal.LinearChart.Scene));
            FacetChart.Scene = Scene;
        })(FacetChart = Internal.FacetChart || (Internal.FacetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Helpers.ts" />
/// <reference path="../base/core/ChartEvents.ts" />
/// <referemce path="../base/Inertia.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var LinearChart;
        (function (LinearChart) {
            var Scrolling = (function (_super) {
                __extends(Scrolling, _super);
                function Scrolling(chart) {
                    _super.call(this);
                    this.animationOrder = 1000;
                    this.chart = null;
                    this.scene = null;
                    this.events = null;
                    /** dragging state tracking */
                    this.pointer1 = null;
                    this.pointer2 = null;
                    this.t1 = 0;
                    this.t2 = 0;
                    this.x1 = 0;
                    this.x2 = 0;
                    this.scaleOrigin = null;
                    /** The initial size (in milliseconds) of the view when pinch zoom was started. */
                    this.initialZoom = null;
                    this.dragStartFrom = null;
                    this.dragStartTo = null;
                    this.active = false;
                    this.lastScrollingY = 0;
                    this.scrollingActive = false;
                    this.scalingActive = 0 /* None */;
                    /** The time value of where the mouse pointer was when the mouse wheel started */
                    this.wheelOrigin = null;
                    /** The proportion (wheelOrigin - from) / (to - from) when the mouse wheel started. */
                    this.wheelProportion = null;
                    /** for lighting zoom ins and outs */
                    this.highlight = null;
                    this.highlightRemoveWhenDone = false;
                    this._animationsDone = true;
                    this.chart = chart;
                    this.scene = chart.scene;
                    this.events = chart.events;
                    this._settings = chart.settings.interaction;
                    this.inertiaF = new Internal.Base.Inertia(1, 0, true);
                    this.inertiaT = new Internal.Base.Inertia(1, 0, true);
                }
                /** returns the width of the visible chart area in the units of X axis */
                Scrolling.prototype.getVisibleRange = function () {
                    return this._currentTo - this._currentFrom;
                };
                /** called to compute target positions, returns [from, to] */
                Scrolling.prototype.onZoomOut = function (from, to, center, scale) {
                    if (scale == null)
                        scale = 2; /*on purpose handle both null and void 0*/
                    return {
                        from: center - (center - from) * scale,
                        to: center + (to - center) * scale,
                        center: center
                    };
                };
                /** called to compute target positions, returns [from, to] */
                Scrolling.prototype.onZoomIn = function (from, to, center, scale) {
                    if (scale === void 0) { scale = 0.5; }
                    if (scale == null)
                        scale = 0.5; // ported from CoffeeScript;
                    return {
                        from: center - (center - from) * scale,
                        to: center + (to - center) * scale,
                        center: center
                    };
                };
                /** computes positions after scroll */
                Scrolling.prototype.onScroll = function (from, to, direction) {
                    if (direction === "<") {
                        return {
                            from: from * 2 - to,
                            to: from
                        };
                    }
                    else {
                        return {
                            from: to,
                            to: 2 * to - from
                        };
                    }
                };
                /** called when home button is pressed, returns [from, to, origin] */
                Scrolling.prototype.onGoHome = function (from, to) {
                    return {
                        from: from,
                        to: to,
                        origin: to
                    };
                };
                /**
                 * Returns the current starting point (in the given point of animation)
                 * @param time - The time at which the value is expected. If Infinity or null given, target value is returned
                 * @returns {number}
                 */
                Scrolling.prototype.getFrom = function (time) {
                    if (time == null || time === Infinity)
                        return this.inertiaF.getTargetValue();
                    return this.inertiaF.getValue(time);
                };
                /**
                 * Returns the To value of the visible scrollable area
                 * @param time - If Infinity or null given, returns the target value
                 * @returns {number}
                 */
                Scrolling.prototype.getTo = function (time) {
                    if (time == null || time === Infinity)
                        return this.inertiaT.getTargetValue();
                    return this.inertiaT.getValue(time);
                };
                /**
                 * Sets the target value of from inertia, optionally via animation
                 * @param value - the target value on X axis (The animator itself will use scene coordinates)
                 * @param animate
                 * @param time - not the absolute timestamp, but as given in requestAnimationFrame
                 * @param limitMaxTime - whether the maximum animation length should be limited
                 */
                Scrolling.prototype.setFrom = function (value, animate, time, limitMaxTime) {
                    if (animate === void 0) { animate = false; }
                    if (limitMaxTime === void 0) { limitMaxTime = false; }
                    if (animate) {
                        this.inertiaF.setTarget(value, time, void 0, limitMaxTime ? this._settings.scrolling.maxAnimationLength : null);
                        this._animationsDone = false;
                    }
                    else {
                        this._currentFrom = value;
                        this.inertiaF.jump(value);
                    }
                };
                /**
                 * Sets the target value of the to inertia
                 * @param value - the target value on X axis (The animator itself will use scene coordinates)
                 * @param animate
                 * @param time - not the absolute timestamp, but as given in requestAnimationFrame
                 * @param limitMaxTime - whether the maximum animation length should be limited
                 */
                Scrolling.prototype.setTo = function (value, animate, time, limitMaxTime) {
                    if (animate === void 0) { animate = false; }
                    if (limitMaxTime === void 0) { limitMaxTime = false; }
                    if (animate) {
                        this.inertiaT.setTarget(value, time, void 0, limitMaxTime ? this._settings.scrolling.maxAnimationLength : null);
                        this._animationsDone = false;
                    }
                    else {
                        this._currentTo = value;
                        this.inertiaT.jump(value);
                    }
                };
                Scrolling.prototype.onWheel = function (event) {
                    // more work has to be done to support dragging and wheeling at the same time.
                    if (this.pointer1 !== null)
                        return;
                    var from = this.getFrom();
                    var to = this.getTo();
                    if (from >= to)
                        return;
                    var config = this._settings;
                    if ((!config.zooming.wheel) || (!config.zooming.enabled) || !this.xyInArea(event.x, event.y))
                        return;
                    this.active = true;
                    var origin = this.wheelOrigin;
                    if (origin === null) {
                        this.wheelOrigin = this.scaleOrigin = origin = this.xyToPosition(event.x, event.y);
                        this.wheelProportion = (origin - from) / (to - from);
                        this.x1 = event.x;
                    }
                    var prop = this.wheelProportion;
                    var ds = Math.pow(Math.max(1.1, config.zooming.wheelSensitivity), event.wheely * 0.004);
                    from = origin - (to - from) * prop * ds;
                    to = origin + (to - from) * (1 - prop) * ds;
                    var scale = event.wheely < 0 ? 1 /* CollapseRange */ : -1 /* ExpandRange */;
                    var time = Internal.Base.Helpers.performanceNow();
                    this.handleZoomWheel(from, to, origin, time, scale);
                    event.consumed = true;
                    this.active = false;
                };
                Scrolling.prototype.onPointerDown = function (event) {
                    this.wheelOrigin = null;
                    var config = this._settings;
                    if (!this.xyInArea(event.x, event.y) || (!config.scrolling.enabled && !config.zooming.enabled)) {
                        return;
                    }
                    // The user can grab the chart during an inertia animation, so the animated value is taken upon pointerDown
                    var pos = this.xyToPosition(event.x, event.y);
                    var time = Internal.Base.Helpers.performanceNow();
                    var from = this.getFrom(time);
                    var to = this.getTo(time);
                    if (from > to) {
                        // this is not sane - switch from with to
                        var c = to;
                        to = from;
                        from = c;
                    }
                    if (this.pointer1 === null) {
                        // touch down of the 1st pointer
                        this.pointer1 = event.identifier;
                        this.x1 = event.x;
                        this.t1 = pos;
                        this.scaleOrigin = pos;
                        this.onStartDragging(from, to, pos);
                        this.lastScrollingY = event.y;
                        this.dragStartFrom = from;
                        this.dragStartTo = to;
                        this.dragCurFrom = from;
                        this.dragCurTo = to;
                        event.consumed = true;
                        // stop ongoing animations if any
                        if (!(this.inertiaF.finished(time) && this.inertiaT.finished(time))) {
                            this.setFrom(from);
                            this.setTo(to);
                            this.stopAnimations();
                            this.scrollingActive = true;
                        }
                        // detach from anchor
                        this.chart.cancelChartUpdateNotify();
                        event.consumed = true;
                    }
                    else if (this.pointer2 === null) {
                        this.pointer2 = event.identifier;
                        this.x2 = event.x;
                        this.t2 = pos;
                        this.initialZoom = to - from;
                        this.scaleOrigin = (this.t1 + this.t2) / 2;
                        event.consumed = true;
                    }
                    else {
                        // just consume any other pointers
                        if (this.scalingActive || this.scrollingActive) {
                            event.consumed = true;
                        }
                    }
                };
                /**
                 * Transforms the coordinate system of a point while dragging
                 * @param x - x coordinate of a point
                 * @param y - y coordinate of a point
                 * @param cFrom - The current value of the "from" of the visible area
                 * @param cTo - The current value of the "to" of the visible area
                 * @returns {number}
                 */
                Scrolling.prototype.xyToDragPosition = function (x, y) {
                    return this.dragCurFrom + (x - this.scene.x0) / this.scene.width * (this.dragCurTo - this.dragCurFrom);
                };
                Scrolling.prototype.scaleViewRange = function (event, from, to) {
                    var ds = Math.pow(1 + this._settings.zooming.sensitivity, -event.dy / this.scene.height);
                    from = (from - this.scaleOrigin) * ds + this.scaleOrigin;
                    to = (to - this.scaleOrigin) * ds + this.scaleOrigin;
                    return { from: from, to: to };
                };
                ;
                Scrolling.prototype.onPointerMove = function (event) {
                    if (this.wheelOrigin !== null) {
                        // the scale origin is stored on the first onwheel so that subsequent onWheel events can use it
                        // otherwise it recalculates the origin for each wheel turn which jumps around due to snapping.
                        if (Math.abs(this.x1 - event.x) > this._settings.zooming.sensitivity) {
                            this.wheelOrigin = null;
                        }
                    }
                };
                Scrolling.prototype.onPointerDrag = function (event) {
                    var from = this.dragCurFrom;
                    var to = this.dragCurTo;
                    var interaction = this._settings;
                    if (event.identifier === this.pointer1 && this.pointer2 === null) {
                        // singe pointer drag
                        this.scaleOrigin = this.t1;
                        this.x1 = event.x;
                        var scaleAmount = event.y - this.lastScrollingY;
                        if (Math.abs(event.dx) > Math.abs(event.dy) * 4 && interaction.scrolling.enabled) {
                            this.scrollingActive = true;
                        }
                        if (interaction.zooming.enabled
                            && interaction.zooming.swipe
                            && Math.abs(scaleAmount) > interaction.zooming.upDownTreshold) {
                            this.scalingActive = scaleAmount > 0 ? 1 /* CollapseRange */ : -1 /* ExpandRange */;
                        }
                        else {
                            this.scalingActive = 0 /* None */;
                        }
                        if (this.scalingActive) {
                            this.clearZoomHighlight();
                            var r = this.scaleViewRange(event, from, to);
                            from = r.from;
                            to = r.to;
                            event.consumed = true;
                        }
                        if (this.scrollingActive) {
                            // scroll
                            var pos = this.xyToDragPosition(event.x, event.y);
                            var dt = this.t1 - pos;
                            from += dt;
                            to += dt;
                        }
                    }
                    else if (event.identifier === this.pointer1 && interaction.scrolling.enabled) {
                        // Two pointer drag (updating from & to separately) - 1st pointer
                        this.x1 = event.x;
                        this.clearZoomHighlight();
                        var twoPointerDragResult = this.twoPointerDrag();
                        from = twoPointerDragResult.from;
                        to = twoPointerDragResult.to;
                    }
                    else if (event.identifier === this.pointer2 && interaction.scrolling.enabled) {
                        // Two pointer drag - 2nd pointer
                        this.x2 = event.x;
                        this.clearZoomHighlight();
                        var twoPointerDragResult = this.twoPointerDrag();
                        from = twoPointerDragResult.from;
                        to = twoPointerDragResult.to;
                    }
                    else {
                        // just consume any other events
                        if (this.scalingActive || this.scrollingActive) {
                            event.consumed = true;
                        }
                        return;
                    }
                    this.dragCurFrom = from;
                    this.dragCurTo = to;
                    var snap = this.onSnapWhileDragging(from, to, this.scaleOrigin, this.scrollingActive, this.scalingActive);
                    this.goToPositionDragging(snap.from, snap.to);
                    event.consumed = true;
                };
                Scrolling.prototype.twoPointerDrag = function () {
                    var config = this._settings;
                    var maxZoom = config.zooming.fingersMaxZoom;
                    this.scaleOrigin = (this.t1 + this.t2) / 2;
                    var dtInitial = this.t2 - this.t1;
                    var from = this.dragCurFrom;
                    var to = this.dragCurTo;
                    var x1Pos = this.xyToDragPosition(this.x1, 0);
                    var x2Pos = this.xyToDragPosition(this.x2, 0);
                    if (config.scrolling.enabled
                        && config.zooming.enabled
                        && config.zooming.fingers && dtInitial !== 0) {
                        // figure out desired center and zoom
                        var initialZoom = this.initialZoom;
                        var centerFraction = ((x1Pos + x2Pos) / 2 - this._currentFrom) / (this._currentTo - this._currentFrom);
                        var dFraction = (x2Pos - x1Pos) / (this._currentTo - this._currentFrom);
                        var targetVisible = void 0;
                        if (dtInitial * dFraction > 0) {
                            targetVisible = dtInitial / dFraction;
                        }
                        else {
                            targetVisible = Infinity;
                        }
                        var maxVisible = initialZoom * maxZoom;
                        var minVisible = initialZoom / maxZoom;
                        targetVisible = Math.max(minVisible, Math.min(maxVisible, targetVisible));
                        from = this.scaleOrigin - centerFraction * targetVisible;
                        to = this.scaleOrigin + (1 - centerFraction) * targetVisible;
                        this.scalingActive = targetVisible < initialZoom ? 1 /* CollapseRange */ : -1 /* ExpandRange */;
                        this.scrollingActive = true;
                    }
                    else if (config.scrolling.enabled) {
                        var ta = (this.t1 + this.t2) / 2;
                        var tb = (x1Pos + x2Pos) / 2;
                        var dt = ta - tb;
                        from += dt;
                        to += dt;
                        this.scrollingActive = true;
                    }
                    return { from: from, to: to };
                };
                Scrolling.prototype.onPointerUp = function (event) {
                    // let time = Base.Helpers.timestampToPerfNow(event.timeStamp);
                    var config = this._settings;
                    var time = Internal.Base.Helpers.performanceNow();
                    var scrollingActive = this.scrollingActive;
                    var scalingActive = this.scalingActive;
                    if (event.identifier === this.pointer2) {
                        // 2nd pointer release
                        this.pointer2 = null;
                        event.consumed = true;
                        this.scaleOrigin = this.t1;
                    }
                    else if (event.identifier === this.pointer1 && this.pointer2 !== null) {
                        // Other pointers being released
                        this.pointer1 = this.pointer2;
                        this.pointer2 = null;
                        this.t1 = this.t2;
                        this.scaleOrigin = this.t1;
                        event.consumed = true;
                    }
                    else if (event.identifier === this.pointer1) {
                        // The last pointer being released
                        this.pointer1 = null;
                        this.active = true;
                        var from = void 0;
                        var to = void 0;
                        var vx = void 0;
                        if (config.scrolling.enabled) {
                            // Update the speed of both inertia animators
                            // get the speed
                            vx = -event.vx;
                            // Limit the max speed - Don't let the scrolling speed exceed 2 scene widths per second
                            if (vx > 0) {
                                vx = Math.min(vx, this.scene.width * 2e-3);
                            }
                            else {
                                vx = Math.max(vx, -this.scene.width * 2e-3);
                            }
                            // x velocity expressed as a fraction of the scene width;
                            var range = this.getVisibleRange();
                            vx = vx * range / this.scene.width;
                        }
                        else {
                            // If scrolling is disabled, inertia is not possible
                            vx = 0;
                        }
                        this.updateFriction(time);
                        // Set the velocity in the both inertia animators (as the pointer was released) - this will be snapped afterwards within the onSnapAfterdragging
                        this.inertiaF.jump(this._currentFrom, vx, time);
                        this.inertiaT.jump(this._currentTo, vx, time);
                        this._animationsDone = false;
                        // all pointers up
                        if (config.scrolling.swipePageFlipping
                            && event.swipeUp
                            && this.scalingActive
                            && event.swipeSpeed > this.scene.height / config.swipeSensitivity) {
                            var zoomOutRange = this.onZoomOut(this.dragStartFrom, this.dragStartTo, this.scaleOrigin);
                            from = zoomOutRange.from;
                            to = zoomOutRange.to;
                        }
                        else if (config.scrolling.swipePageFlipping
                            && event.swipeDown
                            && this.scalingActive
                            && event.swipeSpeed > this.scene.height / config.swipeSensitivity) {
                            var zoomInResult = this.onZoomIn(this.dragStartFrom, this.dragStartTo, this.scaleOrigin);
                            from = zoomInResult.from;
                            to = zoomInResult.to;
                        }
                        else if (scrollingActive || scalingActive) {
                            if (scrollingActive
                                && !scalingActive
                                && config.scrolling.swipePageFlipping
                                && (event.swipeLeft || event.swipeRight)
                                && event.swipeSpeed > this.scene.width / config.swipeSensitivity * 0.7) {
                                // scroll 1 page left/right
                                var direction = event.swipeLeft ? "<" : ">";
                                var onScrollResult = this.onScroll(this.dragStartFrom, this.dragStartTo, direction);
                                from = onScrollResult.from;
                                to = onScrollResult.to;
                            }
                            else {
                                from = this._currentFrom;
                                to = this._currentTo;
                            }
                            this.scaleOrigin = (from + to) / 2;
                        }
                        if (from || to) {
                            // animate to the new position
                            var r = this.onSnapAfterDragging(this.inertiaF.getTargetValue(), this.inertiaT.getTargetValue(), this.scaleOrigin, scrollingActive || scalingActive !== 0 /* None */, // scroll position has to always be adjusted when scaling was done
                            scalingActive);
                            if (r) {
                                this.goToPosition(r.from, r.to, true, time, false);
                            }
                            // clear state
                            event.consumed = true;
                            this.scaleOrigin = null;
                        }
                        this.active = false;
                        this.dragStartFrom = null;
                        this.dragStartTo = null;
                        this.scalingActive = 0 /* None */;
                        this.scrollingActive = false;
                    }
                    else {
                        // just consume any other pointers
                        if (scalingActive || scrollingActive) {
                            event.consumed = true;
                        }
                    }
                };
                Scrolling.prototype.onPointerCancel = function (event) {
                    // let time = Base.Helpers.timestampToPerfNow(event.timeStamp);
                    // let time = Base.Helpers.performanceNow();
                    if (event.identifier === this.pointer2) {
                        this.pointer2 = null;
                        this.scaleOrigin = this.t1;
                    }
                    else if (event.identifier === this.pointer1 && this.pointer2 !== null) {
                        this.pointer1 = this.pointer2;
                        this.t1 = this.t2;
                        this.scaleOrigin = this.t1;
                        this.pointer2 = null;
                        this.t2 = null;
                    }
                    else if (event.identifier === this.pointer1) {
                        this.active = true;
                        this.pointer1 = null;
                        this.t1 = null;
                        this.scaleOrigin = null;
                        this.dragStartFrom = null;
                        this.dragStartTo = null;
                        this.scalingActive = 0 /* None */;
                        this.scrollingActive = false;
                        this.active = false;
                    }
                };
                Scrolling.prototype.onKeyDown = function (event) {
                    /*
                    // for now keyboard events are not supported.
                    let time = event.timeStamp;
                    this.active = true;
                    let from = this.getFrom(time);
                    let to = this.getTo(time);
                    if (!(from < to)) { return; }
        
                    let origin = (from + to) / 2;
                    let scrolling = false;
                    let scaling = false;
                    if (event.keyCode === 37) {
                        // "Left"
                        scrolling = true;
                        let onScrollResult = this.onScroll(from, to, "<");
                        from = onScrollResult.from;
                        to = onScrollResult.to;
                        origin = (from + to) / 2;
                    } else if (event.keyCode === 39) {
                        // "Right"
                        scrolling = true;
                        let onScrollResult = this.onScroll(from, to, ">");
                        from = onScrollResult.from;
                        to = onScrollResult.to;
                        origin = (from + to) / 2;
                    } else if (event.keyCode === 36) {
                        // "Home"
                        scaling = true;
                        scrolling = true;
                        let onGoHomeResult = this.onGoHome(from, to);
                        from = onGoHomeResult.from;
                        to = onGoHomeResult.to;
                        origin = onGoHomeResult.origin;
                    } else if (event.keyCode === 38) {
                        // "Up"
                        let zoom = this.scene.settings.interaction.zooming.keyboardFactor;
                        scaling = true;
                        let onZoomOutResult = this.onZoomOut(from, to, origin, zoom);
                        from = onZoomOutResult.from;
                        to = onZoomOutResult.to;
                        origin = onZoomOutResult.center;
                    } else if (event.keyCode === 40) {
                        // "Down"
                        let zoom = 1 / this.scene.settings.interaction.zooming.keyboardFactor;
                        scaling = true;
                        let zoomInResult = this.onZoomIn(from, to, origin, zoom);
                        from = zoomInResult.from;
                        to = zoomInResult.to;
                    }
        
                    if (scaling || scrolling) {
                        let r = this.onSnapAfterDragging(from, to, origin, scrolling, scaling);
                        if (r) {
                            this.goToPosition(r.from, r.to, true, time);
                        }
        
                        event.consumed = true;
                    }
        
                    this.active = false;
                    */
                };
                /**
                 * Called while dragging to update the position of the chart
                 * @param from
                 * @param to
                 */
                Scrolling.prototype.goToPositionDragging = function (from, to) {
                    this.setFrom(from);
                    this.setTo(to);
                    this.clearZoomHighlight();
                    this.onPositionChanged(from, to);
                };
                /**
                 * Navigates the chart to a position with an optional animation
                 * @param from - The target from position to go to
                 * @param to - the target to position to go to
                 * @param {boolean} animate - Whether to animate (with inertia) to the given position
                 * @param time - Timestamp at which the method was called
                 * @param limitMaxTime - whether the maximum animation length should be limited
                 */
                Scrolling.prototype.goToPosition = function (from, to, animate, time, limitMaxTime) {
                    if (!(from < to)) {
                        return;
                    }
                    // do not animate unless reasonable starting position
                    if (!(this._currentFrom < this._currentTo)) {
                        animate = false;
                    }
                    this.stopAnimations();
                    if (animate) {
                        var threshold = this._settings.zooming.zoomHighlightThreshold;
                        var cFrom = this._currentFrom;
                        var cTo = this._currentTo;
                        this.updateFriction(time, from, to);
                        this.setFrom(from, true, time, limitMaxTime);
                        this.setTo(to, true, time, limitMaxTime);
                        // setup highlight
                        var diff = Math.abs((from - to) / (cFrom - cTo + 1));
                        if (diff < 1 / threshold) {
                            this.setZoomHighlight(from, to, true);
                        }
                        else if (diff > threshold) {
                            var f = (this.dragStartFrom !== null) ? this.dragStartFrom : cFrom;
                            var t = (this.dragStartTo !== null) ? this.dragStartTo : cTo;
                            this.setZoomHighlight(f, t, false);
                        }
                        this.events.notifySceneChanges({ requestPaint: true });
                    }
                    else {
                        this.setFrom(from);
                        this.setTo(to);
                        this.clearZoomHighlight();
                        this.onPositionChanged(from, to);
                        this.onAnimationDone(from, to);
                        this._animationsDone = true;
                    }
                };
                /**
                 * Called on animation frame
                 */
                Scrolling.prototype.doAnimations = function (event) {
                    if (this._animationsDone)
                        return;
                    var time = event.timeStamp;
                    var fromAnimFinished = this.inertiaF.finished(time);
                    var toAnimFinished = this.inertiaT.finished(time);
                    this._animationsDone = fromAnimFinished && toAnimFinished;
                    // update animations
                    // The values of from & to @ this point in time/animation
                    var from = this._currentFrom = this.getFrom(time);
                    var to = this._currentTo = this.getTo(time);
                    // isNaN check is for edge cases when there is no data at all. The goal is to prevent endless animation loops.
                    if (!this._animationsDone && !isNaN(from + to)) {
                        this.onPositionChanged(from, to, true);
                        event.animating = true;
                    }
                    else {
                        // Finish animation
                        this.stopAnimations();
                        this.onPositionChanged(from, to, false);
                        this.onAnimationDone(from, to);
                    }
                };
                /**
                 * Clear the zoom highlight
                 */
                Scrolling.prototype.stopAnimations = function () {
                    if (this.highlight) {
                        if (this.highlightRemoveWhenDone) {
                            this.clearZoomHighlight();
                        }
                        else {
                            // fade out highlight to inactive
                            this.highlight.style.fillColor = this.scene.settings.area.style.zoomHighlightInactive.fillColor;
                            this.events.notifySceneChanges({ highlight: true });
                        }
                    }
                };
                /** Aborts the scrolling if it is currently active.
        
                The intended purpose of this method is to be called when an API method would impact the scrolling and
                thus any pointer positions this class holds would become invalid.
        
                Note that perhaps a better solution would be instead of interrupting the scroll, reset all stored pointers
                so that the user can continue the gesture. */
                Scrolling.prototype.abort = function () {
                    if (!this.isActive())
                        return;
                    // these lines should clear any cached positions etc. they also make sure that when the pointer is 
                    // actually released, nothing happens.
                    if (this.pointer2)
                        this.onPointerCancel({ identifier: this.pointer2 });
                    if (this.pointer1)
                        this.onPointerCancel({ identifier: this.pointer1 });
                    // reset the animators
                    this.setFrom(this._currentFrom);
                    this.setTo(this._currentTo);
                    this.clearZoomHighlight();
                    this._animationsDone = true;
                };
                Scrolling.prototype.isActive = function () {
                    return this.active || this.pointer1 != null || !this._animationsDone;
                };
                Scrolling.prototype.clearZoomHighlight = function () {
                    if (this.highlight) {
                        this.scene.removeHighlight("zoomTrace");
                        this.highlight = null;
                        this.events.notifySceneChanges({ highlight: true });
                    }
                };
                Scrolling.prototype.setZoomHighlight = function (from, to, removeWhenDone) {
                    this.highlight = this.scene.setHighlight("zoomTrace", from, to, this.scene.settings.area.style.zoomHighlight);
                    this.highlightRemoveWhenDone = removeWhenDone;
                    this.events.notifySceneChanges({ highlight: true });
                };
                Scrolling.prototype.updateFriction = function (time, targetFrom, targetTo) {
                    var range = this.getVisibleRange();
                    if (targetFrom != null && targetTo != null) {
                        // Check whether this is a zoom out animation. In case of zoom out, the range used in fricion calculation is target range, not the actual range
                        // This would ensure similar animation durations in zoom-in and zoom-out
                        var targetRange = targetTo - targetFrom;
                        var treshold = 0.3;
                        var isZoomIn = range * (1 - treshold) > targetRange;
                        var isZoomOut = range * (1 + treshold) < targetRange;
                        if (isZoomOut) {
                            range = targetRange;
                        }
                        if (isZoomIn || isZoomOut) {
                            // Increased animation speed for zoom in & zoom out
                            range *= 2;
                        }
                    }
                    // Acceleration needs to be set in the units on the X axis
                    var acc = range * this._settings.scrolling.kineticFriction; // If the scene width has been updated, update acceleration.
                    this.inertiaF.setAcceleration(acc, time);
                    this.inertiaT.setAcceleration(acc, time);
                };
                return Scrolling;
            }(Internal.Base.ChartElement));
            LinearChart.Scrolling = Scrolling;
        })(LinearChart = Internal.LinearChart || (Internal.LinearChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../linearchart/Scrolling.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var FacetChart;
        (function (FacetChart) {
            var Scrolling = (function (_super) {
                __extends(Scrolling, _super);
                function Scrolling(chart) {
                    _super.call(this, chart);
                    this.animationOrder = 100;
                    this.paintOrder = 10;
                    this.updateOrder = 1100;
                    this.animatingFacet = null;
                    this.leftAnimator = null;
                    this.rightAnimator = null;
                    this.activePieReady = false; // keep in mind that active pie needs to re-generated, but that can be done only when chart.width is known.
                    this._shouldZoomOut = false;
                }
                Scrolling.prototype.setState = function (id, offset, count, origin) {
                    if (id.length === 0) {
                        this.chart.error("setPie - array needs at least one item.");
                        return;
                    }
                    var changes = 0;
                    while (this.scene.length() > id.length) {
                        this.scene.pop();
                        changes++;
                    }
                    while (this.scene.length() > 0 && this.scene.peek().id !== id[this.scene.length() - 1]) {
                        this.scene.pop();
                        changes++;
                    }
                    while (this.scene.length() < id.length) {
                        // try to find origin slice
                        var pieId = id[this.scene.length()];
                        this.drillDown(pieId, null);
                        changes++;
                    }
                    var facet = this.scene.peek();
                    this.facet = facet;
                    if (changes) {
                        this.goToPositionDragging(facet.from, facet.to);
                    }
                    // set from/to
                    if (facet.offset !== offset || (count && facet.count !== count)) {
                        var from = offset;
                        var to = void 0;
                        if (count > 0) {
                            to = from + count;
                        }
                        else {
                            to = offset + facet.count;
                        }
                        if (changes) {
                            // active facet changed, set new from, to
                            this.goToPositionDragging(from, to);
                            this.animateFillChart();
                        }
                        else {
                            // changes within the same facet - scroll to new from, to
                            this.goToPosition(from, to, true, Internal.Base.Helpers.performanceNow(), true);
                        }
                    }
                    else if (changes) {
                        // active facet changed, just zoom in/out
                        this.animateFillChart();
                    }
                    this.chart.notifyChartUpdate(origin);
                    if (changes) {
                        this.events.notifySceneChanges({ navigation: true });
                    }
                };
                Scrolling.prototype.getState = function () {
                    var pieIds = [];
                    for (var pieIndex = 0; pieIndex < this.scene.stack.length; pieIndex++) {
                        var pie = this.scene.stack[pieIndex];
                        pieIds.push(pie.id);
                    }
                    var peek = this.scene.peek();
                    return {
                        idArray: pieIds,
                        offset: peek.offset,
                        count: peek.count
                    };
                };
                Scrolling.prototype.goUp = function (origin) {
                    if (this.scene.length() > 1) {
                        this.scene.pop();
                        var f = this.facet = this.scene.peek();
                        this.goToPositionDragging(f.from, f.to);
                        this.animateFillChart();
                        this.events.notifySceneChanges({ navigation: true });
                        this.updateAndNotifyCurrent(origin);
                    }
                    else {
                        // go home and zoom out
                        this.goToPosition(0, this.getMaxItems(), true, Internal.Base.Helpers.performanceNow(), true);
                    }
                };
                Scrolling.prototype.getMaxItems = function () {
                    var m = this.scene.width / this.scene.settings.facetAxis.defaultUnitWidth;
                    if (this.facet.data.totalCount) {
                        m = Math.min(m, this.facet.data.totalCount);
                    }
                    return m;
                };
                Scrolling.prototype.drillDown = function (pieId, origin) {
                    this.stopAnimations();
                    var f = new FacetChart.Facet();
                    f.id = pieId;
                    this.scene.push(f, null);
                    this.chart.builder.updateFacet(f);
                    this.facet = f;
                    this.setFrom(f.from);
                    this.setTo(f.to);
                    this.animateFillChart();
                    this.events.notifySceneChanges({ navigation: true });
                    this.updateAndNotifyCurrent(origin);
                };
                /** --------------
                Inner methods
                -------------- */
                Scrolling.prototype.updateAndNotifyCurrent = function (origin) {
                    this.chart.builder.updateFacet(this.facet);
                    this.chart.notifyChartUpdate(origin);
                };
                Scrolling.prototype.onSceneChange = function (event) {
                    var f = this.facet;
                    var time = event.timeStamp;
                    var sc = event.changes.settingsChanges;
                    if (sc && sc.series) {
                        event.changes.items = true;
                        for (var facetIndex = 0; facetIndex < this.scene.stack.length; facetIndex++) {
                            var facet = this.scene.stack[facetIndex];
                            this.chart.builder.rebuildValues(facet);
                        }
                    }
                    if (event.changes.pieChartPieIds || event.changes.dataArrived || event.changes.data) {
                        this.activePieReady = false;
                        if (event.changes.data || event.changes.dataArrived) {
                            var ids = event.changes.pieChartPieIds || Object.create(null);
                            for (var fi = 0; fi < this.scene.stack.length; fi++) {
                                var facet = this.scene.stack[fi];
                                var rebuild = !facet.data || facet === f || ids[facet.id] || event.changes.dataDeep;
                                if (rebuild) {
                                    facet.rebuild = true;
                                    this.chart.builder.updateFacet(facet, event);
                                    event.changes.items = true;
                                    this.activePieReady = this.activePieReady || (facet === f && !facet.loading);
                                }
                            }
                        }
                    }
                    if (this.activePieReady && this.scene.width > 0) {
                        this.activePieReady = false;
                        if (this.inertiaT.finished(time) && f.from < f.to) {
                            this.setFrom(f.from);
                            this.setTo(f.to);
                            this.animateFillChart();
                        }
                        this.chart.notifyChartUpdate(null);
                    }
                };
                Scrolling.prototype.doAnimations = function (event) {
                    var f = this.facet;
                    if (this.animatingFacet) {
                        f.left = this.leftAnimator.get(event.timeStamp);
                        f.right = this.rightAnimator.get(event.timeStamp);
                        var done = this.leftAnimator.finished(event.timeStamp) || this.rightAnimator.finished(event.timeStamp);
                        if (done) {
                            this.animatingFacet = null;
                            this.leftAnimator = null;
                            this.rightAnimator = null;
                        }
                        this.events.notifySceneChanges({ position: true });
                        event.animating = true;
                    }
                    else {
                        f.opacity = 1;
                    }
                    this.layoutFacets();
                    // build parent facet contents
                    for (var fIndex = 0; fIndex < this.scene.stack.length; fIndex++) {
                        f = this.scene.stack[fIndex];
                        this.chart.builder.updateFacet(f, event);
                    }
                    _super.prototype.doAnimations.call(this, event);
                };
                /** --------------
                Scrolling stuff
                -------------- */
                Scrolling.prototype.xyInArea = function (x, y) {
                    return this.scene.xyInChartOrBottom(x, y);
                };
                Scrolling.prototype.xyToPosition = function (x, y) {
                    return this.scene.xToPosition(x);
                };
                /** called when home button is pressed */
                Scrolling.prototype.onGoHome = function (from, to) {
                    return {
                        from: 0,
                        to: to - from,
                        origin: 0
                    };
                };
                Scrolling.prototype.handleZoomWheel = function (from, to, origin, time, scale) {
                    if (from < 0) {
                        to -= from;
                        from = 0;
                    }
                    var snap1 = this.onSnapWhileDragging(from, to, origin, this.scrollingActive, scale);
                    from = snap1.from;
                    to = snap1.to;
                    var snap2 = this.onSnapAfterDragging(from, to, origin, this.scrollingActive, scale);
                    if (!snap2) {
                        // this handles the go-up action of the facetchart.
                        this.wheelOrigin = null;
                        return;
                    }
                    this.goToPosition(snap2.from, snap2.to, true, time, true);
                };
                /** called when dragging starts, no return value */
                Scrolling.prototype.onStartDragging = function (oldFrom, oldTo, pos) { this.stopAnim(); };
                /** called to determine position snap while dragging, returns snapped [from, to] */
                Scrolling.prototype.onSnapWhileDragging = function (from, to, origin, isScrolling, isScaling) {
                    var diff = to - from;
                    var facet = this.facet;
                    var total = facet.totalCount;
                    var left = 0;
                    var right = 1;
                    var zoomout = false;
                    if (this.scene.stack.length > 1 && (diff > total * 2 || this.scene.width / diff < this.scene.settings.facetAxis.zoomOutUnitWidth)) {
                        // zoom out drag - gesture to go up
                        zoomout = true;
                    }
                    if (zoomout || from < 0) {
                        // make from >=0 by adjusting left
                        left = from / (from - to);
                        from = 0;
                    }
                    if (zoomout || to > total) {
                        right = Math.max(left + 0.1, (total - from) / (to - from));
                        to = total;
                    }
                    this._shouldZoomOut = zoomout;
                    facet.left = left;
                    facet.right = right;
                    return { from: from, to: to };
                };
                /** called to determine position snap after release, returns snapped [from, to]
                also perform any notifications here */
                Scrolling.prototype.onSnapAfterDragging = function (from, to, origin, isScrolling, isScaling) {
                    if (this._shouldZoomOut) {
                        this._shouldZoomOut = false;
                        this.goUp("user");
                        // go up
                        // the `null` value here is important for handleZoomWheel() method.
                        return null;
                    }
                    else {
                        var snapResult = this.snap(from, to, origin, isScrolling, isScaling);
                        from = snapResult.from;
                        to = snapResult.to;
                        this.animateFillChart();
                        this.chart.notifyChartUpdate("user");
                        return { from: from, to: to };
                    }
                };
                /** called when scroll positions have changed, ie - animating */
                Scrolling.prototype.onPositionChanged = function (from, to) {
                    var f = this.facet;
                    f.from = from;
                    f.to = to;
                    this.chart.builder.updateFacet(f);
                    this.events.notifySceneChanges({ position: true });
                };
                /** called when scroll animation is done */
                Scrolling.prototype.onAnimationDone = function (from, to) {
                    this.chart.notifyChartUpdate(null);
                    this.chart.notifyAnimationDone();
                };
                /** Takes the time range and applies snapping rules from settings. */
                Scrolling.prototype.snap = function (from, to, origin, scroll, scale) {
                    var f = this.facet;
                    var total = f.totalCount;
                    if (f.right < 1) {
                        if (f.right === 0)
                            f.right = 1e-10;
                        to = from + (to - from) / f.right;
                    }
                    if (f.left > 0) {
                        if (f.left === 1)
                            f.left = 1 - 1e-10;
                        from = to - (to - from) / (1 - f.left);
                    }
                    // prevent overscale
                    var curItemSize = this.scene.width / (to - from);
                    var itemSize = curItemSize;
                    if (total > 0)
                        itemSize = Math.max(itemSize, this.scene.width / total);
                    itemSize = Math.min(this.scene.settings.facetAxis.maxUnitWidth, itemSize);
                    var scaleFactor = curItemSize / itemSize;
                    from = origin + (from - origin) * scaleFactor;
                    to = origin + (to - origin) * scaleFactor;
                    // prevent overscroll
                    from = Math.round(from);
                    to = Math.round(to);
                    if (from < 0) {
                        to -= from;
                        from = 0;
                    }
                    else if (to > total) {
                        var newFrom = Math.max(0, total - (to - from));
                        to = to - from + newFrom;
                        from = newFrom;
                    }
                    return { from: from, to: to };
                };
                /** --------------
                Layout
                -------------- */
                Scrolling.prototype.animateFillChart = function () {
                    if (this.facet.left !== 0 || this.facet.right !== 1 || this.animatingFacet !== this.facet) {
                        this.animatingFacet = this.facet;
                        this.leftAnimator = new Internal.Base.Animator(this.facet.left, 0, this.scene.settings.interaction.animation.scrollDuration, "<>");
                        this.rightAnimator = new Internal.Base.Animator(this.facet.right, 1, this.scene.settings.interaction.animation.scrollDuration, "<>");
                        this.events.notifySceneChanges({ requestPaint: true });
                    }
                };
                Scrolling.prototype.stopAnim = function () {
                    var f = this.facet;
                    if (this.animatingFacet) {
                        f.opacity = 1;
                        this.animatingFacet = null;
                    }
                    if (this.leftAnimator) {
                        f.left = this.leftAnimator.get(Infinity);
                        this.leftAnimator = null;
                    }
                    if (this.rightAnimator) {
                        f.right = this.rightAnimator.get(Infinity);
                        this.rightAnimator = null;
                    }
                    this.layoutFacets();
                };
                Scrolling.prototype.layoutFacets = function () {
                    for (var i = this.scene.stack.length - 2; i >= 0; i--) {
                        var child = this.scene.stack[i + 1];
                        var parent = this.scene.stack[i];
                        if (child.parentItem) {
                            var getFacetPlacementFromItemResult = this.scene.getFacetPlacementFromItem(child.parentItem, child.left, child.right);
                            parent.left = getFacetPlacementFromItemResult.left;
                            parent.right = getFacetPlacementFromItemResult.right;
                        }
                        parent.opacity = (child.left > 0 || child.right < 1) ? 0.5 : 0;
                    }
                    if (this._shouldZoomOut) {
                        this.facet.opacity = 0.65;
                        this.facet.parentItem.facet.opacity = 1;
                    }
                    else {
                        this.facet.opacity = 1;
                    }
                };
                return Scrolling;
            }(Internal.LinearChart.Scrolling));
            FacetChart.Scrolling = Scrolling;
        })(FacetChart = Internal.FacetChart || (Internal.FacetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="ValueAxis.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var LinearChart;
        (function (LinearChart) {
            var ValueAxisSet = (function () {
                function ValueAxisSet(chart, axisConfigList) {
                    this.axisConfigList = axisConfigList;
                    this.chart = chart;
                    this.axis = Object.create(null);
                    if (axisConfigList.length === 0) {
                        return;
                    }
                    var foundPrimary = false;
                    for (var vaIndex = 0; vaIndex < axisConfigList.length; vaIndex++) {
                        var va = axisConfigList[vaIndex];
                        this.axis[va.id] = new LinearChart.ValueAxis(chart, va);
                        if (!foundPrimary && va.enabled) {
                            foundPrimary = true;
                            this.axis[va.id].isPrimary = true;
                        }
                    }
                }
                ValueAxisSet.prototype.getAxis = function (id) {
                    return this.axis[id];
                };
                ValueAxisSet.prototype.getPanels = function (includeNull) {
                    var panels = [];
                    for (var vaIndex = 0; vaIndex < this.axisConfigList.length; vaIndex++) {
                        var va = this.axisConfigList[vaIndex];
                        var panel = this.axis[va.id].getPanel();
                        if (panel || includeNull) {
                            panels.push(panel);
                        }
                    }
                    return panels;
                };
                ValueAxisSet.prototype.setPanels = function (panels) {
                    for (var i = 0; i < this.axisConfigList.length; i++) {
                        var va = this.axisConfigList[i];
                        this.axis[va.id].setPanel(panels[i]);
                    }
                };
                ValueAxisSet.prototype.updateMinMax = function (event) {
                    for (var name in this.axis) {
                        this.axis[name].updateMinMax(event);
                    }
                    // TODO: sync grid between value axis
                };
                ValueAxisSet.prototype.doAnimations = function (event) {
                    for (var name in this.axis) {
                        this.axis[name].doAnimations(event);
                    }
                };
                ValueAxisSet.prototype.paintUnder = function (event) {
                    for (var name in this.axis) {
                        this.axis[name].paintUnder(event);
                    }
                };
                ValueAxisSet.prototype.paint = function (event) {
                    for (var name in this.axis) {
                        this.axis[name].paint(event);
                    }
                };
                return ValueAxisSet;
            }());
            LinearChart.ValueAxisSet = ValueAxisSet;
        })(LinearChart = Internal.LinearChart || (Internal.LinearChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Stack.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var LinearChart;
        (function (LinearChart) {
            var Series;
            (function (Series) {
                var Cluster = (function () {
                    function Cluster(chart, scene) {
                        this.stacks = [];
                        this.idToStack = {};
                        this.paddingSum = 0;
                        this.scene = scene;
                        this.chart = chart;
                    }
                    /** called after constructor to add all series */
                    Cluster.prototype.addSeries = function (seriesId, seriesConfig, stackConfig, valueAxis) {
                        var stack;
                        if (seriesConfig.stack) {
                            var stackId = seriesConfig.stack + "#" + seriesConfig.type;
                            stack = this.idToStack[stackId];
                            if (!stack) {
                                stack = this.idToStack[stackId] = new Series.Stack(this.chart, this.scene, this, stackConfig, valueAxis);
                                this.stacks.push(stack);
                            }
                        }
                        else {
                            stack = new Series.Stack(this.chart, this.scene, this, stackConfig, valueAxis);
                            this.stacks.push(stack);
                        }
                        stack.addSeries(seriesId, seriesConfig);
                    };
                    /** called after all series have been added */
                    Cluster.prototype.afterInit = function () {
                        for (var stackIndex = 0; stackIndex < this.stacks.length; stackIndex++) {
                            var stack = this.stacks[stackIndex];
                            stack.afterInit();
                        }
                    };
                    /** step 1 of paint loop process is called on every cluster */
                    Cluster.prototype.process = function (seriesData) {
                        // compute horizontal distribution
                        for (var stackIndex = 0; stackIndex < this.stacks.length; stackIndex++) {
                            var stack = this.stacks[stackIndex];
                            stack.process(seriesData);
                        }
                    };
                    /** step 2 of paint loop */
                    Cluster.prototype.afterProcess = function () {
                        for (var stackIndex = 0; stackIndex < this.stacks.length; stackIndex++) {
                            var stack = this.stacks[stackIndex];
                            stack.afterProcess();
                        }
                    };
                    /** step 3 of paint loop */
                    Cluster.prototype.paint = function (event, context) {
                        for (var stackIndex = 0; stackIndex < this.stacks.length; stackIndex++) {
                            var stack = this.stacks[stackIndex];
                            stack.paint(event, context);
                        }
                    };
                    Cluster.prototype.hitTestStack = function (x, y) {
                        var item = null;
                        var distance = Infinity;
                        for (var stackIndex = 0; stackIndex < this.stacks.length; stackIndex++) {
                            var stack = this.stacks[stackIndex];
                            var hitTestStackResult = stack.hitTestStack(x, y);
                            var i = hitTestStackResult.result;
                            var d = hitTestStackResult.distance;
                            if (d < distance) {
                                distance = d;
                                item = i;
                            }
                        }
                        return {
                            result: item,
                            distance: distance
                        };
                    };
                    Cluster.prototype.hitTest = function (x, y, tolerance) {
                        var item = null;
                        var distance = Infinity;
                        for (var stackIndex = 0; stackIndex < this.stacks.length; stackIndex++) {
                            var stack = this.stacks[stackIndex];
                            var hitTestResult = stack.hitTest(x, y, tolerance);
                            var i = hitTestResult.result;
                            var d = hitTestResult.distance;
                            if (d < distance) {
                                distance = d;
                                item = i;
                            }
                        }
                        return {
                            result: item,
                            distance: distance
                        };
                    };
                    /** for info popup */
                    Cluster.prototype.exportData = function (from, to, result) {
                        for (var sIndex = 0; sIndex < this.stacks.length; sIndex++) {
                            var s = this.stacks[sIndex];
                            result.push(s.exportData(from, to));
                        }
                    };
                    /** Called in step 2 from clusters to determine x coordinates
                    Evenly distributes the stacks
                    Used by stacks to determine width */
                    Cluster.prototype.computeStackCenterRadius = function (stack, xes, center, radius) {
                        if (xes.length < 2) {
                            return;
                        }
                        var numStacks = this.stacks.length;
                        var index = this.stacks.indexOf(stack);
                        var centerCoef = (index + 0.5) / numStacks;
                        var radiusCoef = 0.5 / numStacks;
                        var paddingSubstract = 0;
                        var paddingAdd = 0;
                        for (var i = 0; i < this.stacks.length; i++) {
                            var ss = this.stacks[i];
                            paddingSubstract += ss.paddingLeft + ss.paddingRight;
                        }
                        for (var i = 0; i < this.stacks.length; i++) {
                            var ss = this.stacks[i];
                            paddingAdd += ss.paddingLeft;
                            if (ss === stack) {
                                break;
                            }
                            paddingAdd += ss.paddingRight;
                        }
                        var approxStep = xes[1] - xes[0];
                        if (paddingSubstract > approxStep / 2) {
                            paddingSubstract = approxStep / 2;
                            paddingAdd = paddingAdd / approxStep * (approxStep - paddingSubstract);
                        }
                        for (var i = 0; i < xes.length - 1; i++) {
                            var x = xes[i];
                            var width = xes[i + 1] - x - paddingSubstract;
                            center[i] = x + width * centerCoef + paddingAdd;
                            radius[i] = width * radiusCoef;
                        }
                    };
                    return Cluster;
                }());
                Series.Cluster = Cluster;
            })(Series = LinearChart.Series || (LinearChart.Series = {}));
        })(LinearChart = Internal.LinearChart || (Internal.LinearChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/core/ChartEvents.ts" />
/// <reference path="../base/Graphics.ts" />
/// <reference path="../base/Animator.ts" />
/// <reference path="Settings.ts" />
/// <reference path="ValueAxisSet.ts" />
/// <reference path="Series/Stack.ts" />
/// <reference path="Series/Cluster.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var LinearChart;
        (function (LinearChart) {
            var Renderer = (function () {
                function Renderer(chart, valueAxisSet) {
                    this.valueAxisSet = valueAxisSet;
                    this.chart = chart;
                    this.scene = this.chart.scene;
                    this.clusters = [];
                    this.buildSeries();
                }
                /** builds series objects */
                Renderer.prototype.buildSeries = function () {
                    this.clusters = [];
                    var idToCluster = {};
                    var defaultCluster = null;
                    var lineStackClusters = {};
                    var defaultStackConfig = new LinearChart.SettingsStack();
                    var settings = this.scene.settings;
                    // creation order is paint order
                    for (var id = 0; id < settings._computedSeries.length; id++) {
                        var series = settings._computedSeries[id];
                        if (!series.enabled) {
                            continue;
                        }
                        var cluster = void 0;
                        // get cluster
                        if (series.cluster) {
                            cluster = idToCluster[series.cluster];
                            if (!cluster) {
                                cluster = idToCluster[series.cluster] = new LinearChart.Series.Cluster(this.chart, this.scene);
                                this.clusters.push(cluster);
                            }
                        }
                        else {
                            // each line in separate cluster by default, unless stacked that is
                            if (series.type === "line") {
                                if (series.stack) {
                                    if (lineStackClusters.hasOwnProperty(series.stack)) {
                                        cluster = lineStackClusters[series.stack];
                                    }
                                    else {
                                        cluster = lineStackClusters[series.stack] = new LinearChart.Series.Cluster(this.chart, this.scene);
                                        this.clusters.push(cluster);
                                    }
                                }
                                else {
                                    cluster = new LinearChart.Series.Cluster(this.chart, this.scene);
                                    this.clusters.push(cluster);
                                }
                            }
                            else {
                                // all columns in same cluster by default
                                if (!defaultCluster) {
                                    defaultCluster = new LinearChart.Series.Cluster(this.chart, this.scene);
                                    this.clusters.push(defaultCluster);
                                }
                                cluster = defaultCluster;
                            }
                        }
                        // get stack config
                        var stack = settings._computedStacks[series.stack] || defaultStackConfig;
                        cluster.addSeries(id, series, stack, this.valueAxisSet.getAxis(series.valueAxis));
                    }
                    // Do after-inits
                    for (var sIndex = 0; sIndex < this.clusters.length; sIndex++) {
                        var cluster = this.clusters[sIndex];
                        cluster.afterInit();
                    }
                };
                Renderer.prototype.process = function (newData) {
                    // series now process data, find min/max values
                    for (var xIndex = 0; xIndex < this.clusters.length; xIndex++) {
                        var x = this.clusters[xIndex];
                        x.process(newData);
                    }
                };
                Renderer.prototype.afterProcess = function () {
                    // series now convert values to actual x/y representations
                    for (var xIndex = 0; xIndex < this.clusters.length; xIndex++) {
                        var x = this.clusters[xIndex];
                        x.afterProcess();
                    }
                };
                Renderer.prototype.paint = function (event) {
                    var context = event.context;
                    this.scene.seriesWithLabels = 0;
                    for (var clusterIndex = 0; clusterIndex < this.clusters.length; clusterIndex++) {
                        var cluster = this.clusters[clusterIndex];
                        for (var stackIndex = 0; stackIndex < cluster.stacks.length; stackIndex++) {
                            var series = cluster.stacks[stackIndex].series;
                            for (var i = 0; i < series.length; i++) {
                                var s = series[i];
                                if (s.valueLabels && s.valueLabels.enabled)
                                    this.scene.seriesWithLabels++;
                            }
                        }
                    }
                    for (var oIndex = 0; oIndex < this.clusters.length; oIndex++) {
                        var o = this.clusters[oIndex];
                        o.paint(event, context);
                    }
                };
                /** TODO: remove the default value */
                Renderer.prototype.hitTest = function (x, y, tolerance) {
                    if (tolerance === void 0) { tolerance = 4; }
                    var item = null;
                    var distance = Infinity;
                    // first try to get item
                    for (var oIndex = 0; oIndex < this.clusters.length; oIndex++) {
                        var o = this.clusters[oIndex];
                        var hitTestResult = o.hitTest(x, y, tolerance);
                        var i = hitTestResult.result;
                        var dist = hitTestResult.distance;
                        if (dist < distance) {
                            item = i;
                            distance = dist;
                        }
                    }
                    // get a stack without item
                    if (distance > tolerance) {
                        distance = Infinity;
                        item = null;
                        for (var oIndex = 0; oIndex < this.clusters.length; oIndex++) {
                            var o = this.clusters[oIndex];
                            var hitTestStackResult = o.hitTestStack(x, y);
                            var i = hitTestStackResult.result;
                            var dist = hitTestStackResult.distance;
                            if (dist < distance) {
                                item = i;
                                distance = dist;
                            }
                        }
                    }
                    return item;
                };
                /** Params: fromTime, toTime
                Result: [{name:stackName, data:seriesVal}], seriesVal = [{name, values, config}], values = {sum, count, first, last, min,max, avg, change}] */
                Renderer.prototype.exportData = function (from, to) {
                    var result = [];
                    for (var clusterIndex = 0; clusterIndex < this.clusters.length; clusterIndex++) {
                        var cluster = this.clusters[clusterIndex];
                        cluster.exportData(from, to, result);
                    }
                    return result;
                };
                return Renderer;
            }());
            LinearChart.Renderer = Renderer;
        })(LinearChart = Internal.LinearChart || (Internal.LinearChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../linearchart/Renderer.ts" />
/// <reference path="../linearchart/ValueAxisSet.ts" />
/// <reference path="FacetAxis.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var FacetChart;
        (function (FacetChart) {
            var Layer = (function () {
                function Layer(event, chart, facet) {
                    this.bounds = {
                        x0: 0,
                        y0: 0,
                        width: 0,
                        height: 0
                    };
                    this.facet = facet;
                    this.chart = chart;
                    this.scene = this.chart.scene;
                    this.valueAxis = new Internal.LinearChart.ValueAxisSet(this.chart, this.scene.settings._computedValueAxisList);
                    this.xes = [];
                    // build value axis
                    this.facetAxis = new FacetChart.FacetAxis(chart, facet);
                    this.r = new Internal.LinearChart.Renderer(this.chart, this.valueAxis);
                }
                Layer.prototype.getPanels = function () {
                    // since the panels are then paseed to setPanels then it must include even "null"
                    // panels for value axis that are disabled.
                    var panels = this.valueAxis.getPanels(true);
                    panels.push(this.facetAxis.getPanel());
                    return panels;
                };
                Layer.prototype.setPanels = function (panels) {
                    this.valueAxis.setPanels(panels);
                    this.facetAxis.panel = panels[panels.length - 1];
                };
                Layer.prototype.doAnimations = function (event, bounds) {
                    var x = bounds.x0;
                    var y = bounds.y0;
                    var w = bounds.width;
                    var h = bounds.height;
                    var facet = this.facet;
                    var offset = facet.offset;
                    var left = facet.left;
                    var right = facet.right;
                    // move x axis to left and right
                    left = x + w * left;
                    right = x + w * right;
                    var x0 = Math.max(x, left);
                    var x1 = Math.min(x + w, right);
                    this.bounds = {
                        x0: x0,
                        y0: y,
                        width: x1 - x0,
                        height: h
                    };
                    var changes = event.changes;
                    // compute new data and x positions
                    if (changes.position || changes.data || changes.bounds || changes.items) {
                        // compute transform from facet index to screen
                        var trmul = (right - left) / (facet.to - facet.from);
                        var tradd = left - facet.from * trmul;
                        // prepare data
                        var times = [];
                        var xes = [];
                        var min = offset;
                        var max = offset + facet.count;
                        for (var i = min; i <= max + 1; i++) {
                            times.push(i);
                            xes.push(i * trmul + tradd);
                        }
                        this.xes = xes;
                        var values = [];
                        for (var si = 0; si < this.scene.settings._computedSeries.length; si++) {
                            var valueArray = [];
                            var styleArray = [];
                            var countArray = [];
                            for (var i = min; i <= max - 1; i++) {
                                var item = this.facet.items[i - offset];
                                var itemValue = item.values[si];
                                valueArray.push(itemValue.value);
                                countArray.push(1);
                                styleArray.push(itemValue);
                            }
                            values.push({
                                xes: xes,
                                times: times,
                                counts: countArray,
                                fromIndex: 0,
                                toIndex: times.length,
                                values: valueArray,
                                config: styleArray,
                                externalItems: function (from, to) {
                                    var me = this;
                                    return me.config.slice(from, to);
                                }
                            });
                        }
                        // series now process data, find min/max values
                        this.r.process(values);
                    }
                    // values axis now knows min/max values, initiates scale change animations
                    this.valueAxis.updateMinMax(event);
                    // series now convert values to actual x/y representations
                    this.r.afterProcess();
                    /* values axis recalculates locations for labels
                    if there were changes affecting value axis */
                    this.valueAxis.doAnimations(event);
                };
                Layer.prototype.paintScene = function (event) {
                    /* this is the essence of
                    actual painting, delegate to external drivers as
                    much as possible, keeping here pure minimum */
                    var context = event.context;
                    var bounds = this.bounds;
                    var alpha = this.facet.opacity;
                    var axisAlpha = alpha === 1 ? alpha : 0.2;
                    if (alpha === 0)
                        return;
                    context.globalAlpha = axisAlpha;
                    this.valueAxis.paintUnder(event);
                    context.globalAlpha = alpha;
                    Internal.Base.Graphics.pushClip(event, bounds.x0, bounds.y0, bounds.width, bounds.height);
                    this.r.paint(event);
                    Internal.Base.Graphics.popClip(event);
                    context.globalAlpha = axisAlpha;
                    this.facetAxis.paint(event, bounds.x0, bounds.width, this.xes);
                    this.valueAxis.paint(event);
                    context.globalAlpha = 1;
                };
                return Layer;
            }());
            FacetChart.Layer = Layer;
            var Renderer = (function (_super) {
                __extends(Renderer, _super);
                function Renderer(chart) {
                    _super.call(this);
                    this.animationOrder = 400;
                    this.paintOrder = 5;
                    this.updateOrder = 1200;
                    this.chart = chart;
                    this.scene = this.chart.scene;
                    this.events = this.chart.events;
                    this.layers = [];
                    this.panels = [];
                }
                Renderer.prototype.onSceneChange = function (event) {
                    var changes = event.changes;
                    if (changes.settings || changes.navigation || changes.linearChartSeries || changes.linearChartValueAxis) {
                        // update layers stack
                        var sc = changes.settingsChanges;
                        if (changes.linearChartValueAxis || (sc && sc.facetAxis)) {
                            // make chart re-evaluate component placement
                            changes.bounds = true;
                            this.layers = [];
                        }
                        else if (changes.linearChartSeries) {
                            this.layers = [];
                        }
                        for (var i = 0; i < this.layers.length; i++) {
                            var layer = this.layers[i];
                            if (layer.facet !== this.scene.stack[i]) {
                                this.layers = this.layers.slice(0, i);
                            }
                        }
                        while (this.layers.length < this.scene.stack.length) {
                            var f = this.scene.stack[this.layers.length];
                            var l = new Layer(event, this.chart, f);
                            this.layers.push(l);
                        }
                        if (this.layers.length === 0) {
                            // build dummy layer with id = null
                            this.layers.push(new Layer(event, this.chart, new FacetChart.Facet()));
                        }
                        // update panels
                        var panels = this.layers[0].getPanels();
                        this.panels = panels.filter(function (o) { return o != null; });
                        for (var lIndex = 0; lIndex < this.layers.length; lIndex++) {
                            this.layers[lIndex].setPanels(panels);
                        }
                    }
                };
                Renderer.prototype.getPanels = function () {
                    return this.panels;
                };
                Renderer.prototype.doAnimations = function (event) {
                    for (var layerIndex = 0; layerIndex < this.layers.length; layerIndex++) {
                        var layer = this.layers[layerIndex];
                        layer.doAnimations(event, this.scene);
                    }
                };
                Renderer.prototype.paintScene = function (event) {
                    for (var layerIndex = 0; layerIndex < this.layers.length; layerIndex++) {
                        var layer = this.layers[layerIndex];
                        layer.paintScene(event);
                    }
                };
                Renderer.prototype.exportData = function (from, to) {
                    return this.layers[this.layers.length - 1].r.exportData(from, to);
                };
                Renderer.prototype.hitTest = function (x, y) {
                    if (!(this.scene.xyInChart(x, y) && this.layers.length > 0)) {
                        return null;
                    }
                    return this.layers[this.layers.length - 1].r.hitTest(x, y, this.scene.settings.interaction.selection.tolerance);
                };
                return Renderer;
            }(Internal.Base.ChartElement));
            FacetChart.Renderer = Renderer;
        })(FacetChart = Internal.FacetChart || (Internal.FacetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Scene.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var FacetChart;
        (function (FacetChart) {
            var Builder = (function () {
                function Builder(chart) {
                    this.chart = chart;
                    this.scene = chart.scene;
                    this.loading = false;
                }
                Builder.prototype.updateFacet = function (facet, event) {
                    if (event === void 0) { event = null; }
                    var dataSource = this.chart.getData("default");
                    var data = facet.data;
                    if (!data || (event && (event.changes.data || event.changes.dataArrived || event.changes.filters))) {
                        data = facet.data = dataSource.getPieData(facet.id);
                        if (!data) {
                            facet.loading = true;
                            dataSource.requestPieData(facet.id, Math.floor(facet.from));
                            return;
                        }
                    }
                    var changes = false;
                    // setup initial from to
                    if (this.scene.width && (!(facet.from < facet.to) || facet.rebuild)) {
                        facet.rebuild = false;
                        // figure out how many items to show
                        var minSliceCount = Math.max(1, Math.floor(this.scene.width / this.scene.settings.facetAxis.maxUnitWidth));
                        var itemsToShow = Math.max(1, Math.floor(this.scene.width / this.scene.settings.facetAxis.defaultUnitWidth));
                        if (data.totalCount) {
                            itemsToShow = Math.min(data.totalCount, itemsToShow);
                        }
                        itemsToShow = Math.max(minSliceCount, itemsToShow);
                        facet.offset = Math.floor(facet.from);
                        facet.count = 0;
                        facet.to = facet.from + (itemsToShow | 0);
                        facet.items = [];
                    }
                    // build pie items
                    var fromOffset = Math.max(0, (facet.from | 0) - 2);
                    var toOffset = Math.ceil(facet.to + 2);
                    var toData = data.values.length + data.offset;
                    var fromData = data.offset;
                    facet.loading = false;
                    if (fromData > fromOffset) {
                        fromOffset = fromData;
                        dataSource.requestLessPieData(facet.id);
                        facet.loading = true;
                    }
                    if (toData < toOffset) {
                        toOffset = toData;
                        if (!data.done) {
                            dataSource.requestMorePieData(facet.id);
                            facet.loading = true;
                        }
                    }
                    var curToOffset = facet.offset + facet.items.length;
                    // clear all items if no common items found
                    if (toOffset < facet.offset || fromOffset > curToOffset) {
                        facet.offset = fromOffset;
                        facet.items = [];
                        curToOffset = fromOffset;
                    }
                    // add/remove items before
                    if (fromOffset > facet.offset) {
                        facet.items = facet.items.slice(fromOffset - facet.offset);
                    }
                    else if (fromOffset < facet.offset) {
                        var newItems = [];
                        for (var i = fromOffset; i <= facet.offset - 1; i++) {
                            newItems.push(this.buildItem(facet, data, i));
                        }
                        facet.items = newItems.concat(facet.items);
                        changes = true;
                    }
                    facet.offset = fromOffset;
                    // add/remove items after
                    if (toOffset < curToOffset) {
                        facet.items = facet.items.slice(0, toOffset - facet.offset);
                    }
                    else if (toOffset > curToOffset) {
                        for (var i = curToOffset; i < toOffset; i++) {
                            facet.items.push(this.buildItem(facet, data, i));
                        }
                        changes = true;
                    }
                    facet.count = facet.items.length;
                    facet.totalCount = Math.max(facet.offset + facet.count, data.totalCount || 0);
                    // notify changes
                    if (changes) {
                        if (event) {
                            event.changes.items = true;
                            if (!event.changes.changedItems) {
                                event.changes.changedItems = {};
                            }
                            event.changes.changedItems[facet.id] = true;
                        }
                        else {
                            var pieIds = {};
                            pieIds[facet.id] = true;
                            this.chart.events.notifySceneChanges({
                                items: true,
                                changedItems: pieIds
                            });
                        }
                    }
                    // link to child/parent items
                    return this.scene.updateLinks(facet);
                };
                Builder.prototype.rebuildValues = function (facet) {
                    for (var itemIndex = 0; itemIndex < facet.items.length; itemIndex++) {
                        var item = facet.items[itemIndex];
                        this.updateItem(item);
                    }
                };
                Builder.prototype.buildItem = function (facet, data, index) {
                    var value = data.values[index - data.offset];
                    var item = new FacetChart.Item(facet, value.__id, index, value);
                    this.updateItem(item);
                    return item;
                };
                Builder.prototype.updateItem = function (item) {
                    var values = [];
                    // compute values
                    for (var seriesIndex = 0; seriesIndex < this.scene.settings._computedSeries.length; seriesIndex++) {
                        var series = this.scene.settings._computedSeries[seriesIndex];
                        var value = new FacetChart.ItemValue(item.facet, item.id, item.index, item.data, series.id);
                        if (item.data) {
                            value.value = this.getSeriesValue(item.data, series);
                        }
                        else {
                            value.value = null;
                        }
                        values.push(value);
                    }
                    item.values = values;
                };
                Builder.prototype.getSeriesValue = function (data, series) {
                    var func = series.data.valueFunction;
                    var val = null;
                    if (func) {
                        val = func(data);
                    }
                    else {
                        var field = series.data.field || "value";
                        val = data[field];
                    }
                    return Internal.Base.Helpers.tryParseFloat(val, null);
                };
                Builder.prototype.buildPreviewData = function (item, series) {
                    var id = item.id;
                    var sceneData = this.scene.mainData;
                    var data = sceneData.getPieData(id);
                    var pvd = null;
                    if (!data) {
                        if (item.expandable && sceneData.canExpand(id)) {
                            sceneData.requestPieData(item.id, 0);
                        }
                    }
                    else if (data.offset > 0) {
                        sceneData.requestLessPieData(item.id);
                    }
                    else {
                        // we are good, build previewData
                        pvd = [];
                        var sum = 0;
                        for (var valIndex = 0; valIndex < data.values.length; valIndex++) {
                            var val = data.values[valIndex];
                            var v = this.getSeriesValue(val, series);
                            pvd.push(v);
                            sum += v;
                        }
                        if (sum > 0) {
                            sum = 1 / sum;
                            for (var i = 0; i < pvd.length; i++) {
                                pvd[i] = pvd[i] * sum;
                            }
                        }
                        else {
                            pvd = null;
                        }
                    }
                    return pvd;
                };
                return Builder;
            }());
            FacetChart.Builder = Builder;
        })(FacetChart = Internal.FacetChart || (Internal.FacetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Scene.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var FacetChart;
        (function (FacetChart) {
            var Styles = (function (_super) {
                __extends(Styles, _super);
                function Styles(chart) {
                    _super.call(this);
                    this.animationOrder = 200;
                    this.paintOrder = 20;
                    this.updateOrder = 900;
                    this.chart = chart;
                    this.scene = chart.scene;
                }
                Styles.prototype.doAnimations = function (event) {
                    if (!(event.changes.settings || event.changes.items || event.changes.selection || event.changes.navigation)) {
                        return;
                    }
                    var facet = this.scene.activeFacet;
                    if (!facet) {
                        return;
                    }
                    // rebuild style
                    this.computeFacetStyleRec(facet);
                    while (facet && facet.parentItem) {
                        facet = facet.parentItem.facet;
                        this.computeFacetStyleRec(facet);
                    }
                };
                Styles.prototype.computeFacetStyleRec = function (facet) {
                    this.computeFacetStyle(facet);
                    for (var i = 0; i < facet.items.length; i++) {
                        var item = facet.items[i];
                        this.computeItemStyle(facet, item);
                        if (item.innerFacet) {
                            this.computeFacetStyleRec(item.innerFacet);
                        }
                    }
                };
                Styles.prototype.computeFacetStyle = function (facet) {
                    // TODO:
                };
                Styles.prototype.computeItemStyle = function (facet, item) {
                    var series = this.scene.settings._computedSeries;
                    Internal.Base.Helpers.extendStyleTo(this.scene.settings.items.style, item);
                    /* if item.selected
                    Base_Helpers.extend(item, @scene.settings.items.selectedStyle)
                    
                    if @scene.hoverItem == item
                    Base_Helpers.extend(item, @scene.settings.items.hoverStyle) */
                    if (item.data.style) {
                        Internal.Base.SettingsHelper.updateRecursive(item, item.data.style, Internal.Base.SettingsMapping.FacetChartSettingsFacetStyle, {});
                    }
                    if (item.id === item.facet.activeItemId) {
                        for (var i = 0; i < item.values.length; i++) {
                            var value = item.values[i];
                            value.style.fillColor = null;
                            value.style.lineColor = null;
                        }
                    }
                    else {
                        for (var i = 0; i < item.values.length; i++) {
                            var value = item.values[i];
                            Internal.Base.Helpers.extendStyleTo(series[i].style, value.style);
                        }
                    }
                    // apply style functions
                    if (this.scene.settings.items.styleFunction) {
                        this.scene.settings.items.styleFunction(item, item.data);
                        if (item.label && !Internal.Base.Helpers.isString(item.label)) {
                            item.label = "" + item.label;
                        }
                    }
                    else {
                        if (item.data.name) {
                            item.label = item.data.name;
                        }
                    }
                    if (item.id !== item.facet.activeItemId) {
                        for (var i = 0; i < item.values.length; i++) {
                            var value = item.values[i];
                            var s = series[i];
                            // compute preview data
                            if (value.style.previewContents) {
                                value.previewData = this.chart.builder.buildPreviewData(item, s);
                            }
                            else {
                                value.previewData = null;
                            }
                        }
                    }
                    else {
                        item.values[item.values.length - 1].previewData = null;
                    }
                };
                return Styles;
            }(Internal.Base.ChartElement));
            FacetChart.Styles = Styles;
        })(FacetChart = Internal.FacetChart || (Internal.FacetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../linearchart/Impl.ts" />
/// <reference path="../piechart/Data.ts" />
/// <reference path="Scene.ts" />
/// <reference path="Settings.ts" />
/// <reference path="Scrolling.ts" />
/// <reference path="Renderer.ts" />
/// <reference path="Builder.ts" />
/// <reference path="Styles.ts" />
/// <reference path="InfoPopup.ts" />
/// <reference path="Selection.ts" />
/// <reference path="ScrollButtons.ts"/>
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var FacetChart;
        (function (FacetChart) {
            var Impl = (function (_super) {
                __extends(Impl, _super);
                function Impl(settings, api) {
                    _super.call(this, new FacetChart.Settings(settings), new FacetChart.Scene(), api);
                    // prepare components
                    this.builder = new FacetChart.Builder(this);
                    this.renderer = this.events.addElement(new FacetChart.Renderer(this));
                    this.scrolling = this.events.addElement(new FacetChart.Scrolling(this));
                    this.selection = this.events.addElement(new FacetChart.Selection(this));
                    this.events.addElement(new FacetChart.Styles(this));
                    this.events.addElement(new FacetChart.InfoPopup(this));
                    this.events.addElement(new Internal.LinearChart.Highlights(this));
                    this.scrollButtons = this.events.addElement(new FacetChart.ScrollButtons(this));
                    this.finalInitialize();
                    this.scrolling.setState(this.settings.navigation.initialDrilldown, this.settings.navigation.initialOffset, 0, "init");
                }
                Impl.prototype.createDataObj = function (settings) {
                    return new Internal.PieChart.Data(this, settings, true);
                };
                Impl.prototype.getData = function (id) {
                    return _super.prototype.getData.call(this, id);
                };
                Impl.prototype.onSettingsChanged = function (changes) {
                    var ch = {
                        settings: true,
                        settingsChanges: changes,
                        items: false
                    };
                    // update data
                    if (changes.navigation) {
                        this.scrolling.setState(this.settings.navigation.initialDrilldown, this.settings.navigation.initialOffset, null, "api");
                    }
                    if (changes.series || changes.interaction) {
                        ch.items = true;
                    }
                    this.events.notifySceneChanges(ch);
                    if (changes.data || changes.facetAxis) {
                        this.updateSize(true);
                    }
                };
                Impl.prototype.updateFilters = function () {
                    // overrides base functionality
                    return this.updateFilter(true);
                };
                Impl.prototype.updateFilter = function (deep) {
                    if (deep === void 0) { deep = false; }
                    this.log("Update filter");
                    var dataChanges = {};
                    for (var k in this.settings._computedDataMap)
                        dataChanges[k] = true;
                    this.events.notifySceneChanges({ data: dataChanges, dataDeep: deep });
                };
                Impl.prototype.setSelection = function (selection, origin) {
                    if (origin === void 0) { origin = "api"; }
                    this.log("Set selection");
                    var realSelection = [];
                    var selectionIds = [];
                    for (var nIndex = 0; nIndex < selection.length; nIndex++) {
                        var n = selection[nIndex];
                        if (n instanceof FacetChart.Item) {
                            realSelection.push(n);
                        }
                        else if (Internal.Base.Helpers.isString(n)) {
                            selectionIds.push(n);
                        }
                        else {
                            this.error("SetSelection: Selection contents must be FacetChart.Item object or string, got " + (typeof n));
                        }
                    }
                    this.selection.setSelection(realSelection, selectionIds, false, origin);
                };
                Impl.prototype.exportVisibleData = function () {
                    var p = this.scene.peek();
                    if (!p)
                        return [];
                    return Internal.PieChart.Data.exportValues(p.data);
                };
                Impl.prototype.setPie = function (root, offset, count, animate) {
                    if (count === void 0) { count = null; }
                    if (animate === void 0) { animate = true; }
                    this.log("Set pie");
                    this.scrolling.setState(root, offset, count, "api");
                };
                Impl.prototype.getPie = function () {
                    return this.scrolling.getState().idArray;
                };
                Impl.prototype.getPieOffset = function () {
                    return this.scrolling.getState().offset;
                };
                Impl.prototype.getActiveItems = function () {
                    var r = [];
                    for (var pieIndex = 0; pieIndex < this.scene.stack.length; pieIndex++) {
                        var pie = this.scene.stack[pieIndex];
                        if (pie.parentItem) {
                            r.push(pie.parentItem);
                        }
                    }
                    return r;
                };
                Impl.prototype.getActiveFacets = function () {
                    return this.scene.stack;
                };
                Impl.prototype.zoomOut = function (animate, origin) {
                    if (animate === void 0) { animate = true; }
                    if (origin === void 0) { origin = "api"; }
                    this.scrolling.goUp(origin);
                };
                Impl.prototype.zoomOutPossible = function () {
                    var scene = this.scene;
                    return scene.length() > 1 || scene.peek().offset > 0;
                };
                Impl.prototype.getBottomHeight = function () {
                    return this.scene.chartHeight - this.settings.facetAxis.size;
                };
                Impl.prototype.expandItem = function (item, origin) {
                    var facet = item.facet;
                    if (facet === this.scene.peek()) {
                        var id = item.id;
                        if (item.expandable && this.scene.mainData.canExpand(id)) {
                            this.setSelection([]);
                            this.scrolling.drillDown(id, origin);
                            return true;
                        }
                    }
                    return false;
                };
                /** events */
                Impl.prototype.saveNavigation = function () {
                    var pie = this.scene.peek();
                    if (!pie || this.scrolling.isActive())
                        return null;
                    return this.scrolling.getState();
                };
                Impl.prototype.restoreNavigation = function (state, animate, origin) {
                    return this.scrolling.setState(state.idArray, state.offset, state.count, origin);
                };
                Impl.prototype.save = function () {
                    var selectionIds = this.scene.selectionIds.splice(0);
                    for (var sIndex = 0; sIndex < this.scene.selection.length; sIndex++) {
                        var s = this.scene.selection[sIndex];
                        selectionIds.push(s.id);
                    }
                    var state = this.scrolling.getState();
                    return JSON.stringify({
                        pie: state.idArray,
                        offset: state.offset,
                        count: state.count,
                        selection: selectionIds
                    });
                };
                Impl.prototype.restore = function (stateStr, animate) {
                    if (!stateStr) {
                        return;
                    }
                    var pie = JSON.parse(stateStr);
                    this.setPie(pie.pie, pie.offset, pie.count, animate);
                    this.setSelection(pie.selection);
                };
                Impl.prototype.createEventArguments = function (event, origin, clickedItem) {
                    var scene = this.scene;
                    var f = scene.peek();
                    var cf = clickedItem ? clickedItem.facet : null;
                    var hoverInfo = scene.hoverSeriesItem;
                    var hoverSeries = (hoverInfo && hoverInfo.seriesIndex != null) ? scene.settings._computedSeries[hoverInfo.seriesIndex] : null;
                    return {
                        chart: this.api,
                        origin: origin,
                        facet: f,
                        offset: f ? f.offset : null,
                        count: f ? f.count : null,
                        hoverItem: scene.hoverItem,
                        hoverSeries: hoverSeries,
                        hoverMarker: hoverInfo ? hoverInfo.isMarker : false,
                        selection: scene.selection.slice(),
                        clickItem: clickedItem,
                        clickFacet: cf
                    };
                };
                Impl.prototype.defaultClick = function (event, args) {
                    var s = args.clickItem;
                    if (s) {
                        if (s.url) {
                            Internal.Base.Helpers.openUrl(s.url, s.urlTarget);
                            event.preventDefault();
                        }
                        else {
                            if (this.expandItem(s, "user")) {
                                event.preventDefault();
                            }
                        }
                    }
                };
                return Impl;
            }(Internal.LinearChart.Impl));
            FacetChart.Impl = Impl;
        })(FacetChart = Internal.FacetChart || (Internal.FacetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="ZoomCharts.d.ts" />
/// <reference path="facetchart/Settings.ts" />
/// <reference path="facetchart/Impl.ts" />
/// <reference path="base/Api.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    /** @api-class */
    var FacetChart = (function (_super) {
        __extends(FacetChart, _super);
        function FacetChart(settings) {
            var _this = this;
            _super.call(this);
            this.typeName = "FacetChart";
            if (FacetChart.chartFactoryMethod) {
                this._impl = FacetChart.chartFactoryMethod(function (stngs) { return new ZoomCharts.Internal.FacetChart.Impl(stngs, _this); }, settings);
            }
            else {
                this._impl = new ZoomCharts.Internal.FacetChart.Impl(settings, this);
            }
        }
        FacetChart.prototype.updateSettings = function (changes) {
            _super.prototype.updateSettings.call(this, changes);
            return this;
        };
        FacetChart.prototype.replaceSettings = function (changes) {
            _super.prototype.replaceSettings.call(this, changes);
            return this;
        };
        FacetChart.prototype.addData = function (data, sourceId) {
            if (sourceId == null)
                sourceId = "default";
            this._impl.addData(data, sourceId);
        };
        FacetChart.prototype.replaceData = function (data, sourceId) {
            if (sourceId == null)
                sourceId = "default";
            this._impl.replaceData(data, sourceId);
        };
        FacetChart.prototype.updateFilter = function () {
            this._impl.updateFilter();
            return this;
        };
        FacetChart.prototype.selection = function (selected) {
            /* Set/get selection in javascript timestamp (milliseconds).
            Use null, null to remove selection.
            returns [from, to] in list form. */
            if (selected) {
                if (!Array.isArray(selected)) {
                    this._impl.error("FacetChart.selection() - the argument must be an array of FacetChart.Item objects or strings.");
                }
                else {
                    var ids = selected.slice();
                    for (var i = 0; i < ids.length; i++) {
                        var n = ids[i];
                        if (n instanceof ZoomCharts.Internal.FacetChart.Item) {
                            // the user of the public API might be passing in slice objects that are long gone from the chart. To avoid issues in
                            // such cases, use the ID values and not the slice instances themselves.
                            ids[i] = n.id;
                        }
                        else if (!ZoomCharts.Internal.Base.Helpers.isString(n)) {
                            this._impl.error("FacetChart.selection() - the argument must be an array of FacetChart.Item objects or strings.");
                        }
                    }
                    this._impl.setSelection(ids);
                }
            }
            return this._impl.scene.selection.slice();
        };
        FacetChart.prototype.setPie = function (pieId, offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = null; }
            if (!Array.isArray(pieId))
                pieId = [pieId];
            this._impl.setPie(pieId, offset, count);
            return this;
        };
        FacetChart.prototype.getPie = function () {
            return this._impl.getPie();
        };
        FacetChart.prototype.getPieOffset = function () {
            return this._impl.getPieOffset();
        };
        FacetChart.prototype.getActiveItems = function () {
            return this._impl.getActiveItems();
        };
        FacetChart.prototype.getActiveFacets = function () {
            return this._impl.getActiveFacets();
        };
        FacetChart.prototype.getActiveFacet = function () {
            var p = this._impl.getActiveFacets();
            return p[p.length - 1];
        };
        FacetChart.prototype.expandSlice = function (slice) {
            return this._impl.expandItem(slice, "api");
        };
        /** Replaces the existing series configuration with new one instead of merging it like `updateSettings`.
        @deprecated - Use `replaceSettings({series: seriesData})` instead. */
        FacetChart.prototype.replaceSeries = function (series) {
            this._impl.deprecated("replaceSeries", "replaceSettings");
            return this.replaceSettings({ series: series });
        };
        FacetChart.prototype.on = function (name, listener) {
            _super.prototype.on.call(this, name, listener);
        };
        /* tslint:enable:max-line-length */
        /** Gets the currently enabled series
            @version 1.14.0
        */
        FacetChart.prototype.getEnabledSeries = function () {
            return this._impl.getEnabledSeries();
        };
        FacetChart.themes = {
            "dark": ZoomCharts.Internal.FacetChart.Settings.DarkTheme
        };
        /**
         * An internal method that is used by the test runner engine to automatically pass the generated settings when a new chart instance is created.
         * @ignore
         */
        FacetChart.chartFactoryMethod = null;
        return FacetChart;
    }(ZoomCharts.Internal.Base.Api));
    ZoomCharts.FacetChart = FacetChart;
    ZoomCharts.Internal.Base.Helpers.exportSymbol("FacetChart", ZoomCharts.FacetChart);
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Scene.ts" />
/// <reference path="../base/Geometry.ts" />
/// <reference path="../base/Rect.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var ItemsChart;
        (function (ItemsChart) {
            /**
             * A small helper class for storing a set of links or nodes used by selection.
             * Since the same ID may appear for links/nodes in different layers, and the selection can contain them all, the dictionary by ID contains arrays.
             */
            var SelectionSet = (function () {
                function SelectionSet() {
                    this._dict = new Object(null);
                    this._count = 0;
                }
                SelectionSet.prototype.add = function (o) {
                    var arr = this._dict[o.id];
                    if (!arr) {
                        this._dict[o.id] = [o];
                    }
                    else {
                        arr.push(o);
                    }
                    this._count++;
                };
                SelectionSet.prototype.remove = function (o) {
                    var arr = this._dict[o.id];
                    if (arr)
                        Internal.Base.Helpers.removeFromArrayHasty(arr, o);
                    this._count--;
                };
                SelectionSet.prototype.contains = function (o) {
                    var arr = this._dict[o.id];
                    return arr && arr.indexOf(o) >= 0;
                };
                SelectionSet.prototype.clone = function () {
                    var ret = new SelectionSet();
                    for (var i in this._dict) {
                        ret._dict[i] = this._dict[i].slice();
                    }
                    ret._count = this._count;
                    return ret;
                };
                SelectionSet.prototype.count = function () {
                    return this._count;
                };
                return SelectionSet;
            }());
            var Scene = (function (_super) {
                __extends(Scene, _super);
                function Scene() {
                    _super.apply(this, arguments);
                    this.centerX = 0;
                    this.centerY = 0;
                    this.zoom = 1;
                    this.hoverNode = null;
                    this.hoverLink = null;
                    this.hoverItem = null;
                    this.lastClickedNode = null;
                    this.selection = [];
                    this.selectionSet = new SelectionSet();
                    this.notifyChanges = true;
                    this.lastNotifiedSelectionSet = new SelectionSet();
                    // true for normal auto zoom, "overview" for overview zoom, false for manual
                    this.autoZoomMode = false;
                    this.layoutActive = false;
                }
                Scene.prototype.xyInChart = function (x, y) {
                    return (x >= this.x0) && (x < this.x0 + this.width) && (y >= this.y0) && (y < this.y0 + this.height);
                };
                Scene.prototype.toDisplay = function (x, y) {
                    return {
                        x: (x - this.centerX) * this.zoom + this.x0 + this.width * 0.5,
                        y: (y - this.centerY) * this.zoom + this.y0 + this.height * 0.5
                    };
                };
                Scene.prototype.fromDisplay = function (x, y) {
                    return {
                        x: (x - this.x0 - this.width * 0.5) / this.zoom + this.centerX,
                        y: (y - this.y0 - this.height * 0.5) / this.zoom + this.centerY
                    };
                };
                Scene.prototype.toDisplayTransform = function () {
                    // xd = t[0] * x + t[1], yd = t[2]*y + t[3]
                    return {
                        xm: this.zoom,
                        xa: this.x0 + this.width * 0.5 - this.centerX * this.zoom,
                        ym: this.zoom,
                        ya: this.y0 + this.height * 0.5 - this.centerY * this.zoom
                    };
                };
                Scene.prototype.objectRemoved = function (obj) {
                    if (Internal.Base.Helpers.removeFromArray(this.selection, obj)) {
                        obj.selected = false;
                    }
                    if (this.hoverNode === obj || this.hoverLink === obj) {
                        this.setActiveObject(null, null);
                    }
                };
                Scene.prototype.addToSelection = function (newItem) {
                    if (this.selectionSet.contains(newItem))
                        return false;
                    this.selectionSet.add(newItem);
                    this.selection.push(newItem);
                    newItem.layer.touchNodeOrLink(newItem);
                    newItem.selected = true;
                    return true;
                };
                Scene.prototype.removeFromSelection = function (newItem) {
                    if (!this.selectionSet.contains(newItem))
                        return false;
                    this.selectionSet.remove(newItem);
                    Internal.Base.Helpers.removeFromArray(this.selection, newItem);
                    newItem.selected = false;
                    newItem.layer.touchNodeOrLink(newItem);
                    return true;
                };
                Scene.prototype.setSelection = function (newSelected) {
                    var oldSelectionSet = this.selectionSet;
                    var oldSelection = this.selection;
                    var newSelectionSet = new SelectionSet();
                    var newSelection = [];
                    var hasChanges = false;
                    // Add ones that aren't there yet.
                    for (var i = 0; i < newSelected.length; i++) {
                        var o = newSelected[i];
                        if (!newSelectionSet.contains(o)) {
                            newSelectionSet.add(o);
                            newSelection.push(o);
                        }
                        if (!oldSelectionSet.contains(o)) {
                            oldSelectionSet.add(o); // Also add to oldDict to prevent this item from being added double.
                            o.selected = true;
                            hasChanges = true;
                            o.layer.touchNodeOrLink(o);
                        }
                    }
                    // Remove ones that aren't there anymore
                    for (var i = 0; i < oldSelection.length; i++) {
                        var o = oldSelection[i];
                        if (!newSelectionSet.contains(o)) {
                            o.selected = false;
                            o.layer.touchNodeOrLink(o);
                            hasChanges = true;
                        }
                    }
                    this.selectionSet = newSelectionSet;
                    this.selection = newSelection;
                    return hasChanges;
                };
                Scene.prototype.setActiveObject = function (obj, item) {
                    if (this.hoverNode) {
                        this.hoverNode.layer.touchNode(this.hoverNode);
                        for (var linkIndex = 0; linkIndex < this.hoverNode.links.length; linkIndex++) {
                            var link = this.hoverNode.links[linkIndex];
                            link.layer.touchLink(link);
                        }
                        this.hoverNode.hovered = false;
                        this.hoverNode.locks--;
                    }
                    if (this.hoverLink) {
                        this.hoverLink.layer.touchLink(this.hoverLink);
                        this.hoverLink.from.layer.touchNode(this.hoverLink.from);
                        this.hoverLink.to.layer.touchNode(this.hoverLink.to);
                        this.hoverLink.hovered = false;
                    }
                    this.hoverNode = null;
                    this.hoverLink = null;
                    this.hoverItem = item;
                    if (obj instanceof ItemsChart.Node) {
                        this.hoverNode = obj;
                        obj.hovered = true;
                        obj.locks++;
                        this.hoverNode.layer.touchNode(this.hoverNode);
                        for (var linkIndex = 0; linkIndex < this.hoverNode.links.length; linkIndex++) {
                            var link = this.hoverNode.links[linkIndex];
                            link.layer.touchLink(link);
                        }
                    }
                    else if (obj instanceof ItemsChart.Link) {
                        this.hoverLink = obj;
                        obj.hovered = true;
                        this.hoverLink.layer.touchLink(this.hoverLink);
                        this.hoverLink.from.layer.touchNode(this.hoverLink.from);
                        this.hoverLink.to.layer.touchNode(this.hoverLink.to);
                    }
                    else if (obj !== null) {
                        throw ("scene.setActiveObject invalid active object type " + obj);
                    }
                };
                Scene.prototype.getVisibleBounds = function () {
                    var fromDisplayResult = this.fromDisplay(this.x0, this.y0);
                    var x0 = fromDisplayResult.x;
                    var y0 = fromDisplayResult.y;
                    fromDisplayResult = this.fromDisplay(this.x0 + this.width, this.y0 + this.height);
                    var x1 = fromDisplayResult.x;
                    var y1 = fromDisplayResult.y;
                    return new Internal.Base.Rect(x0, y0, x1, y1);
                };
                Scene.prototype.disableSelectionChangeNotification = function () {
                    this.notifyChanges = false;
                };
                Scene.prototype.enableSelectionChangeNotification = function () {
                    this.notifyChanges = true;
                };
                Scene.prototype.notifySelectionChangesIfNeeded = function (chart, origin) {
                    if (!this.notifyChanges)
                        return;
                    var hasChanges = false;
                    for (var i = 0; i < this.selection.length; i++) {
                        if (!this.lastNotifiedSelectionSet.contains(this.selection[i])) {
                            hasChanges = true;
                            break;
                        }
                    }
                    if (hasChanges || this.selection.length !== this.lastNotifiedSelectionSet.count()) {
                        chart.events.notifySceneChanges({ selection: true });
                        chart.notifySelectionChanged(chart.createEventArguments(null, origin));
                        this.lastNotifiedSelectionSet = this.selectionSet.clone();
                    }
                };
                return Scene;
            }(Internal.Base.Scene));
            ItemsChart.Scene = Scene;
        })(ItemsChart = Internal.ItemsChart || (Internal.ItemsChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../base/Graphics.ts" />
/// <reference path="../../base/Rect.ts" />
/// <reference path="../../base/Geometry.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var ItemsChart;
        (function (ItemsChart) {
            var PI2 = Math.PI * 2;
            var Shape = (function () {
                function Shape(node, nodesLayer) {
                    this.node = node;
                    this.nodesLayer = nodesLayer;
                }
                /**
                 * Method called after style update, to prepare the shape for painting
                 * @param nodeStyleSettings
                 * @param context
                 * @param itemRenderer - The label renderer of this context
                 */
                Shape.prototype.postProcess = function (nodeStyleSettings, context, itemRenderer) {
                    var node = this.node;
                    node.targetHWidth = node.targetHHeight;
                    node.bounds = new Internal.Base.Rect(-node.targetHHeight, -node.targetHHeight, node.targetHHeight, node.targetHHeight);
                    this.sizeScale = node.targetHHeight / nodeStyleSettings.nodeLabelScaleBase;
                    this.postProcessLabel(context, itemRenderer);
                };
                /**
                 * Label preparation for node during postprocess
                 */
                Shape.prototype.postProcessLabel = function (g, labelRenderer) {
                    var node = this.node;
                    var xx;
                    var yy;
                    var scale;
                    if (node.label != null && this.nodesLayer.chart.assetsLoaded) {
                        var text = node.label.toString();
                        if (text.length === 0) {
                            this.currentLabel = null;
                        }
                        else {
                            var l = this.currentLabel;
                            if (l == null) {
                                l = this.currentLabel = new Internal.Base.Label(node.labelStyle, true);
                            }
                            else {
                                // Updates label style without recreating the label itself. Recreating the label will trigger a potentially needless onSceneChange().
                                l.style = node.labelStyle;
                            }
                            l.text = text;
                            // TODO: duplicate code below with Renderer
                            labelRenderer.measure(g, l);
                            if (l.style.scaleWithSize) {
                                scale = this.sizeScale;
                            }
                            else if (l.style.scaleWithZoom) {
                                scale = 1;
                            }
                            else {
                                // stopgap value, as this is zoom dependant
                                scale = 1;
                            }
                            xx = 0;
                            yy = node.targetHHeight + l.hheight * scale * 0.8;
                            node.outerBounds.addBounds(xx - l.hwidth * scale, yy - l.hheight * scale, xx + l.hwidth * scale, yy + l.hheight * scale);
                        }
                    }
                };
                Shape.prototype.getAnchor = function () {
                    return {
                        x: 0,
                        y: 0
                    };
                };
                /**
                 * Given the multiplicative and additive part of the transform, adapts the shape coordinates to viewport
                 * @param txm
                 * @param txa
                 * @param tym
                 * @param tya
                 * @param zoom
                 */
                Shape.prototype.adaptToViewport = function (txm, txa, tym, tya, zoom) {
                    var n = this.node;
                    this.x = n.x * txm + txa;
                    this.y = n.y * tym + tya;
                    this.hWidth = n.hHeight * zoom;
                    this.hHeight = n.hWidth * zoom;
                    this.zoom = zoom;
                };
                /**
                 * Checks if the shape is visible in the current viewport, and needs to be rendered
                 * @param x0s - Left edge of the viewport (in the viewport coordinate system)
                 * @param x1s - Right edge of the viewport (in the viewport coordinate system)
                 * @param y0s - Top edge of the viewport (in the viewport coordinate system)
                 * @param y1s - Bottom edge of the viewport (in the viewport coordinate system)
                 * @param zoom - The zoom level
                 *
                 * @returns {boolean}
                 */
                Shape.prototype.isInViewport = function (x0s, x1s, y0s, y1s, zoom) {
                    var b = this.node.outerBounds;
                    return (this.x + b.x0 * zoom < x1s &&
                        this.x + b.x1 * zoom > x0s &&
                        this.y + b.y0 * zoom < y1s &&
                        this.y + b.y1 * zoom > y0s // bottom edge
                    );
                };
                /**
                 * Performs the canvas rendering context methods to outline the strokes in the background of a selected shape, but doesn't call the stroke itself
                 * As a result the render can be batched, and all shapes can have the same styling
                 * @param g - The rendering context
                 * @param prop - The proportional sizing component to scale the shape
                 * @param cons - The additional constant sizing component to scale the shape
                 */
                Shape.prototype.paintSelection = function (g, prop, cons) {
                    var r = this.hWidth * (1 + prop) + cons;
                    g.moveTo(this.x, this.y);
                    g.arc(this.x, this.y, r, 0, Math.PI * 2);
                    g.closePath();
                };
                /**
                 * Paints the basic ellipse or circle of the shape
                 * @param g - Canvas rendering context
                 * @param labelRenderer - The labelRenderer of the event
                 * @param paintDetails - should the shape render details?
                 */
                Shape.prototype.paint = function (g, labelRenderer, paintDetails) {
                    this.paintBasicShape(g);
                    if (paintDetails) {
                        this.image = this.nodesLayer.getNodeImage(this.node);
                        this.paintDetails(g, labelRenderer);
                    }
                };
                /**
                 * Paints the basic elliptic or circular shape
                 * @param g
                 */
                Shape.prototype.paintBasicShape = function (g) {
                    var strokeContext = Internal.Base.Graphics.beginStrokeAndFill(g, this.node);
                    if (this.hWidth !== this.hHeight) {
                        var xx = this.x + this.hHeight - this.hWidth;
                        strokeContext.moveTo(xx, this.y - this.hWidth);
                        strokeContext.arc(xx, this.y, this.hWidth, -Math.PI / 2, Math.PI / 2, false);
                        xx = this.x - this.hHeight + this.hWidth;
                        strokeContext.lineTo(xx, this.y + this.hWidth);
                        strokeContext.arc(xx, this.y, this.hWidth, Math.PI * 0.5, Math.PI * 1.5, false);
                        strokeContext.closePath();
                    }
                    else {
                        strokeContext.moveTo(this.x + this.hWidth, this.y);
                        strokeContext.arc(this.x, this.y, this.hWidth, 0, PI2, false);
                    }
                    Internal.Base.Graphics.endStrokeAndFill(g, strokeContext, this.node);
                };
                Shape.prototype.paintDetails = function (g, labelRenderer) {
                    // Simply render the image, without worries about text dimensions
                    if (this.image) {
                        this.basicPaintImage(g);
                    }
                    this.paintLabel(g, labelRenderer);
                };
                /**
                 * Paints the image of the node centered to the coordinates of the node
                 * @param g - Canvas rendering context
                 * @param scale - By default the image will be rendered to fit inside the shape. Passing
                 * a scale fraction would render the shape centered, and in a fraction of the shape size
                 */
                Shape.prototype.basicPaintImage = function (g, scale) {
                    if (scale === void 0) { scale = 1; }
                    if (!this.image) {
                        return;
                    }
                    var ix0 = 0;
                    var iy0 = 0;
                    var iw;
                    var ih;
                    if (this.node.imageSlicing) {
                        var s = this.node.imageSlicing;
                        ix0 = s[0];
                        iy0 = s[1];
                        iw = s[2];
                        ih = s[3];
                    }
                    else {
                        iw = this.image.width;
                        ih = this.image.height;
                    }
                    Internal.Base.Graphics.drawImageInSquare(g, this.image, ix0, iy0, iw, ih, this.x - this.hHeight + this.hWidth, this.y, this.hWidth * scale);
                };
                /**
                 * Paints the label of the shape
                 * @param g
                 * @param zoom
                 */
                Shape.prototype.paintLabel = function (g, labelRenderer) {
                    var labelScaleBase = this.nodesLayer.style.nodeLabelScaleBase;
                    if (this.node.hovered) {
                        labelScaleBase = Internal.Base.Helpers.toleranceMin(labelScaleBase, this.hWidth, 0.9);
                    }
                    if (this.currentLabel) {
                        var sizeScale = this.hWidth / labelScaleBase;
                        var label = this.currentLabel;
                        var scale = 1;
                        if (this.node.labelStyle.scaleWithSize) {
                            scale = sizeScale;
                        }
                        else if (this.node.labelStyle.scaleWithZoom) {
                            scale = this.zoom;
                        }
                        labelRenderer.measure(g, label);
                        if (label.hheight > 1.5) {
                            var p = this.getLabelPosition(label, scale);
                            labelRenderer.paint(g, p.x, p.y, scale, label);
                        }
                    }
                };
                /**
                 * Returns the center, where the label should be positioned.
                 * For different shapes, the label position may depend on the shape
                 * @param label
                 * @param scale
                 * @returns {{x: number, y: number}}
                 */
                Shape.prototype.getLabelPosition = function (label, scale) {
                    return {
                        x: this.x,
                        y: this.y + this.hWidth + label.hheight * scale * 0.8 + (label.style.margin || 0) * this.zoom
                    };
                };
                /**
                 * Returns the distance from the shape center to the edge, given a direction vector of the ray
                 * @param r - halfHeight
                 * @param w - halfWidth
                 * ddx and ddy is a direction vector pointing from the center of the shape
                 * @param ddx - ddx coefficient of the ray from the shape. sin(alpha). (deltaX / lengthOfRay)
                 * @param ddy - ddx coefficient of the ray from the shape. cos(alpha). (deltaY / lengthOfRay)
                 * @returns {number} - the distance from the shape center to the outer border of the shape
                 */
                Shape.prototype.distanceToEdge = function (r, w, ddx, ddy) {
                    return r;
                };
                /**
                 * During hitTest the NodesLayer would loop over shapes, and perform hitNode(). Within the boundaries of
                 * tolerance, if no shape returns 0, the closest shape will be returned.
                 * @param x
                 * @param y
                 * @param itemScale
                 * @param prevBest - As the NodesLayer loops over nodes, this is the distance to closest node to the coordinate so far
                 * @returns {number} - The distance to node.  In the event of a positive test,
                 * the method should return 0. If the distance is within the boundaries of tolerance,
                 * the distance is returned. Otherwise it just returns the previous nearest distance (of a different node)
                 */
                Shape.prototype.hitTest = function (x, y, itemScale, prevBest) {
                    var n = this.node;
                    var r = n.renderHheight * itemScale;
                    var w = n.renderHwidth * itemScale;
                    var nx = n.x;
                    var ny = n.y;
                    var distanceSq;
                    if (r < w) {
                        var dr = w - r;
                        distanceSq = Internal.Base.Geometry.distanceToSegmentSq(nx - dr, ny, nx + dr, ny, x, y);
                    }
                    else {
                        distanceSq = (x - nx) * (x - nx) + (y - ny) * (y - ny);
                    }
                    var toleranceSq = (r + prevBest) * (r + prevBest);
                    if (distanceSq < toleranceSq) {
                        // is within tolerance, compute the precise distance
                        var insideSq = r * r;
                        if (distanceSq < insideSq) {
                            return 0;
                        }
                        else {
                            return Math.sqrt(distanceSq) - r;
                        }
                    }
                    return prevBest;
                };
                return Shape;
            }());
            ItemsChart.Shape = Shape;
        })(ItemsChart = Internal.ItemsChart || (Internal.ItemsChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../layers/ItemsLayer.ts" />
/// <reference path="../../base/Graphics.ts" />
/// <reference path="Shape.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var ItemsChart;
        (function (ItemsChart) {
            var CustomShape = (function (_super) {
                __extends(CustomShape, _super);
                function CustomShape(node, layer) {
                    _super.call(this, node, layer);
                    this.validate();
                }
                CustomShape.prototype.postProcess = function (nodesStyle, context) {
                    // super.postProcess.apply(this, arguments);
                    var d = this.node.customShape.onUpdate.call(this.node, context, this.node.radius);
                    var bounds = new Internal.Base.Rect(d.bounds[0], d.bounds[1], d.bounds[2], d.bounds[3]);
                    this.node.targetHWidth = d.HWidth;
                    this.node.targetHHeight = d.HHeight;
                    this.node.bounds = bounds;
                    this.node.outerBounds = bounds.clone();
                    if (d.anchor) {
                        this.node.shapeAnchorX = d.anchor[0];
                        this.node.shapeAnchorY = d.anchor[1];
                    }
                };
                CustomShape.prototype.paint = function (g, labelRenderer, paintDetails) {
                    var im = this.nodesLayer.getNodeImage(this.node);
                    this.node.customShape.paint.call(this.node, g, this.x, this.y, this.hWidth, this.hHeight, im, paintDetails);
                    // In the case of customShape, the customShape itself should handle the paint
                    // of details, and whether to paint them
                };
                CustomShape.prototype.paintSelection = function (g, sizeProportional, sizeConstant) {
                    if (this.node.customShape.paintSelection) {
                        this.node.customShape.paintSelection.call(this.node, g, this.x, this.y, this.hWidth, this.hHeight);
                    }
                    else {
                        _super.prototype.paintSelection.call(this, g, sizeProportional, sizeConstant);
                    }
                };
                CustomShape.prototype.distanceToEdge = function (r, w, ddx, ddy) {
                    if (typeof this.node.customShape.distanceToEdge === "function") {
                        return this.node.customShape.distanceToEdge.call(this.node, r, w, ddx, ddy);
                    }
                    return _super.prototype.distanceToEdge.call(this, r, w, ddx, ddy);
                };
                CustomShape.prototype.hitTest = function (x, y, itemScale, prevBest) {
                    if (typeof this.node.customShape.hitTest === "function") {
                        return this.node.customShape.hitTest.call(this.node, x, y, itemScale, prevBest);
                    }
                    return _super.prototype.hitTest.call(this, x, y, itemScale, prevBest);
                };
                CustomShape.prototype.validate = function () {
                    var node = this.node;
                    if (typeof node.customShape !== "object") {
                        Internal.Base.Helpers.error("If the display of an object is \"customShape\", it's mandatory to supply the rendering methods for the custom shape");
                    }
                    else {
                        if (typeof node.customShape.onUpdate !== "function") {
                            Internal.Base.Helpers.error("onUpdate function was not supplied for the custom shape");
                        }
                        if (typeof node.customShape.paint !== "function") {
                            Internal.Base.Helpers.error("paint function was not supplied for the custom shape");
                        }
                    }
                };
                return CustomShape;
            }(ItemsChart.Shape));
            ItemsChart.CustomShape = CustomShape;
        })(ItemsChart = Internal.ItemsChart || (Internal.ItemsChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../base/Layer.ts" />
/// <reference path="../shapes/CustomShape.ts" />
/// <reference path="../../base/Data.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var ItemsChart;
        (function (ItemsChart) {
            (function (NodeAnchorMode) {
                /**
                 * Node if free-floating,
                 */
                NodeAnchorMode[NodeAnchorMode["Floating"] = 0] = "Floating";
                NodeAnchorMode[NodeAnchorMode["Scene"] = 1] = "Scene";
                NodeAnchorMode[NodeAnchorMode["Fixed"] = 2] = "Fixed";
            })(ItemsChart.NodeAnchorMode || (ItemsChart.NodeAnchorMode = {}));
            var NodeAnchorMode = ItemsChart.NodeAnchorMode;
            var ItemsLayerObject = (function () {
                function ItemsLayerObject() {
                    this.id = null;
                    this.data = null;
                    this.added = false;
                    this.removed = false;
                    this.visibility = 1;
                    this.selected = false;
                    this.hovered = false;
                    /** When a node or link is being dragged, other gestures won't remove it from selection. */
                    this.dragging = false;
                    /** When box selection is in progress it locks the selection state of the node to prevent other interactions from deselecting the node. */
                    this.selectionLock = false;
                    this.cursor = null;
                    /** Specifies if the link or node is invisible - thus completely skipping the drawing and hit testing. */
                    this.invisible = false;
                    this.items = [];
                    this.currentItems = null;
                    this.label = null;
                    this._labelStyle = null;
                }
                Object.defineProperty(ItemsLayerObject.prototype, "labelStyle", {
                    get: function () { return this._labelStyle; },
                    set: function (value) {
                        if (this._labelStyle !== null) {
                            Internal.Base.Helpers.warn("For performance reasons it is not recommended to set `labelStyle` to a custom object. Instead modify properties on the existing object.");
                            Internal.Base.SettingsHelper.updateRecursive(this._labelStyle, value, Internal.Base.SettingsMapping.ItemsChartSettingsItemsLayerLabelStyle, {});
                        }
                        else {
                            this._labelStyle = value;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                return ItemsLayerObject;
            }());
            ItemsChart.ItemsLayerObject = ItemsLayerObject;
            /** Scene is the display view of nodes and links
                Objects are animated in and out */
            var Node = (function (_super) {
                __extends(Node, _super);
                function Node(id, layer, loaded) {
                    if (loaded === void 0) { loaded = false; }
                    _super.call(this);
                    this.parentNode = null;
                    this.data = null;
                    // ===== Section: Data and stuff. =====
                    this.links = [];
                    this.dataLinks = [];
                    this.isNode = true;
                    this.isLink = false;
                    this.aura = null;
                    // ===== Section: coordinates related. =====
                    /** Paint center X */
                    this.x = null;
                    /** Paint center Y */
                    this.y = null;
                    // TODO: this is the same as node.coordinates in GeoChart
                    this.anchorX = null;
                    this.anchorY = null;
                    /**
                     * anchor position on shape, relative to node.x, node size is accounted for already.
                     */
                    this.shapeAnchorX = 0;
                    /**
                     * anchor position on shape, relative to node.x, node size is accounted for already.
                     */
                    this.shapeAnchorY = 0;
                    // Fields computed by style
                    /** Animation target half-height */
                    this.targetHHeight = null;
                    /** Animation target half-width */
                    this.targetHWidth = null;
                    /** Current half-height, in scene coordinates */
                    this.hHeight = 0;
                    /** Current half-width, in scene coordinates */
                    this.hWidth = 0;
                    /**
                     * Half-height scaled for rendering - in pixels.
                     */
                    this.renderHheight = 0;
                    /**
                     * Half-width scaled for rendering - in pixels.
                     */
                    this.renderHwidth = 0;
                    this.anchorMode = NodeAnchorMode.Floating;
                    /** Geochart: node coordinates in absolute scene coords. = node.data.coordinates */
                    this.coordinates = null;
                    this.coordinatesCache = null;
                    /** Coordinate cache precision in scene coords. */
                    this.coordinatesCachePrecision = Infinity;
                    // ===== Section: state flags =====
                    this.expanded = false;
                    this.focused = false;
                    this.background = false;
                    /** loading data for this node */
                    this.loading = false;
                    this.userLock = false;
                    this.relevance = 1;
                    // ===== Section: Style =====
                    /** image, text, roundtext, droplet, customShape */
                    this.display = "image";
                    this.image = null;
                    this.imageCropping = null;
                    this.imageSlicing = null;
                    this.tintImage = false;
                    this._anchorStyle = null;
                    this.zindex = 0;
                    this.opacity = 1;
                    this.aspectRatio = 1;
                    /** number of locks applied - 0 = free */
                    this.locks = 0;
                    this.locked = null;
                    this.fillColor = null;
                    this.lineColor = null;
                    this.lineWidth = 1;
                    this.layer = layer;
                    this.id = id;
                }
                Object.defineProperty(Node.prototype, "anchorStyle", {
                    get: function () { return this._anchorStyle; },
                    set: function (value) {
                        if (this._anchorStyle !== null) {
                            Internal.Base.Helpers.warn("For performance reasons it is not recommended to set `anchorStyle` to a custom object. Instead modify properties on the existing object.");
                            Internal.Base.SettingsHelper.updateRecursive(this._anchorStyle, value, Internal.Base.SettingsMapping.ItemsChartSettingsNodeAnchorStyle, {});
                        }
                        else {
                            this._anchorStyle = value;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                return Node;
            }(ItemsLayerObject));
            ItemsChart.Node = Node;
            var Link = (function (_super) {
                __extends(Link, _super);
                function Link(id, layer) {
                    _super.call(this);
                    this.data = null;
                    /** source node */
                    this.from = null;
                    /** target node */
                    this.to = null;
                    this.isNode = false;
                    this.isLink = true;
                    this.multiId = null;
                    /** link width radius - 0..10
                     TODO: the radius should represent half-width, instead it currently represents full width */
                    this.radius = 1;
                    this.fillColor = null;
                    this.lineColor = null;
                    /** multiple of default length */
                    this.length = 1;
                    /** 0 .. 10 */
                    this.strength = 1;
                    this.dashed = false;
                    this.currentRadius = 0;
                    this.background = null;
                    this._angle = null;
                    this.targetRadius = null;
                    this.targetStrength = null;
                    this.targetLength = null;
                    /** null or "U", "D", "L", "R" */
                    this.direction = null;
                    /** 'circle' or 'arrow' */
                    this.fromDecoration = null;
                    /** 'circle' or 'arrow' */
                    this.toDecoration = null;
                    this.relevance = 1;
                    /** pie */
                    this.toPieValue = 0;
                    this.toPieColor = null;
                    this.toPie0 = null;
                    this.toPie1 = null;
                    /** offset from center line between nodes. Non-zero for multi links. = offset / length in units */
                    this.currentCenterOffset = 0;
                    this.layer = layer;
                    this.id = id;
                }
                Link.prototype.otherEnd = function (node) {
                    if (node === this.from) {
                        return this.to;
                    }
                    if (node === this.to) {
                        return this.from;
                    }
                    return null;
                };
                Link.prototype.commonNode = function (link) {
                    if (this.from === link.from || this.from === link.to) {
                        return this.from;
                    }
                    if (this.to === link.from || this.to === link.to) {
                        return this.to;
                    }
                    return null;
                };
                return Link;
            }(ItemsLayerObject));
            ItemsChart.Link = Link;
            var ItemsLayer = (function (_super) {
                __extends(ItemsLayer, _super);
                /** A layer that consists of nodes and links.
                You will need to define animation, paint and hit testing. */
                function ItemsLayer(scene, layerSettings) {
                    _super.call(this, scene);
                    this.parentId = null;
                    this.scaleNodesWithZoom = true;
                    this.scaleLinksWithZoom = true;
                    this._nodes = [];
                    this._links = [];
                    this._nodesDel = null;
                    this._linksDel = null;
                    this.idToNode = {};
                    this.idToLink = {};
                    this.lastClickedNode = null;
                    this.newNodes = {};
                    this.newLinks = {};
                    this.modifiedNodes = {};
                    this.modifiedLinks = {};
                    this.deletedNodes = {};
                    this.deletedLinks = {};
                    this.drilldownId = null;
                    this.layerSettings = layerSettings;
                    this.scene = scene;
                    this.clearModified();
                    this.styleUpdater = this.createStyleUpdater(this.layerSettings.style);
                }
                /** =================================================================================
                methods to override
                ================================================================================= */
                ItemsLayer.prototype.onSettingsChanged = function (settingsChanges) {
                    // update style
                    if (settingsChanges.style) {
                        this.styleUpdater = this.createStyleUpdater(this.layerSettings.style);
                        // mark all objects changed
                        for (var nodeIndex = 0, nodeSource = this.nodes(); nodeIndex < nodeSource.length; nodeIndex++) {
                            var node = nodeSource[nodeIndex];
                            this.touchNode(node);
                        }
                        for (var linkIndex = 0, linkSource = this.links(); linkIndex < linkSource.length; linkIndex++) {
                            var link = linkSource[linkIndex];
                            this.touchLink(link);
                        }
                    }
                };
                ItemsLayer.prototype.updateStyle = function (event) {
                    this.styleUpdater.updateLayer(event, true);
                };
                ItemsLayer.prototype.postprocessStyle = function (event) {
                    this.styleUpdater.postprocessLayer(event);
                };
                ItemsLayer.prototype.createStyleUpdater = function (style) { return null; };
                ItemsLayer.prototype.paintPrepare = function (event) {
                    // a virtual method
                };
                ItemsLayer.prototype.paintBackground = function (event) {
                    // a virtual method
                };
                ItemsLayer.prototype.findObjectById = function (id) {
                    if (this.idToNode.hasOwnProperty(id)) {
                        return this.idToNode[id];
                    }
                    else if (this.idToLink.hasOwnProperty(id)) {
                        return this.idToLink[id];
                    }
                    return null;
                };
                ItemsLayer.prototype.paint = function (event) {
                    this.paintPrepare(event);
                    this.clearModified();
                    this.paintBackground(event);
                    // paint selection
                    var sel = this.scene.selection;
                    if (sel.length > 0) {
                        var nodes_1 = [];
                        var links_1 = [];
                        for (var itemIndex = 0; itemIndex < sel.length; itemIndex++) {
                            var item = sel[itemIndex];
                            if (item.layer === this && item instanceof Node) {
                                nodes_1.push(item);
                            }
                            if (item.layer === this && item instanceof Link) {
                                links_1.push(item);
                            }
                        }
                        if (nodes_1.length > 0 || links_1.length > 0) {
                            this.paintSelection(event, nodes_1, links_1);
                        }
                    }
                    var links = this.links();
                    var hoverLinkPos = this._makeHoveredLast(links, this.scene.hoverLink);
                    this.paintLinks(event, links);
                    this._restoreHovered(links, hoverLinkPos);
                    var nodes = this.nodes();
                    var hoverNodePos = this._makeHoveredLast(nodes, this.scene.hoverNode);
                    this.paintNodes(event, nodes);
                    this._restoreHovered(nodes, hoverNodePos);
                };
                ItemsLayer.prototype.clearObjects = function () {
                    for (var nodeIndex = 0, nodeSource = this.nodes(); nodeIndex < nodeSource.length; nodeIndex++) {
                        var node = nodeSource[nodeIndex];
                        this.removeNode(node);
                    }
                    for (var linkIndex = 0, linkSource = this.links(); linkIndex < linkSource.length; linkIndex++) {
                        var link = linkSource[linkIndex];
                        this.removeLink(link);
                    }
                };
                ItemsLayer.prototype.nodes = function () {
                    if (this._nodesDel === null) {
                        return this._nodes;
                    }
                    // remove removed nodes from nodes list
                    var n = [];
                    for (var nodeIndex = 0; nodeIndex < this._nodes.length; nodeIndex++) {
                        var node = this._nodes[nodeIndex];
                        if (!(this._nodesDel[node.id])) {
                            n.push(node);
                        }
                    }
                    this._nodes = n;
                    this._nodesDel = null;
                    return n;
                };
                ItemsLayer.prototype.links = function () {
                    if (this._linksDel === null) {
                        return this._links;
                    }
                    // remove removed nodes from nodes list
                    var n = [];
                    for (var nodeIndex = 0; nodeIndex < this._links.length; nodeIndex++) {
                        var node = this._links[nodeIndex];
                        if (!(this._linksDel[node.id])) {
                            n.push(node);
                        }
                    }
                    this._links = n;
                    this._linksDel = null;
                    return n;
                };
                ItemsLayer.prototype.addNode = function (nodeId) {
                    // flush nodesDel before adding new
                    this.nodes();
                    var node;
                    if (this.idToNode.hasOwnProperty(nodeId)) {
                        node = this.idToNode[nodeId];
                        node.removed = false;
                        if (!node.added) {
                            node.added = true;
                        }
                    }
                    else if (this.deletedNodes.hasOwnProperty(nodeId)) {
                        node = this.deletedNodes[nodeId];
                        node.removed = false;
                        if (!node.added) {
                            node.added = true;
                        }
                        this.idToNode[nodeId] = node;
                        this._nodes.push(node);
                        delete this.deletedNodes[nodeId];
                    }
                    else {
                        node = new Node(nodeId, this);
                        node.added = true;
                        this.idToNode[nodeId] = node;
                        this._nodes.push(node);
                        this.newNodes[nodeId] = node;
                    }
                    this.modifiedNodes[nodeId] = node;
                    return node;
                };
                ItemsLayer.prototype.touchNodeOrLink = function (obj) {
                    if (obj instanceof Node) {
                        this.modifiedNodes[obj.id] = obj;
                    }
                    else if (obj instanceof Link) {
                        this.modifiedLinks[obj.id] = obj;
                    }
                };
                ItemsLayer.prototype.touchNode = function (node) {
                    this.modifiedNodes[node.id] = node;
                };
                /** marks node for removal */
                ItemsLayer.prototype.removeNode = function (node) {
                    var nodeId = node.id;
                    if (!this.idToNode.hasOwnProperty(nodeId)) {
                        return;
                    }
                    if (node === this.lastClickedNode) {
                        this.lastClickedNode = null;
                    }
                    this.scene.objectRemoved(node);
                    if (this.newNodes.hasOwnProperty(node.id)) {
                        this.deleteNode(node);
                    }
                    else {
                        if (!node.removed) {
                            node.removed = true;
                        }
                        node.added = false;
                        this.modifiedNodes[nodeId] = node;
                    }
                    // node will be removed by animations
                };
                /** actually deletes the node */
                ItemsLayer.prototype.deleteNode = function (node) {
                    if (this._nodesDel === null) {
                        this._nodesDel = {};
                    }
                    this._nodesDel[node.id] = true;
                    this.scene.objectRemoved(node);
                    delete this.newNodes[node.id];
                    delete this.modifiedNodes[node.id];
                    delete this.idToNode[node.id];
                    this.deletedNodes[node.id] = node;
                };
                ItemsLayer.prototype.addLink = function (linkId, from, to) {
                    var fromNode = this.idToNode[from];
                    var toNode = this.idToNode[to];
                    if (!fromNode || !toNode) {
                        throw new Error("Cannot add link - missing nodes");
                    }
                    var link = null;
                    // flush linksDel cache
                    this.links();
                    if (this.idToLink.hasOwnProperty(linkId)) {
                        link = this.idToLink[linkId];
                        link.removed = false;
                        if (!link.added) {
                            link.added = true;
                        }
                    }
                    else if (this.deletedLinks.hasOwnProperty(linkId)) {
                        link = this.deletedLinks[linkId];
                        delete this.deletedLinks[linkId];
                        this.idToLink[linkId] = link;
                        this._links.push(link);
                        link.removed = false;
                        if (!link.added) {
                            link.added = true;
                        }
                    }
                    else {
                        link = new Link(linkId, this);
                        link.added = true;
                        this._links.push(link);
                        this.idToLink[linkId] = link;
                        this.newLinks[linkId] = link;
                    }
                    if (link.from && link.from !== fromNode) {
                        Internal.Base.Helpers.removeFromArrayHasty(link.from.links, link);
                        link.from = null;
                    }
                    if (!link.from) {
                        link.from = fromNode;
                        link.from.links.push(link);
                        this.touchNode(link.from);
                    }
                    if (link.to && link.to !== toNode) {
                        Internal.Base.Helpers.removeFromArrayHasty(link.to.links, link);
                        link.to = null;
                    }
                    if (!link.to) {
                        link.to = toNode;
                        if (link.to !== link.from) {
                            link.to.links.push(link);
                            this.touchNode(link.to);
                        }
                    }
                    link.multiId = (from < to) ? (from + Internal.Base.Helpers.SeparatorChar + to) : (to + Internal.Base.Helpers.SeparatorChar + from);
                    this.modifiedLinks[linkId] = link;
                    return link;
                };
                /** marks links for removal, animation will do the actual delete */
                ItemsLayer.prototype.removeLink = function (link) {
                    var linkId = link.id;
                    if (!this.idToLink.hasOwnProperty(linkId)) {
                        return;
                    }
                    this.scene.objectRemoved(link);
                    if (this.newLinks.hasOwnProperty(linkId)) {
                        this.deleteLink(link);
                    }
                    else {
                        link.added = false;
                        if (!link.removed) {
                            link.removed = true;
                        }
                        this.modifiedLinks[linkId] = link;
                    }
                };
                /** link will be removed by animations */
                ItemsLayer.prototype.deleteLink = function (link) {
                    if (this._linksDel === null) {
                        this._linksDel = {};
                    }
                    this._linksDel[link.id] = true;
                    this.scene.objectRemoved(link);
                    if (this.newLinks.hasOwnProperty(link.id)) {
                        delete this.newLinks[link.id];
                    }
                    else {
                        this.deletedLinks[link.id] = link;
                    }
                    delete this.modifiedLinks[link.id];
                    delete this.idToLink[link.id];
                    Internal.Base.Helpers.removeFromArrayHasty(link.from.links, link);
                    Internal.Base.Helpers.removeFromArrayHasty(link.to.links, link);
                };
                ItemsLayer.prototype.touchLink = function (link) {
                    this.modifiedLinks[link.id] = link;
                };
                ItemsLayer.prototype.getModified = function () {
                    return {
                        this_newNodes: this.newNodes,
                        this_newLinks: this.newLinks,
                        this_modifiedNodes: this.modifiedNodes,
                        this_modifiedLinks: this.modifiedLinks,
                        this_deletedNodes: this.deletedNodes,
                        this_deletedLinks: this.deletedLinks
                    };
                };
                /** TODO: handle link reconnection */
                ItemsLayer.prototype.hasTopologyChanges = function () {
                    return Internal.Base.Helpers.hasProperties(this.newNodes)
                        || Internal.Base.Helpers.hasProperties(this.newLinks)
                        || Internal.Base.Helpers.hasProperties(this.deletedNodes)
                        || Internal.Base.Helpers.hasProperties(this.deletedLinks);
                };
                ItemsLayer.prototype.hasStyleChanges = function () {
                    return this.hasTopologyChanges()
                        || Internal.Base.Helpers.hasProperties(this.modifiedLinks)
                        || Internal.Base.Helpers.hasProperties(this.modifiedNodes);
                };
                ItemsLayer.prototype.clearModified = function () {
                    this.newNodes = {};
                    this.newLinks = {};
                    this.modifiedNodes = {};
                    this.modifiedLinks = {};
                    this.deletedNodes = {};
                    this.deletedLinks = {};
                };
                ItemsLayer.prototype.paintNodeDetails = function (node, x, y, w, r, zoom, nodeLabelScaleBase, event) {
                    var labelRenderer = event.labelRenderer;
                    var g = event.context;
                    var sizeScale = r / nodeLabelScaleBase;
                    var scale;
                    // items
                    if (node.currentItems) {
                        for (var itemIndex = 0; itemIndex < node.currentItems.length; itemIndex++) {
                            var item = node.currentItems[itemIndex];
                            var fx = item.style.x || 0;
                            var fy = item.style.y || 0;
                            var ix = item.style.px || 0;
                            var iy = item.style.py || 0;
                            var xx = x + w * ix + fx;
                            var yy = y + r * iy + fy;
                            if (item.style.scaleWithSize) {
                                scale = sizeScale;
                            }
                            else if (item.style.scaleWithZoom) {
                                scale = zoom;
                            }
                            else {
                                scale = 1;
                            }
                            labelRenderer.measure(g, item);
                            if (item.hheight > 1.5) {
                                labelRenderer.paint(g, xx, yy, scale, item);
                            }
                        }
                    }
                };
                /**
                 * Returns the object zoom in scene coords.
                 */
                ItemsLayer.prototype.getNodesSceneZoom = function () {
                    return this.scaleNodesWithZoom ? 1 : 1 / this.scene.zoom;
                };
                // =================================================================================
                // private methods
                // =================================================================================
                ItemsLayer.prototype.getGeometry = function () {
                    var t = this.scene.toDisplayTransform();
                    // Multiplicative and additive parts of the transform
                    var txm = t.xm;
                    var txa = t.xa;
                    var tym = t.ym;
                    var tya = t.ya;
                    // bounds of the viewport
                    var x0s = this.bounds.x0;
                    var x1s = this.bounds.x1;
                    var y0s = this.bounds.y0;
                    var y1s = this.bounds.y1;
                    // bounds of the viewport in the coordinate system of scene
                    var x0w = (x0s - txa) / txm;
                    var x1w = (x1s - txa) / txm;
                    var y0w = (y0s - tya) / tym;
                    var y1w = (y1s - tya) / tym;
                    var zoom = this.scaleNodesWithZoom ? this.scene.zoom : 1;
                    var linkZoom = this.scaleLinksWithZoom ? this.scene.zoom : 1;
                    return {
                        txm: txm,
                        txa: txa,
                        tym: tym,
                        tya: tya,
                        zoom: zoom,
                        linkZoom: linkZoom,
                        x0s: x0s,
                        x1s: x1s,
                        y0s: y0s,
                        y1s: y1s,
                        x0w: x0w,
                        y0w: y0w,
                        x1w: x1w,
                        y1w: y1w
                    };
                };
                ItemsLayer.prototype._makeHoveredLast = function (list, hobj) {
                    var len = list.length;
                    if (len < 2 || !hobj || hobj === list[len - 1]) {
                        return len - 1;
                    }
                    for (var i = 0; i < list.length; i++) {
                        var obj = list[i];
                        if (obj === hobj) {
                            var n1 = list[len - 1];
                            list[len - 1] = hobj;
                            list[i] = n1;
                            return i;
                        }
                    }
                    return len - 1;
                };
                ItemsLayer.prototype._restoreHovered = function (list, pos) {
                    var len = list.length;
                    if (pos !== len - 1) {
                        var n1 = list[pos];
                        list[pos] = list[len - 1];
                        list[len - 1] = n1;
                    }
                };
                return ItemsLayer;
            }(Internal.Base.Layer));
            ItemsChart.ItemsLayer = ItemsLayer;
        })(ItemsChart = Internal.ItemsChart || (Internal.ItemsChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../base/Label.ts" />
/// <reference path="../Scene.ts" />
/// <reference path="ItemsLayer.ts" />
/// <reference path="../../base/core/ChartEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var ItemsChart;
        (function (ItemsChart) {
            var SettingsItemClass = (function () {
                function SettingsItemClass() {
                    /** Name to use in legend
                        @version 1.15.0
                    */
                    this.nameLegend = null;
                    /** Whether or not to show in legend.
                        @version 1.15.0
                    */
                    this.showInLegend = true;
                    /** Group ID for legend. Items in the same group have a different toggle behavior. When all the items in a group are enabled,
                        clicking an item causes that item to stay enabled and all other items are disabled. Clicking it again enables all items
                        again. Consequently, at least one item in each group is always enabled. The exception to this is if the group ID is null
                        (no group) or the group contains only one item. Then the item is toggled on/off individually.
                        @version 1.15.0
                     */
                    this.legendGroupId = null;
                }
                return SettingsItemClass;
            }());
            ItemsChart.SettingsItemClass = SettingsItemClass;
            var SettingsNodeClass = (function (_super) {
                __extends(SettingsNodeClass, _super);
                function SettingsNodeClass() {
                    _super.apply(this, arguments);
                }
                return SettingsNodeClass;
            }(SettingsItemClass));
            ItemsChart.SettingsNodeClass = SettingsNodeClass;
            var SettingsLinkClass = (function (_super) {
                __extends(SettingsLinkClass, _super);
                function SettingsLinkClass() {
                    _super.apply(this, arguments);
                }
                return SettingsLinkClass;
            }(SettingsItemClass));
            ItemsChart.SettingsLinkClass = SettingsLinkClass;
            var SettingsItemsLayerStyle = (function () {
                function SettingsItemsLayerStyle() {
                    /**
                     *  An "all included" style function.
                     * @returns - links and nodes that the style function has modified. Or `null` to mark all objects as modified.
                     */
                    this.allObjectsStyleFunction = null;
                    /**
                     * A a style function for links. Will be called whenever a link property or data has changed.
                     * Use to dynamically set link style fields.
                     */
                    this.linkStyleFunction = null;
                    /**
                     * A a style function for nodes. Will be called whenever a node property or data has changed.
                     * Use to dynamically set node style fields.
                     */
                    this.nodeStyleFunction = null;
                    /** An object defining one or more functions used to calculate node rendering style.
                    @see Example: [round image nodes](net-chart/examples/style/round-image-nodes.html)
                    @deprecated - use nodeStyleFunction instead*/
                    this.nodeRules = {};
                    /** An object defining one or more functions used to calculate node rendering style.
                    Structure: { 'rule1':function1(nodeObj), 'rule2':function2(nodeObj) }
                    The functions are executed in lexicographic order whenever node data or links change.
                    Each function can modify the nodeObj to add specific style elements.
                    @deprecated - use linkStyleFunction instead*/
                    this.linkRules = {};
                    /** The class rules to apply individual style for node subset. Use known CSS class definition practice.
                    Define one or more classes by specifying name and style and apply those by node definition. If multiple
                    classes applied separate them with space and class rules will cascade in order of class definition. */
                    this.nodeClasses = [];
                    /** The class rules to apply individual style for link subset. Use known CSS class definition practice.
                    Define one or more classes by specifying name and style and apply those by node definition. If multiple
                    classes applied separate them with space and class rules will cascade in order of class definition. */
                    this.linkClasses = [];
                    /** Default node style.
                    @see Documentation: [Style setting precedence](net-chart/introductory-topics/style.html#style-ordering) */
                    this.node = {
                        fillColor: "#c7dae0",
                        lineColor: null,
                        lineWidth: null,
                        radius: 30,
                        aspectRatio: 1,
                        shadowColor: null,
                        lineDash: null
                    };
                    /** Default node  anchor style. */
                    this.nodeAnchor = {
                        lineColor: "blue",
                        lineWidth: 1,
                    };
                    /** Default link style.
                    @see Documentation: [Style setting precedence](net-chart/introductory-topics/style.html#style-ordering) */
                    this.link = {
                        fillColor: "#333",
                        shadowColor: null,
                        fromDecoration: null,
                        toDecoration: null,
                        label: null,
                        radius: 1,
                        length: 1,
                        strength: 1,
                        lineDash: null,
                        toPieValue: 0,
                        toPieColor: null
                    };
                    /** Items are small UI elements that provide extra information. Items are attached to nodes or links and can display a label, image or both. */
                    this.item = {
                        align: "center",
                        aspectRatio: 4,
                        borderRadius: 1000,
                        textStyle: { fillColor: "black", font: "12px Arial" },
                        backgroundStyle: { fillColor: "rgba(255,255,255,0.7)" },
                    };
                    /** Link text style */
                    this.linkLabel = {
                        padding: 0.6,
                        margin: 0,
                        align: "center",
                        aspectRatio: 4,
                        borderRadius: 1000,
                        lineSpacing: 0.2,
                        textStyle: { fillColor: "black", font: "12px Arial" },
                        backgroundStyle: { fillColor: "#FFF", lineColor: "gray" },
                        scaleWithZoom: true,
                        scaleWithSize: false,
                        rotateWithLink: false
                    };
                    /** Node label style. */
                    this.nodeLabel = {
                        padding: 0,
                        margin: 0,
                        align: "center",
                        aspectRatio: 4,
                        borderRadius: 1000,
                        lineSpacing: 0.2,
                        textStyle: { fillColor: "black", font: "12px Arial" },
                        backgroundStyle: { fillColor: "rgba(255,255,255,0.7)" },
                        scaleWithZoom: false,
                        scaleWithSize: true
                    };
                    // TODO: use classes here
                    /** Additional style to apply when a node position is locked.
                    @see Documentation: [Style setting precedence](net-chart/introductory-topics/style.html#style-ordering) */
                    this.nodeLocked = {};
                    /** Additional style to apply when node is expanded.
                    @see Documentation: [Style setting precedence](net-chart/introductory-topics/style.html#style-ordering) */
                    this.nodeExpanded = {};
                    /** Additional style to apply when node is focused.
                    @see Documentation: [Style setting precedence](net-chart/introductory-topics/style.html#style-ordering) */
                    this.nodeFocused = { fillColor: "#09c" };
                    /** Additional style to apply when node data is not yet loaded.
                    @see Documentation: [Style setting precedence](net-chart/introductory-topics/style.html#style-ordering) */
                    this.nodeNotLoaded = { fillColor: "#fff" };
                    /** Additional style to apply when a node is hovered.
                    @see Documentation: [Style setting precedence](net-chart/introductory-topics/style.html#style-ordering) */
                    this.nodeHovered = {
                        shadowOffsetX: 0,
                        shadowOffsetY: 2,
                        shadowBlur: 6,
                        shadowColor: "rgba(0,0,0,.6)"
                    };
                    /** Additional style to apply when a link is hovered.
                    @see Documentation: [Style setting precedence](net-chart/introductory-topics/style.html#style-ordering) */
                    this.linkHovered = {
                        shadowOffsetX: 0,
                        shadowOffsetY: 0,
                        shadowBlur: 2,
                        shadowColor: "blue"
                    };
                    /** Additional style to apply when node is selected.
                    @see Documentation: [Style setting precedence](net-chart/introductory-topics/style.html#style-ordering) */
                    this.nodeSelected = {};
                    /** Additional style to apply when link is selected.
                    @see Documentation: [Style setting precedence](net-chart/introductory-topics/style.html#style-ordering) */
                    this.linkSelected = {};
                    this.selection = {
                        fillColor: "rgba(173, 216, 230, 1)",
                        lineColor: "rgba(255,255,255,0.01)",
                        sizeConstant: 0,
                        sizeProportional: 0,
                        shadowBlur: 8,
                        shadowOffsetX: 0,
                        shadowOffsetY: 3,
                        shadowColor: "rgba(0,0,0,0.8)"
                    };
                    /** Color for fade out animation of removed objects.
                    @type color */
                    this.removedColor = "#EEE";
                    /** Additional style to apply for background nodes.
                    @see Documentation: [Style setting precedence](net-chart/introductory-topics/style.html#style-ordering) */
                    this.nodeBackground = {};
                    /** Node details like labels, items, images are not rendered if chart zoom is below this value.
                    @type float
                    @unit zoom factor */
                    this.nodeDetailMinZoom = 0.2;
                    /** Node details like labels, items, images are hidden if node width in pixels is below this value.
                    @type float
                    @unit pixels */
                    this.nodeDetailMinSize = 5;
                    /** Link details like labels, items are not rendered if chart zoom is below this value.
                    @type float
                    @unit zoom factor */
                    this.linkDetailMinZoom = 0.5;
                    /** Link details like labels, items are hidden if link width in pixels is below this value.
                    @type float
                    @unit pixels */
                    this.linkDetailMinSize = 12;
                    /** Link decoration size calculated as a product of the link radius and scale factor. The value lower than linkDecorationMinSize will take no effect.
                    @type float
                    @unit scale */
                    this.linkDecorationScale = 4;
                    /** Link decorations are not painted if link is shorter than this.
                    @type float
                    @units pixels */
                    this.linkDecorationMinSize = 4;
                    // next setting should be advanced
                    /** Base node size of node label that scales with node size.
                    @type float
                    @units pixels */
                    this.nodeLabelScaleBase = 30;
                    // next setting should be advanced
                    /** Base node size of link label that scales with link size.
                    @type float
                    @units pixels */
                    this.linkLabelScaleBase = 1;
                    /** Determines if node radius is automatically scaled when the chart is zoomed in or out.
                    If `scaleLinksWithZoom` is not set, this value also impacts links. */
                    this.scaleObjectsWithZoom = true;
                    /** Determines if link radius (width) is automatically scaled when the chart is zoomed in or out.
                    If set to `null`, the value is inherited from `scaleObjectsWithZoom` */
                    this.scaleLinksWithZoom = null;
                }
                return SettingsItemsLayerStyle;
            }());
            ItemsChart.SettingsItemsLayerStyle = SettingsItemsLayerStyle;
            var ItemsStyle = (function () {
                function ItemsStyle(styleSettings, layer) {
                    this.layer = layer;
                    this.styleSettings = styleSettings;
                    this.nodeClasses = Internal.Base.Helpers.arrayToMap(this.styleSettings.nodeClasses, "className");
                    this.linkClasses = Internal.Base.Helpers.arrayToMap(this.styleSettings.linkClasses, "className");
                    this.nodeRules = this.sortRules(this.styleSettings.nodeRules);
                    if (this.styleSettings.nodeStyleFunction) {
                        this.nodeRules.unshift(this.styleSettings.nodeStyleFunction);
                    }
                    this.linkRules = this.sortRules(this.styleSettings.linkRules);
                    if (this.styleSettings.linkStyleFunction) {
                        this.linkRules.unshift(this.styleSettings.linkStyleFunction);
                    }
                }
                ItemsStyle.getClasses = function (classString) {
                    if (!classString)
                        return [];
                    return classString.trim().split(/\s+/g);
                };
                ItemsStyle.prototype.updateLayer = function (event, isIncremental) {
                    if (isIncremental === void 0) { isIncremental = false; }
                    if (isIncremental == null)
                        isIncremental = false; // ported from CoffeeScript;
                    this.isIncremental = isIncremental;
                    var settings = this.styleSettings;
                    // since style functions may be looking at the zoom level of the chart to provide different settings,
                    // all nodes must be updated on zoom.
                    var updateEverything = event.changes.style
                        || (event.changes.zoom && !!(this.nodeRules.length || this.linkRules.length));
                    if (updateEverything) {
                        this.isIncremental = false;
                        for (var nodeIndex = 0, nodeSource = this.layer.nodes(); nodeIndex < nodeSource.length; nodeIndex++) {
                            this.layer.touchNode(nodeSource[nodeIndex]);
                        }
                        for (var linkIndex = 0, linkSource = this.layer.links(); linkIndex < linkSource.length; linkIndex++) {
                            this.layer.touchLink(linkSource[linkIndex]);
                        }
                    }
                    var modNodes = this.layer.modifiedNodes;
                    for (var id in modNodes) {
                        var node = modNodes[id];
                        this.updateNode(node);
                        if (isIncremental) {
                            for (var linkIndex = 0; linkIndex < node.links.length; linkIndex++) {
                                this.layer.touchLink(node.links[linkIndex]);
                            }
                        }
                    }
                    var modLinks = this.layer.modifiedLinks;
                    for (var id in modLinks) {
                        var link = modLinks[id];
                        this.updateLink(link);
                    }
                    // Call style functions
                    if (settings.allObjectsStyleFunction && (event.changes.zoom || this.layer.hasStyleChanges())) {
                        var nodes = this.layer.nodes();
                        var links = this.layer.links();
                        var modified = settings.allObjectsStyleFunction(nodes, links);
                        var modifiedLinks = links;
                        var modifiedNodes = nodes;
                        if (modified) {
                            modifiedLinks = modified.modifiedLinks;
                            modifiedNodes = modified.modifiedNodes;
                        }
                        // mark modified
                        for (var i = 0; i < modifiedNodes.length; i += 1) {
                            this.layer.touchNode(modifiedNodes[i]);
                        }
                        for (var i = 0; i < modifiedLinks.length; i += 1) {
                            this.layer.touchLink(modifiedLinks[i]);
                        }
                    }
                    if (this.nodeRules.length > 0) {
                        modNodes = this.layer.modifiedNodes;
                        for (var id in modNodes) {
                            var node = modNodes[id];
                            this.applyStyleRules(node, this.nodeRules);
                        }
                    }
                    if (this.linkRules.length > 0) {
                        modLinks = this.layer.modifiedLinks;
                        for (var id in modLinks) {
                            var link = modLinks[id];
                            this.applyStyleRules(link, this.linkRules);
                        }
                    }
                };
                ItemsStyle.prototype.postprocessLayer = function (event) {
                    var nodes = this.layer.modifiedNodes;
                    for (var id in nodes) {
                        var node = nodes[id];
                        this.postprocessNode(node);
                    }
                    var links = this.layer.modifiedLinks;
                    for (var id in links) {
                        var link = links[id];
                        this.postprocessLink(link);
                    }
                };
                ItemsStyle.prototype.postprocessItems = function (obj) {
                    var currentItems = obj.currentItems;
                    var mapping = obj instanceof ItemsChart.Node ? Internal.Base.SettingsMapping.ItemsChartSettingsNodeItem : Internal.Base.SettingsMapping.ItemsChartSettingsLinkItem;
                    var itemStyle = this.styleSettings.item;
                    for (var itemIndex = 0; itemIndex < obj.items.length; itemIndex++) {
                        var item = obj.items[itemIndex];
                        var i = new Internal.Base.Label(itemStyle);
                        Internal.Base.SettingsHelper.updateRecursive(i.style, item, mapping, {}, "items[" + itemIndex + "]");
                        /* if item == @scene.hoverItem
                        Base_Helpers.extendDeep(i, @styleSettings.itemHovered) */
                        currentItems.push(i);
                    }
                };
                /** ==============================================================================
                private methods
                ============================================================================== */
                ItemsStyle.prototype.sortRules = function (rules) {
                    var names = [];
                    for (var name in rules) {
                        names.push(name);
                    }
                    names.sort();
                    var result = [];
                    for (var nameIndex = 0; nameIndex < names.length; nameIndex++) {
                        var name = names[nameIndex];
                        result.push(rules[name]);
                    }
                    return result;
                };
                ItemsStyle.prototype.updateNode = function (node) {
                    var style = this.styleSettings;
                    var active = node.hovered;
                    if (!node.radius) {
                        node.radius = 10;
                    }
                    node.label = null;
                    Internal.Base.Helpers.extendStyleTo(style.node, node);
                    node._labelStyle = Internal.Base.Helpers.realClone(style.nodeLabel);
                    node._anchorStyle = Internal.Base.Helpers.realClone(style.nodeAnchor);
                    if (node.userLock) {
                        Internal.Base.Helpers.extendStyleTo(style.nodeLocked, node);
                    }
                    if (node.expanded) {
                        Internal.Base.Helpers.extendStyleTo(style.nodeExpanded, node);
                    }
                    if (node.focused) {
                        Internal.Base.Helpers.extendStyleTo(style.nodeFocused, node);
                    }
                    if (node.background) {
                        Internal.Base.Helpers.extendStyleTo(style.nodeBackground, node);
                    }
                    if (!node.data.loaded) {
                        Internal.Base.Helpers.extendStyleTo(style.nodeNotLoaded, node);
                    }
                    // apply style rules
                    if (node.data) {
                        if (node.data.error) {
                            node.label = node.data.error;
                            node.fillColor = "red";
                        }
                        if (node.data.style) {
                            Internal.Base.Helpers.extendStyleTo(node.data.style, node);
                        }
                        if (node.data.className) {
                            var sequence = this.getClassSequence(node.data.className, this.nodeClasses);
                            for (var clIndex = 0; clIndex < sequence.length; clIndex++) {
                                var cl = sequence[clIndex];
                                Internal.Base.Helpers.extendStyleTo(this.styleSettings.nodeClasses[cl].style, node);
                            }
                        }
                    }
                    // Default style
                    if (node.removed) {
                        node.fillColor = style.removedColor;
                    }
                    if (node.selected) {
                        Internal.Base.Helpers.extendStyleTo(style.nodeSelected, node);
                    }
                    if (active) {
                        Internal.Base.Helpers.extendStyleTo(style.nodeHovered, node);
                    }
                };
                ItemsStyle.prototype.updateLink = function (link) {
                    var style = this.styleSettings;
                    link.label = null;
                    link._labelStyle = Internal.Base.Helpers.realClone(style.linkLabel);
                    link.radius = 1;
                    Internal.Base.Helpers.extendStyleTo(style.link, link);
                    var active = link.hovered || link.from.hovered || link.to.hovered;
                    if (link.data.style) {
                        Internal.Base.Helpers.extendStyleTo(link.data.style, link);
                    }
                    if (link.data.className) {
                        var sequence = this.getClassSequence(link.data.className, this.linkClasses);
                        for (var clIndex = 0; clIndex < sequence.length; clIndex++) {
                            var cl = sequence[clIndex];
                            Internal.Base.Helpers.extendStyleTo(style.linkClasses[cl].style, link);
                        }
                    }
                    if (link.selected) {
                        Internal.Base.Helpers.extendStyleTo(style.linkSelected, link);
                    }
                    if (active) {
                        Internal.Base.Helpers.extendStyleTo(style.linkHovered, link);
                        if (link.from.hovered) {
                            link.toPieColor = link.fillColor;
                        }
                    }
                    if (link.removed) {
                        link.fillColor = style.removedColor;
                    }
                };
                ItemsStyle.prototype.applyStyleRules = function (obj, rules) {
                    for (var i = 0; i < rules.length; i++) {
                        var func = rules[i];
                        func(obj);
                    }
                };
                ItemsStyle.prototype.getClassSequence = function (className, map) {
                    var classes = ItemsStyle.getClasses(className);
                    var classIndexes = [];
                    for (var cIndex = 0; cIndex < classes.length; cIndex++) {
                        var c = classes[cIndex];
                        var result = map[c];
                        if (result) {
                            classIndexes.push(result.index);
                        }
                        else {
                            Internal.Base.Helpers.error("Unable to apply item style: class `" + c + "` undefined");
                        }
                    }
                    return classIndexes.sort(function (a, b) { return a - b; });
                };
                return ItemsStyle;
            }());
            ItemsChart.ItemsStyle = ItemsStyle;
        })(ItemsChart = Internal.ItemsChart || (Internal.ItemsChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Settings.ts" />
/// <reference path="../base/Legend.ts" />
/// <reference path="layers/ItemsStyle.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var ItemsChart;
        (function (ItemsChart) {
            var Settings = (function (_super) {
                __extends(Settings, _super);
                function Settings() {
                    _super.apply(this, arguments);
                    this.data = [];
                    /** Info popup for item - meaning links or nodes - with configurable content rendered. */
                    this.info = {
                        /** Show/hide info popup */
                        enabled: false,
                        /** Returns html string to display in passed nodes info popup.
                        @returns a HTML string to display in info popup. */
                        nodeContentsFunction: null,
                        /** Returns html string to display in passed links info popup.
                        @returns a HTML string to display in info popup. */
                        linkContentsFunction: null
                    };
                    /** Customise chart resize handles or animation duration settings. */
                    this.interaction = new SettingsInteraction();
                    /** Configurable node menu with option to specify a range of displaying buttons. */
                    this.nodeMenu = new ItemsChart.SettingsNodeMenu();
                    /** Configurable link menu with option to specify a range of displaying buttons. */
                    this.linkMenu = new ItemsChart.SettingsLinkMenu();
                    this.advanced = new SettingsAdvanced();
                    this.style = {};
                }
                Settings.prototype.apply = function (settings) {
                    this.applyCompatibility(settings, [
                        { from: "style.makeImagesCircular", to: "style.node.imageCropping" },
                        { from: "style.nodeDecorationMinSize", alternative: "style.nodeDetailMinSize" },
                        { from: "style.nodeLabelMinSize", to: "style.nodeDetailMinSize" },
                        { from: "style.nodeRules", alternative: "style.nodeStyleFunction", alternativeAsWarning: true },
                        { from: "style.linkRules", alternative: "style.linkStyleFunction", alternativeAsWarning: true }
                    ]);
                    return _super.prototype.apply.call(this, settings);
                };
                return Settings;
            }(Internal.Base.Settings));
            ItemsChart.Settings = Settings;
            var SettingsData = (function (_super) {
                __extends(SettingsData, _super);
                function SettingsData() {
                    _super.apply(this, arguments);
                    /** Count of caching items including only links and nodes.
                    @type integer */
                    this.cacheSize = 10000;
                    /** Specifies the random layout method: grid, tree, uniform. The default is uniform.
                    @type enum
                    @value grid
                    @value tree
                    @value uniform
                    */
                    this.random = null;
                    this.randomGridLinkProbability = 0.6;
                    /** Generates random data. Specify a value larger than 0 to enable generating random data.
                    @type integer */
                    this.randomNodes = 0;
                    /** Generates random data.
                    @type integer */
                    this.randomLinks = 0;
                    this.randomTreeDensity = 3;
                    /** Max number of nodes to submit in a single request.
                    @type integer */
                    this.requestMaxUnits = 2;
                }
                return SettingsData;
            }(Internal.Base.SettingsData));
            ItemsChart.SettingsData = SettingsData;
            var SettingsInteraction = (function (_super) {
                __extends(SettingsInteraction, _super);
                function SettingsInteraction() {
                    _super.apply(this, arguments);
                    /** Whether to allow moving nodes around. */
                    this.nodesMovable = true;
                    /** Zoom in or out by swiping up or down with mouse scroll pad or by using the Zoom-out feature at the top left. */
                    this.zooming = new SettingsInteractionZooming();
                    /** Move chart vertically and horizontally by clicking on the main chart pane and dragging it on any direction. */
                    this.panning = {
                        /** Enables/disables chart panning. */
                        enabled: true
                    };
                    /** Select node to expand it or getting path. */
                    this.selection = new SettingsInteractionSelection();
                }
                return SettingsInteraction;
            }(Internal.Base.SettingsInteraction));
            ItemsChart.SettingsInteraction = SettingsInteraction;
            var SettingsInteractionSelection = (function () {
                function SettingsInteractionSelection() {
                    /** Enable/disable selection. */
                    this.enabled = true;
                    /** Whether to set nodes selectable. */
                    this.nodesSelectable = true;
                    /** Whether to set links selectable. */
                    this.linksSelectable = true;
                    /** Whether to retain nodes location after being moved by the user. */
                    this.lockNodesOnMove = true;
                    /** Whether to move nodes outside of screen area. */
                    this.allowMoveNodesOffscreen = true;
                    /** Max click distance from object that still counts as click on the object.
                    @type float
                    @units pixels */
                    this.tolerance = 10;
                }
                return SettingsInteractionSelection;
            }());
            ItemsChart.SettingsInteractionSelection = SettingsInteractionSelection;
            var SettingsInteractionZooming = (function () {
                function SettingsInteractionZooming() {
                    /** Enable/Disable zoom in on double click. */
                    this.zoomInOnDoubleClick = true;
                    /** Whether to auto zoom every time user clicks on the chart. */
                    this.autoZoomAfterClick = false;
                    /** A double-click on empty space will trigger zoom in by this value. Set to null or false to disable double click zooming.
                    @type float */
                    this.doubleClickZoom = 1.5;
                    /** Sensitivity of wheel zoom.
                    @type float */
                    this.sensitivity = 1;
                    /** Whether to zoom by mouse wheel. */
                    this.wheel = true;
                    /** Whether to zoom by two finger pinch. */
                    this.fingers = true;
                }
                return SettingsInteractionZooming;
            }());
            ItemsChart.SettingsInteractionZooming = SettingsInteractionZooming;
            var SettingsAdvanced = (function (_super) {
                __extends(SettingsAdvanced, _super);
                function SettingsAdvanced() {
                    _super.apply(this, arguments);
                    /** Whether to display a loading indicator on every node, otherwise only a global loading indicator. */
                    this.perNodeLoadingIndicator = true;
                }
                return SettingsAdvanced;
            }(Internal.Base.SettingsAdvanced));
            ItemsChart.SettingsAdvanced = SettingsAdvanced;
        })(ItemsChart = Internal.ItemsChart || (Internal.ItemsChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../layers/ItemsLayer.ts" />
/// <reference path="../../base/Graphics.ts" />
/// <reference path="Shape.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var ItemsChart;
        (function (ItemsChart) {
            // ImageShape is the default shape
            var ImageShape = (function (_super) {
                __extends(ImageShape, _super);
                function ImageShape() {
                    _super.apply(this, arguments);
                }
                return ImageShape;
            }(ItemsChart.Shape));
            ItemsChart.ImageShape = ImageShape;
        })(ItemsChart = Internal.ItemsChart || (Internal.ItemsChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../layers/ItemsLayer.ts" />
/// <reference path="../../base/Graphics.ts" />
/// <reference path="Shape.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var ItemsChart;
        (function (ItemsChart) {
            var TextShape = (function (_super) {
                __extends(TextShape, _super);
                function TextShape() {
                    _super.apply(this, arguments);
                    this.leftOffset = 0;
                }
                TextShape.prototype.postProcessLabel = function (g, itemRenderer) {
                    if (!this.nodesLayer.chart.assetsLoaded)
                        return;
                    // multiline label inside stretched node
                    var h = this.node.targetHHeight;
                    var l = this.currentLabel;
                    if (l == null) {
                        l = this.currentLabel = new Internal.Base.Label(this.node.labelStyle, true);
                    }
                    else {
                        // Updates label style without recreating the label itself. Recreating the label will trigger a potentially needless onSceneChange().
                        l.style = this.node.labelStyle;
                    }
                    l.text = this.node.label.toString();
                    // right now in the name of backwards compatibility, ignore the background style for the label.
                    // this is done because the node itself is the background.
                    l.style.backgroundStyle = null;
                    l.style.image = null;
                    itemRenderer.measure(g, l);
                    var ww = l.hwidth;
                    var hh = l.hheight;
                    var w = (ww / hh) * h;
                    if (this.node.image) {
                        w += h;
                    }
                    this.node.targetHWidth = Math.max(w, h);
                    this.node.bounds.x0 = -this.node.targetHWidth;
                    this.node.bounds.x1 = this.node.targetHWidth;
                };
                TextShape.prototype.distanceToEdge = function (r, w, ddx, ddy) {
                    return Internal.Base.Geometry.distanceToBalloon(r, w, ddx, ddy);
                };
                TextShape.prototype.paintSelection = function (g, prop, cons) {
                    var r = this.node.renderHheight * (1 + prop) + cons;
                    var w = this.node.renderHwidth - this.node.renderHheight + r;
                    var x = this.x;
                    var y = this.y;
                    var xx = x + w - r;
                    g.moveTo(xx, y - r);
                    g.arc(xx, y, r, -Math.PI / 2, Math.PI / 2, false);
                    xx = x - w + r;
                    g.lineTo(xx, y + r);
                    g.arc(xx, y, r, Math.PI / 2, -Math.PI / 2, false);
                    g.closePath();
                };
                TextShape.prototype.paintDetails = function (g, labelRenderer) {
                    var l = this.currentLabel;
                    if (!l) {
                        // If it's a text node that doesn't have any label assigned, it will still render image like a ImageShape
                        this.basicPaintImage(g);
                    }
                    else if (this.hWidth > 2) {
                        labelRenderer.measure(g, l);
                        this._computeScale();
                        if (this.image) {
                            var im = this.image;
                            var x0 = this.x - this.hHeight;
                            var y0 = this.y - this.imSize / 2;
                            if (this.node.imageSlicing) {
                                var s = this.node.imageSlicing;
                                Internal.Base.Graphics.drawImageHighQuality(g, im, s[0], s[1], s[2], s[3], x0, y0, this.imSize, this.imSize);
                            }
                            else {
                                Internal.Base.Graphics.drawImageHighQuality(g, im, 0, 0, im.width, im.height, x0, y0, this.imSize, this.imSize);
                            }
                        }
                        labelRenderer.paint(g, this.x + this.leftOffset, this.y, this.scale, l);
                        Internal.Base.Graphics.clearShadow(g);
                    }
                };
                TextShape.prototype._computeScale = function () {
                    this.scale = this.hWidth / this.currentLabel.hheight;
                    if (this.image) {
                        this.leftOffset = this.hWidth;
                        this.imSize = this.hWidth * 2;
                    }
                };
                return TextShape;
            }(ItemsChart.Shape));
            ItemsChart.TextShape = TextShape;
        })(ItemsChart = Internal.ItemsChart || (Internal.ItemsChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../layers/ItemsLayer.ts" />
/// <reference path="../../base/Graphics.ts" />
/// <reference path="TextShape.ts" />
/// <reference path="Shape.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var ItemsChart;
        (function (ItemsChart) {
            var RoundTextShape = (function (_super) {
                __extends(RoundTextShape, _super);
                function RoundTextShape() {
                    _super.apply(this, arguments);
                }
                RoundTextShape.prototype.postProcessLabel = function (g, itemRenderer) {
                    if (!this.nodesLayer.chart.assetsLoaded)
                        return;
                    // multiline label inside round node
                    var ls = this.node.labelStyle;
                    ls.backgroundStyle.fillColor = "transparent";
                    var l = this.currentLabel;
                    if (l == null) {
                        l = this.currentLabel = new Internal.Base.Label(ls, true);
                    }
                    else {
                        // Updates label style without recreating the label itself. Recreating the label will trigger a potentially needless onSceneChange().
                        l.style = this.node.labelStyle;
                    }
                    l.text = this.node.label.toString();
                    l.style.aspectRatio = 1;
                    l.style.image = null;
                };
                RoundTextShape.prototype.distanceToEdge = function (r, w, ddx, ddy) {
                    // The RoundTextShape is as circular as ImageShape
                    return ItemsChart.Shape.prototype.distanceToEdge.call(this, r, w, ddx, ddy);
                };
                RoundTextShape.prototype._computeScale = function () {
                    var rad = Math.sqrt(this.currentLabel.hwidth * this.currentLabel.hwidth + this.currentLabel.hheight * this.currentLabel.hheight);
                    if (this.image) {
                        var xx = this.currentLabel.lineHeight + 2 * this.currentLabel.hwidth;
                        var otherRad = (xx * xx + this.currentLabel.hheight * this.currentLabel.hheight) / 2 / xx;
                        if (otherRad > rad) {
                            this.leftOffset = (otherRad - rad);
                            rad = otherRad;
                        }
                    }
                    this.scale = this.hWidth / rad;
                    if (this.image) {
                        this.imSize = this.currentLabel.lineHeight * this.scale;
                    }
                };
                return RoundTextShape;
            }(ItemsChart.TextShape));
            ItemsChart.RoundTextShape = RoundTextShape;
        })(ItemsChart = Internal.ItemsChart || (Internal.ItemsChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../layers/ItemsLayer.ts" />
/// <reference path="../../base/Graphics.ts" />
/// <reference path="../../base/Helpers.ts" />
/// <reference path="../../base/Geometry.ts" />
/// <reference path="ImageShape.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var ItemsChart;
        (function (ItemsChart) {
            var cp = {
                a0x: 0,
                a0y: -1,
                a1x: 0.556548642145067,
                a1y: -1,
                a2x: 1,
                a2y: -0.5534547954623581,
                b0x: 1,
                b0y: 0,
                b1x: 1,
                b1y: 0.808869027157099,
                b2x: 0,
                b2y: 1.2870402200068753,
                apexX: 0,
                apexY: 1.878652526641458,
                imageRadius: 0.6170212765957447
            };
            var polygonLine = [
                cp.a0x, cp.a0y,
                cp.a1x, cp.a1y,
                cp.a2x, cp.a2y,
                cp.b0x, cp.b0y,
                cp.b1x, cp.b1y,
                cp.b2x, cp.b2y,
                cp.apexX, cp.apexY
            ];
            var reversePolygonLine = Internal.Base.Helpers.reversePolyline(Internal.Base.Geometry.transformPolyline(polygonLine, -1, 0, 1, 0));
            var offsetVectors = [
                0, -1,
                0.7095605708093294, -0.7046444467621514,
                1, 0,
                1, 0,
                0.4313896533498214, 0.9021657092700437,
                1, 0
            ];
            var reverseOffsetVectors = Internal.Base.Helpers.reversePolyline(Internal.Base.Geometry.transformPolyline(offsetVectors, -1, 0, 1, 0));
            var DropletShape = (function (_super) {
                __extends(DropletShape, _super);
                function DropletShape() {
                    _super.apply(this, arguments);
                }
                DropletShape.prototype.postProcess = function (nodesStyle, context, itemRenderer) {
                    _super.prototype.postProcess.call(this, nodesStyle, context, itemRenderer);
                    this.node.bounds.addBounds(0, 0, 0, this.node.targetHHeight * cp.apexY); // Add the apex to the bounds of the shape
                    // Assign the anchor position
                    this.node.shapeAnchorX = 0;
                    this.node.shapeAnchorY = this.node.radius * cp.apexY;
                };
                DropletShape.prototype.getAnchor = function () {
                    return {
                        x: 0,
                        y: this.hWidth * cp.apexY
                    };
                };
                DropletShape.prototype.adaptToViewport = function (txm, txa, tym, tya, zoom) {
                    _super.prototype.adaptToViewport.call(this, txm, txa, tym, tya, zoom);
                    this.controlPoints = Internal.Base.Geometry.transformPolyline(polygonLine, this.hWidth, this.x, this.hHeight, this.y);
                    this.reverseControlPoints = Internal.Base.Geometry.transformPolyline(reversePolygonLine, this.hWidth, this.x, this.hHeight, this.y);
                };
                DropletShape.prototype.paintSelection = function (g, prop, cons) {
                    var offset = this.hWidth * prop + cons;
                    var offsetPoly = Internal.Base.Geometry.outlinePolylineByVectors(this.controlPoints, offsetVectors, offset);
                    var reverseOffsetPoly = Internal.Base.Geometry.outlinePolylineByVectors(this.reverseControlPoints, reverseOffsetVectors, offset);
                    // stroke the offset curves
                    g.moveTo.apply(g, offsetPoly.slice(0, 2));
                    g.bezierCurveTo.apply(g, offsetPoly.slice(2, 8));
                    g.bezierCurveTo.apply(g, offsetPoly.slice(8, 14));
                    g.arc(this.controlPoints[12], this.controlPoints[13], offset, 0, Math.PI, false);
                    // Stroke the mirrored controlpoints
                    g.bezierCurveTo.apply(g, reverseOffsetPoly.slice(2, 8));
                    g.bezierCurveTo.apply(g, reverseOffsetPoly.slice(8, 14));
                    g.closePath();
                };
                DropletShape.prototype.paintBasicShape = function (g) {
                    var c = Internal.Base.Graphics.beginStrokeAndFill(g, this.node);
                    c.beginPath();
                    c.moveTo.apply(c, this.controlPoints.slice(0, 2));
                    c.bezierCurveTo.apply(c, this.controlPoints.slice(2, 8));
                    c.bezierCurveTo.apply(c, this.controlPoints.slice(8, 14));
                    c.bezierCurveTo.apply(c, this.reverseControlPoints.slice(2, 8));
                    c.bezierCurveTo.apply(c, this.reverseControlPoints.slice(8, 14));
                    c.closePath();
                    Internal.Base.Graphics.endStrokeAndFill(g, c, this.node);
                };
                DropletShape.prototype.paintDetails = function (g, labelRenderer) {
                    if (this.image) {
                        this.basicPaintImage(g, cp.imageRadius);
                    }
                    this.paintLabel(g, labelRenderer);
                };
                DropletShape.prototype.getLabelPosition = function (label, scale) {
                    return {
                        x: this.x,
                        y: this.y - this.hWidth - label.hheight * scale * 1.1
                    };
                };
                DropletShape.prototype.distanceToEdge = function (r, w, ddx, ddy) {
                    // There are 2 lines going from the side to the apex of the droplet (both lines are symmetrical)
                    var cpx = w; // x control point of the line (+ and -)
                    var cpy = r * cp.apexY; // y coordinate of the apex
                    var toLine1 = Internal.Base.Geometry.rayIntersectsSegment(0, 0, ddx, ddy, 0, cpy, cpx, 0);
                    var toLine2 = Internal.Base.Geometry.rayIntersectsSegment(0, 0, ddx, ddy, -cpx, 0, 0, cpy);
                    var closestLineIntersection = Math.min(toLine1, toLine2);
                    // If the line isn't intersected, it would return infinity. In such case return the radius
                    return (closestLineIntersection < Infinity) ? closestLineIntersection : r;
                };
                return DropletShape;
            }(ItemsChart.Shape));
            ItemsChart.DropletShape = DropletShape;
        })(ItemsChart = Internal.ItemsChart || (Internal.ItemsChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var ItemsChart;
        (function (ItemsChart) {
            var RectangleShape = (function (_super) {
                __extends(RectangleShape, _super);
                function RectangleShape() {
                    _super.apply(this, arguments);
                }
                RectangleShape.prototype.calcHalf = function (hWidth, hHeight) {
                    if (this.node.aspectRatio > 1) {
                        return {
                            hWidth: hWidth,
                            hHeight: hWidth / this.node.aspectRatio
                        };
                    }
                    else {
                        return {
                            hWidth: hHeight * this.node.aspectRatio,
                            hHeight: hHeight
                        };
                    }
                };
                RectangleShape.prototype.render = function (g, prop, cons) {
                    var half = this.calcHalf(this.hWidth, this.hHeight);
                    var hh = half.hHeight;
                    var hw = half.hWidth;
                    hh = hh * (1 + prop) + cons;
                    hw = hw * (1 + prop) + cons;
                    g.moveTo(this.x, this.y);
                    g.moveTo(this.x - hw, this.y - hh);
                    g.lineTo(this.x + hw, this.y - hh);
                    g.lineTo(this.x + hw, this.y + hh);
                    g.lineTo(this.x - hw, this.y + hh);
                    g.lineTo(this.x - hw, this.y - hh);
                };
                RectangleShape.prototype.paintBasicShape = function (g) {
                    var strokeContext = Internal.Base.Graphics.beginStrokeAndFill(g, this.node);
                    this.render(strokeContext, 0, 0);
                    Internal.Base.Graphics.endStrokeAndFill(g, strokeContext, this.node);
                };
                /**
                 * Performs the canvas rendering context methods to outline the strokes in the background of a selected shape, but doesn't call the stroke itself
                 * As a result the render can be batched, and all shapes can have the same styling
                 * @param g - The rendering context
                 * @param prop - The proportional sizing component to scale the shape
                 * @param cons - The additional constant sizing component to scale the shape
                 */
                RectangleShape.prototype.paintSelection = function (g, prop, cons) {
                    this.render(g, prop, cons);
                    g.closePath();
                };
                /**
                 * Returns the distance from the shape center to the edge, given a direction vector of the ray
                 * @param hWidth - halfHeight
                 * @param hHeight - halfWidth
                 * ddx and ddy is a direction vector pointing from the center of the shape
                 * @param ddx - ddx coefficient of the ray from the shape. sin(alpha). (deltaX / lengthOfRay)
                 * @param ddy - ddx coefficient of the ray from the shape. cos(alpha). (deltaY / lengthOfRay)
                 * @returns {number} - the distance from the shape center to the outer border of the shape
                 */
                RectangleShape.prototype.distanceToEdge = function (hWidth, hHeight, ddx, ddy) {
                    var half = this.calcHalf(hWidth, hHeight);
                    return Math.min(half.hHeight / Math.abs(ddy), half.hWidth / Math.abs(ddx));
                };
                /**
                 * During hitTest the NodesLayer would loop over shapes, and perform hitNode(). Within the boundaries of
                 * tolerance, if no shape returns 0, the closest shape will be returned.
                 * @param x
                 * @param y
                 * @param itemScale
                 * @param prevBest - As the NodesLayer loops over nodes, this is the distance to closest node to the coordinate so far
                 * @returns {number} - The distance to node.  In the event of a positive test,
                 * the method should return 0. If the distance is within the boundaries of tolerance,
                 * the distance is returned. Otherwise it just returns the previous nearest distance (of a different node)
                 */
                RectangleShape.prototype.hitTest = function (x, y, itemScale, prevBest) {
                    var n = this.node;
                    var half = this.calcHalf(n.renderHwidth * itemScale, n.renderHheight * itemScale);
                    var d = Math.max(Math.abs(x - n.x) - half.hWidth, Math.abs(y - n.y) - half.hHeight);
                    return d < 0 ? 0 : Math.min(d, prevBest);
                };
                return RectangleShape;
            }(ItemsChart.Shape));
            ItemsChart.RectangleShape = RectangleShape;
        })(ItemsChart = Internal.ItemsChart || (Internal.ItemsChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="ItemsStyle.ts" />
/// <reference path="../../base/Settings.ts" />
/// <reference path="../../base/Label.ts" />
/// <reference path="../shapes/CustomShape.ts" />
/// <reference path="../shapes/ImageShape.ts" />
/// <reference path="../shapes/RoundTextShape.ts" />
/// <reference path="../shapes/TextShape.ts" />
/// <reference path="../shapes/DropletShape.ts" />
/// <reference path="../shapes/RectangleShape.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var ItemsChart;
        (function (ItemsChart) {
            var SettingsNodesLayerStyle = (function (_super) {
                __extends(SettingsNodesLayerStyle, _super);
                function SettingsNodesLayerStyle() {
                    _super.apply(this, arguments);
                    /** Distance between multiple links between two nodes.
                    @type float
                    @units pixels */
                    this.multilinkSpacing = 10;
                    /** Min and max value of node radius, before zooming is applied.
                    @baseType integer */
                    this.nodeRadiusExtent = [10, 150];
                    /** Min and max value of link half-width before zooming is applied.
                    @baseType float */
                    this.linkRadiusExtent = [0.6, 30];
                    /** Min and max value for link strength.
                    @baseType float */
                    this.linkStrengthExtent = [0.1, 1];
                    /** Min and max value of link length before zooming is applied.
                    @baseType float */
                    this.linkLengthExtent = [0.3, 150];
                    /** Controls automatic node scaling.
                    @type enum
                    @value null - scaling disabled
                    @value linear - distribute node radii linearly in the range defined by nodeRadiusExtent
                    @value logaritmic - distribute node radii logarithmicaly in the range defined by nodeRadiusExtent. */
                    this.nodeAutoScaling = null;
                    /** Link radius auto distribution method.
                    @type enum
                    @value null - scaling disabled
                    @value linear - distribute link radii linearly between min, max value of linkRadiusExtent
                    @value logaritmic - distribute link radii logarithmically between min, max value of linkRadiusExtent. */
                    this.linkAutoScaling = null;
                    /** Link strength auto distribution method.
                    @type enum
                    @value null - scaling disabled
                    @value linear - distribute link strengths linearly between min, max value of linkStrengthExtent
                    @value logaritmic -  distribute link strengths logarithmically between min, max value of linkStrengthExtent. */
                    this.linkStrengthAutoScaling = null;
                    /** Link length auto distribution method.
                    @type enum
                    @value null - scaling disabled
                    @value linear - distribute link lengths linearly between min, max value of linkLengthExtent
                    @value logaritmic -  distribute link lengths logarithmically between min, max value of linkLengthExtent. */
                    this.linkLengthAutoScaling = null;
                    /** style for hidden link hints. */
                    this.hiddenLinks = {
                        lineColor: "rgba(100,100,100,0.3)",
                        lineWidth: 1,
                        size: 7
                    };
                    /** Removed object fadeout time.
                    @type integer
                    @units milliseconds */
                    this.fadeTime = 600;
                }
                return SettingsNodesLayerStyle;
            }(ItemsChart.SettingsItemsLayerStyle));
            ItemsChart.SettingsNodesLayerStyle = SettingsNodesLayerStyle;
            var NodesStyle = (function (_super) {
                __extends(NodesStyle, _super);
                function NodesStyle(styleSettings, layer, fadeout) {
                    _super.call(this, styleSettings, layer);
                    this.g = null;
                    this.fadeout = fadeout;
                    this.styleSettings = styleSettings;
                }
                NodesStyle.prototype.updateLayer = function (event, isIncremental) {
                    if (isIncremental === void 0) { isIncremental = false; }
                    this.nodeRadiusChanged =
                        Internal.Base.Helpers.hasProperties(this.layer.newNodes) ||
                            Internal.Base.Helpers.hasProperties(this.layer.deletedNodes) ||
                            (this.styleSettings.allObjectsStyleFunction && this.layer.hasStyleChanges()) ||
                            this.nodeRules.length > 0;
                    this.linkRadiusChanged =
                        Internal.Base.Helpers.hasProperties(this.layer.newLinks) ||
                            Internal.Base.Helpers.hasProperties(this.layer.deletedLinks) ||
                            (this.styleSettings.allObjectsStyleFunction && this.layer.hasStyleChanges()) ||
                            this.linkRules.length > 0;
                    _super.prototype.updateLayer.call(this, event, isIncremental);
                };
                NodesStyle.prototype.postprocessLayer = function (event) {
                    // Custom implementation - does not call super
                    this.g = event.context;
                    var layer = this.layer;
                    var removedColor = this.styleSettings.removedColor;
                    this.itemRenderer = event.labelRenderer;
                    for (var id3 in layer.modifiedLinks) {
                        var link1 = layer.modifiedLinks[id3];
                        if (this.fadeout && link1.relevance < 1) {
                            if (link1.fillColor) {
                                link1.fillColor = Internal.Base.Colors.blend(removedColor, link1.fillColor, link1.relevance);
                            }
                            if (link1.lineColor) {
                                link1.lineColor = Internal.Base.Colors.blend(removedColor, link1.lineColor, link1.relevance);
                            }
                            // TODO: copied from Layout
                            link1.length = 0.2 + (link1.length - 0.2) * link1.relevance;
                        }
                        this.postprocessLink(link1);
                    }
                    for (var id in layer.modifiedNodes) {
                        var node = layer.modifiedNodes[id];
                        if (this.fadeout && node.relevance < 1) {
                            if (node.fillColor) {
                                node.fillColor = Internal.Base.Colors.blend(removedColor, node.fillColor, node.relevance);
                            }
                            if (node.lineColor) {
                                node.lineColor = Internal.Base.Colors.blend(removedColor, node.lineColor, node.relevance);
                            }
                        }
                    }
                    // update node radii
                    var nodes = this.layer.nodes();
                    if (this.nodeRadiusChanged || (this.fadeout && event.changes.navigation)) {
                        this.computeNodeSize(nodes, this.styleSettings.nodeAutoScaling, this.styleSettings.nodeRadiusExtent);
                        for (var nIndex = 0; nIndex < nodes.length; nIndex++) {
                            var n = nodes[nIndex];
                            this.postprocessNode(n);
                        }
                    }
                    else {
                        for (var id2 in layer.modifiedNodes) {
                            var node1 = layer.modifiedNodes[id2];
                            this.postprocessNode(node1);
                        }
                    }
                    // update link radii
                    if (this.linkRadiusChanged || event.changes.navigation) {
                        var links = layer.links();
                        this.computeRadii(links, this.styleSettings.linkAutoScaling, this.styleSettings.linkRadiusExtent);
                        this.computeStrengths(links, this.styleSettings.linkStrengthAutoScaling, this.styleSettings.linkStrengthExtent);
                        this.computeLengths(links, this.styleSettings.linkLengthAutoScaling, this.styleSettings.linkLengthExtent);
                        // sort links to draw biggest in foreground
                        Internal.Base.Helpers.sort(links, function (a, b) {
                            if (a.targetRadius === b.targetRadius) {
                                return 0;
                            }
                            return (a.targetRadius > b.targetRadius) ? 1 : (-1);
                        });
                    }
                    // sort nodes by z index
                    Internal.Base.Helpers.sort(nodes, function (a, b) { return a.zindex - b.zindex; });
                };
                NodesStyle.prototype.updateLink = function (link) {
                    var r = link.radius;
                    _super.prototype.updateLink.call(this, link);
                    if (r !== link.radius) {
                        this.linkRadiusChanged = true;
                    }
                };
                NodesStyle.prototype.updateNode = function (node) {
                    var r = node.radius;
                    _super.prototype.updateNode.call(this, node);
                    if (r !== node.radius) {
                        this.nodeRadiusChanged = true;
                    }
                    if (node.label == null && node.data) {
                        node.label = node.data.id;
                    }
                };
                NodesStyle.prototype.computeNodeSize = function (nodes, mode, extents) {
                    var minE = extents[0];
                    var maxE = extents[1];
                    if (mode === "linear" || mode === "logarithmic" || mode === "square") {
                        var min = Infinity;
                        var max = -Infinity;
                        for (var objIndex = 0; objIndex < nodes.length; objIndex++) {
                            var obj = nodes[objIndex];
                            if (!obj.removed) {
                                var r = obj.radius;
                                if (Internal.Base.Helpers.isNumber(r)) {
                                    min = Math.min(min, r);
                                    max = Math.max(max, r);
                                }
                                else {
                                    obj.targetHHeight = minE;
                                }
                            }
                        }
                        if (min >= max) {
                            for (var objIndex = 0; objIndex < nodes.length; objIndex++) {
                                var obj = nodes[objIndex];
                                if (!obj.removed) {
                                    obj.targetHHeight = minE;
                                }
                            }
                        }
                        else if (mode === "linear") {
                            var mul = maxE / max;
                            for (var objIndex = 0; objIndex < nodes.length; objIndex++) {
                                var obj = nodes[objIndex];
                                if (!obj.removed) {
                                    var r = obj.radius;
                                    if (Internal.Base.Helpers.isNumber(r)) {
                                        obj.targetHHeight = Math.max(minE, r * mul);
                                    }
                                }
                            }
                        }
                        else if (mode === "square") {
                            var mul = maxE / Math.sqrt(max);
                            for (var objIndex = 0; objIndex < nodes.length; objIndex++) {
                                var obj = nodes[objIndex];
                                if (!obj.removed) {
                                    var r = obj.radius;
                                    if (Internal.Base.Helpers.isNumber(r)) {
                                        obj.targetHHeight = Math.max(minE, Math.sqrt(r) * mul);
                                    }
                                }
                            }
                        }
                        else {
                            // logarithmic
                            min = Math.max(0.0001, min);
                            max = Math.max(min + 0.0001, max);
                            var mul = maxE / Math.log(max);
                            for (var objIndex = 0; objIndex < nodes.length; objIndex++) {
                                var obj = nodes[objIndex];
                                if (!obj.removed && Internal.Base.Helpers.isNumber(obj.radius)) {
                                    obj.targetHHeight = Math.max(minE, Math.log(Math.max(0.0001, obj.radius)) * mul);
                                }
                            }
                        }
                    }
                    else {
                        // just apply the extents
                        for (var objIndex = 0; objIndex < nodes.length; objIndex++) {
                            var obj = nodes[objIndex];
                            if (!obj.removed) {
                                if (Internal.Base.Helpers.isNumber(obj.radius)) {
                                    obj.targetHHeight = Math.min(Math.max(0.000001, obj.radius), 1e30);
                                }
                                else {
                                    obj.targetHHeight = minE;
                                }
                            }
                        }
                    }
                    if (this.fadeout) {
                        for (var objIndex = 0; objIndex < nodes.length; objIndex++) {
                            var obj = nodes[objIndex];
                            if (obj.relevance < 1) {
                                obj.targetHHeight = obj.targetHHeight * obj.relevance;
                            }
                        }
                    }
                };
                NodesStyle.prototype.computeRadii = function (objects, mode, extents) {
                    var minE = extents[0];
                    var maxE = extents[1];
                    if (mode === "linear" || mode === "logarithmic" || mode === "square") {
                        var min = Infinity;
                        var max = -Infinity;
                        for (var objIndex = 0; objIndex < objects.length; objIndex++) {
                            var obj = objects[objIndex];
                            if (!obj.removed) {
                                var r = obj.radius;
                                if (Internal.Base.Helpers.isNumber(r)) {
                                    min = Math.min(min, r);
                                    max = Math.max(max, r);
                                }
                                else {
                                    obj.targetRadius = minE;
                                }
                            }
                        }
                        if (min >= max) {
                            for (var objIndex = 0; objIndex < objects.length; objIndex++) {
                                var obj = objects[objIndex];
                                if (!obj.removed) {
                                    obj.targetRadius = minE;
                                }
                            }
                        }
                        else if (mode === "linear") {
                            var mul = maxE / max;
                            for (var objIndex = 0; objIndex < objects.length; objIndex++) {
                                var obj = objects[objIndex];
                                if (!obj.removed) {
                                    var r = obj.radius;
                                    if (Internal.Base.Helpers.isNumber(r)) {
                                        obj.targetRadius = Math.max(minE, r * mul);
                                    }
                                }
                            }
                        }
                        else if (mode === "square") {
                            var mul = maxE / Math.sqrt(max);
                            for (var objIndex = 0; objIndex < objects.length; objIndex++) {
                                var obj = objects[objIndex];
                                if (!obj.removed) {
                                    var r = obj.radius;
                                    if (Internal.Base.Helpers.isNumber(r)) {
                                        obj.targetRadius = Math.max(minE, Math.sqrt(r) * mul);
                                    }
                                }
                            }
                        }
                        else {
                            // logarithmic
                            min = Math.max(0.0001, min);
                            max = Math.max(min + 0.0001, max);
                            var mul = maxE / Math.log(max);
                            for (var objIndex = 0; objIndex < objects.length; objIndex++) {
                                var obj = objects[objIndex];
                                if (!obj.removed && Internal.Base.Helpers.isNumber(obj.radius)) {
                                    obj.targetRadius = Math.max(minE, Math.log(Math.max(0.0001, obj.radius)) * mul);
                                }
                            }
                        }
                    }
                    else {
                        // just apply the extents
                        for (var objIndex = 0; objIndex < objects.length; objIndex++) {
                            var obj = objects[objIndex];
                            if (!obj.removed) {
                                if (Internal.Base.Helpers.isNumber(obj.radius)) {
                                    obj.targetRadius = Math.min(Math.max(0.000001, obj.radius), 1e30);
                                }
                                else {
                                    obj.targetRadius = minE;
                                }
                            }
                        }
                    }
                    if (this.fadeout) {
                        for (var objIndex = 0; objIndex < objects.length; objIndex++) {
                            var obj = objects[objIndex];
                            if (obj.relevance < 1) {
                                obj.targetRadius = obj.targetRadius * obj.relevance;
                            }
                        }
                    }
                };
                NodesStyle.prototype.computeStrengths = function (objects, mode, extents) {
                    var minE = extents[0];
                    var maxE = extents[1];
                    if (mode === "linear" || mode === "logarithmic" || mode === "square") {
                        var min = Infinity;
                        var max = -Infinity;
                        for (var objIndex = 0; objIndex < objects.length; objIndex++) {
                            var obj = objects[objIndex];
                            if (!obj.removed) {
                                min = Math.min(min, obj.strength);
                                max = Math.max(max, obj.strength);
                            }
                        }
                        if (min >= max) {
                            for (var objIndex = 0; objIndex < objects.length; objIndex++) {
                                var obj = objects[objIndex];
                                if (!obj.removed) {
                                    obj.targetStrength = minE;
                                }
                            }
                        }
                        else if (mode === "linear") {
                            var mul = maxE / max;
                            for (var objIndex = 0; objIndex < objects.length; objIndex++) {
                                var obj = objects[objIndex];
                                if (!obj.removed) {
                                    obj.targetStrength = Math.min(minE, obj.strength * mul);
                                }
                            }
                        }
                        else if (mode === "square") {
                            var mul = maxE / Math.sqrt(max);
                            for (var objIndex = 0; objIndex < objects.length; objIndex++) {
                                var obj = objects[objIndex];
                                if (!obj.removed) {
                                    var r = obj.strength;
                                    if (Internal.Base.Helpers.isNumber(r)) {
                                        obj.targetStrength = Math.max(minE, Math.sqrt(r) * mul);
                                    }
                                }
                            }
                        }
                        else {
                            // logarithmic
                            min = Math.max(0.0001, min);
                            max = Math.max(min + 0.0001, max);
                            var mul = maxE / Math.log(max);
                            for (var objIndex = 0; objIndex < objects.length; objIndex++) {
                                var obj = objects[objIndex];
                                if (!obj.removed) {
                                    obj.targetStrength = Math.max(minE, Math.log(Math.max(0.0001, obj.strength)) * mul);
                                }
                            }
                        }
                    }
                    else {
                        // just apply the extents
                        for (var objIndex = 0; objIndex < objects.length; objIndex++) {
                            var obj = objects[objIndex];
                            if (!obj.removed) {
                                obj.targetStrength = Math.min(Math.max(minE, obj.strength), maxE);
                            }
                        }
                    }
                };
                NodesStyle.prototype.computeLengths = function (objects, mode, extents) {
                    var minE = extents[0];
                    var maxE = extents[1];
                    if (mode === "linear" || mode === "logarithmic" || mode === "square") {
                        var min = Infinity;
                        var max = -Infinity;
                        for (var objIndex = 0; objIndex < objects.length; objIndex++) {
                            var obj = objects[objIndex];
                            if (!obj.removed) {
                                min = Math.min(min, obj.length);
                                max = Math.max(max, obj.length);
                            }
                        }
                        if (min >= max) {
                            for (var objIndex = 0; objIndex < objects.length; objIndex++) {
                                var obj = objects[objIndex];
                                if (!obj.removed) {
                                    obj.targetLength = minE;
                                }
                            }
                        }
                        else if (mode === "linear") {
                            var mul = (maxE - minE) / (max - min);
                            var add = maxE - max * mul;
                            for (var objIndex = 0; objIndex < objects.length; objIndex++) {
                                var obj = objects[objIndex];
                                if (!obj.removed) {
                                    obj.targetLength = obj.length * mul + add;
                                }
                            }
                        }
                        else if (mode === "square") {
                            var mul = maxE / Math.sqrt(max);
                            for (var objIndex = 0; objIndex < objects.length; objIndex++) {
                                var obj = objects[objIndex];
                                if (!obj.removed) {
                                    var r = obj.length;
                                    if (Internal.Base.Helpers.isNumber(r)) {
                                        obj.targetLength = Math.max(minE, Math.sqrt(r) * mul);
                                    }
                                }
                            }
                        }
                        else {
                            // logarithmic
                            min = Math.max(0.0001, min);
                            max = Math.max(min + 0.0001, max);
                            var mul = (maxE - minE) / Math.log(max / min);
                            var add = maxE - mul * Math.log(max);
                            for (var objIndex = 0; objIndex < objects.length; objIndex++) {
                                var obj = objects[objIndex];
                                if (!obj.removed) {
                                    obj.targetLength = Math.log(Math.max(0.0001, obj.length)) * mul + add;
                                }
                            }
                        }
                    }
                    else {
                        // just apply the extents
                        for (var objIndex = 0; objIndex < objects.length; objIndex++) {
                            var obj = objects[objIndex];
                            if (!obj.removed) {
                                obj.targetLength = Math.min(Math.max(minE, obj.length), maxE);
                            }
                        }
                    }
                };
                NodesStyle.prototype.postprocessNode = function (node) {
                    // set the node shape based on node display
                    var ShapeClass;
                    switch (node.display) {
                        case "customShape":
                            ShapeClass = ItemsChart.CustomShape;
                            break;
                        case "roundtext":
                            ShapeClass = ItemsChart.RoundTextShape;
                            break;
                        case "text":
                            ShapeClass = ItemsChart.TextShape;
                            break;
                        case "droplet":
                            ShapeClass = ItemsChart.DropletShape;
                            break;
                        case "rectangle":
                            ShapeClass = ItemsChart.RectangleShape;
                            break;
                        default:
                            ShapeClass = ItemsChart.ImageShape;
                            break;
                    }
                    if (!node.shape || node.shape.constructor !== ShapeClass) {
                        if (node.shape) {
                            node.shape.node = null;
                        }
                        node.shape = new ShapeClass(node, this.layer);
                    }
                    var outerBounds = node.outerBounds = Internal.Base.Rect.createEmpty();
                    node.shape.postProcess(this.styleSettings, this.g, this.itemRenderer);
                    outerBounds.addRect(node.bounds);
                    node.currentItems = [];
                    this.postprocessItems(node);
                    // add item bounds
                    var w = node.targetHWidth;
                    var h = node.targetHHeight;
                    for (var lIndex = 0; lIndex < node.currentItems.length; lIndex++) {
                        var l = node.currentItems[lIndex];
                        this.measureCustomItem(w, h, node.shape.sizeScale, l, outerBounds);
                    }
                };
                NodesStyle.prototype.measureCustomItem = function (hwidth, hheight, sizeScale, item, outerBounds) {
                    this.itemRenderer.measure(this.g, item);
                    var scale = 1;
                    if (item.style.scaleWithSize) {
                        scale = sizeScale;
                    }
                    /*
                    else if (item.scaleWithZoom) {
                        scale = 1;
                    } else {
                        // stopgap value, as this is zoom dependant
                        scale = 1;
                    }*/
                    var fx = item.style.x || 0;
                    var fy = item.style.y || 0;
                    var ix = item.style.px || 0;
                    var iy = item.style.py || 0;
                    var xx = hwidth * ix + fx;
                    var yy = hheight * iy + fy;
                    outerBounds.addBounds(xx - item.hwidth * scale, yy - item.hheight * scale, xx + item.hwidth * scale, yy + item.hheight * scale);
                };
                NodesStyle.prototype.postprocessLink = function (link) {
                    // build currentItems
                    var items = [];
                    if (link.label) {
                        var i = void 0;
                        if (link.currentItems && link.currentItems.length) {
                            i = link.currentItems[0];
                            i.style = link.labelStyle;
                        }
                        else {
                            i = new Internal.Base.Label(link.labelStyle);
                        }
                        i.text = link.label.toString();
                        i.style.px = 0;
                        i.style.py = 0;
                        items.push(i);
                    }
                    // link.outerBounds are not calculated here because they cannot be calculated since node X/Y coordinates are not available yet
                    link.currentItems = items;
                    this.postprocessItems(link);
                };
                return NodesStyle;
            }(ItemsChart.ItemsStyle));
            ItemsChart.NodesStyle = NodesStyle;
        })(ItemsChart = Internal.ItemsChart || (Internal.ItemsChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="GeoJSON.d.ts" />
/*

GeoJSON parsing. See http://geojson.org/geojson-spec.html

Back already? OK, now for the ugly part (naturally).

GeoJSON is a nice format, but it doesn't map well to geochart data format. It will work fine for the simple cases, but in the
universal case it's not very good. That is because, as of this writing, GeoChart really only understands two different objects:
a single point and a... well, I'll call it a "polygroup" to give it a unique name.

A polygroup is an array of polygons that are each drawn separately as whole polygons. If two individual polygons overlap, they
are still drawn on top of each other. However for the purposes of hittesting, if two polygons overlap, the common area is
treated like a "hole". If a third polygon overlaps the common area, then it's considered to be a part of the polygroup again,
etc. In other words, a point is considered to belong to the polygroup, if and only if it belongs to an odd number of
polygons in the polygroup.

With this in mind, here's how GeoJSON objects map to points/polygroups.

Feature: Each feature is normally converted one node (shape). However GeometryCollections and MultiPoints will create multiple
    nodes. The ID of each node is taken from the feature. In the end, all nodes with identical IDs get their IDs altered to make
    them unique.

FeatureCollection: Each feature in the collection is treated separately.

GeometryCollection: Each new geometry creates a separate node, but they all share the same feature object (and ID).

Point: This maps directly to a single node.

MultiPoint: Each point in the MultiPoint is a separate node.

Line: There is no way to represent lines, so each line is treated as a polygon. Not really correct, but what else?

MultiLine: similar to Line, each line is treated as a polygon, and all the polygons are gathered in a single polygroup.

Polygon/MultiPolygon: all the LineRings are converted to polygons and added to a single polygroup. This tends to work more or
    less OK for simple cases, although with weird overlaps it's easy to achieve wrong effects.

Ideas that won't work:

We cannot split a single GeoJSON multipolygon into several polygroups, because they need to be
treated as the same node Typical example: Estonia consists of a mainland and several small islands which are defined a
a GeoJSON multipolygon. But for the purposes of selection/hovering they need to be treated as a single node (shape).

We cannot ignore the "holes" in the polygons, otherwise hittesting gets wrong. For example: in the Latvian GeoJSON file there
is a feature "Daugavpils novads" which has a hole in it. There is also a feature "Daugavpils" which fits exactly in this hole.
If the hole is ignored, then hittesting never finds "Daugavpils", instead always returning "Daugavpils novads". Thus it is
better to keep the holes, even if they're drawn wrongly, because it makes the chart behave correctly.

*/
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var GeoChart;
        (function (GeoChart) {
            function getFeatureId(feature) {
                if (!feature)
                    return null;
                if (feature.properties && feature.properties.id && Internal.Base.Helpers.isString(feature.properties.id))
                    return feature.properties.id;
                return feature.id;
            }
            function expandLineString(coordinates) {
                if (!Array.isArray(coordinates))
                    return "GeoJSON LineString data contained invalid coordinate collection.";
                if (coordinates.length < 2)
                    return "GeoJSON LineString data must contain at least 2 points.";
                var ret = new Array(coordinates.length * 2);
                for (var j = 0; j < coordinates.length; j++) {
                    var p = coordinates[j];
                    if (!p || !Internal.Base.Helpers.isNumber(p[0]) || !Internal.Base.Helpers.isNumber(p[1]))
                        return "GeoJSON LineString data contained invalid coordinates.";
                    ret[j * 2] = p[0];
                    ret[j * 2 + 1] = p[1];
                }
                return ret;
            }
            function expandPoly(coordinates, target) {
                if (!Array.isArray(coordinates))
                    return "GeoJSON Polygon data contained invalid coordinate collection.";
                if (coordinates.length < 1)
                    return "GeoJSON Polygon data doesn't contain any LinearRings.";
                for (var i = 0; i < coordinates.length; i++) {
                    var x = expandLineString(coordinates[i]);
                    if (Internal.Base.Helpers.isString(x)) {
                        return x;
                    }
                    else {
                        target.push(x);
                    }
                }
                return null;
            }
            function expandPoint(coordinates) {
                if (!Internal.Base.Helpers.isNumber(coordinates[0]) || !Internal.Base.Helpers.isNumber(coordinates[1]))
                    return "GeoJSON data contained invalid coordinates.";
                return [coordinates[0], coordinates[1]];
            }
            function extractPoly(geometry) {
                var ret = [];
                var err = expandPoly(geometry.coordinates, ret);
                if (err) {
                    return err;
                }
                else {
                    return ret;
                }
            }
            function extractMultiPoly(geometry) {
                var coordinates = geometry.coordinates;
                if (!Array.isArray(coordinates))
                    return "GeoJSON MultiPolygon data contained invalid coordinates";
                if (coordinates.length < 1)
                    return "GeoJSON MultiPolygon data doesn't contain any Polygons.";
                var allPolygons = [];
                for (var i = 0; i < coordinates.length; i++) {
                    var err = expandPoly(coordinates[i], allPolygons);
                    if (err)
                        return err;
                }
                return allPolygons;
            }
            function extractLine(geometry) {
                var ret = expandLineString(geometry.coordinates);
                return Internal.Base.Helpers.isString(ret) ? ret : [ret];
            }
            function extractMultiLine(geometry) {
                var coordinates = geometry.coordinates;
                if (!Array.isArray(coordinates))
                    return "GeoJSON MultiLineString data contained invalid coordinates";
                if (coordinates.length < 1)
                    return "GeoJSON MultiLineString data doesn't contain any lines.";
                var allLines = new Array(coordinates.length);
                for (var i = 0; i < coordinates.length; i++) {
                    var line = expandLineString(coordinates[i]);
                    if (Internal.Base.Helpers.isString(line)) {
                        return line;
                    }
                    else {
                        allLines[i] = line;
                    }
                }
                return allLines;
            }
            function tryAddNode(nodes, coordinates, type, feature, geometry, error) {
                if (Internal.Base.Helpers.isString(coordinates)) {
                    error(coordinates, feature);
                }
                else {
                    nodes.push({
                        _x: 0,
                        _y: 0,
                        id: getFeatureId(feature),
                        loaded: true,
                        coordinates: coordinates,
                        type: type,
                        shapeFeature: feature,
                        shapeGeometry: geometry
                    });
                }
            }
            function convertGeometryWithCoordinates(nodes, geometry, feature, error) {
                if (!Array.isArray(geometry.coordinates)) {
                    error("GeoJSON data contained invalid object.", feature);
                    return;
                }
                switch (geometry.type) {
                    case "Point":
                        tryAddNode(nodes, expandPoint(geometry.coordinates), "point", feature, geometry, error);
                        break;
                    case "MultiPoint":
                        var obj = geometry;
                        if (!Array.isArray(obj.coordinates)) {
                            error("GeoJSON data contained invalid MultiPoint object.", feature);
                        }
                        else {
                            for (var i = 0; i < obj.coordinates.length; i++)
                                tryAddNode(nodes, expandPoint(obj.coordinates[i]), "point", feature, geometry, error);
                        }
                        break;
                    case "LineString":
                        tryAddNode(nodes, extractLine(geometry), "line", feature, geometry, error);
                        break;
                    case "MultiLineString":
                        tryAddNode(nodes, extractMultiLine(geometry), "line", feature, geometry, error);
                        break;
                    case "Polygon":
                        tryAddNode(nodes, extractPoly(geometry), "polygon", feature, geometry, error);
                        break;
                    case "MultiPolygon":
                        tryAddNode(nodes, extractMultiPoly(geometry), "polygon", feature, geometry, error);
                        break;
                    default:
                        error("GeoJSON data contained unknown object with type \"" + geometry.type + "\" .", feature);
                        return;
                }
            }
            function convertGeometry(nodes, object, feature, error) {
                if (object.type === "GeometryCollection") {
                    var o = object;
                    if (!Array.isArray(o.geometries)) {
                        error("GeoJSON data contained invalid GeometryCollection object.", feature);
                    }
                    else {
                        for (var i = 0; i < o.geometries.length; i++)
                            convertGeometry(nodes, o.geometries[i], feature, error);
                    }
                }
                else {
                    convertGeometryWithCoordinates(nodes, object, feature, error);
                }
            }
            function convertFeature(nodes, feature, error) {
                if (!feature.geometry || feature.type !== "Feature") {
                    error("GeoJSON data contained invalid feature object.", feature);
                    return;
                }
                convertGeometry(nodes, feature.geometry, feature, error);
            }
            function convertFeatureCollection(nodes, object, error) {
                if (!Array.isArray(object.features) || object.type !== "FeatureCollection") {
                    error("GeoJSON data contained invalid FeatureCollection object.", null);
                    return;
                }
                for (var i = 0; i < object.features.length; i++) {
                    convertFeature(nodes, object.features[i], error);
                }
            }
            function convertFromGeoJson(object, chart) {
                if (!object)
                    return [];
                var nodes = [];
                function error(error, feature) {
                    chart.error("Error: " + error + " Feature id: '" + getFeatureId(feature) + "'");
                }
                switch (object.type) {
                    case "FeatureCollection":
                        convertFeatureCollection(nodes, object, error);
                        break;
                    case "Feature":
                        convertFeature(nodes, object, error);
                        break;
                    case "GeometryCollection":
                        convertGeometry(nodes, object, null, error);
                        break;
                    case "Point":
                    case "MultiPoint":
                    case "LineString":
                    case "MultiLineString":
                    case "Polygon":
                    case "MultiPolygon":
                        convertGeometryWithCoordinates(nodes, object, null, error);
                        break;
                    default:
                        error("GeoJSON data contained unknown object with type \"" + object.type + "\" .", null);
                        return;
                }
                // Ensure unique IDs.
                var idCounters = { "##default": 0 };
                for (var i = 0; i < nodes.length; i++) {
                    var node = nodes[i];
                    if (node.id == null) {
                        node.id = "##default" + Internal.Base.Helpers.SeparatorChar + (idCounters["##default"]++); // Append a GUID so that the ID is definitely unique.
                    }
                    else if (Internal.Base.Helpers.hasProperty(idCounters, node.id)) {
                        node.id += Internal.Base.Helpers.SeparatorChar + (idCounters[node.id]++);
                    }
                    else {
                        idCounters[node.id] = 0;
                    }
                }
                return nodes;
            }
            GeoChart.convertFromGeoJson = convertFromGeoJson;
        })(GeoChart = Internal.GeoChart || (Internal.GeoChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Data.ts" />
/// <reference path="../base/AreaCollection.ts" />
/// <reference path="../itemschart/Settings.ts" />
/// <reference path="GeoJSONParser.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var GeoChart;
        (function (GeoChart) {
            var DataLayer = (function () {
                function DataLayer(level, id, cacheId) {
                    this.nodes = {};
                    this.links = {};
                    this.area = new Internal.Base.AreaCollection();
                    this.requestedArea = new Internal.Base.AreaCollection();
                    /**areas yet to be requested for current layer*/
                    this.pendingArea = null;
                    this.cacheId = cacheId;
                    this.id = id;
                    this.level = level;
                }
                return DataLayer;
            }());
            GeoChart.DataLayer = DataLayer;
            var SettingsData = (function (_super) {
                __extends(SettingsData, _super);
                function SettingsData() {
                    _super.apply(this, arguments);
                    this.dataFunction = null;
                    this.preloaded = null;
                    // multiples of visible width, one for each direction
                    this.prefetchRatio = 1;
                    // int long, lat coord
                    this.bounds = [-180, -85.0511287798, 180, 85.0511287798];
                    this.wrapLng = true;
                    // in projected coords
                    this.maxRequestRect = [256, 256];
                    /** If true, data source will use bounds to limit response, if false, assume all data is returned. */
                    this.perBoundsData = true;
                    /** If true, separate data is requested at each zoom level. */
                    this.perZoomData = false;
                    /** If true, separate data is requested at each drilldown level. */
                    this.perDrilldownData = false;
                    /** If true, the data request will include the coordinates for the aggregation grid.
                    @deprecated - use the automatic proximity based aggregation instead
                    @version 1.12.0 - The setting was added. Previously the `perBoundsData` had to be `true` for the grid to be included. */
                    this.useGridBasedAggregation = false;
                    /** Specifies the size of the grid that is included in the request.
                    @deprecated - use the automatic proximity based aggregation instead */
                    this.aggregationGridSize = 100;
                    /** The value will be passed to the data request together with the aggregation grid data.
                    @deprecated - use the automatic proximity based aggregation instead */
                    this.aggregationMinCount = 5;
                }
                return SettingsData;
            }(Internal.ItemsChart.SettingsData));
            GeoChart.SettingsData = SettingsData;
            var Data = (function (_super) {
                __extends(Data, _super);
                function Data(chart, dataSettings) {
                    var _this = this;
                    _super.call(this, chart, dataSettings);
                    /**key - zoomLevel+parent*/
                    this.layers = {};
                    /**layers that have data that needs loading*/
                    this.pendingLayers = [];
                    this.nextId = 0;
                    // grid cell size in units
                    this.aggregationGridSize = 1;
                    // current zoom level
                    this.zoomLevel = null;
                    this.projectFun = function (lon, lat) { return _this.chart.scene.project(lon, lat); };
                    this.unprojectFun = function (x, y) { return _this.chart.scene.unproject(x, y); };
                    // compute full projected bounds
                    var p0 = this.projectFun(this.dataSettings.bounds[0], this.dataSettings.bounds[1]);
                    var p1 = this.projectFun(this.dataSettings.bounds[2], this.dataSettings.bounds[3]);
                    this.projectedBounds = new Internal.Base.Rect(Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y));
                }
                /** returns all bounds rect in projected coords */
                Data.prototype.getProjectedBounds = function () {
                    return this.projectedBounds;
                };
                Data.prototype.setViewParams = function (aggregationGridSize, zoomLevel, visibleRect, returnDataRect, loadDataRect) {
                    if (this.dataSettings.perZoomData) {
                        this.zoomLevel = zoomLevel;
                    }
                    else {
                        this.zoomLevel = null;
                    }
                    this.aggregationGridSize = aggregationGridSize;
                    this.loadDataArea = this.buildRectArea(loadDataRect);
                    this.returnDataArea = this.buildRectArea(returnDataRect);
                    this.visibleArea = this.buildRectArea(visibleRect);
                    this.pendingLayers = [];
                };
                Data.prototype.getLayer = function (id) {
                    var cacheId = "";
                    var zl = null;
                    if (id) {
                        cacheId += "" + id;
                    }
                    if (this.zoomLevel !== null) {
                        cacheId += "#z" + this.zoomLevel;
                        zl = this.zoomLevel;
                    }
                    var layer;
                    if (!this.layers.hasOwnProperty(cacheId)) {
                        layer = this.layers[cacheId] = new DataLayer(zl, id, cacheId);
                    }
                    else {
                        layer = this.layers[cacheId];
                    }
                    this.lastLayer = layer;
                    return layer;
                };
                Data.prototype.getData = function (id) {
                    var layer = this.getLayer(id);
                    var loading;
                    if (layer.area.coversArea(this.loadDataArea)) {
                        layer.pendingArea = new Internal.Base.AreaCollection();
                        loading = false;
                    }
                    else if (layer.requestedArea.coversArea(this.loadDataArea)) {
                        loading = this.hasPendingRequests();
                    }
                    else {
                        // request more data
                        layer.pendingArea = this.loadDataArea.makeCopy().subtractArea(layer.requestedArea);
                        if (!layer.pendingArea.isEmpty()) {
                            // build a new list of layers that need loading
                            if (this.pendingLayers.indexOf(layer) < 0) {
                                this.pendingLayers.push(layer);
                            }
                            this.scheduleRequests(true);
                        }
                        loading = this.hasPendingRequests();
                    }
                    var result = this.applyFilters(layer, this.returnDataArea);
                    this.chart.log("Data: returned " + result.nodes.length + " nodes and " + result.links.length + " links for ID: " + id + ", loading=" + loading);
                    return {
                        nodes: result.nodes,
                        links: result.links,
                        hasData: layer.area.intersectsArea(this.visibleArea),
                        loading: loading
                    };
                };
                Data.prototype.applyFilters = function (layer, boundsArea) {
                    var rects = boundsArea.toRects();
                    // TODO: filters move to layers...
                    var nodeFilter = this.settings.filters.nodeFilter;
                    var nodes = [];
                    var links = [];
                    var matchingNodeIds = {};
                    // First Collect nodes inside bounds
                    var rectIndex;
                    var rect;
                    for (var id in layer.nodes) {
                        var node = layer.nodes[id];
                        var b = node._bounds;
                        var isGood = !nodeFilter || nodeFilter(node);
                        if (isGood) {
                            for (rectIndex = 0; rectIndex < rects.length; rectIndex++) {
                                rect = rects[rectIndex];
                                if (rect.overlapsRect(b.x0, b.y0, b.x1, b.y1)) {
                                    nodes.push(node);
                                    matchingNodeIds[id] = true;
                                    break;
                                }
                            }
                        }
                    }
                    // Add links that end on visible nodes, add opposite node too if necessary
                    for (var id in layer.links) {
                        var link = layer.links[id];
                        var hasFrom = matchingNodeIds[link.from];
                        var hasTo = matchingNodeIds[link.to];
                        if (hasFrom || hasTo) {
                            links.push(link);
                            // Get missing end nodes
                            if (!hasFrom) {
                                matchingNodeIds[link.from] = true;
                                nodes.push(layer.nodes[link.from]);
                            }
                            if (!hasTo) {
                                matchingNodeIds[link.to] = true;
                                nodes.push(layer.nodes[link.to]);
                            }
                        }
                        else {
                            // Test if link intersects bounds
                            var fromNode = layer.nodes[link.from];
                            var toNode = layer.nodes[link.to];
                            if (fromNode._x && toNode._x) {
                                var x0 = fromNode._x;
                                var y0 = fromNode._y;
                                var x1 = toNode._x;
                                var y1 = toNode._y;
                                for (rectIndex = 0; rectIndex < rects.length; rectIndex++) {
                                    rect = rects[rectIndex];
                                    if (rect.intersectsSegment(x0, y0, x1, y1)) {
                                        nodes.push(fromNode);
                                        nodes.push(toNode);
                                        matchingNodeIds[link.from] = true;
                                        matchingNodeIds[link.to] = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    return { nodes: nodes, links: links };
                };
                Data.prototype.unprojectRect = function (rect) {
                    var p0 = this.unprojectFun(rect.x0, rect.y0);
                    var p1 = this.unprojectFun(rect.x1, rect.y1);
                    return new Internal.Base.Rect(Math.min(p0.lng, p1.lng), Math.min(p0.lat, p1.lat), Math.max(p0.lng, p1.lng), Math.max(p0.lat, p1.lat));
                };
                Data.prototype.projectRect = function (rect) {
                    var p0 = this.projectFun(rect.x0, rect.y0);
                    var p1 = this.projectFun(rect.x1, rect.y1);
                    return new Internal.Base.Rect(Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y));
                };
                Data.prototype.buildRectArea = function (rect) {
                    // clips request area to data constraints and wraps X if needed
                    var pb = this.projectedBounds;
                    var x0 = rect.x0;
                    var y0 = rect.y0;
                    var x1 = rect.x1;
                    var y1 = rect.y1;
                    var result = new Internal.Base.AreaCollection();
                    y0 = Math.max(y0, pb.y0);
                    y1 = Math.min(y1, pb.y1);
                    if (this.dataSettings.wrapLng) {
                        var diff = pb.x1 - pb.x0;
                        if (x1 - x0 > diff) {
                            // full range
                            x0 = pb.x0;
                            x1 = pb.x1;
                        }
                        else {
                            // partial range
                            while ((x0 < pb.x0)) {
                                x0 += diff;
                                x1 += diff;
                            }
                            while (x0 > pb.x1) {
                                x0 -= diff;
                                x1 -= diff;
                            }
                        }
                        if (x1 <= pb.x1) {
                            // a single part
                            result.addRect(new Internal.Base.Rect(x0, y0, x1, y1));
                        }
                        else {
                            // split into two parts
                            result.addRect(new Internal.Base.Rect(x0, y0, pb.x1, y1));
                            result.addRect(new Internal.Base.Rect(pb.x0, y0, x1 - diff, y1));
                        }
                    }
                    else {
                        result.addRect(rect.clone().clip(pb));
                    }
                    return result;
                };
                Data.prototype.buildRequest = function () {
                    if (this.pendingLayers.length > 0) {
                        var layer = this.pendingLayers[0];
                        var a = layer.pendingArea.findOverlappingRect(this.dataSettings.maxRequestRect[0], this.dataSettings.maxRequestRect[1]);
                        layer.pendingArea.subtractRect(a);
                        if (layer.pendingArea.isEmpty()) {
                            Internal.Base.Helpers.removeFromArray(this.pendingLayers, layer);
                        }
                        var rect = a;
                        var xcuts = [];
                        var ycuts = [];
                        if (this.dataSettings.useGridBasedAggregation) {
                            var buildAggregationRequestResult = this.buildAggregationRequest(a);
                            rect = buildAggregationRequestResult.rectangle;
                            xcuts = buildAggregationRequestResult.xcuts;
                            ycuts = buildAggregationRequestResult.ycuts;
                        }
                        layer.requestedArea.addRect(rect);
                        var llRect = this.unprojectRect(rect);
                        return {
                            id: layer.id,
                            layerId: layer.cacheId,
                            west: llRect.x0,
                            north: llRect.y1,
                            east: llRect.x1,
                            south: llRect.y0,
                            zoom: this.zoomLevel,
                            aggregateLat: ycuts,
                            aggregateLng: xcuts,
                            aggregateMinItems: this.dataSettings.aggregationMinCount
                        };
                    }
                    else {
                        return null;
                    }
                };
                Data.prototype.buildAggregationRequest = function (rect) {
                    var grid = this.aggregationGridSize;
                    var x0 = Math.floor(rect.x0 / grid) * grid;
                    var x1 = Math.ceil(rect.x1 / grid) * grid;
                    var y0 = Math.floor(rect.y0 / grid) * grid;
                    var y1 = Math.ceil(rect.y1 / grid) * grid;
                    var bx0 = this.dataSettings.bounds[0];
                    var by0 = this.dataSettings.bounds[1];
                    var bx1 = this.dataSettings.bounds[2];
                    var by1 = this.dataSettings.bounds[3];
                    var xcuts = [];
                    var ycuts = [];
                    for (var xi = x0; xi <= x1; xi += grid) {
                        xcuts.push(Math.min(Math.max(this.unprojectFun(xi, y0).lng, bx0), bx1));
                    }
                    for (var yi = y0; yi <= y1; yi += grid) {
                        ycuts.push(Math.min(Math.max(this.unprojectFun(x0, yi).lat, by0), by1));
                    }
                    return {
                        rectangle: new Internal.Base.Rect(x0, y0, x1, y1),
                        xcuts: xcuts,
                        ycuts: ycuts
                    };
                };
                Data.prototype.dataFunc = function (request, success, fail) {
                    var config = this.dataSettings;
                    if (config.dataFunction) {
                        config.dataFunction(request, success, fail);
                    }
                    else if (config.url) {
                        var params = [
                            ["id", request.id],
                            ["south", request.south.toString(10)],
                            ["west", request.west.toString(10)],
                            ["north", request.north.toString(10)],
                            ["east", request.east.toString(10)],
                        ];
                        if (request.aggregateLat.length || request.aggregateLng.length) {
                            params.push(["aggregateLat", request.aggregateLat.join(",")]);
                            params.push(["aggregateLng", request.aggregateLng.join(",")]);
                            params.push(["aggregateMinItems", request.aggregateMinItems.toString(10)]);
                        }
                        if (request.zoom !== null)
                            params.push(["zoom", request.zoom.toString(10)]);
                        Internal.Base.Data.doRequest(config.url, config, params, success, fail);
                    }
                    else {
                        fail({ error: "Chart configuration does not define data retrieval function" });
                    }
                };
                Data.prototype.verifyData = function (request, data) {
                    if (this.dataSettings.format.toLowerCase() === "geojson")
                        data.nodes = GeoChart.convertFromGeoJson(data, this.chart);
                    var allOk = true;
                    if (!data.hasOwnProperty("nodes"))
                        data.nodes = [];
                    if (!data.hasOwnProperty("links"))
                        data.links = [];
                    var west = Internal.Base.Helpers.tryParseFloat(data.west, request ? request.west : Infinity);
                    var east = Internal.Base.Helpers.tryParseFloat(data.east, request ? request.east : -Infinity);
                    var north = Internal.Base.Helpers.tryParseFloat(data.north, request ? request.north : Infinity);
                    var south = Internal.Base.Helpers.tryParseFloat(data.south, request ? request.south : -Infinity);
                    data._bounds = new Internal.Base.Rect(west, south, east, north);
                    var seenIds = {};
                    for (var nodeIndex = 0; nodeIndex < data.nodes.length; nodeIndex++) {
                        var node = data.nodes[nodeIndex];
                        if (!Array.isArray(node.coordinates)) {
                            this.chart.error("Data response: Node has no coordinates, or not an array");
                            allOk = false;
                        }
                        if (node.aggregate) {
                            if (!Internal.Base.Helpers.isNumber(node.count)) {
                                this.chart.error("Aggregated node needs `count` field that contains a number.");
                                allOk = false;
                            }
                        }
                        else if (!node.hasOwnProperty("id")) {
                            this.chart.error("Data response: Node without ID");
                            allOk = false;
                        }
                        else {
                            var id = node.id.toString();
                            if (seenIds.hasOwnProperty(id)) {
                                this.chart.error("Data response: Multiple nodes with same id: " + id);
                            }
                            seenIds[id] = true;
                        }
                    }
                    var seenLinkIDs = {};
                    for (var lIndex = 0; lIndex < data.links.length; lIndex++) {
                        var link = data.links[lIndex];
                        if (link.hasOwnProperty("id")) {
                            if (seenLinkIDs.hasOwnProperty(link.id)) {
                                this.chart.error("Data response: Multiple links with the same ID: " + link.id);
                            }
                        }
                        else {
                            link.id = Internal.Base.Helpers.SeparatorChar + (this.nextId++).toString(10);
                        }
                        if (!seenIds[link.from] && !seenIds[link.to]) {
                            this.chart.error("Data response: Returned link that does not match any node: " + link.id);
                        }
                        seenLinkIDs[link.id] = true;
                    }
                    return allOk;
                };
                Data.prototype.addVerifiedData = function (request, data) {
                    var layerId;
                    var drilldownId;
                    if (request) {
                        drilldownId = request.id;
                        layerId = request.layerId;
                    }
                    else {
                        layerId = "";
                        drilldownId = "";
                    }
                    var node;
                    var link;
                    var layer = this.layers[layerId];
                    if (!layer) {
                        // fallback for preloaded data
                        layer = this.getLayer(drilldownId);
                    }
                    if (data.clearCache) {
                        // client can request that all cached data is invalidated. this is an alternative to Api.replaceData()
                        // that is needed so that the remaining nodes can be properly animated.
                        layer.nodes = {};
                        layer.links = {};
                        layer.area = new Internal.Base.AreaCollection();
                        layer.area.addRect(this.projectedBounds);
                    }
                    else if (data._bounds.x0 !== Infinity) {
                        var dataBounds = this.projectRect(data._bounds);
                        // data has bounds, filter out previous objects within the bounds (since they should have been part
                        // of this result set as well - if they are not, then they are removed.
                        for (var id in layer.nodes) {
                            node = layer.nodes[id];
                            if (dataBounds.overlaps(node._bounds)) {
                                delete layer.nodes[id];
                            }
                        }
                        // remove all links that were connected to any of the removed nodes.
                        for (var id in layer.links) {
                            link = layer.links[id];
                            if (!layer.nodes[link.from] || !layer.nodes[link.to]) {
                                delete layer.links[id];
                            }
                        }
                        layer.area.addRect(dataBounds);
                    }
                    else {
                        layer.area.addRect(this.projectedBounds);
                    }
                    // add new data
                    var dataNodesIds = {};
                    for (var nodeIndex = 0; nodeIndex < data.nodes.length; nodeIndex++) {
                        node = data.nodes[nodeIndex];
                        node.loaded = true;
                        if (node.aggregate) {
                            // generate internal ID for aggregate nodes.
                            node.id = Internal.Base.Helpers.SeparatorChar + this.nextId;
                            this.nextId++;
                            layer.nodes[node.id] = node;
                        }
                        else {
                            dataNodesIds[node.id] = true;
                            if (layer.nodes.hasOwnProperty(node.id)) {
                                Internal.Base.Helpers.extendDeep(layer.nodes[node.id], node);
                            }
                            else {
                                layer.nodes[node.id] = node;
                            }
                        }
                        // prepare node coordinates
                        if (node.coordinates) {
                            if (Array.isArray(node.coordinates[0])) {
                                this.prepareShape(node);
                            }
                            else {
                                this.preparePoint(node);
                            }
                        }
                    }
                    // add new links 
                    var dataLinkIds = {};
                    for (var linkIndex = 0; linkIndex < data.links.length; linkIndex++) {
                        link = data.links[linkIndex];
                        dataLinkIds[link.id] = true;
                        layer.links[link.id] = link;
                    }
                    var rr = {};
                    rr[drilldownId || ""] = { nodes: dataNodesIds, links: dataLinkIds };
                    var r = {};
                    r[this.dataSettings.id] = rr;
                    // changes object
                    return { geoChartDataNodesIds: r };
                };
                Data.prototype.prepareShape = function (node) {
                    var lines = [];
                    var bounds = Internal.Base.Rect.createEmpty();
                    for (var lIndex = 0; lIndex < node.coordinates.length; lIndex++) {
                        var l = node.coordinates[lIndex];
                        var str = this.projectLineString(l, bounds);
                        lines.push(str);
                    }
                    node._bounds = bounds;
                    node._coordinates = lines;
                };
                Data.prototype.preparePoint = function (node) {
                    if (node.coordinates.length !== 2) {
                        this.chart.error("Point coordinates must be an array of two numbers.");
                        return;
                    }
                    var nodeCoords = node.coordinates;
                    var lon = nodeCoords[0];
                    var lat = nodeCoords[1];
                    var c = this.projectFun(lon, lat);
                    node._x = c.x;
                    node._y = c.y;
                    node._bounds = new Internal.Base.Rect(c.x, c.y, c.x, c.y);
                };
                Data.prototype.projectLineString = function (line, bounds) {
                    var result = [];
                    for (var i = 0; i < line.length - 1; i += 2) {
                        var c = this.projectFun(line[i], line[i + 1]);
                        result.push(c.x);
                        result.push(c.y);
                        bounds.addPoint(c.x, c.y);
                    }
                    return result;
                };
                Data.prototype.exportAreas = function () {
                    var areasRects = this.lastLayer.area.toRects();
                    var reqAreasRects = this.lastLayer.requestedArea.toRects();
                    var pendingAreasRects = this.lastLayer.pendingArea.toRects();
                    this.projectRects(areasRects);
                    this.projectRects(reqAreasRects);
                    this.projectRects(pendingAreasRects);
                    return {
                        areasRects: areasRects,
                        reqAreasRects: reqAreasRects,
                        pendingAreasRects: pendingAreasRects
                    };
                };
                Data.prototype.projectRects = function (rects) {
                    for (var rIndex = 0; rIndex < rects.length; rIndex++) {
                        var r = rects[rIndex];
                        var p = this.projectFun(r.x0, r.y0);
                        r.x0 = p.x;
                        r.y0 = p.y;
                        p = this.projectFun(r.x1, r.y1);
                        r.x1 = p.x;
                        r.y1 = p.y;
                        if (r.y1 < r.y0) {
                            var a = r.y0;
                            r.y0 = r.y1;
                            r.y1 = a;
                        }
                    }
                };
                return Data;
            }(Internal.Base.Data));
            GeoChart.Data = Data;
        })(GeoChart = Internal.GeoChart || (Internal.GeoChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="leaflet.d.ts" />
/// <reference path="../base/core/ChartEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var GeoChart;
        (function (GeoChart) {
            GeoChart.Leaflet = null;
            // store the Leaflet namespace in case someone calls L.noConflict();
            if (typeof L !== "undefined")
                GeoChart.Leaflet = L;
            var ItemLayer = (function () {
                function ItemLayer(chart, chartContainer, layers) {
                    var _this = this;
                    this.layers = layers;
                    this.chartContainer = chartContainer;
                    this.chart = chart;
                    this.wasDragged = null;
                    this.wasZoomed = false;
                    this.translate = null;
                    this.updatePosDelegate = function () { return _this.updatePos(); };
                    this.onZoomDelegate = function (e) { return _this.onZoom(e); };
                    this.viewResetDelegate = function () { return _this.viewReset(); };
                    this.userActionEndDelegate = function () { return _this.userActionEnd(); };
                    this.userActionStartDelegate = function () { return _this.userActionStart(); };
                }
                ItemLayer.prototype.onAdd = function (map) {
                    this.map = map;
                    map.getPanes().overlayPane.appendChild(this.chartContainer);
                    // add a viewreset event listener for updating layer"s position, do the latter
                    map.on("move", this.updatePosDelegate, this);
                    map.on("zoomanim", this.onZoomDelegate, this);
                    map.on("viewreset", this.viewResetDelegate, this);
                    map.on("moveend", this.userActionEndDelegate, this);
                    map.on("movestart", this.userActionStartDelegate, this);
                };
                ItemLayer.prototype.onRemove = function (map) {
                    map.getPanes().overlayPane.removeChild(this.chartContainer);
                    map.off("move", this.updatePosDelegate, this);
                    map.off("zoomanim", this.onZoomDelegate, this);
                    map.off("viewreset", this.viewResetDelegate, this);
                    map.off("moveend", this.userActionEndDelegate, this);
                    map.off("movestart", this.userActionStartDelegate, this);
                };
                ItemLayer.prototype.userActionStart = function () {
                    this.wasDragged = true;
                };
                ItemLayer.prototype.userActionEnd = function () {
                    var origin;
                    if (this.wasDragged === true) {
                        origin = "user";
                    }
                    else if (this.wasDragged === null) {
                        origin = "init";
                    }
                    else {
                        origin = "api";
                    }
                    this.chart.notifyChartUpdate(origin);
                    this.wasDragged = false;
                };
                ItemLayer.prototype.viewReset = function () {
                    this.updatePos();
                    this.userActionEnd();
                };
                ItemLayer.prototype.setTranslate = function () {
                    // the transformation is only applied when the actual frame is being painted
                    // it is not done in updatePos() so that the canvas position does not lag behind
                    // the map position.
                    if (this.translate !== null) {
                        this.chartContainer.style[GeoChart.Leaflet.DomUtil.TRANSFORM] = this.translate;
                        this.translate = null;
                    }
                };
                ItemLayer.prototype.updatePos = function () {
                    if (!this.map) {
                        return;
                    }
                    var crs = this.map.options.crs;
                    var scene = this.chart.scene;
                    this.offset = this.map.containerPointToLayerPoint(GeoChart.Leaflet.point(0, 0));
                    this.chartContainer.setAttribute("class", " ");
                    this.translate = GeoChart.Leaflet.DomUtil.getTranslateString(this.offset);
                    // compute new scene center and zoom
                    var bounds = this.map.getPixelBounds();
                    var topLeft = crs.transformation.untransform(bounds.min, crs.scale(this.map.getZoom()));
                    topLeft = crs.transformation.transform(topLeft, crs.scale(0));
                    var bottomRight = crs.transformation.untransform(bounds.max, crs.scale(this.map.getZoom()));
                    bottomRight = crs.transformation.transform(bottomRight, crs.scale(0));
                    var zoom = this.map.getZoom();
                    if (zoom !== scene.zoomLevel) {
                        scene.zoom = Math.pow(2, zoom);
                        scene.zoomLevel = zoom;
                        this.wasZoomed = true;
                    }
                    scene.centerX = (bottomRight.x + topLeft.x) / 2;
                    scene.centerY = (bottomRight.y + topLeft.y) / 2;
                    if (this.chart.events && !this.layers.resizing) {
                        if (this.wasZoomed) {
                            this.chart.events.notifySceneChanges({ zoom: true, position: true });
                            this.wasZoomed = false;
                        }
                        else {
                            this.chart.events.notifySceneChanges({ position: true });
                        }
                    }
                };
                ItemLayer.prototype.onZoom = function (e) {
                    // animate existing layer without repaint, viewReset will be called afterwards
                    var scale = this.map.getZoomScale(e.zoom);
                    var mapCenter = this.map.latLngToLayerPoint(e.center).subtract(this.map.containerPointToLayerPoint(this.map.getSize().divideBy(2)));
                    var offset = mapCenter.multiplyBy(-scale).add(this.offset);
                    this.chartContainer.setAttribute("class", " leaflet-zoom-animated");
                    this.translate = GeoChart.Leaflet.DomUtil.getTranslateString(offset) + " scale(" + scale + ") ";
                    this.setTranslate();
                    this.wasZoomed = true;
                };
                return ItemLayer;
            }());
            var SettingsBackground = (function () {
                function SettingsBackground() {
                    this.enabled = true;
                    this.type = "tile";
                    this.url = "https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png";
                    this.params = {
                        subdomains: "abcd",
                        attribution: "&copy; <a target=\"_blank\" href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors, "
                            + "&copy; <a href=\"https://cartodb.com/attributions\" target=\"_blank\">CartoDB</a>"
                    };
                }
                return SettingsBackground;
            }());
            GeoChart.SettingsBackground = SettingsBackground;
            var DomLayer = (function (_super) {
                __extends(DomLayer, _super);
                function DomLayer(chart) {
                    var _this = this;
                    _super.call(this, chart);
                    this.animationOrder = 100;
                    this.resizing = false; // if true, chart bounds resizing is in progress...
                    this._focusHandler = function () { return _this.containerOnFocusChange(); };
                }
                DomLayer.prototype.createDom = function (shell) {
                    var _this = this;
                    _super.prototype.createDom.call(this, shell);
                    // Reorder the layers to insert Lefalet
                    this.leafletContainer = Internal.Base.Helpers.createDom("div", "DVSL-leaflet", null, null);
                    this.container.insertBefore(this.leafletContainer, this.canvas);
                    this.container.removeChild(this.canvas);
                    this.container.removeChild(this.outerBorder);
                    this.container.removeChild(this.interactionContainer);
                    this.interactionContainer.appendChild(this.canvas);
                    this.canvas.style.position = "static";
                    // this.interactionContainer = this.canvas;
                    this.outerBorder = null;
                    // Revert the IE9/10 workaround because it does not work for GeoChart where the events should fall through to the Leaflet container.
                    this.menuContainer.className = "DVSL-menu-container";
                    this.itemLayer = new ItemLayer(this.chart, this.interactionContainer, this);
                    DomLayer.setContainerStyle(this.leafletContainer);
                    this.chart.scene.project = function (lon, lat) { return _this.projectFunc(lon, lat); };
                    this.chart.scene.unproject = function (x, y) { return _this.unprojectFunc(x, y); };
                    if (GeoChart.Leaflet != null) {
                        this.createMap();
                    }
                    else {
                        this.chart.assetsLoader.ensureAssetsList(["assets://leaflet.js"], function (async) { return _this.leafletLoaded(async); });
                    }
                    Internal.Base.Helpers.listen(this.interactionContainer, "focus", this._focusHandler);
                    Internal.Base.Helpers.listen(this.interactionContainer, "blur", this._focusHandler);
                    Internal.Base.Helpers.listen(this.leafletContainer, "focus", this._focusHandler);
                    Internal.Base.Helpers.listen(this.leafletContainer, "blur", this._focusHandler);
                };
                DomLayer.prototype.containerOnFocusChange = function () {
                    if (!this.map)
                        return;
                    var hasFocus = Internal.Base.Helpers.isParentOf(this.container, document.activeElement);
                    var swz = this.map.scrollWheelZoom;
                    if (hasFocus || !this.chart.settings.advanced.pointer.mouseWheelRequiresFocus) {
                        swz.enable();
                    }
                    else {
                        swz.disable();
                    }
                };
                DomLayer.prototype.leafletLoaded = function (async) {
                    if (this.removed)
                        return;
                    if (typeof L === "undefined")
                        throw new Error("`leaflet.js` was loaded but the global variable `L` was not found. Please make sure that `L.noConflict()` is not called.");
                    GeoChart.Leaflet = L;
                    this.createMap();
                    if (async)
                        this.chart.notifyChartUpdate("api");
                };
                DomLayer.prototype.ensureMap = function () {
                    if (!this.map)
                        throw new Error("This method is only available after leaflet.js has been loaded.");
                };
                DomLayer.prototype.createMap = function () {
                    var navOptions = this.chart.settings.navigation;
                    var options = {
                        maxZoom: navOptions.maxZoom,
                        minZoom: navOptions.minZoom,
                        worldCopyJump: false
                    };
                    this.map = GeoChart.Leaflet.map(this.leafletContainer, options);
                    this.map.attributionControl.setPrefix("");
                    var bounds = navOptions.maxBounds;
                    this.map.setMaxBounds(new GeoChart.Leaflet.LatLngBounds(new GeoChart.Leaflet.LatLng(bounds.south, bounds.west), new GeoChart.Leaflet.LatLng(bounds.north, bounds.east)));
                    this.createMapBackground();
                    this.map.addLayer(this.itemLayer);
                    this.crs = this.map.options.crs;
                    this.containerOnFocusChange();
                    this.chart.domLayerCreated();
                };
                DomLayer.prototype.createMapBackground = function () {
                    var map = this.map;
                    var tileLayer = this.tileLayer;
                    if (tileLayer) {
                        map.removeLayer(tileLayer);
                        tileLayer = null;
                    }
                    var bg = this.scene.settings.background;
                    if (bg.enabled) {
                        if (bg.type === "tile") {
                            tileLayer = GeoChart.Leaflet.tileLayer(bg.url, bg.params);
                            map.addLayer(tileLayer);
                        }
                        else if (bg.type === "wms") {
                            tileLayer = GeoChart.Leaflet.tileLayer.wms(bg.url, bg.params);
                            map.addLayer(tileLayer);
                        }
                    }
                    this.tileLayer = tileLayer;
                };
                DomLayer.prototype.onSceneChange = function (event) {
                    this.itemLayer.setTranslate();
                };
                DomLayer.prototype.remove = function () {
                    this.removed = true;
                    Internal.Base.Helpers.unlisten(this.interactionContainer, "focus", this._focusHandler);
                    Internal.Base.Helpers.unlisten(this.interactionContainer, "blur", this._focusHandler);
                    Internal.Base.Helpers.unlisten(this.leafletContainer, "focus", this._focusHandler);
                    Internal.Base.Helpers.unlisten(this.leafletContainer, "blur", this._focusHandler);
                    if (this.map)
                        this.map.remove();
                    this.map = null;
                };
                DomLayer.prototype.updateSettings = function (changes) {
                    _super.prototype.updateSettings.call(this, changes);
                    // leafletContainer check verifies if this method isn't called on the initial settings instead of actual updateSettings() call.
                    if (this.removed || !this.leafletContainer)
                        return;
                    if (this.map && changes.background) {
                        this.createMapBackground();
                    }
                    if (changes.navigation) {
                        // TODO: implement...
                        if (changes.navigation.minZoom || changes.navigation.maxZoom)
                            Internal.Base.Helpers.warn("Changing of navigation.minZoom or navigation.maxZoom with updateSettings() is not yet supported.");
                        if (this.map && changes.navigation.maxBounds) {
                            // if map has not been created, the new settings will be applied during its creation.
                            var bounds = changes.navigation.maxBounds;
                            this.map.setMaxBounds(new GeoChart.Leaflet.LatLngBounds(new GeoChart.Leaflet.LatLng(bounds.south, bounds.west), new GeoChart.Leaflet.LatLng(bounds.north, bounds.east)));
                        }
                    }
                };
                DomLayer.prototype.projectFunc = function (lon, lat) {
                    this.ensureMap();
                    return this.crs.latLngToPoint(new GeoChart.Leaflet.LatLng(lat, lon), 0);
                };
                DomLayer.prototype.unprojectFunc = function (x, y) {
                    this.ensureMap();
                    return this.crs.pointToLatLng(new GeoChart.Leaflet.Point(x, y), 0);
                };
                DomLayer.prototype.doAnimations = function (event) {
                    _super.prototype.doAnimations.call(this, event);
                    if (event.changes.bounds) {
                        var scene = this.scene;
                        /*
                        Workaround for title that would break the positioning of items in the chart.
                        Basically this forces all panels to overlap the chart data, instead of creating margins.
                        A proper solution would be to resize the leaflet container but that cannot be done since the
                        canvas itself is a child layer of the leaflet container.
                        */
                        scene.x0 = scene.chartLeft;
                        scene.y0 = scene.chartTop;
                        scene.width = scene.chartWidth;
                        scene.height = scene.chartHeight;
                        scene.leftMargin = 0;
                        scene.rightMargin = 0;
                        scene.topMargin = 0;
                        scene.bottomMargin = 0;
                        /* End of the workaround */
                        if (this.map) {
                            this.resizing = true;
                            // fires move event immediately
                            this.map.invalidateSize(null);
                            this.resizing = false;
                        }
                        this.interactionContainer.style.width = scene.chartWidth + "px";
                        this.interactionContainer.style.height = scene.chartHeight + "px";
                    }
                };
                return DomLayer;
            }(Internal.Base.DomLayer));
            GeoChart.DomLayer = DomLayer;
        })(GeoChart = Internal.GeoChart || (Internal.GeoChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var GeoChart;
        (function (GeoChart) {
            var SettingsAggregation = (function () {
                function SettingsAggregation() {
                    /** Enables/Disables automatic aggregation */
                    this.enabled = false;
                    /** The approximate minimum distance in pixels between two nodes before they are aggregated together.
                    @type integer */
                    this.distance = 60;
                    /** The last zoom level on which the nodes are automatically agregated. When the chart is zoomed in deeper, the original
                    nodes will be used instead.
                    @type integer */
                    this.maxZoom = 18;
                    /** Function that returns the value used as weight in the aggregation process for each node. */
                    this.weightFunction = null;
                }
                return SettingsAggregation;
            }());
            GeoChart.SettingsAggregation = SettingsAggregation;
            var Aggregation = (function () {
                function Aggregation(settings, scene, chart) {
                    this.zoom = scene.zoom;
                    this.scene = scene;
                    this.settings = settings;
                    this.chart = chart;
                }
                /**
                 * return 1 if right oriented, -1 if left oriented, 0 if collinear
                 * @param {object} a - the vertex of vector ab
                 * @param {object} b - the vertex of vector ab
                 * @param {object} p - the point whose location should be determined - left, right, collinear
                 * */
                Aggregation.orientation = function (a, b, p) {
                    var turn = ((b.x - a.x) * (p.y - a.y)) - ((b.y - a.y) * (p.x - a.x));
                    return (turn === 0) ? 0 : (turn > 0) ? 1 : -1;
                };
                /**
                 * return distance from point to line.
                 * @param {object} a - the vertex of segment ab
                 * @param {object} b - the vertex of segment ab
                 * @param {object} p - the point whose distance to segment ab should be determined
                 * */
                Aggregation.distanceLineToPoint = function (a, b, p) {
                    var nl = Math.sqrt((b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y)); // normal vector length
                    return Math.abs((p.x - a.x) * (b.y - a.y) - (p.y - a.y) * (b.x - a.x)) / nl;
                };
                Aggregation.prototype.findMainNodes = function (nodes, links) {
                    /** maps original node ID values to the aggregated note that now contains it */
                    var aggregateNodeMap = {};
                    var bitmap = {};
                    var aggregateValues = {};
                    var hasWeightFunction = Internal.Base.Helpers.isFunction(this.settings.weightFunction);
                    if (hasWeightFunction) {
                        for (var i = 0; i < nodes.length; i++)
                            aggregateValues[nodes[i].id] = this.settings.weightFunction(nodes[i]);
                        nodes.sort(function (a, b) { return aggregateValues[b.id] - aggregateValues[a.id]; });
                    }
                    var coef = this.zoom / (this.settings.distance / 2);
                    var centrals = [];
                    var usedNodes = {};
                    var b1;
                    var b2;
                    var b3;
                    for (var i = 0; i < nodes.length; i++) {
                        var n = nodes[i];
                        var x = Math.floor(n._x * coef);
                        var y = Math.floor(n._y * coef);
                        b1 = bitmap[x] || (bitmap[x] = {});
                        if (b1[y] !== void 0 || b1[y - 1] !== void 0 || b1[y + 1] !== void 0)
                            continue;
                        b2 = bitmap[x - 1] || (bitmap[x - 1] = {});
                        if (b2[y] !== void 0 || b2[y - 1] !== void 0 || b2[y + 1] !== void 0)
                            continue;
                        b3 = bitmap[x + 1] || (bitmap[x + 1] = {});
                        if (b3[y] !== void 0 || b3[y - 1] !== void 0 || b3[y + 1] !== void 0)
                            continue;
                        b1[y] = centrals.length;
                        b1[y + 1] = centrals.length;
                        b1[y - 1] = centrals.length;
                        b2[y] = centrals.length;
                        b2[y + 1] = centrals.length;
                        b2[y - 1] = centrals.length;
                        b3[y] = centrals.length;
                        b3[y + 1] = centrals.length;
                        b3[y - 1] = centrals.length;
                        var cw = hasWeightFunction ? (aggregateValues[n.id] || 0) : 1;
                        var newCentral = {
                            id: "__aggr_" + n.id,
                            aggregatedWeight: cw,
                            _originalWeight: cw,
                            _x: n._x,
                            _y: n._y,
                            _bounds: n._bounds,
                            aggregatedNodes: [n],
                            loaded: true
                        };
                        centrals.push(newCentral);
                        aggregateNodeMap[n.id] = newCentral;
                        usedNodes[i] = true;
                    }
                    var candidates = [];
                    for (var i = 0; i < nodes.length; i++) {
                        if (usedNodes[i])
                            continue;
                        var n = nodes[i];
                        var x = Math.floor(n._x * coef);
                        var y = Math.floor(n._y * coef);
                        var parent = centrals[bitmap[x][y]];
                        if (!parent) {
                            b1 = bitmap[x] || (bitmap[x] = {});
                            b2 = bitmap[x - 1] || (bitmap[x - 1] = {});
                            b3 = bitmap[x + 1] || (bitmap[x + 1] = {});
                            candidates.push(b1[y]);
                            candidates.push(b1[y - 1]);
                            candidates.push(b1[y + 1]);
                            candidates.push(b2[y]);
                            candidates.push(b2[y - 1]);
                            candidates.push(b2[y + 1]);
                            candidates.push(b3[y]);
                            candidates.push(b3[y - 1]);
                            candidates.push(b3[y + 1]);
                            var curDistSq = Infinity;
                            while (candidates.length > 0) {
                                var candIndex = candidates.pop();
                                if (candIndex === void 0)
                                    continue;
                                var candidate = centrals[candIndex];
                                var newDistSq = (candidate._x - n._x) * (candidate._x - n._x) + (candidate._y - n._y) * (candidate._y - n._y);
                                if (newDistSq < curDistSq) {
                                    curDistSq = newDistSq;
                                    parent = candidate;
                                }
                            }
                        }
                        var w = hasWeightFunction ? (aggregateValues[n.id] || 0) : 1;
                        if (parent.aggregatedWeight > 0 || w > 0) {
                            parent._x = (parent._x * parent.aggregatedWeight + n._x * w) / (parent.aggregatedWeight + w);
                            parent._y = (parent._y * parent.aggregatedWeight + n._y * w) / (parent.aggregatedWeight + w);
                        }
                        if (parent._originalWeight < w) {
                            // the ID should match the largest node being aggregated so that when zooming it stays the same as much as possible.
                            parent._originalWeight = w;
                            parent.id = "__aggr_" + n.id;
                        }
                        aggregateNodeMap[n.id] = parent;
                        parent.aggregatedNodes.push(n);
                        parent.aggregatedWeight += w;
                    }
                    for (var i = 0; i < centrals.length; i++) {
                        var n = centrals[i];
                        var c = this.scene.unproject(n._x, n._y);
                        n.coordinates = [c.lng, c.lat];
                    }
                    if (this.settings.postProcessAggregatedNodes) {
                        var modifiedNodes = [];
                        this.settings.postProcessAggregatedNodes(centrals, aggregateNodeMap, modifiedNodes);
                        for (var i = 0; i < modifiedNodes.length; i++) {
                            var n = modifiedNodes[i];
                            var xy = this.scene.project(n.coordinates[0], n.coordinates[1]);
                            n._x = xy.x;
                            n._y = xy.y;
                        }
                    }
                    var aggrLinks = this.aggregateLinks(links, aggregateNodeMap);
                    this.findConvexShapes(centrals);
                    return { nodes: centrals, links: aggrLinks };
                };
                Aggregation.prototype.aggregateLinks = function (links, aggregateNodeMap) {
                    var aggrLinks = [];
                    var aggrLinkMap = {};
                    for (var i = 0; i < links.length; i++) {
                        var link = links[i];
                        var newFrom = aggregateNodeMap[link.from];
                        var newTo = aggregateNodeMap[link.to];
                        if (!newFrom) {
                            this.chart.error("Link with ID '" + link.id + "' specifies non existant start node: '" + link.from + "'");
                            continue;
                        }
                        else if (!newTo) {
                            this.chart.error("Link with ID '" + link.id + "' specifies non existant end node: '" + link.to + "'");
                            continue;
                        }
                        var aggr = void 0;
                        var newId = newFrom.id + "-" + newTo.id;
                        if (Internal.Base.Helpers.hasProperty(aggrLinkMap, newId)) {
                            aggrLinkMap[newId].aggregatedLinks.push(link);
                        }
                        else {
                            aggr = {
                                id: newId,
                                from: newFrom.id,
                                to: newTo.id,
                                aggregatedLinks: [link]
                            };
                            aggrLinks.push(aggr);
                            aggrLinkMap[newId] = aggr;
                        }
                    }
                    return aggrLinks;
                };
                /**
                 * returns bound coordinates of aggregated nodes.
                 * Based on recursively implemented QuickHull algorithm without any trigonometric function
                 * */
                Aggregation.prototype.findConvexShapes = function (nodes) {
                    for (var i = 0; i < nodes.length; i++) {
                        var bound = [];
                        var collection = nodes[i].aggregatedNodes;
                        // find the base edge
                        var a = collection[0];
                        var b = collection[0];
                        for (var j = 1; j < collection.length; j++) {
                            var p = collection[j];
                            if (p._x <= a._x) {
                                a = collection[j];
                            }
                            if (p._x >= b._x) {
                                b = collection[j];
                            }
                        }
                        // divide points corresponding to orientation against base edge AB
                        var r = [];
                        var l = [];
                        for (var j = 0; j < collection.length; j++) {
                            var p = collection[j];
                            if (p != null) {
                                var sign = Aggregation.orientation({ x: a._x, y: a._y }, { x: b._x, y: b._y }, { x: p._x, y: p._y });
                                if (sign > 0) {
                                    r.push(p); // right
                                }
                                else if (sign < 0) {
                                    l.push(p); // left
                                }
                            }
                        }
                        var cw = [a];
                        var map = {};
                        bound = [];
                        this.separateOuterPoints(a, b, l, bound, map);
                        // ordering clockwise left oriented points - x should increase
                        cw = cw.concat(bound.sort(function (a, b) { return a._x - b._x; }));
                        cw.push(b);
                        bound = [];
                        this.separateOuterPoints(b, a, r, bound, map);
                        // ordering clockwise right oriented points - x should decrease
                        cw = cw.concat(bound.sort(function (a, b) { return b._x - a._x; }));
                        nodes[i].convexShape = cw;
                    }
                };
                Aggregation.prototype.separateOuterPoints = function (vertexA, vertexB, points, bound, map) {
                    if (points.length === 0)
                        return;
                    if (points.length === 1) {
                        map[points[0].id] = 1;
                        bound.push(points[0]);
                        return;
                    }
                    // find the highest point corresponding to edge AB
                    var dist = 0;
                    var farthestPoint = null;
                    for (var i = 0; i < points.length; i++) {
                        var p = points[i];
                        var d = Aggregation.distanceLineToPoint({ x: vertexA._x, y: vertexA._y }, { x: vertexB._x, y: vertexB._y }, { x: p._x, y: p._y });
                        if (d > dist) {
                            dist = d;
                            farthestPoint = p;
                        }
                    }
                    if (!map[farthestPoint.id]) {
                        bound.push(farthestPoint);
                        map[farthestPoint.id] = 1;
                    }
                    // select left oriented points only, right oriented should not be verified at all
                    var lv = []; // vertex A to farthest point
                    var lf = []; // farthest point to vertex B
                    for (var i = 0; i < points.length; i++) {
                        var p = points[i];
                        if (!map[p.id]) {
                            var signf = Aggregation.orientation({ x: vertexA._x, y: vertexA._y }, { x: farthestPoint._x, y: farthestPoint._y }, { x: p._x, y: p._y });
                            if (signf !== 0 && signf < 0) {
                                lf.push(p);
                            }
                            var signv = Aggregation.orientation({ x: farthestPoint._x, y: farthestPoint._y }, { x: vertexB._x, y: vertexB._y }, { x: p._x, y: p._y });
                            if (signv !== 0 && signv < 0) {
                                lv.push(p);
                            }
                        }
                    }
                    this.separateOuterPoints(vertexA, farthestPoint, lf, bound, map);
                    this.separateOuterPoints(farthestPoint, vertexB, lv, bound, map);
                };
                Aggregation.prototype.aggregate = function (nodes, links) {
                    if (this.zoom > Math.pow(2, this.settings.maxZoom)) {
                        var wrappedNodes = [];
                        var wrappedLinks = [];
                        var hasWeightFunction = Internal.Base.Helpers.isFunction(this.settings.weightFunction);
                        var i = void 0;
                        for (i = 0; i < nodes.length; i++) {
                            var n = nodes[i];
                            wrappedNodes.push({
                                id: "__aggr_" + n.id,
                                aggregatedWeight: hasWeightFunction ? this.settings.weightFunction(n) : 1,
                                _x: n._x,
                                _y: n._y,
                                _bounds: n._bounds,
                                coordinates: n.coordinates,
                                aggregatedNodes: [n],
                                loaded: true
                            });
                        }
                        for (i = 0; i < links.length; i++) {
                            var l = links[i];
                            wrappedLinks.push({
                                from: "__aggr_" + l.from,
                                to: "__aggr_" + l.to,
                                id: "__aggr_" + l.from + "-__aggr_" + l.to,
                                aggregatedLinks: [l]
                            });
                        }
                        return { nodes: wrappedNodes, links: wrappedLinks };
                    }
                    return this.findMainNodes(nodes, links);
                };
                return Aggregation;
            }());
            GeoChart.Aggregation = Aggregation;
        })(GeoChart = Internal.GeoChart || (Internal.GeoChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../itemschart/Settings.ts" />
/// <reference path="../itemschart/layers/ItemsStyle.ts" />
/// <reference path="../itemschart/layers/NodesStyle.ts" />
/// <reference path="Data.ts" />
/// <reference path="DomLayer.ts" />
/// <reference path="Aggregation.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var GeoChart;
        (function (GeoChart) {
            var Settings = (function (_super) {
                __extends(Settings, _super);
                function Settings(settings) {
                    // initialize common settings
                    _super.call(this, Internal.Base.SettingsMapping.GeoChartSettings);
                    this._computedLayers = [];
                    /** Theme to apply. You can either use this to share configuration objects between multiple charts or use one of the predefined
                    themes.
                    @see Documentation: [Pre-defined themes](geo-chart/api-reference/api.html#doc_themes)
                    */
                    this.theme = Settings.FlatTheme;
                    this.area = new SettingsArea();
                    this.background = new GeoChart.SettingsBackground();
                    this.data = [];
                    // overrides default settings
                    this.style = {
                        fadeTime: 200,
                        selection: {
                            fillColor: "rgba(200, 200, 255 ,0.7)",
                            sizeConstant: 5,
                            sizeProportional: 0.2
                        }
                    };
                    /** The default values for specific layer types. Any custom values in specified in `layers` property will be applied on top of the
                    values specified here, based on the `type` property witin them. */
                    this.layerTypes = {
                        shapes: { type: "shapes" },
                        items: { type: "items" },
                        aggregateOnShapes: { type: "aggregateOnShapes" },
                        charts: { type: "charts" }
                    };
                    /** Specifies the defaults for all layers, independent of the layer type.
                    @deprecated - This section is no longer used, specify the defaults in `layerTypes` section, based on the appropriate layer type.
                    */
                    this.layersDefault = null;
                    // note that this property does not contain the class instances but rather anonymous objects because the real instances are created
                    // afterwards by merging these values on top of `layerTypes`.
                    /** An array of objects. Have a look at "layerTypes" for the possible object types
                    @update mergeByID*/
                    this.layers = [];
                    this.navigation = {
                        /** Specify latitude of the initial center coordinate (WGS-84 degrees) */
                        initialLat: 40,
                        /** Specify longitude of the initial center coordinate (WGS-84 degrees) */
                        initialLng: 25,
                        /** Specify the initial zoom level for the chart. (For most chart data sources, valid values are 0..18 inclusive).*/
                        initialZoom: 3,
                        minZoom: 0,
                        maxZoom: 18,
                        maxBounds: { west: -200, north: -85, east: 200, south: 85 },
                        initialDrilldown: [""],
                        drilldownLayer: "default"
                    };
                    this.filters = {
                        nodeFilter: null
                    };
                    this.interaction = new SettingsInteraction();
                    // TODO: Find out how to fix the fullscreen mode for GeoChart
                    this.toolbar = new Internal.Base.SettingsToolbar(false, [new Internal.Base.SettingsToolbarItem("fullscreen")], "bottom", "left");
                    this.advanced.assets.push({ url: "assets://leaflet.css", required: function () { return !Internal.Base.Helpers.isStyleSheetDefined("leaflet-tile", "visibility"); } });
                    this.area.defaultHeight = 500;
                    this.advanced.style.loadingArcStyle.r = 15;
                    this.advanced.style.loadingArcStyle.lineColor = "red";
                    this.advanced.style.loadingArcStyle.lineWidth = 7;
                    this.apply(settings);
                    this._initializing = false;
                }
                Settings.prototype.apply = function (settings) {
                    this.applyCompatibility(settings, [
                        { from: "layersDefault", alternative: "layerTypes" }
                    ]);
                    var changes = _super.prototype.apply.call(this, settings);
                    // generate _computedLayers
                    if (this._initializing || changes.layers || changes.layerTypes) {
                        this._computedLayers = Internal.Base.SettingsHelper.mergeDefaultValues(this.layers, this.layersDefault, this.layerTypes, SettingsLayerBase.createInstance, SettingsLayerBase.getMapping, "layers");
                    }
                    return changes;
                };
                Settings.FlatTheme = {
                    advanced: { themeCSSClass: "DVSL-flat" }
                };
                return Settings;
            }(Internal.ItemsChart.Settings));
            GeoChart.Settings = Settings;
            var SettingsArea = (function (_super) {
                __extends(SettingsArea, _super);
                function SettingsArea() {
                    _super.apply(this, arguments);
                    this.style = new SettingsAreaStyle();
                }
                return SettingsArea;
            }(Internal.Base.SettingsArea));
            GeoChart.SettingsArea = SettingsArea;
            var SettingsAreaStyle = (function (_super) {
                __extends(SettingsAreaStyle, _super);
                function SettingsAreaStyle() {
                    _super.apply(this, arguments);
                }
                return SettingsAreaStyle;
            }(Internal.Base.SettingsAreaStyle));
            GeoChart.SettingsAreaStyle = SettingsAreaStyle;
            var SettingsNodesLayerStyle = (function (_super) {
                __extends(SettingsNodesLayerStyle, _super);
                function SettingsNodesLayerStyle() {
                    _super.call(this);
                    /** The style used to draw convex shapes for the automatically aggregated nodes. */
                    this.aggregatedShape = {
                        mode: 1 /* hovered */,
                        lineColor: "rgba(0,0,128,0.5)",
                        lineWidth: 1,
                        fillColor: "rgba(0,0,128,0.3)"
                    };
                    this.scaleObjectsWithZoom = false;
                    this.node.radius = 10;
                    this.node.fillColor = "orange";
                    this.node.lineColor = "red";
                    this.linkLabel.scaleWithSize = false;
                    this.linkLabel.scaleWithZoom = false;
                    this.linkLabel.backgroundStyle.fillColor = "white";
                    this.linkLabel.backgroundStyle.lineColor = "black";
                    this.nodeLabel.scaleWithSize = false;
                    this.nodeLabel.scaleWithZoom = false;
                    this.nodeLabel.backgroundStyle.fillColor = "white";
                    this.nodeLabel.backgroundStyle.lineColor = "black";
                }
                return SettingsNodesLayerStyle;
            }(Internal.ItemsChart.SettingsNodesLayerStyle));
            GeoChart.SettingsNodesLayerStyle = SettingsNodesLayerStyle;
            var SettingsLayerBase = (function () {
                function SettingsLayerBase() {
                    this.enabled = true;
                    this.id = "default";
                    this.name = "";
                    /**
                    @type enum
                    @value shapes
                    @value items
                    @value charts
                    @value aggregateOnShapes
                    */
                    this.type = "shapes";
                    /** @type integer */
                    this.minZoom = 0;
                    /** @type integer*/
                    this.maxZoom = 20;
                    /** Forces style re-evaluation on zoom change. Use to provide zoom dependant style. */
                    this.perZoomStyle = false;
                    this.data = {
                        id: "default"
                    };
                }
                /** Used dynamically by SettingsHelper to determine the correct mapping based on the type. */
                SettingsLayerBase.getMapping = function (target, source) {
                    if (target && source.type && target.type !== source.type)
                        throw new Error("It is not possible to change the value of `type` property for an existing layer.");
                    switch (target ? target.type : source.type) {
                        case "shapes":
                            return Internal.Base.SettingsMapping.GeoChartSettingsLayerShapes;
                        case "items":
                            return Internal.Base.SettingsMapping.GeoChartSettingsLayerItems;
                        case "charts":
                            return Internal.Base.SettingsMapping.GeoChartSettingsLayerCharts;
                        case "aggregateOnShapes":
                            return Internal.Base.SettingsMapping.GeoChartSettingsLayerAggregated;
                        default:
                            throw new Error(("The value '" + source.type + "' is not valid for the `type` property of a layer.")
                                + " Valid values are: shapes, items, charts, aggregateOnShapes.");
                    }
                };
                SettingsLayerBase.createInstance = function (source, type) {
                    switch (type || source.type) {
                        case "shapes":
                            return new SettingsLayerShapes();
                        case "items":
                            return new SettingsLayerItems();
                        case "charts":
                            return new SettingsLayerCharts();
                        case "aggregateOnShapes":
                            return new SettingsLayerAggregated();
                        default:
                            throw new Error(("The value '" + (type || source.type) + "' is not valid for the `type` property of a layer. ")
                                + "Valid values are: shapes, items, charts, aggregateOnShapes.");
                    }
                };
                return SettingsLayerBase;
            }());
            GeoChart.SettingsLayerBase = SettingsLayerBase;
            var SettingsLayerShapes = (function (_super) {
                __extends(SettingsLayerShapes, _super);
                function SettingsLayerShapes() {
                    _super.call(this);
                    this.style = new GeoChart.SettingsShapesLayerStyle();
                    this.type = "shapes";
                }
                return SettingsLayerShapes;
            }(SettingsLayerBase));
            GeoChart.SettingsLayerShapes = SettingsLayerShapes;
            var SettingsLayerItems = (function (_super) {
                __extends(SettingsLayerItems, _super);
                function SettingsLayerItems() {
                    _super.call(this);
                    this.style = new SettingsNodesLayerStyle();
                    /** Controls automatic proximity based aggregation. */
                    this.aggregation = new GeoChart.SettingsAggregation();
                    this.layout = new GeoChart.SettingsNodesLayout();
                    /** Contains settings for the auras drawn beneath the nodes.
                    @version 1.15.0 */
                    this.auras = new Internal.ItemsChart.SettingsNodesLayerAuras();
                    this.type = "items";
                }
                return SettingsLayerItems;
            }(SettingsLayerBase));
            GeoChart.SettingsLayerItems = SettingsLayerItems;
            var SettingsLayerOverlay = (function (_super) {
                __extends(SettingsLayerOverlay, _super);
                function SettingsLayerOverlay() {
                    _super.apply(this, arguments);
                    /** The ID of a linked shapes layer. The shapes layer must be defined before the overlay layer. */
                    this.shapesLayer = null;
                }
                return SettingsLayerOverlay;
            }(SettingsLayerBase));
            GeoChart.SettingsLayerOverlay = SettingsLayerOverlay;
            var SettingsLayerAggregated = (function (_super) {
                __extends(SettingsLayerAggregated, _super);
                function SettingsLayerAggregated() {
                    _super.call(this);
                    /** Data field used for aggregation. */
                    this.aggregationField = null;
                    /** Aggregation function to use.
                    @type enum
                    @value sum
                    @value min
                    @value max
                    @value first
                    @value last
                    @value avg
                    @value count */
                    this.aggregation = "count";
                    /** Custom function to call for aggregation
                    @returns aggregated value, to be passed to styleFunction */
                    this.aggregationFunction = null;
                    /** Function for applying the aggregated value on node. */
                    this.styleFunction = null;
                    this.type = "aggregateOnShapes";
                }
                return SettingsLayerAggregated;
            }(SettingsLayerOverlay));
            GeoChart.SettingsLayerAggregated = SettingsLayerAggregated;
            var SettingsLayerCharts = (function (_super) {
                __extends(SettingsLayerCharts, _super);
                function SettingsLayerCharts() {
                    _super.call(this);
                    /** Chart type to use
                     @type enum
                     @value piechart
                     @value timechart
                     @value facetchart */
                    this.chartType = "piechart";
                    /** The settings that will be passed to each nested chart. Note that if `settingsFunction` is also specified, these
                    settings will not be used and `settingsFunction` will be called instead.
                    @update reference */
                    this.settings = null;
                    /** The delegate that will be used to retrieve custom setting for a particular node. This function is called every time the node is modified.
                    The result should only contain modified settings that will be passed to `chart.updateSettings()`. */
                    this.settingsFunction = null;
                    /** automatic size based on shape size
                     //TODO: implement this
                     @ignore
                     */
                    this.autoSize = false;
                    this.data = {
                        /** ID should be `null` because the charts layer does not retrieve data this way. */
                        id: null
                    };
                    this.type = "charts";
                }
                return SettingsLayerCharts;
            }(SettingsLayerOverlay));
            GeoChart.SettingsLayerCharts = SettingsLayerCharts;
            var SettingsInteraction = (function (_super) {
                __extends(SettingsInteraction, _super);
                function SettingsInteraction() {
                    _super.call(this);
                    /**
                    @type enum
                    @value drilldown
                    @value select
                    @value toggle*/
                    this.mode = "drilldown";
                    this.nodesMovable = false;
                    this.selection.enabled = false;
                }
                return SettingsInteraction;
            }(Internal.ItemsChart.SettingsInteraction));
            GeoChart.SettingsInteraction = SettingsInteraction;
        })(GeoChart = Internal.GeoChart || (Internal.GeoChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/core/ChartEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var ItemsChart;
        (function (ItemsChart) {
            /** Describes a custom button that is added to the menu.
            @version 1.12.0 */
            var SettingsMenuButton = (function () {
                function SettingsMenuButton() {
                    /** The CSS class that is applied to the HTML link element (the button). */
                    this.className = null;
                    /** The text (HTML is supported) that is displayed within the button. */
                    this.text = null;
                    /** The callback that will be invoked when the menu button is first created for the particular object. */
                    this.onInit = null;
                    /** The callback that will be invoked when the menu is being opened after creation. The callback is also
                    invoked for every button after any menu button is clicked. */
                    this.onRefresh = null;
                    /** The callback that will be invoked when the menu is clicked. */
                    this.onClick = null;
                }
                return SettingsMenuButton;
            }());
            ItemsChart.SettingsMenuButton = SettingsMenuButton;
            var SettingsMenu = (function () {
                function SettingsMenu() {
                    /** Show/hide node/link menu. */
                    this.enabled = true;
                    /** Whether to add a view data button to the menu. Useful for debugging. */
                    this.showData = false;
                    /** Prepare html string or DOM element to include in the menu. Called whenever a menu is about to be shown.
            
                    If this callback is not defined, the menu will display the label of the element.
                    @returns A HTML string or DOM element to include in the menu. Alternatively return null and call callback() later.
                    @version 1.9.0 - added the ability to return `HTMLElement`. */
                    this.contentsFunction = null;
                    /** Buttons to show in node menu. It is possible to add custom buttons or use built-in buttons if
                    that particular menu supports them.
                    
                    Currently only the `nodeMenu` on the NetChart supports any of following built-in buttons: `expand`, `focus`, `lock`, `hide`.
                    
                    @version 1.12.0 - added support for the custom buttons. */
                    this.buttons = [];
                }
                return SettingsMenu;
            }());
            ItemsChart.SettingsMenu = SettingsMenu;
            var SettingsNodeMenu = (function (_super) {
                __extends(SettingsNodeMenu, _super);
                function SettingsNodeMenu() {
                    _super.apply(this, arguments);
                    this.contentsFunction = null;
                }
                return SettingsNodeMenu;
            }(SettingsMenu));
            ItemsChart.SettingsNodeMenu = SettingsNodeMenu;
            var SettingsLinkMenu = (function (_super) {
                __extends(SettingsLinkMenu, _super);
                function SettingsLinkMenu() {
                    _super.apply(this, arguments);
                    this.contentsFunction = null;
                }
                return SettingsLinkMenu;
            }(SettingsMenu));
            ItemsChart.SettingsLinkMenu = SettingsLinkMenu;
            var Menu = (function (_super) {
                __extends(Menu, _super);
                function Menu(chart) {
                    _super.call(this);
                    this.animationOrder = 600;
                    this.paintOrder = 40;
                    this.updateOrder = 2000;
                    this.node = null;
                    this.link = null;
                    this.contents = null;
                    this.x = 0;
                    this.y = 0;
                    this.chart = chart;
                    this.container = chart.shell.menuContainer;
                    this.scene = chart.scene;
                    this.events = chart.events;
                    this.buttons = [];
                    this.popup = Internal.Base.Helpers.createDom("div", "DVSL-Menu", null, this.container);
                    var closeButton = Internal.Base.Helpers.createDom("a", "DVSL-Menu-close", "X", this.popup);
                    this.popupValue = Internal.Base.Helpers.createDom("div", "DVSL-Menu-title", null, this.popup);
                    this.detailsDiv = Internal.Base.Helpers.createDom("div", "DVSL-Menu-details", null, this.popup);
                    this.popupActions = Internal.Base.Helpers.createDom("nav", null, null, this.popup);
                    this.buildDetailsPanel(this.detailsDiv);
                    this.buildCloseButton(closeButton);
                    this.popup.style.position = "absolute";
                    this.popup.style.display = "none";
                }
                Menu.prototype.doAnimations = function (event) {
                    if (!this.node) {
                        return;
                    }
                    if (this.node.removed || (this.link && this.link.removed)) {
                        this.hideMenu();
                    }
                    else if (this.node.layer.modifiedNodes.hasOwnProperty(this.node.id)) {
                        this.updateMenu();
                    }
                };
                Menu.prototype.previewPointerDown = function (event) { this.hideMenu(); };
                Menu.prototype.previewWheel = function (event) { this.hideMenu(); };
                Menu.prototype.toggleNodeMenu = function (node) {
                    if (this.node === node) {
                        this.hideMenu();
                    }
                    else {
                        this.showNodeMenu(node);
                    }
                };
                Menu.prototype.toggleLinkMenu = function (x, y, link) {
                    if (this.link === link) {
                        this.hideMenu();
                    }
                    else {
                        this.showLinkMenu(x, y, link);
                    }
                };
                Menu.prototype.showNodeMenu = function (node) {
                    if (!this.scene.settings.nodeMenu.enabled) {
                        return;
                    }
                    if (this.node === node) {
                        this.updateMenu();
                    }
                    else {
                        this.hideMenu();
                        this.showPopup(node, null);
                    }
                };
                Menu.prototype.showLinkMenu = function (x, y, link) {
                    if (!this.scene.settings.linkMenu.enabled) {
                        return;
                    }
                    this.x = x;
                    this.y = y;
                    if (this.link === link) {
                        this.updateMenu();
                    }
                    else {
                        this.hideMenu();
                        this.showPopup(null, link);
                    }
                };
                Menu.prototype.showPopup = function (node, link) {
                    this.node = node;
                    this.link = link;
                    if (this.node) {
                        this.node.locks += 1;
                    }
                    this.buildButtons();
                    this.contents = null;
                    this.popupValue.innerHTML = "";
                    this.popup.style.display = "block";
                    this.updateMenu();
                    this.updateXY();
                };
                Menu.prototype.hideMenu = function () {
                    if (!this.node && !this.link) {
                        return;
                    }
                    if (this.node) {
                        this.node.locks -= 1;
                    }
                    this.node = null;
                    this.link = null;
                    this.popup.style.display = "none";
                };
                Menu.prototype.updateMenu = function () {
                    var _this = this;
                    // update contents
                    var settings;
                    var obj;
                    if (this.node) {
                        settings = this.scene.settings.nodeMenu;
                        obj = this.node;
                    }
                    else {
                        settings = this.scene.settings.linkMenu;
                        obj = this.link;
                    }
                    var contents = null;
                    var curNode = this.node;
                    var curLink = this.link;
                    var callback = function (data) {
                        if (_this.node === curNode && _this.link === curLink && data !== _this.contents) {
                            if (data == null) {
                                _this.popupValue.innerHTML = "";
                            }
                            else if (Internal.Base.Helpers.isString(data)) {
                                _this.popupValue.innerHTML = data;
                            }
                            else if (Internal.Base.Helpers.isDomObject(data)) {
                                _this.popupValue.innerHTML = "";
                                _this.popupValue.appendChild(data);
                            }
                            else {
                                Internal.Base.Helpers.error("Invalid value for menu text. Must be either a string or a DOM element.");
                                return;
                            }
                            _this.contents = data;
                        }
                    };
                    if (settings.contentsFunction) {
                        var text = settings.contentsFunction.call(this.chart.api, obj.data, obj, callback);
                        if (Internal.Base.Helpers.isString(text) || Internal.Base.Helpers.isDomObject(text)) {
                            contents = text;
                        }
                        else if (this.contents == null) {
                            contents = "<small>" + this.scene.settings.localization.loadingLabel + "</small>";
                        }
                        else {
                            contents = this.contents;
                        }
                    }
                    else {
                        contents = obj.label;
                    }
                    callback(contents);
                    this.updateButtons();
                    if (settings.showData) {
                        this.details.innerHTML = JSON.stringify(obj.data, null, "  ");
                        this.detailsDiv.style.display = "block";
                    }
                    else {
                        this.detailsDiv.style.display = "none";
                        if (contents == null && this.buttons.length === 0) {
                            this.hideMenu();
                        }
                    }
                };
                Menu.prototype.updateXY = function () {
                    var margin = 12;
                    var ny0;
                    var nx0;
                    var nx1;
                    var ny1;
                    var nx;
                    var ny;
                    if (this.node) {
                        var toDisplayResult = this.scene.toDisplay(this.node.x, this.node.y);
                        nx = toDisplayResult.x;
                        ny = toDisplayResult.y;
                        ny0 = ny - this.node.renderHheight - margin;
                        ny1 = ny + this.node.renderHheight + margin;
                        nx0 = nx - this.node.renderHheight - margin;
                        nx1 = nx + this.node.renderHheight + margin;
                    }
                    else {
                        ny0 = ny1 = ny = this.y;
                        nx0 = this.x - margin;
                        nx1 = this.x + margin;
                    }
                    // use the main scene for chart-on-charts
                    var rootScene = this.chart.getRootChart().scene;
                    var x0 = rootScene.x0;
                    var x1 = rootScene.x0 + rootScene.width;
                    var w = this.popup.offsetWidth;
                    var h = this.popup.offsetHeight;
                    ny = Math.max(Math.min(ny, rootScene.y0 + rootScene.height - h), rootScene.y0);
                    if (nx1 + w <= x1) {
                        nx = nx1;
                    }
                    else if (nx0 - w >= x0) {
                        nx = nx0 - w;
                    }
                    else {
                        nx = Math.max(nx0 - w / 2, x0);
                        ny = ny1;
                    }
                    this.popup.style.left = nx + "px";
                    this.popup.style.top = ny + "px";
                };
                Menu.prototype.buildDefaultButton = function (target, button) {
                    this.chart.error("The menu does not support any named buttons.");
                };
                Menu.prototype.buildButton = function (target, cl, title, initFun, clickFun, refreshFun) {
                    var _this = this;
                    var button = Internal.Base.Helpers.createDom("a", cl, title, this.popupActions);
                    button.title = title;
                    button.onclick = function (e) {
                        if (clickFun)
                            clickFun.call(_this.chart.api, target, button);
                        _this.hideMenu();
                        e.preventDefault();
                    };
                    button.href = "#";
                    if (initFun) {
                        initFun.call(this.chart.api, target, button);
                    }
                    this.buttons.push({ e: button, t: target, a: refreshFun });
                };
                Menu.prototype.buildButtons = function () {
                    this.popupActions.innerHTML = "";
                    this.buttons = [];
                    var settings;
                    var obj;
                    if (this.node) {
                        settings = this.scene.settings.nodeMenu;
                        obj = this.node;
                    }
                    else {
                        settings = this.scene.settings.linkMenu;
                        obj = this.link;
                    }
                    var sb = settings.buttons;
                    if (sb) {
                        for (var i = 0; i < sb.length; i++) {
                            var b = sb[i];
                            if (Internal.Base.Helpers.isString(b)) {
                                this.buildDefaultButton(obj, b);
                            }
                            else {
                                this.buildButton(obj, b.className, b.text, b.onInit, b.onClick, b.onRefresh);
                            }
                        }
                    }
                };
                Menu.prototype.updateButtons = function () {
                    for (var bIndex = 0; bIndex < this.buttons.length; bIndex++) {
                        var b = this.buttons[bIndex];
                        if (b.a) {
                            b.a.call(this.chart.api, b.t, b.e);
                        }
                    }
                };
                Menu.prototype.buildCloseButton = function (a) {
                    var _this = this;
                    a.title = this.scene.settings.localization.closeButton;
                    a.href = "#";
                    a.onclick = function (e) {
                        _this.hideMenu();
                        e.preventDefault();
                    };
                };
                Menu.prototype.buildDetailsPanel = function (div) {
                    var a = Internal.Base.Helpers.createDom("small", null, "Technical data", div);
                    var d = this.details = Internal.Base.Helpers.createDom("pre", null, "", div);
                    d.style.display = "none";
                    a.onclick = function () {
                        if (d.style.display === "none") {
                            d.style.display = "block";
                        }
                        else {
                            d.style.display = "none";
                        }
                    };
                };
                return Menu;
            }(Internal.Base.ChartElement));
            ItemsChart.Menu = Menu;
        })(ItemsChart = Internal.ItemsChart || (Internal.ItemsChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/InfoPopup.ts" />
/// <reference path="Scene.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var ItemsChart;
        (function (ItemsChart) {
            var InfoPopup = (function (_super) {
                __extends(InfoPopup, _super);
                function InfoPopup(chart) {
                    _super.call(this);
                    this.animationOrder = 800;
                    this.paintOrder = 45;
                    this.updateOrder = 2000;
                    this.chart = chart;
                    this.scene = chart.scene;
                    this.options = this.scene.settings;
                    this.item = null;
                    this.x = null;
                    this.y = null;
                    this.popup = new Internal.Base.InfoPopup(chart);
                }
                InfoPopup.prototype.previewPointerMove = function (event) {
                    this.onMove(event.x, event.y);
                };
                InfoPopup.prototype.doAnimations = function (event) {
                    if (this.x !== null && this.y !== null) {
                        this.onMove(this.x, this.y);
                    }
                };
                InfoPopup.prototype.previewPointerDown = function (event) {
                    this.x = this.y = null;
                    this.setCurrentObject(0, 0, null);
                };
                InfoPopup.prototype.previewPointerDrag = function (event) {
                    this.x = this.y = null;
                    this.setCurrentObject(0, 0, null);
                };
                InfoPopup.prototype.onPointerOut = function (event) {
                    this.x = this.y = null;
                    this.setCurrentObject(0, 0, null);
                };
                InfoPopup.prototype.onMove = function (x, y) {
                    this.y = y;
                    this.x = x;
                    if (!this.options.info.enabled) {
                        return;
                    }
                    var item = this.scene.hoverNode ? this.scene.hoverNode : this.scene.hoverLink;
                    this.setCurrentObject(x, y, item);
                };
                InfoPopup.prototype.setCurrentObject = function (x, y, item) {
                    if (!item) {
                        this.item = null;
                        this.popup.hide();
                    }
                    else {
                        if (item !== this.item) {
                            var contents = this.buildContents(item);
                            this.popup.show(x, x, y, contents);
                        }
                        else {
                            this.popup.updateXY(x, x, y);
                        }
                        this.item = item;
                    }
                };
                InfoPopup.prototype.buildContents = function (item) {
                    var _this = this;
                    var func = null;
                    if (item instanceof ItemsChart.Node) {
                        func = this.options.info.nodeContentsFunction;
                    }
                    else if (item instanceof ItemsChart.Link) {
                        func = this.options.info.linkContentsFunction;
                    }
                    if (func) {
                        var callback = function (contents) {
                            if (item === _this.item) {
                                _this.popup.updateContents(contents);
                            }
                        };
                        return func.call(this.chart.api, item.data, item, callback);
                    }
                    else {
                        return item.label;
                    }
                };
                return InfoPopup;
            }(Internal.Base.ChartElement));
            ItemsChart.InfoPopup = InfoPopup;
        })(ItemsChart = Internal.ItemsChart || (Internal.ItemsChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var ItemsChart;
        (function (ItemsChart) {
            var hasTypedArrays = typeof Float32Array !== typeof void 0;
            /**
             * @version 1.15.0
             */
            var SettingsNodesLayerAuras = (function () {
                function SettingsNodesLayerAuras() {
                    /** Specifies if the node auras are enabled. */
                    this.enabled = true;
                    /** The draw limit (0..1) which cells will be considered to belong to the aura.
            
                    Larger values result in smaller auras. The cells under the center of the node usually have values close to 1,
                    while the edges have values close to 0. */
                    this.drawLimit = 0.8;
                    /** The cell size of the grid (in display pixels). Smaller values result in more precise aura calculations but
                    can be much slower. Note that decreasing the value also increses the memory requirements which can be
                    significant if the number of auras is large. */
                    this.cellSize = 3;
                    /** The multiplier for the node radius that defines the total area of the aura the node emanates.
            
                    Note that this defines the size of the aura before the `drawLimit` value is applied to reduce the size
                    of the aura. */
                    this.intensity = 6;
                    /** Defines specific styles for each aura. The key of the mapping has to match the aura ID. */
                    this.style = {};
                    /** Defines the default colors that are applied to auras for whom there are no specific style settings
                    defined in the `style` property.
            
                    If this is set to an empty array, only auras explicitly defined in `style` will be displayed. */
                    this.defaultColors = [
                        "rgba(47,195,47,0.3)",
                        "rgba(176,220,11,0.3)",
                        "rgba(234,180,4,0.3)",
                        "rgba(222,103,44,0.3)",
                        "rgba(236,46,46,0.3)",
                        "rgba(213,66,155,0.3)",
                        "rgba(111,82,184,0.3)",
                        "rgba(28,124,213,0.3)",
                        "rgba(86,185,247,0.3)",
                        "rgba(10,232,235,0.3)"
                    ];
                    /** Specifies if the auras can be drawn overlapped or if every cell can only belong to a single aura. */
                    this.overlap = false;
                }
                return SettingsNodesLayerAuras;
            }());
            ItemsChart.SettingsNodesLayerAuras = SettingsNodesLayerAuras;
            var NodesLayerAuras = (function () {
                function NodesLayerAuras(scene, events, settings) {
                    /** Number of cells that are added to each side of the grid to make some calculations easier (the calculations
                    no longer need to perform precise bounds checking). */
                    this._marginCells = 1;
                    /** The coordinates (using indexes for the `_cells` array) of the edge polygons that were detected.
            
                    The outer array contains a single entry for each aura (matching indexes with `_auras`), the inner array
                    has multiple polygons (clockwise for outer edges, counterclockwise for holes). */
                    this._polygons = [];
                    /** Counter of how many auras have been automatically added to the settings based on the data.
            
                    This represents the next color that will be used from `style.defaultColors`. */
                    this._autoAuraCounter = 0;
                    /** Specifies if the warning about multiple auras on a node without overlapping enabled has been showed or
                    is not needed. */
                    this._overlapWarning = true;
                    this._settings = settings;
                    this._scene = scene;
                    this._events = events;
                }
                /**
                 * Recreates all internal structures based on the given settings.
                 */
                NodesLayerAuras.prototype.reinitialize = function (event) {
                    var scene = this._scene;
                    var settings = this._settings;
                    this._overlapWarning = settings.overlap;
                    // TODO: use event.scaleX/Y to reduce the grid size automatically
                    // this would mean that the _cellSize has to be split into _cellSizeX, _cellSizeY as well.
                    var width = scene.width;
                    var height = scene.height;
                    var auraIDs = Object.keys(settings.style);
                    auraIDs.sort(function (a, b) {
                        var x = settings.style[a].zIndex - settings.style[b].zIndex;
                        return x === 0 ? a.localeCompare(b) : x;
                    });
                    this._auras = new Array(auraIDs.length + 1);
                    this._aurasMap = Object.create(null);
                    this._aurasMap[""] = 0;
                    for (var i = 0; i < auraIDs.length; i++) {
                        var k = auraIDs[i];
                        this._aurasMap[k] = i + 1;
                        this._auras[i + 1] = settings.style[k];
                    }
                    var m = this._marginCells;
                    var cs = settings.cellSize;
                    var w = this._widthCells = Math.ceil(width / cs) + m * 2;
                    var h = this._heightCells = Math.ceil(height / cs) + m * 2;
                    // note the "+1" - it is there because the first aura is actually for nodes that do not have an aura so that they correctly create holes.
                    var cellLength = this._cellLength = auraIDs.length + 1;
                    var count = w * h * cellLength;
                    var cells = this._cells = hasTypedArrays ? new Float32Array(count) : new Array(count);
                    var cellsEdges = this._cellEdges = hasTypedArrays ? new Int8Array(count) : new Array(count);
                    var w2 = w * cellLength;
                    for (var j = 0; j < count; j++) {
                        cellsEdges[j] = -1;
                    }
                    if (!hasTypedArrays) {
                        // typed arrays are initialized to zeroes.
                        for (var i = 0; i < cells.length; i++) {
                            cells[i] = 0;
                        }
                    }
                    var deltas = [
                        /*  0 */ -w2,
                        /*  1 */ -w2 + cellLength,
                        /*  2 */ +cellLength,
                        /*  3 */ +w2 + cellLength,
                        /*  4 */ +w2,
                        /*  5 */ +w2 - cellLength,
                        /*  6 */ -cellLength,
                        /*  7 */ -w2 - cellLength,
                        /*  8 */ -w2,
                        /*  9 */ -w2 + cellLength,
                        /* 10 */ +cellLength,
                        /* 11 */ +w2 + cellLength,
                        /* 12 */ +w2,
                        /* 13 */ +w2 - cellLength,
                        /* 14 */ -cellLength,
                        /* 15 */ -w2 - cellLength
                    ];
                    this._edgeFinderDeltas = hasTypedArrays ? new Int16Array(deltas) : deltas;
                };
                NodesLayerAuras.prototype.doAnimations = function (nodes, event) {
                    if (!this._settings.enabled || !nodes)
                        return;
                    // optimize for the most common case - no auras are defined.
                    // also create styles for any auras that are not explicitly defined
                    var aurasAdded = false;
                    var hasAuras = false;
                    for (var i = 0; i < nodes.length; i++) {
                        var auras = nodes[i].aura;
                        if (auras) {
                            if (!Array.isArray(auras)) {
                                auras = [auras];
                            }
                            else if (!this._overlapWarning && auras.length > 1) {
                                Internal.Base.Helpers.warn("One or more nodes defined more than one aura."
                                    + " It is recommended to set `overlap: true` in the chart configuration to better handle this scenario.");
                                this._overlapWarning = true;
                            }
                            for (var j = 0; j < auras.length; j++) {
                                var auraID = "" + (auras[j] || "");
                                if (auraID !== "") {
                                    hasAuras = true;
                                    aurasAdded = this.ensureAura(auraID) || aurasAdded;
                                }
                            }
                        }
                    }
                    if (!hasAuras)
                        return;
                    if (aurasAdded) {
                        // Notify the legend (and possibly other components) that new auras have been added to the settings.
                        this._events.notifySceneChanges({ settingsChanges: { auras: {} } });
                    }
                    var ch = event.changes;
                    var sch = ch.settingsChanges;
                    // currently not checking the GeoChart case because there the whole layer should be recreated
                    // once its settings are changed.
                    if (aurasAdded || !this._auras || ch.bounds || (sch && sch.auras)) {
                        this.reinitialize(event);
                    }
                    this.reset();
                    this.stage1(nodes);
                    this.stage2();
                    this.stage3();
                };
                /** Ensures that an aura with the given ID is present in the configuration object and has mandatory default properties assigned.
                 */
                NodesLayerAuras.prototype.ensureAura = function (id) {
                    var config = this._settings;
                    var cnt = this._autoAuraCounter;
                    var defColors = config.defaultColors;
                    if (!defColors || !defColors.length)
                        return false;
                    var currentConfig = config.style[id];
                    if (!currentConfig) {
                        currentConfig = {};
                        config.style[id] = currentConfig;
                    }
                    var hasChanges = false;
                    if (currentConfig.lineWidth === void 0) {
                        currentConfig.lineWidth = 1;
                        hasChanges = true;
                    }
                    if (currentConfig.fillColor === void 0) {
                        currentConfig.fillColor = defColors[cnt];
                        this._autoAuraCounter = (cnt + 1) % defColors.length;
                        hasChanges = true;
                    }
                    if (currentConfig.showInLegend == null) {
                        currentConfig.showInLegend = true;
                    }
                    if (currentConfig.enabled == null) {
                        currentConfig.enabled = true;
                    }
                    if (currentConfig.zIndex == null) {
                        currentConfig.zIndex = 0;
                    }
                    return hasChanges;
                };
                /** Resets all reusable arrays so that they can be used for the calculations of the new frame. */
                NodesLayerAuras.prototype.reset = function () {
                    var cellEdges = this._cellEdges;
                    for (var i = 0; i < cellEdges.length; i++) {
                        cellEdges[i] = -1;
                    }
                    var cells = this._cells;
                    for (var i = 0; i < cells.length; i++) {
                        cells[i] = 0;
                    }
                    this._polygons = new Array(this._auras.length);
                    for (var i = 0; i < this._polygons.length; i++) {
                        this._polygons[i] = [];
                    }
                };
                /** Fills the grid by drawing gradients from the center of each node. */
                NodesLayerAuras.prototype.stage1 = function (nodes) {
                    var scene = this._scene;
                    var zoom = scene.zoom;
                    var config = this._settings;
                    var cs = config.cellSize;
                    var margin = this._marginCells;
                    var w = this._widthCells;
                    var h = this._heightCells;
                    var cells = this._cells;
                    var clen = this._cellLength;
                    var auraMap = this._aurasMap;
                    var intensity = config.intensity;
                    // deltaX/Y are used so that the grid does not jump as the chart area is moved around.
                    // the grid is always aligned to the center of the scene instead of the edge of the scene.
                    var deltaX = (scene.centerX * scene.zoom) % cs;
                    var deltaY = (scene.centerY * scene.zoom) % cs;
                    for (var i = 0; i < nodes.length; i++) {
                        var n = nodes[i];
                        var coords = scene.toDisplay(n.x, n.y);
                        var cx = (coords.x + deltaX) / cs + margin;
                        var cy = (coords.y + deltaY) / cs + margin;
                        var cx0 = cx | 0;
                        var cy0 = cy | 0;
                        // deltaCx/y are used to center the gradient on the exact node coordinates instead of the center of the
                        // cell that contains the node center. This results in slightly more fluid movement.
                        var deltaCx = cx - cx0;
                        var deltaCy = cy - cy0;
                        var auras = nodes[i].aura;
                        if (!auras)
                            continue;
                        if (!Array.isArray(auras))
                            auras = [auras];
                        for (var j = 0; j < auras.length; j++) {
                            var auraID = "" + (auras[j] || "");
                            var auraIndex = auraMap[auraID];
                            if (auraIndex === void 0 || !this._auras[auraIndex].enabled) {
                                continue;
                            }
                            /** The precise radius of the node in number of cells (fractions allowed) */
                            var rl = Math.min((n.radius * zoom + 5) / cs, w, h);
                            /** The full radius of the aura bubble for the node in number of cells (fractions allowed) */
                            var rx = rl * intensity + 1;
                            /** The full diameter of the aura bubble for the node in number of cells (fractions allowed) */
                            var rx2 = rx * 2;
                            // ignore the nodes whose auras are completely outside the scene
                            if (cx > -rx2 && cx < w + rx2 && cy > -rx2 && cy < h + rx2) {
                                /** The radius (in number of cells) that will always have max aura. Used so that node centers
                                are more likely to belong to the aura of that node. */
                                var rlim = rl / 2;
                                var r = Math.ceil(rx);
                                rx -= rlim;
                                for (var x = -r; x < r; x++) {
                                    if (cx + x < margin || cx + x >= w - margin)
                                        continue;
                                    var x2 = deltaCx - x;
                                    for (var y = -r; y < r; y++) {
                                        if (cy + y < margin || cy + y >= h - margin)
                                            continue;
                                        var y2 = deltaCy - y;
                                        var dist = Math.sqrt(x2 * x2 + y2 * y2) - rlim;
                                        if (dist < rx) {
                                            dist = dist <= 0 ? 1 : 1 - (dist / rx);
                                            var index = auraIndex + (cy0 + y) * w * clen + (cx0 + x) * clen;
                                            // use alpha copositioning to merge multiple auras together.
                                            cells[index] = cells[index] + dist - cells[index] * dist;
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
                /** Handles non-overlapping auras by leaving only the largest aura in each X/Y coordinate. */
                NodesLayerAuras.prototype.stage2 = function () {
                    // note that this could be optimized (at least in terms of memory usage) by doing a similar operation during stage1
                    // as soon as a two whole auras are processed. That would required sorting the nodes by their aura ID and also storing
                    // the auraID for each X/Y coordinate.
                    var clen = this._cellLength;
                    if (clen === 1 || this._settings.overlap)
                        return;
                    var cells = this._cells;
                    for (var ci = 0; ci < cells.length; ci += clen) {
                        var index = ci;
                        var val = cells[ci];
                        for (var cj = 1; cj < clen; cj++) {
                            var val2 = cells[ci + cj];
                            if (val2 > val) {
                                val = val2;
                                cells[index] = 0;
                                index = ci + cj;
                            }
                            else if (val2 > 0) {
                                cells[ci + cj] = 0;
                            }
                        }
                    }
                };
                /** Given a start position, walks the edge of the aura. */
                NodesLayerAuras.prototype.stage3FindEdge = function (polygons, startIndex) {
                    var cells = this._cells;
                    var cellEdges = this._cellEdges;
                    var config = this._settings;
                    var lim = config.drawLimit;
                    var deltas = this._edgeFinderDeltas;
                    var result = [startIndex];
                    var curIndex = startIndex;
                    // The stage3() method always checks that the cell to the left was empty. So the entry direction in the edge is from the left to the right.
                    var lastDirection = 2;
                    var directionChecker1 = 0;
                    var directionChecker2 = 0;
                    /** Determines if the lines should be smoothed. It means that most smaller corners that point to the inside of the polygon will be ignored.
                    It is not used for non-overlapping polygons because in that case the edges tend to overlap and also the jumps are much more visible. */
                    var smoothLines = config.overlap;
                    /** Counter for how many steps in the same directions have been skipped. It is limited so that the corner radius is not too large in some cases. */
                    var skipping = 0;
                    /** Safety check to make sure the edge finder does not get stuck. */
                    var iter = 0;
                    do {
                        // this check prevents loops within incomplete edges - the edge finder should never walk the same route twice.
                        var rep = cellEdges[curIndex];
                        var nextIndex = void 0;
                        // find the next filled cell by walking clockwise starting from the previously visited cell.
                        var prevDir = (lastDirection + 5) % 8;
                        var newDir = prevDir;
                        var found = false;
                        for (; newDir < prevDir + 8; newDir++) {
                            if (rep !== newDir) {
                                nextIndex = curIndex + deltas[newDir];
                                if (cells[nextIndex] >= lim) {
                                    found = true;
                                    break;
                                }
                            }
                        }
                        if (!found) {
                            // this case also happens when the aura only covers a single cell.
                            if (curIndex !== startIndex) {
                                // this check for an erorr in the algorithm
                                Internal.Base.Helpers.error("Edge finder stuck");
                            }
                            break;
                        }
                        newDir = newDir % 8;
                        if (lastDirection !== newDir || (++skipping > 5)) {
                            if (directionChecker1 === 0) {
                                // the first direction 7 (up-left) means that this edge marks a hole (counter-clockwise), otherwise it is the outer edge (clockwise).
                                directionChecker1 = newDir === 7 ? 7 : 1;
                                directionChecker2 = newDir === 7 ? 6 : 2;
                            }
                            if (!smoothLines || (lastDirection !== (newDir + directionChecker1) % 8 && lastDirection !== (newDir + directionChecker2) % 8)) {
                                result.push(curIndex);
                            }
                            skipping = 0;
                        }
                        // only store the first direction outwards from the cell. the subsequent directions will be handled by the fact that they are taken clockwise from
                        // the previous cell.
                        if (rep === -1)
                            cellEdges[curIndex] = newDir;
                        lastDirection = newDir;
                        curIndex = nextIndex;
                        if (++iter > 10000) {
                            Internal.Base.Helpers.error("Edge finder run into a loop");
                            break;
                        }
                    } while (curIndex !== startIndex);
                    // this makes sure that the last entry is the same as the start. this can be necessary if the last entry was skipped due to smoothing.
                    if (result[result.length - 1] !== startIndex)
                        result.push(startIndex);
                    // isHole = directionChecker1 === 7
                    polygons.push(result);
                };
                /** Walks the grid and finds any edges. */
                NodesLayerAuras.prototype.stage3 = function () {
                    var clen = this._cellLength;
                    var w = this._widthCells * clen;
                    var cells = this._cells;
                    var cellEdges = this._cellEdges;
                    var config = this._settings;
                    var lim = config.drawLimit;
                    var lastCell = w - clen;
                    var polygons = this._polygons;
                    var iter = 0;
                    var ciMax = cells.length - clen;
                    for (var ci = 0; ci < ciMax; ci++) {
                        var c = cells[ci];
                        // ci%w - handles the first cell of a line.
                        // checks that the current cell is empty
                        if ((ci % w >= lastCell) || c < lim) {
                            var ni = ci + clen;
                            // and that the next one is not and also that the next one is not already a part of any edge.
                            if (cells[ni] >= lim && cellEdges[ni] < 0) {
                                this.stage3FindEdge(polygons[ni % clen], ni);
                                if (++iter > 10000) {
                                    Internal.Base.Helpers.error("Edge finder found too many polygons");
                                    break;
                                }
                            }
                        }
                    }
                };
                /*
                public paintGrid(context: CanvasRenderingContext2D, nr: number) {
                    // this method is useful for debugging the auras. It should not be included in the production build.
        
                    let clen = this._cellLength;
                    nr = Math.max(0, Math.min(nr, clen - 1));
                    let config = this._settings;
                    let cs = config.cellSize;
                    let marginCells = this._marginCells;
                    let margin = marginCells * cs;
                    let lim = config.drawLimit;
                    let w = this._widthCells * clen;
        
                    let aura = this._auras[nr];
        
                    context.save();
        
                    context.font = "8px Arial Narrow";
                    context.fillStyle = "rgba(0,0,0,0.4)";
                    context.textBaseline = "top";
                    for (let x = marginCells; x < this._widthCells - marginCells; x++) {
                        for (let y = marginCells; y < this._heightCells - marginCells; y++) {
                            let v = this._cells[nr + x * clen + w * y];
                            if (v === 0)
                                continue;
                            v = Math.floor(v * 10) / 10;
        
                            if (v >= lim) {
                                context.fillStyle = aura.fillColor;
                                context.fillRect(x * cs - margin, y * cs - margin, cs, cs);
                            }
        
                            //context.fillStyle = v < lim ? "rgba(0,0,0,0.3)" : "rgba(0,0,0,0.6)";
                            //context.fillText(v.toString(), x * cs - margin, y * cs - margin);
        
                            //context.fillStyle = "rgba(0,0,0,0.3)";
                            //context.fillText(x + "," + y, x * cs - margin, y * cs - margin);
        
                        }
                    }
        
                    // draw gridlines
        
                    //context.strokeStyle = "#ccc";
                    //context.lineWidth = 1;
                    //context.setLineDash([2, 2]);
                    //context.beginPath();
                    //
                    //for (let x = marginCells; x < this._widthCells - marginCells; x++) {
                    //    context.moveTo(x * cs - 0.5 - margin, 0);
                    //    context.lineTo(x * cs - 0.5 - margin, this._height);
                    //}
                    //for (let y = marginCells; y < this._heightCells - marginCells; y++) {
                    //    context.moveTo(0, y * cs - 0.5 - margin);
                    //    context.lineTo(this._width, y * cs - 0.5 - margin);
                    //}
                    //
                    //context.stroke();
        
        
                    context.restore();
                }
                */
                /** Draws the calculated polygons onto the context. */
                NodesLayerAuras.prototype.paintPolygons = function (event) {
                    if (!this._settings.enabled)
                        return;
                    var context = event.context;
                    context.save();
                    var config = this._settings;
                    var cs = config.cellSize;
                    var marginCells = this._marginCells;
                    var margin = marginCells * cs - cs / 2;
                    var clen = this._cellLength;
                    var w = this._widthCells;
                    var auras = this._auras;
                    var polygons = this._polygons;
                    var scene = this._scene;
                    // The same check as in stage1 - used to align the grid to the center of the scene, not the edge.
                    var deltaX = (-scene.centerX * scene.zoom) % cs;
                    var deltaY = (-scene.centerY * scene.zoom) % cs;
                    for (var a = 1; a < polygons.length; a++) {
                        var polArray = polygons[a];
                        var aura = auras[a];
                        var dashcontext = Internal.Base.Graphics.beginStrokeAndFill(context, aura);
                        // the data is already clockwise for outer edges and counter-clockwise for holes.
                        for (var i = 0; i < polArray.length; i++) {
                            var p = polArray[i];
                            var t0 = (p[0] / clen) | 0;
                            var x0 = (t0 % w) * cs - margin + deltaX;
                            var y0 = ((t0 / w) | 0) * cs - margin + deltaY;
                            var t = (p[1] / clen) | 0;
                            var prevX = (t % w) * cs - margin + deltaX;
                            var prevY = ((t / w) | 0) * cs - margin + deltaY;
                            dashcontext.moveTo((x0 + prevX) / 2, (prevY + y0) / 2);
                            for (var ci = 2; ci < p.length; ci++) {
                                t = (p[ci] / clen) | 0;
                                var x_1 = (t % w) * cs - margin + deltaX;
                                var y_1 = ((t / w) | 0) * cs - margin + deltaY;
                                dashcontext.quadraticCurveTo(prevX, prevY, (x_1 + prevX) / 2, (y_1 + prevY) / 2);
                                prevX = x_1;
                                prevY = y_1;
                            }
                            t = (p[1] / clen) | 0;
                            var x = (t % w) * cs - margin + deltaX;
                            var y = ((t / w) | 0) * cs - margin + deltaY;
                            dashcontext.quadraticCurveTo(prevX, prevY, (x + prevX) / 2, (y + prevY) / 2);
                            dashcontext.closePath();
                        }
                        Internal.Base.Graphics.endStrokeAndFill(context, dashcontext, aura);
                    }
                    Internal.Base.Graphics.restore(context);
                };
                return NodesLayerAuras;
            }());
            ItemsChart.NodesLayerAuras = NodesLayerAuras;
        })(ItemsChart = Internal.ItemsChart || (Internal.ItemsChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../base/Graphics.ts" />
/// <reference path="../Scene.ts" />
/// <reference path="ItemsLayer.ts" />
/// <reference path="NodesLayerAuras.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var ItemsChart;
        (function (ItemsChart) {
            var NodesLayer = (function (_super) {
                __extends(NodesLayer, _super);
                function NodesLayer(chart, layerSettings, useFadeout) {
                    _super.call(this, chart.scene, layerSettings);
                    this.chart = chart;
                    this.imageCache = {};
                    this.imageLoading = {};
                    this.multilinks = {};
                    this.useFadeout = useFadeout;
                    this.styleUpdater = this.createStyleUpdater(layerSettings.style);
                    this.events = chart.events;
                    this.layerSettings = layerSettings;
                    var style = layerSettings.style;
                    this.style = style;
                    this.scaleNodesWithZoom = style.scaleObjectsWithZoom;
                    this.scaleLinksWithZoom = style.scaleLinksWithZoom == null ? style.scaleObjectsWithZoom : style.scaleLinksWithZoom;
                    this._auras = new ItemsChart.NodesLayerAuras(chart.scene, chart.events, layerSettings.auras);
                }
                NodesLayer.prototype.createStyleUpdater = function (style) {
                    if (this.useFadeout == null)
                        return null;
                    return new ItemsChart.NodesStyle(style, this, this.useFadeout);
                };
                NodesLayer.prototype.updateStyle = function (event) {
                    var incremental = !event.changes.newGraph;
                    this.styleUpdater.updateLayer(event, incremental);
                };
                NodesLayer.prototype.postprocessStyle = function (event) {
                    _super.prototype.postprocessStyle.call(this, event);
                    this.animateSize(event);
                };
                NodesLayer.prototype.animateSize = function (event) {
                    var time = event.timeStamp;
                    var instant = event.changes.newGraph;
                    var dt = event.dtime;
                    var animating = false;
                    var invokeDynamicLayout = false;
                    var fadeTime = this.style.fadeTime;
                    instant = instant || (!(fadeTime > 0) || dt > fadeTime);
                    var nodesToRemove = [];
                    var linksToRemove = [];
                    if (instant) {
                        // fast route
                        for (var nodeIndex = 0, nodeSource = this.nodes(); nodeIndex < nodeSource.length; nodeIndex++) {
                            var node = nodeSource[nodeIndex];
                            if (node.removed) {
                                node.visibility = 0;
                                nodesToRemove.push(node);
                            }
                            else if (node.targetHWidth !== node.hWidth) {
                                node.added = false;
                                node.visibility = 1;
                                node.hHeight = node.targetHHeight;
                                node.hWidth = node.targetHWidth;
                            }
                        }
                        for (var linkIndex = 0, linkSource = this.links(); linkIndex < linkSource.length; linkIndex++) {
                            var link = linkSource[linkIndex];
                            if (link.removed) {
                                link.visibility = 0;
                                linksToRemove.push(link);
                            }
                            else if (link.targetRadius !== link.currentRadius) {
                                link.added = false;
                                link.visibility = 1;
                                link.currentRadius = link.targetRadius;
                            }
                        }
                    }
                    else {
                        // nice route
                        var fadeProp = (fadeTime > 0) ? (Math.max(0, Math.pow(0.2, dt / fadeTime))) : 0;
                        var finishProp = 0.01;
                        for (var nodeIndex = 0, nodeSource = this.nodes(); nodeIndex < nodeSource.length; nodeIndex++) {
                            var node = nodeSource[nodeIndex];
                            if (node.added === true) {
                                node.added = time;
                            }
                            if (node.added + fadeTime < time) {
                                node.added = false;
                            }
                            if (node.removed === true) {
                                node.removed = time;
                            }
                            if (node.removed) {
                                animating = true;
                                node.visibility = fadeProp;
                                node.hHeight = node.hHeight * fadeProp;
                                node.hWidth = node.hWidth * fadeProp;
                                if (time - node.removed < fadeTime) {
                                    node.visibility = 1 - (time - node.removed) / fadeTime;
                                }
                                else {
                                    nodesToRemove.push(node);
                                }
                            }
                            else {
                                if (time - node.added < fadeTime) {
                                    node.visibility = (time - node.added) / fadeTime;
                                    animating = true;
                                }
                                else {
                                    node.visibility = 1;
                                }
                                var thh = node.targetHHeight;
                                var hh = node.hHeight;
                                var thw = node.targetHWidth;
                                var hw = node.hWidth;
                                if (thh !== hh || thw !== hw) {
                                    if (!invokeDynamicLayout) {
                                        // only resume dynamic layout if the radius change is significant.
                                        // TODO: make the constant configurable. it was not done already because settings.layout is only
                                        // in NetChart while this code is within ItemsChart. It could be better if the sceneChanges would
                                        // only contain the maximum node radius change as a number and then the layout class would decide
                                        // what to do with it.
                                        if (Math.abs(thh - hh) / Math.max(thh, hh) >= 0.5 || Math.abs(thw - hw) / Math.max(thw, hw) >= 0.5)
                                            invokeDynamicLayout = true;
                                    }
                                    animating = true;
                                    node.hHeight = hh * fadeProp + thh * (1 - fadeProp);
                                    node.hWidth = hw * fadeProp + thw * (1 - fadeProp);
                                    if (Math.abs(node.hHeight - thh) < finishProp * thh) {
                                        node.hHeight = thh;
                                        node.hWidth = thw;
                                    }
                                }
                            }
                        }
                        for (var linkIndex = 0, linkSource = this.links(); linkIndex < linkSource.length; linkIndex++) {
                            var link = linkSource[linkIndex];
                            if (link.added === true) {
                                link.added = time;
                            }
                            if (link.added + fadeTime < time) {
                                link.added = false;
                            }
                            if (link.removed === true) {
                                link.removed = time;
                            }
                            if (link.removed) {
                                animating = true;
                                link.currentRadius = link.currentRadius * fadeProp;
                                if (time - link.removed < fadeTime) {
                                    link.visibility = 1 - (time - link.removed) / fadeTime;
                                }
                                else {
                                    linksToRemove.push(link);
                                }
                            }
                            else {
                                if (time - link.added < fadeTime && !link.invisible) {
                                    link.visibility = (time - link.added) / fadeTime;
                                    animating = true;
                                }
                                else {
                                    link.visibility = 1;
                                }
                                if (link.targetRadius !== link.currentRadius) {
                                    animating = true;
                                    link.currentRadius = link.currentRadius * fadeProp + link.targetRadius * (1 - fadeProp);
                                    if (Math.abs(link.currentRadius - link.targetRadius) < finishProp * link.targetRadius) {
                                        link.currentRadius = link.targetRadius;
                                    }
                                }
                            }
                        }
                    }
                    for (var lIndex = 0; lIndex < linksToRemove.length; lIndex++) {
                        var l = linksToRemove[lIndex];
                        this.deleteLink(l);
                    }
                    for (var nIndex = 0; nIndex < nodesToRemove.length; nIndex++) {
                        var n = nodesToRemove[nIndex];
                        this.deleteNode(n);
                    }
                    if (animating) {
                        var c = { position: true };
                        if (invokeDynamicLayout)
                            c.dynamicLayout = true;
                        this.events.notifySceneChanges(c);
                        event.animating = true;
                    }
                };
                NodesLayer.prototype.paintPrepare = function (event) {
                    this.computeNodeRenderRadii();
                    this.multilinks = this.updateMultilinks();
                    if (event.changes.position || this.hasTopologyChanges()) {
                        this.placePies();
                    }
                };
                NodesLayer.prototype.paintBackground = function (event) {
                    // doAnimations is called here instead of the animation phase because it needs the most current
                    // scene.centerX, scene.centerY values that can be set by AutoZoom. However AutoZoom.animationOrder
                    // is after the renderer and it wasn't that straight forward to change it when auras was initially
                    // created. If it could be fixed, you are welcome to do so. Just check that the auras do not show
                    // extra jumps with autozoom (dataBig.html test showed this nicely).
                    this._auras.doAnimations(this.nodes(), event);
                    this._auras.paintPolygons(event);
                };
                NodesLayer.prototype.paintSelection = function (event, selectedNodes, selectedLinks) {
                    var getGeometryResult = this.getGeometry();
                    var txm = getGeometryResult.txm;
                    var txa = getGeometryResult.txa;
                    var tym = getGeometryResult.tym;
                    var tya = getGeometryResult.tya;
                    var zoom = getGeometryResult.zoom;
                    var g = event.context;
                    var selStyle = this.style.selection;
                    var prop = selStyle.sizeProportional;
                    var cons = selStyle.sizeConstant;
                    g.beginPath();
                    // nodes
                    for (var objIndex = 0; objIndex < selectedNodes.length; objIndex++) {
                        var node = selectedNodes[objIndex];
                        if (node.invisible) {
                            continue;
                        }
                        node.shape.adaptToViewport(txm, txa, tym, tya, zoom);
                        node.shape.paintSelection(g, prop, cons);
                    }
                    // links
                    for (var objIndex = 0; objIndex < selectedLinks.length; objIndex++) {
                        var link = selectedLinks[objIndex];
                        if (link.invisible) {
                            continue;
                        }
                        var r = (link.currentRadius * (1 + prop) + cons) * zoom;
                        var n1 = link.from;
                        var n2 = link.to;
                        var x0 = n1.x * txm + txa;
                        var y0 = n1.y * tym + tya;
                        var x1 = n2.x * txm + txa;
                        var y1 = n2.y * tym + tya;
                        var dx = x0 - x1;
                        var dy = y0 - y1;
                        var invLen = 1 / Math.sqrt(dx * dx + dy * dy);
                        var ddx = dx * invLen;
                        var ddy = dy * invLen;
                        if (link.currentCenterOffset !== 0) {
                            var ofx = ddy * link.currentCenterOffset * zoom;
                            var ofy = -ddx * link.currentCenterOffset * zoom;
                            x0 += ofx;
                            y0 += ofy;
                            x1 += ofx;
                            y1 += ofy;
                        }
                        ddx *= r;
                        ddy *= r;
                        g.moveTo(x0 + ddy, y0 - ddx);
                        g.lineTo(x0 - ddy, y0 + ddx);
                        g.lineTo(x1 - ddy, y1 + ddx);
                        g.lineTo(x1 + ddy, y1 - ddx);
                        g.closePath();
                    }
                    return Internal.Base.Graphics.paint(g, selStyle);
                };
                NodesLayer.prototype.paintLinks = function (event, links) {
                    var geometry = this.getGeometry();
                    return this.paintLinksImpl(event, links, this.multilinks, {
                        geometry: geometry,
                        paintDetails: geometry.zoom > this.style.linkDetailMinZoom
                    });
                };
                NodesLayer.prototype.paintNodes = function (event, nodes) {
                    var geometry = this.getGeometry();
                    event.animating = this.paintNodesImpl(event, nodes, {
                        geometry: geometry,
                        paintDetails: geometry.zoom > this.style.nodeDetailMinZoom
                    }, event.timeStamp) || event.animating;
                };
                NodesLayer.prototype.updateMultilinks = function () {
                    if (!this.hasTopologyChanges()) {
                        return this.multilinks;
                    }
                    var links = this.links();
                    var multiLinks = {};
                    var arrays = [];
                    for (var linkIndex = 0; linkIndex < links.length; linkIndex++) {
                        var link = links[linkIndex];
                        var multiId = link.multiId;
                        if (!multiLinks.hasOwnProperty(multiId)) {
                            multiLinks[multiId] = link;
                        }
                        else {
                            var l = multiLinks[multiId];
                            if (l instanceof Array) {
                                l.push(link);
                            }
                            else {
                                var arr = [l, link];
                                arrays.push(arr);
                                multiLinks[multiId] = arr;
                            }
                        }
                    }
                    for (var i = 0; i < arrays.length; i++) {
                        arrays[i].sort(function (a, b) { return ("" + (a.id || "")).localeCompare("" + (b.id || "")); });
                    }
                    return multiLinks;
                };
                /** internal functions */
                NodesLayer.prototype.getNodeImage = function (node) {
                    var _this = this;
                    if (!node.image) {
                        return null;
                    }
                    var tint = node.tintImage && node.fillColor;
                    var crop = node.imageCropping;
                    var imageId = node.image;
                    var imageUrl = imageId;
                    if (tint) {
                        imageId += "##" + node.fillColor;
                    }
                    if (this.imageCache.hasOwnProperty(imageId)) {
                        return this.imageCache[imageId];
                    }
                    else if (this.imageLoading[imageId]) {
                        return null;
                    }
                    else {
                        // build new image
                        var doRounding = function (image) {
                            if (crop) {
                                image = Internal.Base.Graphics.cropImageToCircle(image, crop);
                            }
                            if (tint) {
                                image = Internal.Base.Graphics.applyColorToImage(image, node.fillColor, false);
                            }
                            _this.imageCache[imageId] = image;
                            delete _this.imageLoading[imageId];
                            _this.events.notifySceneChanges({ layout: true });
                            return image;
                        };
                        var image = this.scene.assetsLoader.getAssetImage(imageUrl);
                        if (image) {
                            return doRounding(image);
                        }
                        else {
                            return null;
                        }
                    }
                };
                NodesLayer.prototype.computeNodeRenderRadii = function () {
                    var z0 = this.getGeometry().zoom;
                    for (var nodeIndex = 0, nodeSource = this.nodes(); nodeIndex < nodeSource.length; nodeIndex++) {
                        var node = nodeSource[nodeIndex];
                        var r = node.hHeight * z0;
                        var w = node.hWidth * z0;
                        if (node.lineWidth) {
                            r += node.lineWidth / 2;
                            w += node.lineWidth / 2;
                        }
                        node.renderHheight = r;
                        node.renderHwidth = w;
                    }
                };
                NodesLayer.prototype.paintLinksImpl = function (event, links, multiLinks, setup) {
                    var g = event.context;
                    var txm = setup.geometry.txm;
                    var txa = setup.geometry.txa;
                    var tym = setup.geometry.tym;
                    var tya = setup.geometry.tya;
                    var zoom = setup.geometry.linkZoom;
                    var x0w = setup.geometry.x0w;
                    var y0w = setup.geometry.y0w;
                    var x1w = setup.geometry.x1w;
                    var y1w = setup.geometry.y1w;
                    var invzoom = 1 / zoom;
                    var nodeSceneZoom = this.scaleNodesWithZoom ? 1 : 1 / this.scene.zoom;
                    g.textAlign = "center";
                    g.textBaseline = "middle";
                    var styleSettings = this.style;
                    var linkDetailMinSizeSq = styleSettings.linkDetailMinSize * styleSettings.linkDetailMinSize;
                    var paintLinkDetails = setup.paintDetails && this.chart.assetsLoaded;
                    var linkSpacing = styleSettings.multilinkSpacing * zoom;
                    var decorationScale = styleSettings.linkDecorationScale;
                    var decorationMinSize = styleSettings.linkDecorationMinSize;
                    var linkLabelScaleBase = styleSettings.linkLabelScaleBase;
                    var pieSpacing = 2;
                    var pieSizeConst = 5;
                    var pieSizeProp = 0.1;
                    for (var linkIndex = 0; linkIndex < links.length; linkIndex++) {
                        var link = links[linkIndex];
                        if (link.invisible)
                            continue;
                        var x0 = link.from.x;
                        var y0 = link.from.y;
                        var x1 = link.to.x;
                        var y1 = link.to.y;
                        var linkCurrentItems = link.currentItems;
                        var applyRotation = linkCurrentItems && linkCurrentItems.length && linkCurrentItems[0].style.rotateWithLink;
                        var angle = void 0;
                        var r0 = link.from.renderHheight;
                        var r1 = link.to.renderHheight;
                        var w0 = link.from.renderHwidth;
                        var w1 = link.to.renderHwidth;
                        // bounds check and shorten long offscreen links
                        var coords = Internal.Base.Geometry.clipSegmentToBounds(x0, y0, x1, y1, (r0 + w0) * nodeSceneZoom, (r1 + w1) * nodeSceneZoom, x0w, y0w, x1w, y1w);
                        if (!coords) {
                            continue;
                        }
                        x0 = coords[0];
                        y0 = coords[1];
                        x1 = coords[2];
                        y1 = coords[3];
                        x0 = x0 * txm + txa;
                        y0 = y0 * tym + tya;
                        x1 = x1 * txm + txa;
                        y1 = y1 * tym + tya;
                        var dx = x1 - x0;
                        var dy = y1 - y0;
                        var lenSq = dx * dx + dy * dy;
                        var r = Math.max(0.25, link.currentRadius * zoom * 0.5);
                        var active = link.hovered || link.from.hovered || link.to.hovered;
                        var paintItems = active || (paintLinkDetails && lenSq > linkDetailMinSizeSq);
                        if (lenSq > 25) {
                            // detailed view with pies, decorations
                            var len = Math.sqrt(lenSq);
                            if (applyRotation) {
                                angle = Math.atan2(dy, dx) * (180 / Math.PI);
                                if (x0 >= x1) {
                                    angle -= 180;
                                }
                                link.currentItems[0].style.angle = angle;
                            }
                            // add pies
                            if (link.toPieValue > 0) {
                                var pieInner = r1 + pieSpacing;
                                var pieOuter = pieInner + pieSizeConst + pieSizeProp * r1;
                                this.paintLinkPie(g, x1, y1, pieInner, pieOuter, link.toPie0, link.toPie1, link.toPieColor);
                                r1 = pieOuter;
                            }
                            if (len < r0 + r1) {
                                continue;
                            }
                            // clip to node
                            var invlen = 1 / len;
                            var ddx = dx * invlen;
                            var ddy = dy * invlen;
                            var t0 = void 0;
                            var t1 = void 0;
                            t0 = link.from.shape.distanceToEdge(r0, w0, ddx, ddy); // ddx and ddy is a direction vector pointing from the center of the "from" shape
                            t1 = link.to.shape.distanceToEdge(r1, w1, -ddx, -ddy); // -ddx and -ddy is a direction vector pointing from the center of the "to" shape
                            if (len <= t0 + t1) {
                                continue;
                            }
                            // add space for decorations
                            var decorationSize = Math.min((len - t0 - t1) / 4, Math.max(decorationMinSize, r * decorationScale));
                            if (link.fromDecoration) {
                                t0 += decorationSize;
                            }
                            if (link.toDecoration) {
                                t1 += decorationSize;
                            }
                            x0 += ddx * t0;
                            y0 += ddy * t0;
                            x1 -= ddx * t1;
                            y1 -= ddy * t1;
                            dx = x1 - x0;
                            dy = y1 - y0;
                            len = len - t0 - t1;
                            invlen = 1 / len;
                            /* handle multilinks
                            TODO: this might be slow */
                            var multiId = link.multiId;
                            var ml = multiLinks[multiId];
                            if (ml instanceof Array) {
                                var count = ml.length;
                                var width = Math.min(linkSpacing * (count - 1), r0 * 1.5, r1 * 1.5);
                                var offset = width * (ml.indexOf(link) - (count - 1) / 2) / (count - 1);
                                if (link.from.id > link.to.id) {
                                    offset = -offset;
                                }
                                link.currentCenterOffset = offset * invzoom;
                                x0 -= ddy * offset;
                                x1 -= ddy * offset;
                                y0 += ddx * offset;
                                y1 += ddx * offset;
                            }
                            else {
                                link.currentCenterOffset = 0;
                            }
                            g.beginPath();
                            if (link.fromDecoration) {
                                this.paintLinkDecoration(g, x0, y0, ddx, ddy, decorationSize, link.fromDecoration, link.fillColor);
                            }
                            if (link.toDecoration) {
                                this.paintLinkDecoration(g, x1, y1, -ddx, -ddy, decorationSize, link.toDecoration, link.fillColor);
                            }
                            // paint the link
                            // TODO: common dashed line renderer should be used instead.
                            if (link.lineDash) {
                                var x0a = x0 + ddy * r;
                                var y0a = y0 - ddx * r;
                                var x0b = x0 - ddy * r;
                                var y0b = y0 + ddx * r;
                                if (link.lineDash.length > 0) {
                                    var dA = link.lineDash;
                                    var dsLen = dA.length;
                                    var dsLenpx = dA.reduce(function (a, b) { return a + b; }) * zoom;
                                    var np = 0;
                                    for (var i = 0; i <= len / dsLenpx; i++) {
                                        for (var j = 0; j <= dsLen - 1; j += 2) {
                                            var l0 = (i * dsLenpx) + np;
                                            if (l0 > len - r) {
                                                break;
                                            }
                                            var tc = l0 + dA[j] * zoom;
                                            var l1 = (tc >= len - r) ? (len - r) : tc;
                                            g.moveTo(x0a + l0 * ddx, y0a + l0 * ddy);
                                            g.lineTo(x0b + l0 * ddx, y0b + l0 * ddy);
                                            g.lineTo(x0b + l1 * ddx, y0b + l1 * ddy);
                                            g.lineTo(x0a + l1 * ddx, y0a + l1 * ddy);
                                            g.closePath();
                                            np += zoom * (dA[j] + dA[j + 1]);
                                        }
                                        np = 0;
                                    }
                                }
                                else {
                                    var dashLen = Math.max(5, 3 * r);
                                    for (var i = 0; i <= len / dashLen; i += 2) {
                                        var l0 = i * dashLen;
                                        var l1 = Math.min((i + 1) * dashLen, len);
                                        g.moveTo(x0a + l0 * ddx, y0a + l0 * ddy);
                                        g.lineTo(x0b + l0 * ddx, y0b + l0 * ddy);
                                        g.lineTo(x0b + l1 * ddx, y0b + l1 * ddy);
                                        g.lineTo(x0a + l1 * ddx, y0a + l1 * ddy);
                                        g.closePath();
                                    }
                                }
                            }
                            else {
                                g.moveTo(x0 + ddy * r, y0 - ddx * r);
                                g.lineTo(x0 - ddy * r, y0 + ddx * r);
                                g.lineTo(x1 - ddy * r, y1 + ddx * r);
                                g.lineTo(x1 + ddy * r, y1 - ddx * r);
                                g.closePath();
                            }
                            link.renderPoints = { x0: x0, y0: y0, x1: x1, y1: y1 }; // not using Base.Rect because it reorders X0/X1 by min/max
                            link.renderBounds = new Internal.Base.Rect(x0, y0, x1, y1);
                            Internal.Base.Graphics.fill(g, link);
                            if (paintItems && link.currentItems && !link.removed) {
                                var zz = void 0;
                                var zs = void 0;
                                if (active) {
                                    zz = Internal.Base.Helpers.toleranceMax(zoom, 1, 0.9);
                                    zs = Internal.Base.Helpers.toleranceMax(r / linkLabelScaleBase, 1, 0.9);
                                }
                                else {
                                    zz = zoom;
                                    zs = r / linkLabelScaleBase;
                                }
                                this.paintLinkItems(g, event.labelRenderer, zz, zs, x0, y0, ddx, ddy, len, r, link.currentItems, link.renderBounds);
                            }
                        }
                        else if (link.fillColor) {
                            // simplified render
                            g.beginPath();
                            g.lineWidth = Math.max(0.1, r * 2);
                            g.strokeStyle = link.fillColor;
                            if (link.dashed) {
                                var len = Math.sqrt(lenSq);
                                var invlen = 1 / len;
                                var ddx = dx * invlen;
                                var ddy = dy * invlen;
                                var dashLen = Math.max(5, r * 3);
                                for (var i = 0; i <= len / dashLen; i += 2) {
                                    var l0 = i * dashLen;
                                    var l1 = Math.min((i + 1) * dashLen, len);
                                    g.moveTo(x0 + l0 * ddx, y0 + l0 * ddy);
                                    g.lineTo(x0 + l1 * ddx, y0 + l1 * ddy);
                                }
                            }
                            else {
                                g.moveTo(x0, y0);
                                g.lineTo(x1, y1);
                            }
                            g.stroke();
                            link.renderPoints = { x0: x0, y0: y0, x1: x1, y1: y1 }; // not using Base.Rect because it reorders X0/X1 by min/max
                            link.renderBounds = new Internal.Base.Rect(x0, y0, x1, y1);
                        }
                    }
                    return false;
                };
                NodesLayer.prototype.paintNodesImpl = function (event, nodes, setup, time) {
                    var animating = false;
                    var g = event.context;
                    var txm = setup.geometry.txm;
                    var txa = setup.geometry.txa;
                    var tym = setup.geometry.tym;
                    var tya = setup.geometry.tya;
                    var zoom = setup.geometry.zoom;
                    var x0s = setup.geometry.x0s;
                    var x1s = setup.geometry.x1s;
                    var y0s = setup.geometry.y0s;
                    var y1s = setup.geometry.y1s;
                    var invzoom = 1 / txm;
                    var paintNodeDetails = setup.paintDetails;
                    var nodeDetailMinSizeSq = this.style.nodeDetailMinSize * this.style.nodeDetailMinSize * invzoom * invzoom;
                    var hiddenLinksStyle = this.style.hiddenLinks;
                    var nodeLabelScaleBase = this.style.nodeLabelScaleBase;
                    g.textAlign = "center";
                    g.textBaseline = "middle";
                    var removedColor = this.style.removedColor;
                    // paint node anchors
                    for (var nodeIndex = 0; nodeIndex < nodes.length; nodeIndex++) {
                        var node = nodes[nodeIndex];
                        if (!node.data || node.invisible) {
                            continue;
                        }
                        var s = node.shape;
                        s.adaptToViewport(txm, txa, tym, tya, zoom);
                        // link to anchor position
                        if (node.anchorX != null && node.anchorY != null && node.anchorMode === ItemsChart.NodeAnchorMode.Floating) {
                            var ax = node.anchorX * txm + txa;
                            var ay = node.anchorY * tym + tya;
                            var sa = s.getAnchor();
                            var sx = s.x + sa.x;
                            var sy = s.y + sa.y;
                            var dx = sx - ax;
                            var dy = sy - ay;
                            var my = sy;
                            if (dy < 0) {
                                my = Math.max(my, ay - dy * Math.min(0.3, Math.abs(dx) / dy));
                            }
                            g.beginPath();
                            g.moveTo(sx, sy);
                            g.lineTo(sx, my);
                            g.lineTo(ax, ay);
                            Internal.Base.Graphics.stroke(g, node.anchorStyle);
                        }
                    }
                    // paint node base
                    for (var nodeIndex = 0; nodeIndex < nodes.length; nodeIndex++) {
                        var node = nodes[nodeIndex];
                        var s = node.shape;
                        if (!node.data || node.invisible) {
                            continue;
                        }
                        // Don't render the shape, if it's not in the viewport
                        if (!s.isInViewport(x0s, x1s, y0s, y1s, zoom)) {
                            continue;
                        }
                        var opacity = node.opacity;
                        var bw = node.outerBounds.w();
                        var bh = node.outerBounds.h();
                        var paintDetails = paintNodeDetails && bw * bh > nodeDetailMinSizeSq || node.hovered;
                        if (opacity < 1) {
                            g.globalAlpha = opacity;
                        }
                        // Hidden links
                        if (paintDetails && !node.removed) {
                            var hlinks = node.dataLinks.length - node.links.length;
                            if (hlinks > 0) {
                                if (this.useFadeout && node.relevance < 1) {
                                    // TODO: test performance
                                    var oldLine = hiddenLinksStyle.lineColor;
                                    hiddenLinksStyle.lineColor = Internal.Base.Colors.blend(removedColor, oldLine, node.relevance);
                                    this.paintHiddenLinks(g, node, s.x, s.y, s.hWidth, s.hHeight, hlinks, hiddenLinksStyle, hiddenLinksStyle.size * zoom);
                                    hiddenLinksStyle.lineColor = oldLine;
                                }
                                else {
                                    this.paintHiddenLinks(g, node, s.x, s.y, s.hWidth, s.hHeight, hlinks, hiddenLinksStyle, hiddenLinksStyle.size * zoom);
                                }
                            }
                        }
                        s.paint(g, event.labelRenderer, paintDetails);
                        // Paint node items (label, items)
                        if (paintDetails && !node.removed) {
                            var zz = void 0;
                            var zs = void 0;
                            if (node.hovered) {
                                zz = Internal.Base.Helpers.toleranceMax(zoom, 1, 0.9);
                                zs = Internal.Base.Helpers.toleranceMin(nodeLabelScaleBase, s.hWidth, 0.9);
                            }
                            else {
                                zz = zoom;
                                zs = nodeLabelScaleBase;
                            }
                            this.paintNodeDetails(node, s.x, s.y, s.hHeight, s.hWidth, zz, zs, event);
                        }
                        if (opacity < 1) {
                            g.globalAlpha = 1;
                        }
                    }
                    // loading symbols on nodes
                    if (this.scene.settings.advanced.perNodeLoadingIndicator) {
                        var style = this.scene.settings.advanced.style.loadingArcStyle;
                        g.save();
                        g.lineCap = "round";
                        g.lineWidth = style.lineWidth;
                        g.strokeStyle = style.lineColor;
                        var a = time / 1400;
                        a = (a - Math.floor(a)) * (Math.PI * 2);
                        var a1 = a + Math.PI / 2;
                        for (var nodeIndex = 0; nodeIndex < nodes.length; nodeIndex++) {
                            var node = nodes[nodeIndex];
                            if (node.invisible) {
                                continue;
                            }
                            var s = node.shape;
                            if (node.loading || (node.image && this.getNodeImage(node) === null)) {
                                // bounds check
                                if (!s.isInViewport(x0s, x1s, y0s, y1s, zoom)) {
                                    continue;
                                }
                                animating = true;
                                g.beginPath();
                                g.arc(s.x, s.y, s.hWidth, a, a1);
                                g.stroke();
                            }
                        }
                        Internal.Base.Graphics.restore(g);
                    }
                    return animating;
                };
                NodesLayer.prototype.paintLinkDecoration = function (g, x, y, dx, dy, size, decoration, color) {
                    g.fillStyle = color;
                    if (decoration === "circle") {
                        g.moveTo(x + size, y);
                        g.arc(x, y, size, 0, Math.PI * 2, true);
                    }
                    else if (decoration === "arrow") {
                        g.moveTo(x - dx * size, y - dy * size);
                        g.lineTo(x + dx * size - dy * size, y + dy * size + dx * size);
                        g.lineTo(x + dx * size + dy * size, y + dy * size - dx * size);
                    }
                    else {
                        Internal.Base.Helpers.error("Unrecognized link decoration value. Valid values are 'circle' and 'arrow'.");
                    }
                };
                NodesLayer.prototype.paintLinkPie = function (g, x, y, innerRadius, outerRadius, a0, a1, color) {
                    var r = (innerRadius + outerRadius) / 2;
                    var w = outerRadius - innerRadius;
                    g.beginPath();
                    g.arc(x, y, r, a0, a1);
                    Internal.Base.Graphics.paint(g, {
                        lineColor: color,
                        lineWidth: w
                    });
                };
                NodesLayer.prototype.paintLinkItems = function (g, labelRenderer, zoom, size, x, y, dx, dy, linkLength, linkRadius, items, renderBounds) {
                    for (var itemIndex = 0; itemIndex < items.length; itemIndex++) {
                        var item = items[itemIndex];
                        // absolute coords
                        var fx = item.x || 0;
                        // absolute coords
                        var fy = item.y || 0;
                        // along link axis, fraction of length
                        var ix = item.style.px || 0;
                        // to the side of link axis, pixels
                        var iy = item.style.py || 0;
                        // along link axis, fraction of length
                        var lx = item.style.lx || 0;
                        // to the side of link axis, pixels
                        var ly = item.style.ly || 0;
                        // ix range is [-1..1]
                        ix = linkLength * (ix + 1) * 0.5 + lx;
                        iy = iy * linkRadius + ly;
                        var xx = x + dx * ix - dy * iy + fx;
                        var yy = y + dy * ix + dx * iy + fy;
                        var scale = 0;
                        if (item.style.scaleWithSize) {
                            scale = size;
                        }
                        else if (item.style.scaleWithZoom) {
                            scale = zoom;
                        }
                        else {
                            scale = 1;
                        }
                        labelRenderer.paint(g, xx, yy, scale, item);
                        renderBounds.addRect(item.currentBounds);
                    }
                };
                NodesLayer.prototype.paintHiddenLinks = function (g, node, x, y, r, w, count, style, size) {
                    var PI2 = Math.PI * 2;
                    // let sidePr = size * 0.73 / r;
                    // let sinkPr = (r - size * 0.1) / r;
                    // figure out outwards direction
                    var ddx;
                    var ddy;
                    if (node.links.length > 0) {
                        var xx = 0;
                        var yy = 0;
                        for (var linkIndex = 0; linkIndex < node.links.length; linkIndex++) {
                            var link = node.links[linkIndex];
                            xx += link.otherEnd(node).x;
                            yy += link.otherEnd(node).y;
                        }
                        xx = node.x - xx / node.links.length;
                        yy = node.y - yy / node.links.length;
                        var invlen = 1 / Math.sqrt(xx * xx + yy * yy);
                        ddx = xx * invlen;
                        ddy = yy * invlen;
                    }
                    else {
                        ddx = 1;
                        ddy = 0;
                    }
                    var da = PI2 / count / 3;
                    // compute start angle
                    var xt = Math.cos(-da * (count - 1) / 2);
                    var yt = Math.sin(-da * (count - 1) / 2);
                    var ddx1 = ddx * xt - ddy * yt;
                    var yc = ddx * yt + ddy * xt;
                    var xc = ddx1;
                    // increment
                    xt = Math.cos(da);
                    yt = Math.sin(da);
                    // paint gradient lines
                    g.beginPath();
                    for (var i = 1; i <= count; i++) {
                        // figure out distance from center
                        var t0 = node.shape.distanceToEdge(r, w, xc, yc);
                        g.moveTo(x + xc * t0, y + yc * t0);
                        g.lineTo(x + xc * (t0 + size), y + yc * (t0 + size));
                        ddx1 = xc * xt - yc * yt;
                        yc = xc * yt + yc * xt;
                        xc = ddx1;
                    }
                    /* radial gradient is super slow in FF, disable it for now.
                    grad = g.createRadialGradient(x,y, Math.max(0,r-size), x,y,r*tipPr);
                    grad.addColorStop(0, style.lineColor)
                    grad.addColorStop(1, "transparent") */
                    g.strokeStyle = style.lineColor;
                    g.lineWidth = style.lineWidth;
                    g.stroke();
                };
                /** hitLink = (l, ) */
                NodesLayer.prototype.findObjectAt = function (displayX, displayY, tolerance) {
                    var scene = this.scene;
                    var fromDisplayResult = scene.fromDisplay(displayX, displayY);
                    var x = fromDisplayResult.x;
                    var y = fromDisplayResult.y;
                    var invzoom = 1 / scene.zoom;
                    var linkZoom = this.scaleLinksWithZoom ? invzoom : 1;
                    var best = null;
                    var itemsToCheck = [];
                    var bestDetails = null;
                    /** the distance for the current best item. In canvas pixels. */
                    var min = tolerance;
                    var hoverNode = scene.hoverNode;
                    if (hoverNode && hoverNode.layer === this && !hoverNode.invisible) {
                        var newDist = hoverNode.shape.hitTest(x, y, invzoom, min * invzoom);
                        if (newDist / invzoom < min) {
                            min = newDist / invzoom;
                            best = hoverNode;
                            var bestItem = this.findItem(displayX, displayY, best, tolerance);
                            if (bestItem) {
                                bestDetails = bestItem.item;
                                min = Math.min(min, bestItem.distance);
                            }
                            if (min <= 0) {
                                return { object: best, details: bestDetails };
                            }
                        }
                    }
                    var nodes = this.nodes();
                    for (var i = nodes.length - 1; i >= 0; i--) {
                        var n = nodes[i];
                        if (!n.removed && !n.invisible && Internal.Base.Geometry.distanceToRect(x - n.x, y - n.y, n.outerBounds) < min * invzoom) {
                            var newDist = n.shape.hitTest(x, y, invzoom, min * invzoom);
                            if (newDist <= 0) {
                                min = 0;
                                best = n;
                                break;
                            }
                            else if (newDist / invzoom < min) {
                                min = newDist / invzoom;
                                best = n;
                            }
                            itemsToCheck.push(n);
                        }
                    }
                    if (min > 0) {
                        // the currently hovered link is tested after the nodes because the link ends are considered under the end nodes
                        var hoverLink = scene.hoverLink;
                        if (hoverLink && hoverLink.layer === this && !hoverLink.invisible) {
                            var r = hoverLink.targetRadius / 2 * linkZoom;
                            var coords = hoverLink.renderPoints;
                            var distanceSq = Internal.Base.Geometry.distanceToSegmentSq(coords.x0, coords.y0, coords.x1, coords.y1, displayX, displayY);
                            if (distanceSq <= (min + r) * (min + r)) {
                                min = 0;
                                best = hoverLink;
                                var bestItem = this.findItem(displayX, displayY, best, tolerance);
                                if (bestItem) {
                                    bestDetails = bestItem.item;
                                    min = Math.min(min, bestItem.distance);
                                }
                                if (min <= 0) {
                                    return { object: best, details: bestDetails };
                                }
                            }
                        }
                    }
                    if (min > 0) {
                        for (var lIndex = 0, lSource = this.links(); lIndex < lSource.length; lIndex++) {
                            var l = lSource[lIndex];
                            var coords = l.renderPoints;
                            if (!l.removed && !l.invisible && coords && Internal.Base.Geometry.distanceToRect(displayX, displayY, l.renderBounds) < min) {
                                var r = l.targetRadius / linkZoom * 2;
                                var distanceSq = Internal.Base.Geometry.distanceToSegmentSq(coords.x0, coords.y0, coords.x1, coords.y1, displayX, displayY);
                                var toleranceSq = Math.min(min * min, r * r);
                                if (distanceSq < toleranceSq) {
                                    min = Math.sqrt(distanceSq);
                                    best = l;
                                }
                                itemsToCheck.push(l);
                            }
                        }
                    }
                    if (min === 0) {
                        // for an exact match, find the label item
                        var bestItem = this.findItem(displayX, displayY, best, tolerance);
                        return { object: best, details: bestItem ? bestItem.item : null };
                    }
                    // now verify if an item has been hovered (the preference is to highlight a node that is directly hovered)
                    // with the exception of when the item of the currently hovered link/node is kept hovered.
                    for (var i = 0; i < itemsToCheck.length; i++) {
                        var o = itemsToCheck[i];
                        var bestItem = this.findItem(displayX, displayY, o, tolerance);
                        if (bestItem && bestItem.distance < min) {
                            min = bestItem.distance;
                            best = o;
                            bestDetails = bestItem.item;
                        }
                    }
                    if (min > tolerance) {
                        best = null;
                        bestDetails = null;
                    }
                    return { object: best, details: bestDetails };
                };
                /** Finds the item of the given object that is closest to the given coordinates. */
                NodesLayer.prototype.findItem = function (displayX, displayY, obj, tolerance) {
                    if (!obj) {
                        return null;
                    }
                    var tolerSq = tolerance * tolerance;
                    // first check hover item
                    var hi = this.scene.hoverItem;
                    if (hi && hi.hwidth && obj.currentItems.indexOf(hi) > -1) {
                        var distSq = Internal.Base.Geometry.distanceToRect(displayX, displayY, hi.currentBounds, true);
                        if (distSq <= tolerSq)
                            return { item: hi, distance: Math.sqrt(distSq) };
                    }
                    var closest = null;
                    var closestDistanceSq = tolerance * tolerance;
                    if (obj instanceof ItemsChart.Node) {
                        // check the default label
                        var currentLabel = obj.shape.currentLabel;
                        if (currentLabel && currentLabel.currentBounds) {
                            var distSq = Internal.Base.Geometry.distanceToRect(displayX, displayY, currentLabel.currentBounds, true);
                            if (distSq < closestDistanceSq) {
                                closest = currentLabel;
                                closestDistanceSq = distSq;
                            }
                        }
                    }
                    for (var iIndex = 0; iIndex < obj.currentItems.length; iIndex++) {
                        var i = obj.currentItems[iIndex];
                        if (!i.hwidth) {
                            continue;
                        }
                        var distSq = Internal.Base.Geometry.distanceToRect(displayX, displayY, i.currentBounds, true);
                        if (distSq <= closestDistanceSq) {
                            closest = i;
                            closestDistanceSq = distSq;
                        }
                    }
                    if (closestDistanceSq > tolerSq || !closest)
                        return null;
                    return { item: closest, distance: Math.sqrt(closestDistanceSq) };
                };
                /**
                 * Returns the bounds of the added nodes in scene coordinate system
                 * @param {Node[]} [nodes=this.nodes()] - The nodes that should be included in the bounds.
                 *  If this argument is not passed, all visible nodes are included
                 * @returns {ZoomCharts.Internal.Base.Rect}
                 */
                NodesLayer.prototype.getGraphBounds = function (nodes) {
                    if (nodes === void 0) { nodes = this.nodes(); }
                    if (nodes.length === 0) {
                        return new Internal.Base.Rect(0, 0, 0, 0);
                    }
                    var bounds = Internal.Base.Rect.createEmpty();
                    for (var nodeIndex = 0; nodeIndex < nodes.length; nodeIndex++) {
                        var node = nodes[nodeIndex];
                        if (node.removed) {
                            continue;
                        }
                        var x = node.x;
                        var y = node.y;
                        var ob = node.outerBounds;
                        bounds.addBounds(ob.x0 + x, ob.y0 + y, ob.x1 + x, ob.y1 + y);
                    }
                    return bounds;
                };
                NodesLayer.prototype.getNodeNeighborsBounds = function (cnode) {
                    if (!cnode || this.nodes().length === 0) {
                        return new Internal.Base.Rect(0, 0, 0, 0);
                    }
                    var bounds = cnode.outerBounds.clone().moveBy(cnode.x, cnode.y);
                    // base node
                    var node = cnode;
                    // linked nodes
                    for (var linkIndex = 0; linkIndex < cnode.links.length; linkIndex++) {
                        var link = cnode.links[linkIndex];
                        node = link.otherEnd(cnode);
                        if (node.removed) {
                            continue;
                        }
                        var ob = node.outerBounds;
                        var x = node.x;
                        var y = node.y;
                        bounds.addBounds(ob.x0 + x, ob.y0 + y, ob.x1 + x, ob.y1 + y);
                    }
                    return bounds;
                };
                NodesLayer.prototype.placePies = function () {
                    var PI2 = Math.PI * 2;
                    var pieLinks = [];
                    for (var nodeIndex = 0, nodeSource = this.nodes(); nodeIndex < nodeSource.length; nodeIndex++) {
                        var node = nodeSource[nodeIndex];
                        var sum = 0;
                        for (var linkIndex = 0; linkIndex < node.links.length; linkIndex++) {
                            var link = node.links[linkIndex];
                            if (link.to === node && link.toPieValue > 0) {
                                sum += link.toPieValue;
                                pieLinks.push(link);
                                link._angle = Math.atan2(link.to.y - link.from.y, link.to.x - link.from.x);
                            }
                        }
                        if (sum > 0) {
                            pieLinks.sort(function (a, b) { return a._angle - b._angle; });
                            var mul = PI2 / sum;
                            var angle = 0;
                            var offset = 0;
                            for (var link1_index = 0; link1_index < pieLinks.length; link1_index++) {
                                var link1 = pieLinks[link1_index];
                                link1.toPie0 = angle;
                                angle += link1.toPieValue * mul;
                                link1.toPie1 = angle;
                                var offCenter = link1._angle - (link1.toPie0 + link1.toPie1) / 2;
                                if (offCenter < 0) {
                                    offCenter += Math.PI * 2;
                                }
                                offset += offCenter;
                            }
                            offset /= pieLinks.length;
                            offset -= Math.PI;
                            for (var link2_index = 0; link2_index < pieLinks.length; link2_index++) {
                                var link2 = pieLinks[link2_index];
                                link2.toPie0 += offset;
                                link2.toPie1 += offset;
                            }
                            pieLinks = [];
                        }
                    }
                };
                return NodesLayer;
            }(ItemsChart.ItemsLayer));
            ItemsChart.NodesLayer = NodesLayer;
        })(ItemsChart = Internal.ItemsChart || (Internal.ItemsChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Impl.ts" />
/// <reference path="Menu.ts" />
/// <reference path="InfoPopup.ts" />
/// <reference path="layers/NodesLayer.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var ItemsChart;
        (function (ItemsChart) {
            var Impl = (function (_super) {
                __extends(Impl, _super);
                function Impl(settings, scene, api) {
                    _super.call(this, settings, scene, api);
                }
                Impl.prototype.getNode = function (id) {
                    throw new Error("Method not implemented in derived class");
                };
                Impl.prototype.expandNode = function (id) {
                    throw new Error("Method not implemented in derived class");
                };
                Impl.prototype.collapseNode = function (id) {
                    throw new Error("Method not implemented in derived class");
                };
                Impl.prototype.removeFocusNode = function (id) {
                    throw new Error("Method not implemented in derived class");
                };
                Impl.prototype.addFocusNode = function (id, levels) {
                    throw new Error("Method not implemented in derived class");
                };
                Impl.prototype.lockNode = function (id) {
                    throw new Error("Method not implemented in derived class");
                };
                Impl.prototype.unlockNode = function (id) {
                    throw new Error("Method not implemented in derived class");
                };
                Impl.prototype.hideNode = function (id) {
                    throw new Error("Method not implemented in derived class");
                };
                Impl.prototype.zoomOut = function () {
                    throw new Error("Not implemented");
                };
                Impl.prototype.zoomOutPossible = function () {
                    return false;
                };
                Impl.prototype.setSelection = function (selection) {
                    var realSelection = [];
                    var foundNode;
                    for (var nIndex = 0; nIndex < selection.length; nIndex++) {
                        var n = selection[nIndex];
                        if (n instanceof ItemsChart.Node || n instanceof ItemsChart.Link) {
                            realSelection.push(n);
                        }
                        else if (foundNode = this.getNode(n)) {
                            // try to find a node with this ID
                            realSelection.push(foundNode);
                        }
                        else {
                            this.error("SetSelection: Non chart object in selection: " + n);
                        }
                    }
                    if (this.scene.setSelection(realSelection)) {
                        this.events.notifySceneChanges({ selection: true });
                        this.notifySelectionChanged(this.createEventArguments(null, "api"));
                    }
                };
                Impl.prototype.scrollIntoView = function (nodeIds) {
                    throw new Error("Method not implemented in the derived class");
                };
                Impl.prototype.createEventArguments = function (event, origin) {
                    var cx = null;
                    var cy = null;
                    if (event && (event.x || event.y)) {
                        var fromDisplayResult = this.scene.fromDisplay(event.x, event.y);
                        cx = fromDisplayResult.x;
                        cy = fromDisplayResult.y;
                    }
                    return {
                        chart: this.api,
                        origin: origin,
                        chartX: cx,
                        chartY: cy,
                        hoverLink: this.scene.hoverLink,
                        hoverNode: this.scene.hoverNode,
                        hoverItem: this.scene.hoverItem,
                        selection: this.scene.selection.slice()
                    };
                };
                return Impl;
            }(Internal.Base.Impl));
            ItemsChart.Impl = Impl;
        })(ItemsChart = Internal.ItemsChart || (Internal.ItemsChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/core/ChartEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var GeoChart;
        (function (GeoChart) {
            var Selection = (function (_super) {
                __extends(Selection, _super);
                function Selection(chart) {
                    _super.call(this);
                    this.animationOrder = 2000;
                    this.updateOrder = 1100;
                    this.scene = null;
                    this.events = null;
                    this.currentObject = null;
                    this.chart = chart;
                    this.scene = chart.scene;
                    this.events = chart.events;
                    this.dragPointers = {};
                }
                Selection.prototype.onPointerMove = function (event) {
                    this.updateCurrentObject(event);
                    if (this.currentObject) {
                        this.updateCursor(event);
                        event.hovered = true;
                    }
                };
                Selection.prototype.onPointerOut = function (event) {
                    this.switchCurrentObject(null, null, event);
                };
                Selection.prototype.onPointerDown = function (event) {
                    this.updateCurrentObject(event);
                    var cro = this.currentObject;
                    if (cro instanceof Internal.ItemsChart.Node) {
                        // select nodes before starting drag
                        this.updateSelection(event, cro, true);
                        this.updateCursor(event);
                        // node dragging
                        if (this.scene.settings.interaction.nodesMovable) {
                            this.setPointerNode(event, cro);
                            event.consumed = true;
                        }
                    }
                };
                Selection.prototype.onPointerUp = function (event) {
                    if (this.dragPointers[event.identifier]) {
                        if (this.dragPointers[event.identifier].dragging) {
                            event.consumed = true;
                            this.updateLastNode(event, this.dragPointers[event.identifier].node);
                        }
                        this.updateCursor(event);
                        this.setPointerNode(event, null);
                    }
                };
                Selection.prototype.onPointerCancel = function (event) {
                    this.onPointerUp(event);
                };
                Selection.prototype.onPointerDrag = function (event) {
                    var p = this.dragPointers[event.identifier];
                    if (!p) {
                        return;
                    }
                    var fromDisplayResult = this.scene.fromDisplay(event.x, event.y);
                    var newX = fromDisplayResult.x;
                    var newY = fromDisplayResult.y;
                    p.mouseX = event.x;
                    p.mouseY = event.y;
                    p.dragging = true;
                    this.dragNodes(p, newX, newY, this.scene.settings.interaction.selection.lockNodesOnMove);
                    this.updateCursor(event);
                    event.consumed = true;
                };
                Selection.prototype.onClick = function (event) {
                    if (!this.scene.xyInChart(event.x, event.y)) {
                        return;
                    }
                    if (!this.currentObject
                        || (!this.scene.settings.interaction.selection.nodesSelectable && this.currentObject.isNode)
                        || (!this.scene.settings.interaction.selection.linksSelectable && this.currentObject.isLink)) {
                        // deselect if clicked on blank space
                        this.updateSelection(event, null, false);
                    }
                    this.chart.notifyClick(event, this.buildEventArgs(event));
                    if (event.defaultPrevented) {
                        event.consumed = true;
                    }
                };
                Selection.prototype.onRightClick = function (event) {
                    if (!this.scene.xyInChart(event.x, event.y)) {
                        return;
                    }
                    var args = this.buildEventArgs(event);
                    this.updateSelection(event, this.currentObject, false);
                    this.chart.notifyRightClick(event, args);
                    if (event.defaultPrevented) {
                        event.consumed = true;
                    }
                };
                Selection.prototype.onDoubleClick = function (event) {
                    if (!this.scene.xyInChart(event.x, event.y)) {
                        return;
                    }
                    this.chart.notifyDoubleClick(event, this.buildEventArgs(event));
                    if (event.defaultPrevented) {
                        event.consumed = true;
                    }
                };
                Selection.prototype.onTripleClick = function (event) {
                    if (!this.scene.xyInChart(event.x, event.y)) {
                        return;
                    }
                    this.chart.notifyTripleClick(event, this.buildEventArgs(event));
                    if (event.defaultPrevented) {
                        event.consumed = true;
                    }
                };
                Selection.prototype.doAnimations = function (event) {
                    // keep dragged nodes pinned to pointer positions
                    for (var id in this.dragPointers) {
                        var p = this.dragPointers[id];
                        var fromDisplayResult = this.scene.fromDisplay(p.mouseX, p.mouseY);
                        var newX = fromDisplayResult.x;
                        var newY = fromDisplayResult.y;
                        this.dragNodes(p, newX, newY, false);
                        event.changes.coordinates = true;
                    }
                };
                Selection.prototype.updateSelection = function (event, target, softDeselect) {
                    if (!this.scene.settings.interaction.selection.enabled) {
                        return;
                    }
                    if (!event.shiftKey
                        && !event.ctrlKey
                        && (!target
                            || (!this.scene.settings.interaction.selection.nodesSelectable && target.isNode)
                            || (!this.scene.settings.interaction.selection.linksSelectable && target.isLink))) {
                        this.setSelection([], "user");
                    }
                    else if (target && event.ctrlKey) {
                        if (target.selected) {
                            this.scene.removeFromSelection(target);
                        }
                        else {
                            this.scene.addToSelection(target);
                        }
                        this.notifySelectionChanged("user");
                    }
                    else if (target && event.shiftKey || (softDeselect && target.selected)) {
                        if (this.scene.addToSelection(target)) {
                            this.notifySelectionChanged("user");
                        }
                    }
                    else if (target) {
                        this.setSelection([target], "user");
                    }
                };
                Selection.prototype.dragNodes = function (p, newX, newY, lock) {
                    var dx = newX + p.x - p.node.x;
                    var dy = newY + p.y - p.node.y;
                    if (!(dx !== 0 || dy !== 0)) {
                        return;
                    }
                    this.moveNode(p.node, dx, dy, lock);
                    if (p.extraNodes && p.extraNodes.length > 0) {
                        for (var nIndex = 0; nIndex < p.extraNodes.length; nIndex++)
                            this.moveNode(p.extraNodes[nIndex], dx, dy, lock);
                    }
                    this.events.notifySceneChanges({ coordinates: true });
                };
                Selection.prototype.moveNode = function (node, dx, dy, lock) {
                    node.x += dx;
                    node.y += dy;
                    if (lock) {
                        node.userLock = true;
                    }
                    if (!this.scene.settings.interaction.selection.allowMoveNodesOffscreen) {
                        var bounds = this.scene.getVisibleBounds();
                        var sizeX = node.renderHwidth * 1.2 / this.scene.zoom;
                        var sizeY = node.renderHheight * 1.2 / this.scene.zoom;
                        node.x = Math.min(Math.max(node.x, bounds.x0 + sizeX), bounds.x1 - sizeX);
                        node.y = Math.min(Math.max(node.y, bounds.y0 + sizeY), bounds.y1 - sizeY);
                    }
                };
                Selection.prototype.setPointerNode = function (event, node) {
                    var id = event.identifier;
                    var oldP = this.dragPointers[id];
                    if (oldP) {
                        oldP.node.locks--;
                        if (oldP.extraNodes && oldP.extraNodes.length > 0)
                            for (var i = 0; i < oldP.extraNodes.length; i++)
                                oldP.extraNodes[i].locks--;
                        delete this.dragPointers[id];
                    }
                    if (node) {
                        var fromDisplayResult = this.scene.fromDisplay(event.x, event.y);
                        var x = fromDisplayResult.x;
                        var y = fromDisplayResult.y;
                        var extraNodes = null;
                        if (!Internal.Base.Helpers.hasProperties(this.dragPointers) && this.scene.selection.length > 0) {
                            extraNodes = [];
                            for (var i = 0; i < this.scene.selection.length; i++) {
                                var obj = this.scene.selection[i];
                                if (obj !== node && obj instanceof Internal.ItemsChart.Node) {
                                    obj.locks++;
                                    extraNodes.push(obj);
                                }
                            }
                        }
                        this.dragPointers[event.identifier] = {
                            x: node.x - x,
                            y: node.y - y,
                            node: node,
                            extraNodes: extraNodes,
                            mouseX: event.x,
                            mouseY: event.y,
                            dragging: false
                        };
                        node.locks++;
                    }
                };
                Selection.prototype.updateCurrentObject = function (event) {
                    if (!this.chart.renderer || !this.scene.xyInChart(event.x, event.y)) {
                        return;
                    }
                    var n = this.chart.renderer.findObjectAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
                    this.switchCurrentObject(n ? n.object : null, n ? n.details : null, event);
                };
                Selection.prototype.updateCursor = function (event) {
                    if (this.currentObject && this.currentObject.cursor) {
                        event.cursor = this.currentObject.cursor;
                    }
                    else {
                        event.cursor = "default";
                    }
                };
                Selection.prototype.switchCurrentObject = function (obj, item, event) {
                    if (obj === this.currentObject && item === this.currentItem) {
                        return;
                    }
                    event.changes.current = true;
                    this.scene.setActiveObject(obj, item);
                    this.currentObject = obj;
                    this.currentItem = item;
                    this.chart.notifyHoverChanged(event, this.chart.createEventArguments(null, "api"));
                };
                Selection.prototype.buildEventArgs = function (event) {
                    var args = this.chart.createEventArguments(event, "user");
                    args.clickItem = this.currentItem;
                    var cro = this.currentObject;
                    if (cro instanceof Internal.ItemsChart.Node) {
                        args.clickNode = cro;
                        this.updateLastNode(event, cro);
                    }
                    else {
                        args.clickLink = cro;
                    }
                    return args;
                };
                Selection.prototype.updateLastNode = function (event, node) {
                    this.scene.lastClickedNode = node;
                    if (this.scene.settings.interaction.zooming.autoZoomAfterClick) {
                        this.scene.autoZoomMode = true;
                        event.changes.zoom = true;
                    }
                };
                Selection.prototype.setSelection = function (selection, origin) {
                    var hasChanges = this.scene.setSelection(selection);
                    if (hasChanges) {
                        this.notifySelectionChanged(origin);
                    }
                };
                Selection.prototype.notifySelectionChanged = function (origin) {
                    this.events.notifySceneChanges({ selection: true });
                    this.chart.notifySelectionChanged(this.chart.createEventArguments(null, origin));
                };
                return Selection;
            }(Internal.Base.ChartElement));
            GeoChart.Selection = Selection;
        })(GeoChart = Internal.GeoChart || (Internal.GeoChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../base/Random.ts" />
/// <reference path="../cp.d.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var GeoChart;
        (function (GeoChart) {
            var SettingsNodesLayout = (function () {
                function SettingsNodesLayout() {
                    /** Layout mode.
                     @type enum
                     @value dynamic - incrementally update whole network when user moves nodes
                     @value static - other nodes stay fixed while user moves nodes. */
                    this.mode = "static";
                    /** Desired distance between nodes.
                     @type integer
                     @units pixels */
                    this.nodeSpacing = 3;
                    /**
                     * Anchor strength, relative to link strength.
                     */
                    this.anchorStrength = 1;
                }
                return SettingsNodesLayout;
            }());
            GeoChart.SettingsNodesLayout = SettingsNodesLayout;
            var NodeState = (function () {
                function NodeState() {
                }
                return NodeState;
            }());
            var NodesLayout = (function () {
                function NodesLayout(scene, layer, settings) {
                    this.initialLoad = true;
                    this.scene = scene;
                    this.settings = settings;
                    this.layer = layer;
                    this.random = new Internal.Base.Random(1);
                }
                NodesLayout.isNodeLocked = function (node) {
                    return node.userLock || node.locks > 0 || (node.anchorMode === Internal.ItemsChart.NodeAnchorMode.Fixed);
                };
                NodesLayout.prototype.doAnimations = function (event, hasChanges) {
                    var _this = this;
                    var newPos = false;
                    var topologyChanges = this.layer.hasTopologyChanges();
                    var dynamic = this.settings.mode === "dynamic";
                    if (dynamic && typeof Internal.Chipmunk === "undefined") {
                        // dynamically include cp.js when needed
                        if (NodesLayout.cpRequestInitiated)
                            return;
                        if (this.scene.assetsLoader.loadAssetsList([{ url: "assets://cp.js", required: function () { return typeof Internal.Chipmunk === "undefined"; } }], function () { _this.layer.events.notifySceneChanges({ requestPaint: true }); })) {
                            // download of cp.js has been started asynchronously
                            // the callback will initiate a repaint once the library has been loaded
                            NodesLayout.cpRequestInitiated = true;
                            return;
                        }
                    }
                    // TODO: fix this later. Calling adaptToViewport to make getAnchor work
                    var layerNodes = this.layer.nodes();
                    var geometry = this.layer.getGeometry();
                    for (var i = 0; i < layerNodes.length; i += 1) {
                        var node = layerNodes[i];
                        node.shape.adaptToViewport(geometry.txm, geometry.txa, geometry.tym, geometry.tya, geometry.zoom);
                    }
                    if (this.initialLoad) {
                        topologyChanges = true;
                        hasChanges = true;
                    }
                    if (topologyChanges) {
                        this.random = new Internal.Base.Random(1);
                        this.placeNewNodes(dynamic);
                        newPos = true;
                    }
                    if (dynamic) {
                        this.placeModifiedNodes();
                        var isAlive = this.updateLayout(event.dtime, topologyChanges, hasChanges, event.changes.zoom);
                        if (isAlive) {
                            event.animating = true;
                            newPos = true;
                        }
                    }
                    else {
                        this.placeModifiedNodes();
                        this.computeNodeAnchorCoordinates();
                    }
                    if (newPos) {
                        event.changes.position = true;
                    }
                    this.initialLoad = false;
                };
                NodesLayout.prototype.computeNodeAnchorCoordinates = function () {
                    var zoom = this.layer.getNodesSceneZoom();
                    for (var nIndex = 0, nSource = this.layer.nodes(); nIndex < nSource.length; nIndex++) {
                        var n = nSource[nIndex];
                        var shapeAnchor = n.shape.getAnchor();
                        n.x = n.anchorX - shapeAnchor.x * zoom;
                        n.y = n.anchorY - shapeAnchor.y * zoom;
                    }
                };
                NodesLayout.prototype.placeNewNodes = function (randomize) {
                    var zoom = this.layer.getNodesSceneZoom();
                    // means there are new nodes not directly connected to existing nodes
                    for (var nIndex = 0, nSource = this.layer.nodes(); nIndex < nSource.length; nIndex++) {
                        var n = nSource[nIndex];
                        var shapeAnchor = n.shape.getAnchor();
                        n.anchorX = n.data._x;
                        n.anchorY = n.data._y;
                        if (n.x === null || n.y === null) {
                            n.x = n.anchorX - shapeAnchor.x * zoom;
                            n.y = n.anchorY - shapeAnchor.y * zoom;
                            if (randomize) {
                                n.x += this.random.get() * zoom;
                            }
                        }
                    }
                };
                NodesLayout.prototype.placeModifiedNodes = function () {
                    for (var id in this.layer.modifiedNodes) {
                        var n = this.layer.modifiedNodes[id];
                        n.anchorX = n.data._x;
                        n.anchorY = n.data._y;
                    }
                };
                NodesLayout.prototype.removeNode = function (node) {
                    var state = this.idToState[node.id];
                    var space = this.cpSpace;
                    space.removeShape(state.shape);
                    if (!state.locked) {
                        space.removeBody(state.body);
                        space.removeShape(state.anchorShape);
                    }
                    delete this.idToState[node.id];
                };
                NodesLayout.prototype.addNode = function (node, locked) {
                    var state = new NodeState();
                    var space = this.cpSpace;
                    var zoom = this.layer.getNodesSceneZoom();
                    var shapeAnchor = node.shape.getAnchor();
                    state.locked = locked;
                    this.idToState[node.id] = state;
                    if (!locked) {
                        var body = space.addBody(new Internal.Chipmunk.Body(1, Infinity));
                        state.body = body;
                        body.setPos(Internal.Chipmunk.v(node.x + shapeAnchor.x * zoom, node.y + shapeAnchor.y * zoom));
                    }
                    return state;
                };
                NodesLayout.prototype.updateLayout = function (dt, topologyChanges, styleChanges, zoomChanges) {
                    if (!this.cpSpace) {
                        this.cpSpace = new Internal.Chipmunk.Space();
                        this.cpSpace.sleepTimeThreshold = 1;
                        this.cpSpace.damping = 0.2;
                        this.idToState = {};
                        topologyChanges = true;
                    }
                    var space = this.cpSpace;
                    var idToState = this.idToState;
                    var nodeSpacing = this.settings.nodeSpacing;
                    var anchorStrength = this.settings.anchorStrength;
                    var zoom = this.layer.getNodesSceneZoom();
                    this.zoom = zoom;
                    this.cpSpace.collisionSlop = 2 * zoom;
                    this.cpSpace.idleSpeedThreshold = 5 * zoom;
                    var layerNodes = this.layer.nodes();
                    if (topologyChanges) {
                        // add new nodes, remove missing nodes
                        for (var id in this.layer.deletedNodes) {
                            this.removeNode(this.layer.deletedNodes[id]);
                        }
                        for (var id in this.layer.newNodes) {
                            var node = this.layer.newNodes[id];
                            this.addNode(node, NodesLayout.isNodeLocked(node));
                        }
                    }
                    if (styleChanges || topologyChanges) {
                        // update node sizes and link strengths
                        for (var i = 0; i < layerNodes.length; i += 1) {
                            var node = layerNodes[i];
                            var state = idToState[node.id];
                            var locked = NodesLayout.isNodeLocked(node);
                            var prevPosition = null;
                            if (!state || locked !== state.locked) {
                                if (state) {
                                    if (state.body)
                                        prevPosition = state.body.p;
                                    this.removeNode(node);
                                }
                                state = this.addNode(node, locked);
                            }
                            var radius = (Math.max(node.bounds.w(), node.bounds.h()) + nodeSpacing) / 2 * zoom;
                            var shapeAnchor = node.shape.getAnchor();
                            var x = node.anchorX;
                            var y = node.anchorY;
                            if (!zoomChanges && state.prevAX === x && state.prevAY === y && state.prevR === radius)
                                continue;
                            if (state.locked) {
                                // TODO: maybe can update without add/remove
                                var shape = state.shape;
                                if (shape) {
                                    space.removeShape(shape);
                                }
                                if (!prevPosition) {
                                    prevPosition = Internal.Chipmunk.v(x - shapeAnchor.x * zoom, y - shapeAnchor.y * zoom);
                                }
                                prevPosition.x -= shapeAnchor.x * zoom;
                                prevPosition.y -= shapeAnchor.y * zoom;
                                shape = space.addShape(new Internal.Chipmunk.CircleShape(space.staticBody, radius, prevPosition));
                                state.p = prevPosition;
                                shape.setElasticity(0);
                                shape.setFriction(0);
                                state.shape = shape;
                            }
                            else {
                                if (state.prevR !== radius) {
                                    var shape = state.shape;
                                    if (shape) {
                                        space.removeShape(shape);
                                    }
                                    shape = space.addShape(new Internal.Chipmunk.CircleShape(state.body, radius, Internal.Chipmunk.v(-shapeAnchor.x * zoom, -shapeAnchor.y * zoom)));
                                    shape.setElasticity(0);
                                    shape.setFriction(0);
                                    state.shape = shape;
                                }
                                // TODO: maybe can update without add/remove
                                if (zoomChanges || state.prevAX !== x || state.prevAY !== y) {
                                    var anchorShape = state.anchorShape;
                                    if (anchorShape) {
                                        space.removeShape(anchorShape);
                                    }
                                    anchorShape = space.addShape(new Internal.Chipmunk.CircleShape(space.staticBody, 2 * zoom, Internal.Chipmunk.v(x, y)));
                                    anchorShape.setElasticity(0);
                                    anchorShape.setFriction(0);
                                    state.anchorShape = anchorShape;
                                }
                            }
                            state.prevAX = x;
                            state.prevAY = y;
                            state.prevR = radius;
                        }
                    }
                    // apply forces
                    for (var i = 0; i < layerNodes.length; i += 1) {
                        var node = layerNodes[i];
                        var state = idToState[node.id];
                        if (state.locked)
                            continue;
                        var ax = node.anchorX;
                        var ay = node.anchorY;
                        var nx = state.body.p.x;
                        var ny = state.body.p.y;
                        var body = state.body;
                        var dx = nx - ax;
                        var dy = ny - ay;
                        // Basic PID tuning - compensate for velocity
                        var vx = body.vx;
                        var vy = body.vy;
                        dx += vx * 0.5;
                        dy += vy * 0.5;
                        var fx = -Math.abs(dx * 3) * Internal.Base.Helpers.sign(dx);
                        var fy = 0;
                        if (dy < 0) {
                            fy = -2 * dy;
                        }
                        else {
                            fy = -5 * dy;
                        }
                        // body.resetForces();
                        // body.applyForce(cp.v(fx * anchorStrength, fy * anchorStrength), body.p);
                        // ResetForces prevents sleeping, useing direct force application here.
                        body.f = Internal.Chipmunk.v(fx * anchorStrength, fy * anchorStrength);
                    }
                    space.step(1 / 60);
                    var sleeping = true;
                    for (var i = 0; i < layerNodes.length; i += 1) {
                        var node = layerNodes[i];
                        var state = idToState[node.id];
                        var shapeAnchor = node.shape.getAnchor();
                        if (!state.locked) {
                            node.x = state.body.p.x - shapeAnchor.x * zoom;
                            node.y = state.body.p.y - shapeAnchor.y * zoom;
                            sleeping = sleeping && state.body.isSleeping();
                        }
                        else {
                            if (state.p) {
                                node.x = state.p.x;
                                node.y = state.p.y;
                            }
                            else {
                                node.x = node.data._x - shapeAnchor.x * zoom;
                                node.y = node.data._y - shapeAnchor.y * zoom;
                            }
                        }
                    }
                    return !sleeping;
                };
                NodesLayout.cpRequestInitiated = false;
                return NodesLayout;
            }());
            GeoChart.NodesLayout = NodesLayout;
        })(GeoChart = Internal.GeoChart || (Internal.GeoChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../itemschart/layers/NodesLayer.ts" />
/// <reference path="../../itemschart/layers/NodesStyle.ts" />
/// <reference path="NodesLayerLayout.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var GeoChart;
        (function (GeoChart) {
            var NodesLayer = (function (_super) {
                __extends(NodesLayer, _super);
                function NodesLayer(chart, layerSettings, useFadeout) {
                    _super.call(this, chart, layerSettings, useFadeout);
                    this.layout = null;
                    this.hoveredNode = null;
                    this.layout = new GeoChart.NodesLayout(chart.scene, this, layerSettings.layout);
                }
                NodesLayer.prototype.postprocessStyle = function (event) {
                    _super.prototype.postprocessStyle.call(this, event);
                    var changes = event.changes.zoom || this.hasStyleChanges();
                    this.layout.doAnimations(event, changes);
                };
                /** Paints the additional shape specified on the currently hovered node. */
                NodesLayer.prototype.paintHoverShape = function (context) {
                    var style = this.style.aggregatedShape;
                    switch (style.mode) {
                        case 0 /* disabled */:
                            break;
                        default:
                        case 1 /* hovered */:
                            if (this.hoveredNode === null || !this.hoveredNode.hovered || this.hoveredNode.removed) {
                                var nodes_2 = this.modifiedNodes;
                                this.hoveredNode = null;
                                for (var id in nodes_2) {
                                    if (nodes_2[id].hovered) {
                                        this.hoveredNode = nodes_2[id];
                                        break;
                                    }
                                }
                            }
                            if (this.hoveredNode)
                                this.paintConvex(this.hoveredNode, context, style);
                            break;
                        case 2 /* always */:
                            var nodes = this.nodes();
                            for (var i = 0; i < nodes.length; i++) {
                                var n = nodes[i];
                                if (!n.removed)
                                    this.paintConvex(n, context, style);
                            }
                            break;
                        case 3 /* selected */:
                            var selNodes = this.nodes();
                            for (var i = 0; i < selNodes.length; i++) {
                                var n = selNodes[i];
                                if (!n.removed && n.selected)
                                    this.paintConvex(n, context, style);
                            }
                            break;
                    }
                };
                NodesLayer.prototype.paintConvex = function (node, context, style) {
                    var nodeData = node.data;
                    var convexShape = nodeData.convexShape;
                    if (!convexShape || convexShape.length < 2)
                        return;
                    // draw convex shape
                    var geometry = this.getGeometry();
                    var bounds = {};
                    var g = Internal.Base.Graphics.beginStrokeAndFill(context, style);
                    bounds[convexShape[0].id] = 1;
                    g.moveTo(convexShape[0]._x * geometry.txm + geometry.txa, convexShape[0]._y * geometry.tym + geometry.tya);
                    for (var i = 1; i < convexShape.length; i++) {
                        bounds[convexShape[i].id] = 1;
                        g.lineTo(convexShape[i]._x * geometry.txm + geometry.txa, convexShape[i]._y * geometry.tym + geometry.tya);
                    }
                    g.closePath();
                    Internal.Base.Graphics.endStrokeAndFill(context, g, style);
                    // draw aggregated nodes except bounds
                    for (var i = 0; i < nodeData.aggregatedNodes.length; i++) {
                        var agn = nodeData.aggregatedNodes[i];
                        if (!bounds[agn.id]) {
                            g = Internal.Base.Graphics.beginStroke(context, style);
                            g.arc(agn._x * geometry.txm + geometry.txa, agn._y * geometry.tym + geometry.tya, 1, 0, 2 * Math.PI, false);
                            Internal.Base.Graphics.endStroke(context, g, style);
                        }
                    }
                };
                NodesLayer.prototype.paint = function (event) {
                    this.paintHoverShape(event.context);
                    _super.prototype.paint.call(this, event);
                };
                return NodesLayer;
            }(Internal.ItemsChart.NodesLayer));
            GeoChart.NodesLayer = NodesLayer;
        })(GeoChart = Internal.GeoChart || (Internal.GeoChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../itemschart/Scene.ts" />
/// <reference path="Data.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var GeoChart;
        (function (GeoChart) {
            var Scene = (function (_super) {
                __extends(Scene, _super);
                function Scene() {
                    _super.call(this);
                    // array of ids
                    this.stack = [];
                    this.zoomLevel = 0;
                    // project function (x, y) -> lon, lat
                    this.project = null;
                    // unproject function (lon, lat) -> x, y
                    this.unproject = null;
                }
                Scene.prototype.push = function (node) {
                    return this.stack.push(node);
                };
                Scene.prototype.peek = function () {
                    if (this.stack.length === 0) {
                        return null;
                    }
                    return this.stack[this.stack.length - 1];
                };
                Scene.prototype.pop = function () {
                    if (this.stack.length === 0) {
                        return null;
                    }
                    return this.stack.pop();
                };
                Scene.prototype.getVisibleBoundsLatLon = function () {
                    var fromDisplayResult = this.fromDisplay(this.x0, this.y0);
                    var x0 = fromDisplayResult.x;
                    var y0 = fromDisplayResult.y;
                    fromDisplayResult = this.fromDisplay(this.x0 + this.width, this.y0 + this.height);
                    var x1 = fromDisplayResult.x;
                    var y1 = fromDisplayResult.y;
                    return this.unprojectRect(new Internal.Base.Rect(x0, y0, x1, y1));
                };
                Scene.prototype.unprojectRect = function (rect) {
                    var p0 = this.unproject(rect.x0, rect.y0);
                    var p1 = this.unproject(rect.x1, rect.y1);
                    return new Internal.Base.Rect(Math.min(p0.lng, p1.lng), Math.min(p0.lat, p1.lat), Math.max(p0.lng, p1.lng), Math.max(p0.lat, p1.lat));
                };
                return Scene;
            }(Internal.ItemsChart.Scene));
            GeoChart.Scene = Scene;
        })(GeoChart = Internal.GeoChart || (Internal.GeoChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../itemschart/layers/ItemsStyle.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var GeoChart;
        (function (GeoChart) {
            var SettingsShapesLayerStyle = (function (_super) {
                __extends(SettingsShapesLayerStyle, _super);
                function SettingsShapesLayerStyle() {
                    _super.apply(this, arguments);
                    /**
                     * Controls shape simplification to improve rendering performance.
                     * Distance in pixels between points to simplify.
                     * Use 0 to disable simplification.
                     * @type float
                     */
                    this.shapeSimplificationPrecision = 1.5;
                    /** Default node style. */
                    this.node = {
                        fillColor: "#c7dae0",
                        lineColor: null,
                        lineWidth: null,
                        radius: 30,
                        shadowColor: null,
                        lineDash: null,
                        expandable: false
                    };
                }
                return SettingsShapesLayerStyle;
            }(GeoChart.SettingsNodesLayerStyle));
            GeoChart.SettingsShapesLayerStyle = SettingsShapesLayerStyle;
            var ShapesStyle = (function (_super) {
                __extends(ShapesStyle, _super);
                function ShapesStyle(styleSettings, layer) {
                    _super.call(this, styleSettings, layer);
                }
                ShapesStyle.prototype.postprocessNode = function (node) {
                    node.currentItems = [];
                    if (node.label) {
                    }
                    this.postprocessItems(node);
                };
                ShapesStyle.prototype.postprocessLink = function (link) {
                    // build currentItems
                    var items = [];
                    if (link.label) {
                        var i = new Internal.Base.Label(link.labelStyle);
                        i.text = link.label.toString();
                        i.style.px = 0;
                        i.style.py = 0;
                        items.push(i);
                    }
                    link.currentItems = items;
                    this.postprocessItems(link);
                };
                return ShapesStyle;
            }(Internal.ItemsChart.ItemsStyle));
            GeoChart.ShapesStyle = ShapesStyle;
        })(GeoChart = Internal.GeoChart || (Internal.GeoChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../base/Graphics.ts" />
/// <reference path="../Scene.ts" />
/// <reference path="../../itemschart/layers/ItemsLayer.ts" />
/// <reference path="../../itemschart/layers/ItemsStyle.ts" />
/// <reference path="ShapesStyle.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var GeoChart;
        (function (GeoChart) {
            var ShapesLayer = (function (_super) {
                __extends(ShapesLayer, _super);
                function ShapesLayer(scene, layerSettings) {
                    _super.call(this, scene, layerSettings);
                    this.style = layerSettings.style;
                }
                ShapesLayer.prototype.createStyleUpdater = function (style) {
                    return new GeoChart.ShapesStyle(style, this);
                };
                ShapesLayer.prototype.paintSelection = function (event, selectedNodes, selectedLinks) {
                    var getGeometryResult = this.getGeometry();
                    var txm = getGeometryResult.txm;
                    var txa = getGeometryResult.txa;
                    var tym = getGeometryResult.tym;
                    var tya = getGeometryResult.tya;
                    var invzoom = 1 / txm;
                    var g = event.context;
                    var selStyle = this.style.selection;
                    g.beginPath();
                    for (var nodeIndex = 0; nodeIndex < selectedNodes.length; nodeIndex++) {
                        var node = selectedNodes[nodeIndex];
                        for (var lineIndex = 0, lineSource = this.getNodeCoords(node, invzoom); lineIndex < lineSource.length; lineIndex++) {
                            var line = lineSource[lineIndex];
                            var lx = line[0] * txm + txa;
                            var ly = line[1] * tym + tya;
                            g.moveTo(lx, ly);
                            for (var i = 2; i <= line.length - 2; i += 2) {
                                g.lineTo(line[i] * txm + txa, line[i + 1] * tym + tya);
                            }
                            g.closePath();
                        }
                    }
                    g.fillStyle = selStyle.fillColor;
                    g.strokeStyle = selStyle.fillColor;
                    g.lineWidth = selStyle.sizeConstant * 2;
                    g.fill();
                    g.stroke();
                };
                ShapesLayer.prototype.paintLinks = function (event, links) {
                    // not supported by ShapesLayer
                };
                ShapesLayer.prototype.paintNodes = function (event, nodes) {
                    var g = event.context;
                    var getGeometryResult = this.getGeometry();
                    var txm = getGeometryResult.txm;
                    var txa = getGeometryResult.txa;
                    var tym = getGeometryResult.tym;
                    var tya = getGeometryResult.tya;
                    var zoom = getGeometryResult.zoom;
                    var x0w = getGeometryResult.x0w;
                    var y0w = getGeometryResult.y0w;
                    var x1w = getGeometryResult.x1w;
                    var y1w = getGeometryResult.y1w;
                    var invzoom = 1 / txm;
                    var paintNodeDetails = zoom > this.style.nodeDetailMinZoom;
                    var nodeDetailMinSizeSq = this.style.nodeDetailMinSize * this.style.nodeDetailMinSize * invzoom * invzoom;
                    var nodeLabelScaleBase = this.style.nodeLabelScaleBase;
                    // TODO: removed color...
                    // let removedColor = this.style.removedColor;
                    // paint node base
                    for (var nodeIndex = 0; nodeIndex < nodes.length; nodeIndex++) {
                        var node = nodes[nodeIndex];
                        if (node.removed) {
                            this.deleteNode(node);
                            continue;
                        }
                        if (!node.data)
                            continue;
                        var bounds = node.bounds;
                        // bounds check
                        if (bounds.x1 < x0w || bounds.x0 > x1w || bounds.y1 < y0w || bounds.y0 > y1w) {
                            continue;
                        }
                        var opacity = node.opacity;
                        var paintDetails = paintNodeDetails && bounds.area() > nodeDetailMinSizeSq || node.hovered;
                        if (opacity < 1) {
                            g.globalAlpha = opacity;
                        }
                        // Basic shape
                        // Color check
                        if (node.fillColor || node.lineColor) {
                            var strokeContext = Internal.Base.Graphics.beginStrokeAndFill(g, node);
                            for (var lineIndex = 0, lineSource = this.getNodeCoords(node, invzoom); lineIndex < lineSource.length; lineIndex++) {
                                var line = lineSource[lineIndex];
                                var lx = line[0] * txm + txa;
                                var ly = line[1] * tym + tya;
                                strokeContext.moveTo(lx, ly);
                                for (var i = 2; i <= line.length - 2; i += 2) {
                                    strokeContext.lineTo(line[i] * txm + txa, line[i + 1] * tym + tya);
                                }
                                strokeContext.closePath();
                            }
                            // } else if (display === "line") {
                            //    for (lineIndex = 0, lineSource = this.getNodeCoords(node, invzoom); lineIndex < lineSource.length; lineIndex++) {
                            //        line = lineSource[lineIndex];
                            //        lx = line[0] * txm + txa;
                            //        ly = line[1] * tym + tya;
                            //        strokeContext.moveTo(lx, ly);
                            //
                            //        for (i = 2; i <= line.length - 2; i += 2) {
                            //            strokeContext.lineTo(line[i] * txm + txa, line[i + 1] * tym + tya);
                            //        }
                            //    }
                            // }
                            Internal.Base.Graphics.endStrokeAndFill(g, strokeContext, node);
                        }
                        // details
                        if (paintDetails) {
                            var x = (bounds.x1 + bounds.x0) / 2 * txm + txa;
                            var y = (bounds.y1 + bounds.y0) / 2 * tym + tya;
                            var w = (bounds.x1 - bounds.x0) / 2 * txm;
                            var r = (bounds.y1 - bounds.y0) / 2 * tym;
                            this.paintNodeDetails(node, x, y, w, r, zoom, nodeLabelScaleBase, event);
                        }
                        if (opacity < 1) {
                            g.globalAlpha = 1;
                        }
                    }
                    // no animations
                    return false;
                };
                ShapesLayer.prototype.findObjectAt = function (displayX, displayY, tolerance) {
                    var fromDisplayResult = this.scene.fromDisplay(displayX, displayY);
                    var x = fromDisplayResult.x;
                    var y = fromDisplayResult.y;
                    var invzoom = 1 / this.scene.zoom;
                    var min = tolerance * invzoom;
                    var best = null;
                    var nodes = this.nodes();
                    for (var i = nodes.length - 1; i >= 0; i--) {
                        var n = nodes[i];
                        if (n.removed) {
                            continue;
                        }
                        var coordinates = this.getNodeCoords(n, invzoom);
                        var distSq = Internal.Base.Geometry.distanceToPolygonSq(x, y, coordinates);
                        var toleranceSq = min * min;
                        if (distSq <= 0) {
                            return { object: n, details: null };
                        }
                        else if (distSq < toleranceSq) {
                            var distance = Math.sqrt(distSq);
                            if (distance < min) {
                                min = distance;
                                best = n;
                            }
                        }
                    }
                    return { object: best, details: null };
                };
                /** ========================================================================
                private functions
                ======================================================================== */
                ShapesLayer.prototype.getNodeCoords = function (node, invzoom) {
                    var precision = this.style.shapeSimplificationPrecision;
                    if (!(precision > 0)) {
                        // do not simplify
                        return node.coordinates;
                    }
                    precision *= invzoom;
                    // reuse existing cache
                    var current = node.coordinatesCachePrecision;
                    if (current <= precision && current * 2 > precision) {
                        return node.coordinatesCache;
                    }
                    // rebuild coordinate cache
                    var cache = [];
                    var source;
                    if (current < precision) {
                        source = node.coordinatesCache;
                    }
                    else {
                        source = node.coordinates;
                    }
                    for (var shapeIndex = 0; shapeIndex < source.length; shapeIndex++) {
                        var shape = source[shapeIndex];
                        var size = Internal.Base.Geometry.computeBoundsSize(shape);
                        if (size > precision * 4) {
                            if (shape.length > 10) {
                                shape = Internal.Base.Geometry.simplify(shape, precision);
                            }
                            cache.push(shape);
                        }
                    }
                    node.coordinatesCachePrecision = precision;
                    node.coordinatesCache = cache;
                    return cache;
                };
                return ShapesLayer;
            }(Internal.ItemsChart.ItemsLayer));
            GeoChart.ShapesLayer = ShapesLayer;
        })(GeoChart = Internal.GeoChart || (Internal.GeoChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../base/Graphics.ts" />
/// <reference path="../../base/Layer.ts" />
/// <reference path="../Scene.ts" />
/// <reference path="../../itemschart/layers/ItemsLayer.ts" />
/// <reference path="../../itemschart/layers/ItemsStyle.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var GeoChart;
        (function (GeoChart) {
            var OverlayLayerBase = (function (_super) {
                __extends(OverlayLayerBase, _super);
                /** A layer that consists of nodes and links.
                You will need to define animation, paint and hit testing. */
                function OverlayLayerBase(scene, baseLayer, layerSettings) {
                    _super.call(this, scene);
                    this.layerSettings = layerSettings;
                    this.parentId = null;
                    this.baseLayer = baseLayer;
                }
                OverlayLayerBase.prototype.findObjectAt = function (displayX, displayY, tolerance) { return null; };
                // public getLegendItems() { return []; }
                /* =================================================================================
                public methods
                ================================================================================= */
                OverlayLayerBase.prototype.nodes = function () {
                    return this.baseLayer.nodes();
                };
                OverlayLayerBase.prototype.links = function () {
                    return this.baseLayer.links();
                };
                OverlayLayerBase.prototype.getModified = function () {
                    return this.baseLayer.getModified();
                };
                /** TODO: handle link reconnection */
                OverlayLayerBase.prototype.hasTopologyChanges = function () {
                    return this.baseLayer.hasTopologyChanges();
                };
                OverlayLayerBase.prototype.hasStyleChanges = function () {
                    return this.baseLayer.hasStyleChanges();
                };
                OverlayLayerBase.prototype.getGeometry = function () {
                    return this.baseLayer.getGeometry();
                };
                return OverlayLayerBase;
            }(Internal.Base.Layer));
            GeoChart.OverlayLayerBase = OverlayLayerBase;
            var ChartsLayer = (function (_super) {
                __extends(ChartsLayer, _super);
                function ChartsLayer(scene, baseLayer, layerSettings, chart) {
                    _super.call(this, scene, baseLayer, layerSettings);
                    this.idToChart = {};
                    this.chart = chart;
                }
                ChartsLayer.prototype.updateStyle = function (event) {
                    // Nothing here
                };
                ChartsLayer.prototype.postprocessStyle = function (event) {
                    for (var id in this.baseLayer.newNodes) {
                        var node = this.baseLayer.newNodes[id];
                        this.idToChart[id] = this.createChart(node);
                    }
                    var chart;
                    for (var id in this.baseLayer.modifiedNodes) {
                        var node = this.baseLayer.modifiedNodes[id];
                        if (this.baseLayer.newNodes.hasOwnProperty(id)) {
                            continue;
                        }
                        chart = this.idToChart[id];
                        if (chart) {
                            this.updateChart(chart, node);
                        }
                        else {
                            this.idToChart[id] = this.createChart(node);
                        }
                    }
                    for (var id in this.baseLayer.deletedNodes) {
                        chart = this.idToChart[id];
                        if (chart) {
                            delete this.idToChart[id];
                            this.removeChart(chart);
                        }
                    }
                    // update chart positions
                    for (var nodeIndex = 0, nodeSource = this.nodes(); nodeIndex < nodeSource.length; nodeIndex++) {
                        var node = nodeSource[nodeIndex];
                        chart = this.idToChart[node.id];
                        if (chart) {
                            this.updateXY(chart, node);
                        }
                    }
                };
                ChartsLayer.prototype.paint = function (event) {
                    // Nothing here
                };
                ChartsLayer.prototype.createChart = function (node) {
                    var chartType = this.layerSettings.chartType;
                    var chartSettings = this.getChartSettings(node);
                    if (!chartSettings) {
                        return null;
                    }
                    chartSettings.parentChart = this.chart.api;
                    if (!chartSettings.area) {
                        chartSettings.area = { width: 100, height: 100 };
                    }
                    else if (!chartSettings.area.width) {
                        chartSettings.area.width = 100;
                        chartSettings.area.height = 100;
                    }
                    var chart;
                    if (chartType === "piechart") {
                        chart = new ZoomCharts.PieChart(chartSettings);
                    }
                    else if (chartType === "facetchart") {
                        chart = new ZoomCharts.FacetChart(chartSettings);
                    }
                    else if (chartType === "timechart") {
                        chart = new ZoomCharts.TimeChart(chartSettings);
                    }
                    else {
                        chart = null;
                    }
                    return chart;
                };
                ChartsLayer.prototype.getChartSettings = function (node) {
                    if (this.layerSettings.settingsFunction) {
                        return this.layerSettings.settingsFunction(node, node.data);
                    }
                    else {
                        return this.layerSettings.settings;
                    }
                };
                ChartsLayer.prototype.updateChart = function (chart, node) {
                    // TODO: disabled for now
                    var settings = this.getChartSettings(node);
                    chart.updateSettings(settings);
                };
                ChartsLayer.prototype.removeChart = function (chart) {
                    chart.remove();
                };
                ChartsLayer.prototype.updateXY = function (chart, node) {
                    var r = this.scene.toDisplay(node.x, node.y);
                    var x = r.x;
                    var y = r.y;
                    var width = 0;
                    var height = 0;
                    var curArea = chart._impl.settings.area;
                    if (this.layerSettings.autoSize) {
                        throw "TODO: implement autoSize";
                    }
                    else {
                        width = curArea.width;
                        height = curArea.height;
                    }
                    var left = x - width / 2;
                    var top = y - height / 2;
                    if (curArea.left !== left || curArea.top !== top || curArea.width !== width || curArea.height !== height) {
                        chart.updateSettings({ area: { left: x - width / 2, top: y - height / 2, width: width, height: height } });
                    }
                };
                ChartsLayer.prototype.remove = function () {
                    for (var key in this.idToChart) {
                        this.removeChart(this.idToChart[key]);
                    }
                    this.idToChart = {};
                };
                return ChartsLayer;
            }(OverlayLayerBase));
            GeoChart.ChartsLayer = ChartsLayer;
        })(GeoChart = Internal.GeoChart || (Internal.GeoChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/core/ChartEvents.ts" />
/// <reference path="../base/Graphics.ts" />
/// <reference path="../base/Label.ts" />
/// <reference path="../base/Geometry.ts" />
/// <reference path="layers/NodesLayer.ts" />
/// <reference path="layers/ShapesLayer.ts" />
/// <reference path="layers/ChartsLayer.ts" />
/// <reference path="Aggregation.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var GeoChart;
        (function (GeoChart) {
            var InternalNodesLayer = (function () {
                function InternalNodesLayer(chart, data, layerSettings, drilldownId) {
                    this.drilldownId = drilldownId;
                    this.layerSettings = layerSettings;
                    this.data = data;
                    this.chart = chart;
                    this.loading = true;
                    this.scene = chart.scene;
                    this.layer = this.createLayer();
                    this.layer.drilldownId = this.drilldownId;
                    this.dataBounds = Internal.Base.Rect.createEmpty();
                    this.expandedNode = null;
                }
                InternalNodesLayer.calculateShapeCentroid = function (node) {
                    var maxAreaId = 0;
                    var maxArea = 0;
                    var i;
                    var a;
                    // Find the shape polygon with the largest area
                    for (i = 0; i < node.coordinates.length; i++) {
                        a = Internal.Base.Geometry.calculatePolyArea(node.coordinates[i]);
                        if (Math.abs(a) > Math.abs(maxArea)) {
                            maxArea = a;
                            maxAreaId = i;
                        }
                    }
                    if (maxArea === 0) {
                        // This multi-polygon only consists of points, not polygons. this is not right
                        // bounds will be then used instead
                        node.x = (node.bounds.x0 + node.bounds.x1) / 2;
                        node.y = (node.bounds.y0 + node.bounds.y1) / 2;
                        return;
                    }
                    var c = Internal.Base.Geometry.calculatePolyCentroid(node.coordinates[maxAreaId], maxArea);
                    node.x = c.x;
                    node.y = c.y;
                };
                InternalNodesLayer.prototype.createLayer = function () {
                    if (this.layerSettings.type === "shapes") {
                        return new GeoChart.ShapesLayer(this.scene, this.layerSettings);
                    }
                    else if (this.layerSettings.type === "items") {
                        return new GeoChart.NodesLayer(this.chart, this.layerSettings, false);
                    }
                    return null;
                };
                InternalNodesLayer.prototype.onSceneChange = function (event) {
                    // update layers data on view change
                    var dataSettings = this.data.dataSettings;
                    var layerSettings = this.layerSettings;
                    var prefetch = dataSettings.prefetchRatio;
                    var viewBounds;
                    var newViewRect;
                    var loadDataRect;
                    if (dataSettings.perBoundsData) {
                        viewBounds = this.chart.scene.getVisibleBounds();
                        newViewRect = viewBounds.clone().inflate(1 + prefetch / 2);
                        loadDataRect = viewBounds.clone().inflate(1 + prefetch);
                    }
                    else {
                        newViewRect = loadDataRect = viewBounds = this.data.getProjectedBounds();
                    }
                    var dataArrivedNodes = event.changes.geoChartDataNodesIds ? ((event.changes.geoChartDataNodesIds[dataSettings.id] || {})[this.drilldownId || ""]) : null;
                    var aggregationEnabled = layerSettings instanceof GeoChart.SettingsLayerItems && layerSettings.aggregation.enabled;
                    if (this.dataBounds.isEmpty()
                        || dataArrivedNodes
                        || !viewBounds.isInside(this.dataBounds)
                        || (event.changes.zoom && (dataSettings.perZoomData || aggregationEnabled))) {
                        this.loading = false;
                        this.data.setViewParams(dataSettings.aggregationGridSize / this.scene.zoom, this.scene.zoomLevel, viewBounds, newViewRect, loadDataRect);
                        // update visible objects
                        var getNodesResult = this.data.getData(this.drilldownId);
                        var nodesData = getNodesResult.nodes;
                        var linksData = getNodesResult.links;
                        var hasData = getNodesResult.hasData;
                        var loading = getNodesResult.loading;
                        var nodeCount = nodesData.length;
                        if (hasData || nodeCount > 0) {
                            this.chart.log("Layer " + this.layerSettings.id + ": Updating view rect to " + newViewRect + ", contains " + nodeCount + " objects");
                            if (aggregationEnabled) {
                                var agr = new GeoChart.Aggregation(layerSettings.aggregation, this.scene, this.chart);
                                var agrResult = agr.aggregate(nodesData, linksData);
                                nodesData = agrResult.nodes;
                                linksData = agrResult.links;
                            }
                            this.applyVisibleNodes(this.layer, nodesData, linksData, null);
                            this.dataBounds = newViewRect;
                        }
                        this.loading = loading;
                    }
                    else if (viewBounds.area() * (1 + prefetch) * (1 + prefetch) < this.dataBounds.area() / 5) {
                        // shrink scene bounds
                        newViewRect = viewBounds.inflate(1 + prefetch);
                        this.chart.log("Layer " + this.layerSettings.id + ": Shrinking view to " + newViewRect);
                        this.shrinkVisibleBounds(newViewRect);
                        this.dataBounds = newViewRect;
                    }
                    if (layerSettings.perZoomStyle && event.changes.zoom) {
                        for (var nodeIndex = 0, layerNodes = this.layer.nodes(); nodeIndex < layerNodes.length; nodeIndex++) {
                            this.layer.touchNode(layerNodes[nodeIndex]);
                        }
                        for (var linkIndex = 0, layerLinks = this.layer.links(); linkIndex < layerLinks.length; linkIndex++) {
                            this.layer.touchLink(layerLinks[linkIndex]);
                        }
                    }
                };
                InternalNodesLayer.prototype.updateStyle = function (event) {
                    this.layer.setBounds(this.scene.x0, this.scene.y0, this.scene.x0 + this.scene.width, this.scene.y0 + this.scene.height);
                    this.layer.updateStyle(event);
                };
                InternalNodesLayer.prototype.postprocessStyle = function (event) {
                    this.layer.postprocessStyle(event);
                };
                InternalNodesLayer.prototype.remove = function () {
                    // a virtual method.
                };
                InternalNodesLayer.prototype.paint = function (event) {
                    this.layer.paint(event);
                };
                InternalNodesLayer.prototype.findObjectAt = function (x, y, tolerance) {
                    return this.layer.findObjectAt(x, y, tolerance);
                };
                InternalNodesLayer.prototype.findObjectById = function (id) {
                    return this.layer.findObjectById(id);
                };
                InternalNodesLayer.prototype.touchObject = function (id) {
                    var l = this.layer;
                    var obj = l.findObjectById(id);
                    if (obj)
                        l.touchNodeOrLink(obj);
                };
                InternalNodesLayer.prototype.setExpandedNode = function (nodeId) {
                    if (this.expandedNode) {
                        this.expandedNode.expanded = false;
                        this.layer.touchNode(this.expandedNode);
                        this.expandedNode = null;
                    }
                    if (nodeId) {
                        this.expandedNode = this.layer.idToNode[nodeId];
                        if (this.expandedNode) {
                            this.expandedNode.expanded = true;
                            this.layer.touchNode(this.expandedNode);
                        }
                    }
                };
                InternalNodesLayer.prototype.applyVisibleNodes = function (layer, nodes, links, parentNode) {
                    var idToNode = layer.idToNode;
                    var nodesToKeep = {};
                    var linksToKeep = {};
                    var isShape = this.layerSettings.type === "shapes";
                    // add/update visible nodes
                    for (var dataIndex = 0; dataIndex < nodes.length; dataIndex++) {
                        var data = nodes[dataIndex];
                        var goodData = (isShape && data._coordinates) || (!isShape && data.hasOwnProperty("_x"));
                        if (!goodData) {
                            // TODO: should add a warning here about invalid data?
                            continue;
                        }
                        var id = data.id;
                        nodesToKeep[id] = true;
                        var node = layer.addNode(id);
                        node.data = data;
                        if (isShape) {
                            node.coordinates = data._coordinates;
                            node.bounds = data._bounds;
                            InternalNodesLayer.calculateShapeCentroid(node);
                        }
                        node.parentNode = parentNode;
                    }
                    for (var linkDataIndex = 0; linkDataIndex < links.length; linkDataIndex++) {
                        var linkData = links[linkDataIndex];
                        // no need to check if the link target nodes are added - that should already be done in the Data class
                        var link = layer.addLink(linkData.id, linkData.from, linkData.to);
                        link.data = linkData;
                        linksToKeep[link.id] = true;
                    }
                    // remove nodes no more in view
                    for (var id in idToNode) {
                        var node = idToNode[id];
                        if (!nodesToKeep.hasOwnProperty(id)) {
                            layer.removeNode(node);
                            for (var li = 0; li < node.links.length; li++) {
                                layer.removeLink(node.links[li]);
                            }
                        }
                    }
                    var idToLink = layer.idToLink;
                    for (var id in idToLink) {
                        if (!linksToKeep.hasOwnProperty(id))
                            layer.removeLink(idToLink[id]);
                    }
                };
                InternalNodesLayer.prototype.shrinkVisibleBounds = function (bounds) {
                    // remove nodes no more in view
                    for (var id in this.layer.idToNode) {
                        var node = this.layer.idToNode[id];
                        if (node.data._bounds.isOutside(bounds)) {
                            this.layer.removeNode(node);
                        }
                    }
                };
                return InternalNodesLayer;
            }());
            /**
              Layer that creates overlay from nodes in a nodes layer.
            */
            var InternalOverlayLayer = (function () {
                function InternalOverlayLayer(chart, baseLayer, layerSettings, drilldownId) {
                    this.data = null; // Will always be null, as overlayLayer does not have it's data source
                    this.drilldownId = drilldownId;
                    this.layerSettings = layerSettings;
                    this.baseLayer = baseLayer;
                    this.chart = chart;
                    this.scene = chart.scene;
                    this.loading = false;
                    this.layer = this.createLayer();
                }
                InternalOverlayLayer.prototype.createLayer = function () {
                    if (this.layerSettings.type === "charts") {
                        return new GeoChart.ChartsLayer(this.scene, this.baseLayer.layer, this.layerSettings, this.chart);
                    }
                    return null;
                };
                InternalOverlayLayer.prototype.onSceneChange = function (event) {
                    // a virtual method
                };
                InternalOverlayLayer.prototype.updateStyle = function (event) {
                    this.layer.updateStyle(event);
                };
                InternalOverlayLayer.prototype.postprocessStyle = function (event) {
                    this.layer.postprocessStyle(event);
                };
                /** nothing here */
                InternalOverlayLayer.prototype.setExpandedNode = function (nodeId) {
                    // not supported.
                };
                /** nothing here */
                InternalOverlayLayer.prototype.paint = function (event) {
                    this.layer.paint(event);
                };
                /** nothing here */
                InternalOverlayLayer.prototype.findObjectAt = function (x, y, tolerance) { return null; };
                InternalOverlayLayer.prototype.findObjectById = function (id) { return null; };
                InternalOverlayLayer.prototype.touchObject = function (id) {
                    // not supported
                };
                InternalOverlayLayer.prototype.remove = function () {
                    this.layer.remove();
                };
                return InternalOverlayLayer;
            }());
            var InternalAggregateOnShapesLayer = (function () {
                function InternalAggregateOnShapesLayer(chart, shapesLayer, data, layerSettings, drilldownId) {
                    this.firstTime = true;
                    this.drilldownId = drilldownId;
                    this.layerSettings = layerSettings;
                    this.data = data;
                    this.baseLayer = shapesLayer;
                    this.chart = chart;
                    this.loading = true;
                    this.scene = chart.scene;
                    this.dataBounds = Internal.Base.Rect.createEmpty();
                    // node id to aggregated data
                    this.nodeToAggregated = {};
                    // node id to bool for pending nodes
                    this.pendingNodes = {};
                }
                InternalAggregateOnShapesLayer.prototype.onSceneChange = function (event) {
                    if (this.firstTime || (this.layerSettings.perZoomStyle && event.changes.zoom) || event.changes.data) {
                        this.firstTime = false;
                        var layer = this.baseLayer.layer;
                        for (var nodeIndex = 0, nodes = layer.nodes(); nodeIndex < nodes.length; nodeIndex++) {
                            layer.touchNode(nodes[nodeIndex]);
                        }
                        for (var linkIndex = 0, links = layer.links(); linkIndex < links.length; linkIndex++) {
                            layer.touchLink(links[linkIndex]);
                        }
                    }
                };
                InternalAggregateOnShapesLayer.prototype.updateStyle = function (event) {
                    var dataSettings = this.data.dataSettings;
                    var layerSettings = this.layerSettings;
                    var modNodes = this.baseLayer.layer.modifiedNodes;
                    var dataArrivedNodes = event.changes.geoChartDataNodesIds ? ((event.changes.geoChartDataNodesIds[dataSettings.id] || {})[this.drilldownId || ""]) : null;
                    if (!Internal.Base.Helpers.hasProperties(modNodes) && !Internal.Base.Helpers.hasProperties(dataArrivedNodes)) {
                        return;
                    }
                    // update layers data on view change
                    var styleFunc = layerSettings.styleFunction;
                    // apply style where possible, add rest to pending
                    for (var id in modNodes) {
                        var node = modNodes[id];
                        if (this.nodeToAggregated.hasOwnProperty(node.id)) {
                            styleFunc(node, this.nodeToAggregated[node.id]);
                        }
                        else {
                            this.pendingNodes[id] = node;
                        }
                    }
                    if (!Internal.Base.Helpers.hasProperties(this.pendingNodes)) {
                        this.loading = false;
                        return;
                    }
                    // prepare request for new data
                    var nodesBounds;
                    if (dataSettings.perBoundsData) {
                        nodesBounds = Internal.Base.Rect.createEmpty();
                        for (var id in this.pendingNodes) {
                            var node = this.pendingNodes[id];
                            nodesBounds.addRect(node.data._bounds);
                        }
                    }
                    else {
                        nodesBounds = this.data.getProjectedBounds();
                    }
                    /* TODO: respect PerZoomData, respect perDrilldownData
                    get nodes data: */
                    this.data.setViewParams(dataSettings.aggregationGridSize / this.scene.zoom, this.scene.zoomLevel, nodesBounds, nodesBounds, nodesBounds);
                    var getNodesResult = this.data.getData(this.drilldownId);
                    var nodesData = getNodesResult.nodes;
                    var loading = getNodesResult.loading;
                    if (!loading) {
                        // compute node->aggr
                        for (var id in this.pendingNodes) {
                            var node = this.pendingNodes[id];
                            var aggr = this.computeAggr(node.data._bounds, node.data._coordinates, nodesData);
                            this.nodeToAggregated[node.id] = aggr;
                            if (styleFunc) {
                                styleFunc(node, aggr);
                            }
                        }
                        this.pendingNodes = {};
                    }
                    this.loading = loading;
                };
                InternalAggregateOnShapesLayer.prototype.postprocessStyle = function (event) {
                    // Nothing here.
                };
                InternalAggregateOnShapesLayer.prototype.computeAggr = function (bounds, polygon, dataPoints) {
                    var options = this.layerSettings;
                    if (options.aggregationFunction) {
                        var pointsList = new Array();
                        for (var pIndex = 0; pIndex < dataPoints.length; pIndex++) {
                            var p = dataPoints[pIndex];
                            var x = p._x;
                            var y = p._y;
                            if (bounds.containsPoint(x, y) && Internal.Base.Geometry.isInsidePolygon(x, y, polygon)) {
                                pointsList.push(p);
                            }
                        }
                        return options.aggregationFunction(pointsList);
                    }
                    else {
                        var method = options.aggregation;
                        var field_1 = options.aggregationField;
                        var iter_1 = 0;
                        var hasNext = function () {
                            while (iter_1 < dataPoints.length
                                && (!bounds.containsPoint(dataPoints[iter_1]._x, dataPoints[iter_1]._y)
                                    || !Internal.Base.Geometry.isInsidePolygon(dataPoints[iter_1]._x, dataPoints[iter_1]._y, polygon))) {
                                iter_1 += 1;
                            }
                            return iter_1 < dataPoints.length;
                        };
                        var next = function () {
                            // Yes, <any>. This is a sort of "reflection" where the necessary field is specified in the options. And it HAS to be a number. Hopefully...
                            var v = dataPoints[iter_1][field_1];
                            iter_1 += 1;
                            return v;
                        };
                        return Internal.Base.Helpers.aggregate(method, hasNext, next);
                    }
                };
                InternalAggregateOnShapesLayer.prototype.setExpandedNode = function (nodeId) {
                    // not needed
                };
                /** nothing here */
                InternalAggregateOnShapesLayer.prototype.paint = function (event) {
                    // not needed
                };
                /** nothing here */
                InternalAggregateOnShapesLayer.prototype.findObjectAt = function (x, y, tolerance) { return null; };
                InternalAggregateOnShapesLayer.prototype.findObjectById = function (id) { return null; };
                InternalAggregateOnShapesLayer.prototype.touchObject = function (id) {
                    // not needed
                };
                InternalAggregateOnShapesLayer.prototype.remove = function () {
                    // not needed
                };
                return InternalAggregateOnShapesLayer;
            }());
            var InternalDrilldownLayer = (function () {
                function InternalDrilldownLayer(chart, renderer, data, layerSettings) {
                    this.layers = [];
                    this.firstTime = true;
                    this.layerSettings = layerSettings;
                    this.data = data;
                    this.renderer = renderer;
                    this.chart = chart;
                    this.loading = true;
                    this.scene = chart.scene;
                }
                InternalDrilldownLayer.prototype.onSceneChange = function (event) {
                    /* update layers data on view change
                    update drilldown */
                    if (event.changes.navigation || this.firstTime) {
                        this.firstTime = false;
                        var drilldown = this.scene.stack;
                        // figure out common ancestor
                        var commonLen = 0;
                        while (commonLen < Math.min(this.layers.length, drilldown.length) && drilldown[commonLen] === this.layers[commonLen].drilldownId) {
                            commonLen += 1;
                        }
                        // remove layers that are not in drilldown
                        while (this.layers.length > commonLen) {
                            var l = this.layers.pop();
                            this.renderer.removeSimpleLayer(l);
                            var prevLayer = (this.layers.length > 0) ? (this.layers[this.layers.length - 1]) : null;
                            if (prevLayer) {
                                prevLayer.setExpandedNode(null);
                            }
                        }
                        // create new layers for drilldown
                        while (this.layers.length < drilldown.length) {
                            var drilldownId = drilldown[this.layers.length];
                            var prevLayer = (this.layers.length > 0) ? (this.layers[this.layers.length - 1]) : null;
                            if (prevLayer) {
                                prevLayer.setExpandedNode(drilldownId);
                            }
                            var l = this.renderer.createSimpleLayer(this.data, this.layerSettings, drilldownId);
                            if (!l) {
                                break;
                            }
                            this.layers.push(l);
                        }
                    }
                    // update layers
                    this.loading = false;
                    for (var layerIndex = 0; layerIndex < this.layers.length; layerIndex++) {
                        var layer = this.layers[layerIndex];
                        layer.onSceneChange(event);
                        this.loading = this.loading || layer.loading;
                    }
                };
                InternalDrilldownLayer.prototype.updateStyle = function (event) {
                    for (var layerIndex = 0; layerIndex < this.layers.length; layerIndex++) {
                        var layer = this.layers[layerIndex];
                        layer.updateStyle(event);
                    }
                };
                InternalDrilldownLayer.prototype.postprocessStyle = function (event) {
                    for (var layerIndex = 0; layerIndex < this.layers.length; layerIndex++) {
                        var layer = this.layers[layerIndex];
                        layer.postprocessStyle(event);
                    }
                };
                InternalDrilldownLayer.prototype.paint = function (event) {
                    for (var layerIndex = 0; layerIndex < this.layers.length; layerIndex++) {
                        var layer = this.layers[layerIndex];
                        layer.paint(event);
                    }
                };
                InternalDrilldownLayer.prototype.findObjectAt = function (x, y, tolerance) {
                    for (var i = this.layers.length - 1; i >= 0; i--) {
                        var r = this.layers[i].findObjectAt(x, y, tolerance);
                        if (r && r.object) {
                            return r;
                        }
                    }
                    return null;
                };
                InternalDrilldownLayer.prototype.findObjectById = function (id) {
                    for (var i = this.layers.length - 1; i >= 0; i--) {
                        var r = this.layers[i].findObjectById(id);
                        if (r) {
                            return r;
                        }
                    }
                    return null;
                };
                InternalDrilldownLayer.prototype.touchObject = function (id) {
                    for (var i = 0; i <= this.layers.length; i++) {
                        this.layers[i].touchObject(id);
                    }
                };
                InternalDrilldownLayer.prototype.remove = function () {
                    for (var lIndex = 0; lIndex < this.layers.length; lIndex++) {
                        var l = this.layers[lIndex];
                        this.renderer.removeSimpleLayer(l);
                    }
                    this.layers = [];
                };
                return InternalDrilldownLayer;
            }());
            //#endregion
            var Renderer = (function (_super) {
                __extends(Renderer, _super);
                function Renderer(chart) {
                    _super.call(this);
                    this.animationOrder = 900;
                    this.paintOrder = 10;
                    this.updateOrder = 10;
                    // array of layer sets
                    this.layers = [];
                    this.idToLayer = {};
                    this.idToSimpleLayer = {};
                    this.drilldownLayer = null;
                    this.chart = chart;
                    this.scene = chart.scene;
                    this.events = chart.events;
                }
                Renderer.prototype.createData = function (dataSettings) {
                    var data = null;
                    if (dataSettings.id) {
                        data = this.chart.getData(dataSettings.id);
                    }
                    return data;
                };
                Renderer.prototype.createSimpleLayer = function (data, layerSettings, drilldownId) {
                    var r;
                    if (layerSettings instanceof GeoChart.SettingsLayerOverlay) {
                        var shapesLayer = this.idToSimpleLayer[layerSettings.shapesLayer + drilldownId];
                        if (!shapesLayer) {
                            this.chart.error("ItemsOnShape layer: shapesLayer " + layerSettings.shapesLayer + " not found, must come first in the layers array.");
                            return null;
                        }
                        if (layerSettings.type === "charts") {
                            r = new InternalOverlayLayer(this.chart, shapesLayer, layerSettings, drilldownId);
                        }
                        else if (layerSettings.type === "aggregateOnShapes") {
                            r = new InternalAggregateOnShapesLayer(this.chart, shapesLayer, data, layerSettings, drilldownId);
                        }
                    }
                    else {
                        r = new InternalNodesLayer(this.chart, data, layerSettings, drilldownId);
                    }
                    this.idToSimpleLayer[layerSettings.id + drilldownId] = r;
                    return r;
                };
                Renderer.prototype.removeLayer = function (layer) {
                    if (layer instanceof InternalDrilldownLayer) {
                        layer.remove();
                    }
                    else {
                        this.removeSimpleLayer(layer);
                    }
                };
                Renderer.prototype.removeSimpleLayer = function (layer) {
                    layer.remove();
                    var id = layer.layerSettings.id + layer.drilldownId;
                    delete this.idToSimpleLayer[id];
                };
                Renderer.prototype.onSceneChange = function (event) {
                    var updateLayers = false;
                    var changes = event.changes;
                    var sc = changes.settingsChanges;
                    if (sc && (sc.layers || sc.layerTypes)) {
                        // rebuild changed layers
                        for (var id in sc.layers) {
                            var layer = this.idToLayer[id];
                            if (layer) {
                                this.removeLayer(layer);
                                delete this.idToLayer[id];
                            }
                        }
                        updateLayers = true;
                    }
                    else if (changes.zoom || changes.data) {
                        updateLayers = true;
                    }
                    if (updateLayers) {
                        // incrementally update layers based on zoom preferences
                        var oldLayers = this.idToLayer;
                        this.layers = [];
                        this.idToLayer = {};
                        var zoom = this.scene.zoomLevel;
                        this.drilldownLayer = null;
                        var drilldownLayerId = this.scene.settings.navigation.drilldownLayer;
                        for (var layerSettingsIndex = 0; layerSettingsIndex < this.chart.settings._computedLayers.length; layerSettingsIndex++) {
                            var layerSettings = this.chart.settings._computedLayers[layerSettingsIndex];
                            var showLayer = layerSettings.enabled && layerSettings.minZoom <= zoom && layerSettings.maxZoom >= zoom;
                            var prevLayer = oldLayers[layerSettings.id];
                            if (!showLayer) {
                                if (prevLayer) {
                                    this.removeLayer(prevLayer);
                                }
                                continue;
                            }
                            var data = this.createData(layerSettings.data);
                            var perDrilldownData = false;
                            if (data && data.dataSettings.perDrilldownData) {
                                perDrilldownData = true;
                            }
                            if (layerSettings instanceof GeoChart.SettingsLayerOverlay) {
                                var baseLayer = this.idToLayer[layerSettings.shapesLayer];
                                if (!baseLayer) {
                                    this.chart.error("Overlay layer: shapeLayer " + layerSettings.shapesLayer + " not found, must come first in the layers array.");
                                    continue;
                                }
                                if (prevLayer && prevLayer.baseLayer !== baseLayer) {
                                    this.removeLayer(prevLayer);
                                    prevLayer = null;
                                }
                                perDrilldownData = perDrilldownData || baseLayer.data.dataSettings.perDrilldownData;
                            }
                            var layer = void 0;
                            if (prevLayer && prevLayer.data === data) {
                                layer = prevLayer;
                            }
                            else {
                                if (prevLayer) {
                                    this.removeLayer(prevLayer);
                                }
                                if (perDrilldownData) {
                                    layer = new InternalDrilldownLayer(this.chart, this, data, layerSettings);
                                }
                                else {
                                    layer = this.createSimpleLayer(data, layerSettings, null);
                                    if (!layer) {
                                        continue;
                                    }
                                }
                            }
                            if (layerSettings.id === drilldownLayerId) {
                                this.drilldownLayer = layer;
                            }
                            this.layers.push(layer);
                            this.idToLayer[layerSettings.id] = layer;
                        }
                        // cleanup old layers
                        for (var id in oldLayers) {
                            var layer = oldLayers[id];
                            if (!this.idToLayer.hasOwnProperty(id)) {
                                this.removeLayer(layer);
                            }
                        }
                    }
                    for (var layerIndex = 0; layerIndex < this.layers.length; layerIndex++) {
                        var layer = this.layers[layerIndex];
                        layer.onSceneChange(event);
                    }
                };
                Renderer.prototype.doAnimations = function (event) {
                    for (var layerIndex = 0; layerIndex < this.layers.length; layerIndex++) {
                        var layer = this.layers[layerIndex];
                        layer.updateStyle(event);
                    }
                    var loading = false;
                    for (var layerIndex = 0; layerIndex < this.layers.length; layerIndex++) {
                        var layer = this.layers[layerIndex];
                        layer.postprocessStyle(event);
                        loading = loading || layer.loading;
                    }
                    this.scene.loading = loading;
                };
                Renderer.prototype.paintScene = function (event) {
                    // paint selection
                    Internal.Base.Graphics.pushClip(event, this.scene.x0, this.scene.y0, this.scene.width, this.scene.height);
                    var loading = false;
                    for (var layerIndex = 0; layerIndex < this.layers.length; layerIndex++) {
                        var layer = this.layers[layerIndex];
                        // paint objects
                        layer.paint(event);
                        loading = loading || layer.loading;
                    }
                    /* if @scene.settings.advanced.logging
                    @paintDataBounds(event) */
                    Internal.Base.Graphics.popClip(event);
                    this.scene.loading = loading;
                };
                Renderer.prototype.findObjectById = function (id) {
                    for (var i = this.layers.length - 1; i >= 0; i--) {
                        var layer = this.layers[i];
                        var t = layer.findObjectById(id);
                        if (t) {
                            return t;
                        }
                    }
                    return null;
                };
                Renderer.prototype.touchObjects = function (objects) {
                    for (var i = this.layers.length - 1; i >= 0; i--) {
                        var layer = this.layers[i];
                        for (var j = 0; j < objects.length; j++) {
                            layer.touchObject(objects[j]);
                        }
                    }
                };
                Renderer.prototype.findObjectAt = function (x, y, tolerance) {
                    for (var i = this.layers.length - 1; i >= 0; i--) {
                        var layer = this.layers[i];
                        var t = layer.findObjectAt(x, y, tolerance);
                        if (t && t.object) {
                            return t;
                        }
                    }
                    return null;
                };
                Renderer.prototype.paintDataBounds = function (event) {
                    var g = event.context;
                    var exportAreasResult = this.scene.mainData.exportAreas();
                    var loadedAreas = exportAreasResult.areasRects;
                    var reqAreas = exportAreasResult.reqAreasRects;
                    var pendingAreas = exportAreasResult.pendingAreasRects;
                    this.paintRects(g, reqAreas, {
                        fillColor: "rgba(255,0,0, 0.2)"
                    });
                    this.paintRects(g, loadedAreas, {
                        fillColor: "rgba(0,255,0, 0.3)"
                    });
                    this.paintRects(g, pendingAreas, {
                        fillColor: "rgba(0,0,255, 0.5)"
                    });
                };
                Renderer.prototype.paintRects = function (g, rects, style) {
                    var t = this.scene.toDisplayTransform();
                    var txm = t.xm;
                    var txa = t.xa;
                    var tym = t.ym;
                    var tya = t.ya;
                    g.beginPath();
                    for (var rIndex = 0; rIndex < rects.length; rIndex++) {
                        var r = rects[rIndex];
                        var x0 = r.x0 * txm + txa;
                        var y0 = r.y0 * tym + tya;
                        var x1 = r.x1 * txm + txa;
                        var y1 = r.y1 * tym + tya;
                        g.rect(x0, y0, x1 - x0, y1 - y0);
                    }
                    Internal.Base.Graphics.fill(g, style);
                };
                return Renderer;
            }(Internal.Base.ChartElement));
            GeoChart.Renderer = Renderer;
        })(GeoChart = Internal.GeoChart || (Internal.GeoChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/core/ChartEvents.ts" />
/// <reference path="../base/Navigator.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var GeoChart;
        (function (GeoChart) {
            var Navigator = (function (_super) {
                __extends(Navigator, _super);
                function Navigator(chart) {
                    _super.call(this);
                    this.animationOrder = 1000;
                    this.paintOrder = 5;
                    this.updateOrder = 1300;
                    this.chart = chart;
                    this.scene = this.chart.scene;
                }
                Navigator.prototype.showInitialNodes = function () {
                    var initial = this.scene.settings.navigation.initialDrilldown;
                    this.scene.stack = initial;
                    return this.chart.events.notifySceneChanges({ navigation: true });
                };
                Navigator.prototype.onPanZoom = function () {
                    // TODO: maybe needed maybe not
                };
                Navigator.prototype.onNewDataObject = function () {
                    // TODO: restore navigation state from new data possibly not needed as Renderer does most of this.
                };
                Navigator.prototype.expandNode = function (node) {
                    // get layer id
                    var parentId = node.layer.drilldownId;
                    var nodeId = node.id;
                    if (nodeId === this.scene.peek()) {
                        return false;
                    }
                    while (this.scene.peek() !== parentId) {
                        this.scene.pop();
                    }
                    this.scene.push(nodeId);
                    this.chart.events.notifySceneChanges({ navigation: true });
                    return true;
                };
                Navigator.prototype.collapseNode = function (node) {
                    throw "Not implemented";
                };
                return Navigator;
            }(Internal.Base.Navigator));
            GeoChart.Navigator = Navigator;
        })(GeoChart = Internal.GeoChart || (Internal.GeoChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Impl.ts" />
/// <reference path="../itemschart/Impl.ts" />
/// <reference path="../itemschart/InfoPopup.ts" />
/// <reference path="Selection.ts" />
/// <reference path="../itemschart/Menu.ts" />
/// <reference path="Renderer.ts" />
/// <reference path="Data.ts" />
/// <reference path="Scene.ts" />
/// <reference path="DomLayer.ts" />
/// <reference path="Settings.ts" />
/// <reference path="Navigator.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var GeoChart;
        (function (GeoChart) {
            var leafletVersionChecked = false;
            var Impl = (function (_super) {
                __extends(Impl, _super);
                function Impl(settings, api) {
                    _super.call(this, new GeoChart.Settings(settings), new GeoChart.Scene(), api);
                    this.events.forceFloating = true;
                    // the super() call might or might not set the _map to actual map instance.
                    this._map = this._map || null;
                    this._pendingZoomLevel = null;
                    this._pendingLatitude = null;
                    this._pendingBounds = null;
                    this._pendingClearData = null;
                    this.navigator = this.events.addElement(new GeoChart.Navigator(this));
                    this.menu = this.events.addElement(new Internal.ItemsChart.Menu(this));
                    this.info = this.events.addElement(new Internal.ItemsChart.InfoPopup(this));
                    this.selection = this.events.addElement(new GeoChart.Selection(this));
                    // in case the map was loaded synchronously.
                    if (this._map)
                        this.renderer = this.events.addElement(new GeoChart.Renderer(this));
                    this.navigator.showInitialNodes();
                    this.finalInitialize();
                }
                Impl.prototype.getMap = function () {
                    return this._map;
                };
                /** Called when `DomLayer` has finished initializing. The initialization is delayed because leaflet.js might be loaded asynchronously. */
                Impl.prototype.domLayerCreated = function () {
                    if (!leafletVersionChecked) {
                        if (!Internal.Base.Helpers.compareVersions(L.version, [0, 7]))
                            this.error("ZoomCharts requires Leaflet.js version 0.7.0 or newer. The loaded version is " + L.version);
                        leafletVersionChecked = true;
                    }
                    if (this._map)
                        return;
                    this._map = this._domLayer.map;
                    if (this._pendingLatitude != null) {
                        this.setView(this._pendingLatitude, this._pendingLongitude, this._pendingZoomLevel);
                    }
                    else {
                        if (this.settings.navigation.initialLat !== null)
                            this.setView(this.settings.navigation.initialLat, this.settings.navigation.initialLng, this.settings.navigation.initialZoom);
                        if (this._pendingZoomLevel != null)
                            this.setZoomLevel(this._pendingZoomLevel);
                    }
                    if (this._pendingBounds != null) {
                        this.setBounds(this._pendingBounds);
                    }
                    if (this._pendingClearData != null)
                        this.clearData();
                    if (this.events) {
                        this.renderer = this.events.addElement(new GeoChart.Renderer(this));
                        // raise all events on the new elements created, most notably Renderer
                        this.events.notifySceneChanges({
                            settings: true,
                            settingsChanges: this.settings,
                            zoom: true,
                            bounds: true,
                        });
                    }
                    this.scene.loading = false;
                };
                Impl.prototype.createDomLayer = function () {
                    this._domLayer = new GeoChart.DomLayer(this);
                    return this._domLayer;
                };
                Impl.prototype.clearData = function (final) {
                    // super.clearData() initializes the Data object which in turn requires the projection methods to be setup which
                    // come from the Leaflet.
                    if (this._map) {
                        _super.prototype.clearData.call(this, final);
                    }
                    else {
                        this._pendingClearData = !!final;
                    }
                };
                Impl.prototype.createDataObj = function (dataSettings) {
                    return new GeoChart.Data(this, dataSettings);
                };
                Impl.prototype.getData = function (id) {
                    return _super.prototype.getData.call(this, id);
                };
                Impl.prototype.onSettingsChanged = function (changes) {
                    var ch = {};
                    var reinitChart = changes.navigation && changes.navigation.initialDrilldown;
                    if (reinitChart) {
                        this.navigator.showInitialNodes();
                    }
                    if (changes.filters) {
                        ch.filters = true;
                    }
                    if (changes.style) {
                        ch.style = true;
                    }
                    this.events.notifySceneChanges(ch);
                };
                Impl.prototype.saveNavigation = function () {
                    if (!this._map) {
                        return null;
                    }
                    return this.scene.getVisibleBoundsLatLon();
                };
                Impl.prototype.restoreNavigation = function (data) {
                    this.setBounds(data);
                };
                Impl.prototype.save = function () { return ""; };
                Impl.prototype.restore = function (stateStr, animate) {
                    return;
                };
                Impl.prototype.setZoomLevel = function (zoom) {
                    if (this._map) {
                        this._map.setZoom(zoom);
                    }
                    else {
                        this._pendingZoomLevel = zoom;
                    }
                };
                Impl.prototype.setView = function (latitude, longitude, zoom) {
                    if (this._map) {
                        this._map.setView(L.latLng(latitude, longitude), zoom);
                    }
                    else {
                        this._pendingLatitude = latitude;
                        this._pendingLongitude = longitude;
                        this._pendingZoomLevel = zoom;
                    }
                };
                Impl.prototype.setBounds = function (boundsRect) {
                    if (this._map) {
                        var gr = boundsRect;
                        if (gr.east !== void 0) {
                            this._map.fitBounds(L.latLngBounds(L.latLng(gr.south, gr.west), L.latLng(gr.north, gr.east)));
                        }
                        else {
                            var r = boundsRect;
                            this._map.fitBounds(L.latLngBounds(L.latLng(r.y1, r.x0), L.latLng(r.y0, r.x1)));
                        }
                    }
                    else {
                        this._pendingBounds = boundsRect;
                    }
                };
                Impl.prototype.getNodeDimensions = function (nodeOrId) {
                    var node = nodeOrId;
                    if (Internal.Base.Helpers.isString(nodeOrId)) {
                        node = this.getNode(nodeOrId);
                    }
                    if (!node) {
                        return null;
                    }
                    var toDisplayResult = this.scene.toDisplay(node.x, node.y);
                    var x = toDisplayResult.x;
                    var y = toDisplayResult.y;
                    var r = node.hHeight * this.scene.zoom;
                    var w = node.hWidth * this.scene.zoom;
                    return {
                        x: x,
                        y: y,
                        radius: r,
                        hwidth: w
                    };
                };
                Impl.prototype.expandNode = function (id) {
                    var node = null;
                    if (Internal.Base.Helpers.isString(id)) {
                        node = this.getNode(id);
                    }
                    else {
                        node = id;
                    }
                    this.navigator.expandNode(node);
                };
                Impl.prototype.collapseNode = function (id) {
                    var node = null;
                    if (Internal.Base.Helpers.isString(id)) {
                        node = this.getNode(id);
                    }
                    else {
                        node = id;
                    }
                    this.navigator.collapseNode(node);
                };
                Impl.prototype.getNode = function (id) {
                    return this.renderer ? this.renderer.findObjectById(id) : null;
                };
                Impl.prototype.zoomIn = function (nodes, animate) {
                    this.error("ZoomIn: not implmeneted");
                };
                Impl.prototype.hideMenu = function () {
                    this.menu.hideMenu();
                };
                Impl.prototype.defaultClick = function (event, args) {
                    var isDrilldown = this.settings.interaction.mode === "drilldown";
                    var node = args.clickNode;
                    if (isDrilldown && node && node.expandable) {
                        if (this.navigator.expandNode(node)) {
                            this.setBounds(this.scene.unprojectRect(node.data._bounds));
                            event.preventDefault();
                        }
                    }
                };
                Impl.prototype.defaultRightClick = function (event, args) {
                    if (args.clickNode) {
                        this.menu.toggleNodeMenu(args.clickNode);
                        event.preventDefault();
                    }
                    if (args.clickLink) {
                        this.menu.toggleLinkMenu(event.x, event.y, args.clickLink);
                        event.preventDefault();
                    }
                };
                return Impl;
            }(Internal.ItemsChart.Impl));
            GeoChart.Impl = Impl;
        })(GeoChart = Internal.GeoChart || (Internal.GeoChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="ZoomCharts.d.ts" />
/// <reference path="geochart/Settings.ts" />
/// <reference path="geochart/Impl.ts" />
/// <reference path="base/Api.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    /** @api-class */
    var GeoChart = (function (_super) {
        __extends(GeoChart, _super);
        function GeoChart(settings) {
            var _this = this;
            _super.call(this);
            this.typeName = "GeoChart";
            if (GeoChart.chartFactoryMethod) {
                this._impl = GeoChart.chartFactoryMethod(function (stngs) { return new ZoomCharts.Internal.GeoChart.Impl(stngs, _this); }, settings);
            }
            else {
                this._impl = new ZoomCharts.Internal.GeoChart.Impl(settings, this);
            }
        }
        GeoChart.prototype.updateSettings = function (changes) {
            _super.prototype.updateSettings.call(this, changes);
            return this;
        };
        GeoChart.prototype.replaceSettings = function (changes) {
            _super.prototype.replaceSettings.call(this, changes);
            return this;
        };
        GeoChart.prototype.addData = function (data, sourceId) {
            if (sourceId == null)
                sourceId = "default";
            this._impl.addData(data, sourceId);
        };
        GeoChart.prototype.replaceData = function (data, sourceId) {
            if (sourceId == null)
                sourceId = "default";
            this._impl.replaceData(data, sourceId);
        };
        GeoChart.prototype.hideMenu = function () {
            this._impl.hideMenu();
            return this;
        };
        GeoChart.prototype.getNode = function (id) {
            return this._impl.getNode(id);
        };
        /**@ignore*/
        GeoChart.prototype.showNode = function (id) {
            return this._impl.addFocusNode(id, 0.9);
        };
        /**@ignore*/
        GeoChart.prototype.hideNode = function (id) {
            return this._impl.hideNode(id);
        };
        /**@ignore*/
        GeoChart.prototype.expandNode = function (id) {
            return this._impl.expandNode(id);
        };
        /**@ignore*/
        GeoChart.prototype.collapseNode = function (id) {
            return this._impl.collapseNode(id);
        };
        /** Updates (recalculates) the style for the whole chart or specific objects matching the given IDs.
        @param objects - A list of IDs for the objects which need their style recalculated */
        GeoChart.prototype.updateStyle = function (objects) {
            if (!objects) {
                this._impl.updateStyle(null);
            }
            else {
                if (this._impl.renderer) {
                    this._impl.renderer.touchObjects(objects);
                    this._impl.events.requestPaint();
                }
            }
        };
        /**
         * Set/Get selected objects.
         * @param selected - array of objects identifiers to select. Do not pass this parameter if you don't want to change current selection.
         * @returns currently selected objects.
         */
        GeoChart.prototype.selection = function (selected) {
            if (selected) {
                this._impl.setSelection(selected);
            }
            return this._impl.scene.selection;
        };
        GeoChart.prototype.bounds = function (bounds) {
            if (bounds) {
                this._impl.setBounds(bounds);
            }
            var r = this._impl.scene.getVisibleBoundsLatLon();
            return {
                east: r.x1,
                north: r.y1,
                west: r.x0,
                south: r.y0
            };
        };
        GeoChart.prototype.back = function () {
            this._impl.back();
            return this;
        };
        /** @ignore */
        GeoChart.prototype.zoomIn = function (objects, animate) {
            if (animate === void 0) { animate = true; }
            if (animate == null)
                animate = true; // ported from CoffeeScript;
            // Zooms in to list of objects
            return this._impl.zoomIn(objects, animate);
        };
        GeoChart.prototype.zoomLevel = function (newZoom) {
            if (newZoom) {
                this._impl.setZoomLevel(newZoom);
            }
            return this._impl.scene.zoomLevel;
        };
        GeoChart.prototype.getNodeDimensions = function (node) {
            /* returns dimensions object on screen
            x, y, radius, hwidth */
            return this._impl.getNodeDimensions(node);
        };
        /**
        Returns the Leaflet.Map object to enable any advanced customizations.

        Please note that this method might return `null` if `leaflet.js` has not been loaded yet.
        If `leaflet.js` is not loaded synchronously in the page, it will be loaded on demand by GeoChart.
        In this case the map object will not be available until the load is finished.
        
        To handle this scenario, subscribe to `onChartUpdate` event and verify if this method returns non-null value.
        @experimental
        */
        GeoChart.prototype.leaflet = function () {
            return this._impl.getMap();
        };
        GeoChart.prototype.on = function (name, listener) {
            _super.prototype.on.call(this, name, listener);
        };
        GeoChart.themes = {
            "flat": ZoomCharts.Internal.GeoChart.Settings.FlatTheme,
        };
        /**
         * An internal method that is used by the test runner engine to automatically pass the generated settings when a new chart instance is created.
         * @ignore
         */
        GeoChart.chartFactoryMethod = null;
        return GeoChart;
    }(ZoomCharts.Internal.Base.Api));
    ZoomCharts.GeoChart = GeoChart;
    ZoomCharts.Internal.Base.Helpers.exportSymbol("GeoChart", ZoomCharts.GeoChart);
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var Layouts;
            (function (Layouts) {
                var SpringEdge = (function () {
                    function SpringEdge(to, strength, len, vis, direction) {
                        /** target node */
                        this.to = null;
                        /** spring constant of the edge */
                        this.K = 0;
                        /** desired length of the edge */
                        this.len = 0;
                        /** strength of the edge */
                        this.strength = 0;
                        this.vis = 0;
                        this.direction = null;
                        this.to = to;
                        this.vis = vis;
                        this.len = len;
                        this.strength = strength;
                        this.direction = direction;
                    }
                    return SpringEdge;
                }());
                Layouts.SpringEdge = SpringEdge;
                var SpringNode = (function () {
                    function SpringNode() {
                        /** position */
                        this.x = 0;
                        this.y = 0;
                        this.z = 0;
                        this.r = 1;
                        this.zattr = 1;
                        /** repulsive force */
                        this.repulsiveForceX = 0;
                        this.repulsiveForceY = 0;
                        this.repulsiveForceZ = 0;
                        this.component = 0;
                        this.locked = false;
                        this.offsetX = 0;
                        this.offsetY = 0;
                        this.minr = 0;
                        /** accumulated value of spring constants (K) of all edges adjacent to
                        the node */
                        this.fsum = 0;
                        /** list of SpringEdge */
                        this.edges = [];
                    }
                    return SpringNode;
                }());
                Layouts.SpringNode = SpringNode;
                var RepulsiveTreeNode = (function (_super) {
                    __extends(RepulsiveTreeNode, _super);
                    function RepulsiveTreeNode() {
                        _super.apply(this, arguments);
                        this.forceLinkList = null;
                        this.fx = 0;
                        this.fy = 0;
                        this.sizeEstimate = 0;
                        this.left = null;
                        this.right = null;
                        this.leafCount = 0;
                        this.leaves = null;
                    }
                    return RepulsiveTreeNode;
                }(SpringNode));
                Layouts.RepulsiveTreeNode = RepulsiveTreeNode;
            })(Layouts = NetChart.Layouts || (NetChart.Layouts = {}));
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="SpringNodes.ts"/>
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var Layouts;
            (function (Layouts) {
                var BHTree = (function () {
                    function BHTree() {
                        this.maxLeafCount = 5;
                        this.root = null;
                        this.freeNodeRoot = null;
                        // Spring embedder temperature
                        this.temperature = 0;
                        this.nodeCount = 0;
                    }
                    /*
                    public static test() {
                        let t = new BHTree();
                        t.maxLeafCount = 2;
                        t.temperature = 1;
                        let nodes = new Array<SpringNode>();
                        let base = {
                            z: 0,
                            dx: 0,
                            dy: 0,
                            dz: 0,
                            repulsiveForceX: 0,
                            repulsiveForceY: 0,
                            repulsiveForceZ: 0,
                            fsum: 0
                        };
            
                        nodes.push(Base.Helpers.extend({ r: 5, x: 10, y: 10 }, base));
                        nodes.push(Base.Helpers.extend({ r: 5, x: 0, y: 0 }, base));
                        nodes.push(Base.Helpers.extend({ r: 5, x: 0, y: 10 }, base));
                        nodes.push(Base.Helpers.extend({ r: 5, x: 10, y: 0 }, base));
                        nodes.push(Base.Helpers.extend({ r: 5, x: 10, y: 10 }, base));
                        nodes.push(Base.Helpers.extend({ r: 5, x: 20, y: 0 }, base));
                        nodes.push(Base.Helpers.extend({ r: 5, x: 25, y: 0 }, base));
                        return t.buildTree(nodes);
                    }
                    */
                    /** Swaps two elements in an array. */
                    BHTree._swap = function (arr, a, b) {
                        var p = arr[a];
                        arr[a] = arr[b];
                        arr[b] = p;
                    };
                    BHTree.prototype.buildTree = function (nodeArray) {
                        this.iters = 0;
                        var count = nodeArray.length;
                        if (this.root) {
                            this.freeNode(this.root);
                        }
                        this.root = this.newNode();
                        if (count > 0) {
                            this.buildTreeRecursive(nodeArray, 0, count, this.root);
                        }
                        // calculate the node forces
                        for (var i = 0; i <= count - 1; i++) {
                            nodeArray[i].repulsiveForceX = 0;
                            nodeArray[i].repulsiveForceY = 0;
                            nodeArray[i].repulsiveForceZ = 0;
                        }
                        this.calculateForces();
                    };
                    /** Stores the nodes for reuse. */
                    BHTree.prototype.freeNode = function (node) {
                        if (node.left) {
                            this.freeNode(node.left);
                        }
                        if (node.right) {
                            this.freeNode(node.right);
                        }
                        node.left = this.freeNodeRoot;
                        this.freeNodeRoot = node;
                    };
                    /** Allocates a new node. It reuses any free node if it exists. */
                    BHTree.prototype.newNode = function () {
                        var node;
                        if (this.freeNodeRoot) {
                            node = this.freeNodeRoot;
                            this.freeNodeRoot = node.left;
                            node.left = null;
                            node.right = null;
                            node.leafCount = 0;
                            node.sizeEstimate = 0;
                            node.forceLinkList.length = 0;
                        }
                        else {
                            node = new Layouts.RepulsiveTreeNode();
                            node.forceLinkList = [];
                            node.leaves = new Array(this.maxLeafCount);
                        }
                        node.repulsiveForceX = 0;
                        node.repulsiveForceY = 0;
                        node.repulsiveForceZ = 0;
                        return node;
                    };
                    /** Adds and edge of possible force interaction between the
                    specified nodes. */
                    BHTree.prototype.addForceLink = function (source, target) {
                        source.forceLinkList.push(target);
                    };
                    /** Calculates the median index of the point array x
                    coordinates in the specified range.
                    In addition it sorts the array range such that all elemnts with smaller
                    x than the median are below median element, and all elemnts with larger
                    x are above the median. */
                    BHTree.prototype.getMedianX = function (arr, low, high) {
                        high -= 1;
                        var median = ((low + high) / 2) | 0;
                        while (true) {
                            if (high <= low) {
                                // One element only
                                return median;
                            }
                            if (high === low + 1) {
                                // Two elements only
                                if (arr[low].x > arr[high].x) {
                                    BHTree._swap(arr, low, high);
                                    return median;
                                }
                            }
                            /* Find median of low, middle and high items swap into position
                            low */
                            var middle = ((low + high) / 2) | 0;
                            if (arr[middle].x > arr[high].x) {
                                BHTree._swap(arr, middle, high);
                            }
                            if (arr[low].x > arr[high].x) {
                                BHTree._swap(arr, low, high);
                            }
                            if (arr[middle].x > arr[low].x) {
                                BHTree._swap(arr, middle, low);
                            }
                            // Swap low item (now in position middle) into position (low+1)
                            BHTree._swap(arr, middle, low + 1);
                            // Nibble from each end towards middle, swapping items when stuck
                            var ll = low + 1;
                            var hh = high;
                            while (true) {
                                while (true) {
                                    ll += 1;
                                    if (!(arr[low].x > arr[ll].x)) {
                                        break;
                                    }
                                }
                                while (true) {
                                    hh -= 1;
                                    if (!(arr[hh].x > arr[low].x)) {
                                        break;
                                    }
                                }
                                if (hh < ll) {
                                    break;
                                }
                                // swap(arr, ll, hh)
                                var tmp = arr[ll];
                                arr[ll] = arr[hh];
                                arr[hh] = tmp;
                            }
                            // Swap middle item (in position low) back into correct position
                            BHTree._swap(arr, low, hh);
                            // Re-set active partition
                            if (hh <= median) {
                                low = ll;
                            }
                            if (hh >= median) {
                                high = hh - 1;
                            }
                        }
                    };
                    /** Calculates the median index of the point array y
                    coordinates in the specified range.
                    In addition it sorts the array range such that all elemnts with smaller
                    y than the median are below median element, and all elemnts with larger
                    y are above the median. */
                    BHTree.prototype.getMedianY = function (arr, low, high) {
                        high -= 1;
                        var median = ((low + high) / 2) | 0;
                        while (true) {
                            if (high <= low) {
                                // One element only
                                return median;
                            }
                            if (high === low + 1) {
                                // Two elements only
                                if (arr[low].y > arr[high].y) {
                                    BHTree._swap(arr, low, high);
                                }
                                return median;
                            }
                            /* Find median of low, middle and high items swap into position
                            low */
                            var middle = ((low + high) / 2) | 0;
                            if (arr[middle].y > arr[high].y) {
                                BHTree._swap(arr, middle, high);
                            }
                            if (arr[low].y > arr[high].y) {
                                BHTree._swap(arr, low, high);
                            }
                            if (arr[middle].y > arr[low].y) {
                                BHTree._swap(arr, middle, low);
                            }
                            // Swap low item (now in position middle) into position (low+1)
                            BHTree._swap(arr, middle, low + 1);
                            // Nibble from each end towards middle, swapping items when stuck
                            var ll = low + 1;
                            var hh = high;
                            while (true) {
                                while (true) {
                                    ll += 1;
                                    if (!(arr[low].y > arr[ll].y)) {
                                        break;
                                    }
                                }
                                while (true) {
                                    hh -= 1;
                                    if (!(arr[hh].y > arr[low].y)) {
                                        break;
                                    }
                                }
                                if (hh < ll) {
                                    break;
                                }
                                // swap(arr, ll, hh)
                                var tmp = arr[ll];
                                arr[ll] = arr[hh];
                                arr[hh] = tmp;
                            }
                            // Swap middle item (in position low) back into correct position
                            BHTree._swap(arr, low, hh);
                            // Re-set active partition
                            if (hh <= median) {
                                low = ll;
                            }
                            if (hh >= median) {
                                high = hh - 1;
                            }
                        }
                    };
                    /** Rrecursive tree building.
                    Note that hi endpoint is not included.
                    The order of points in the array is changed. */
                    BHTree.prototype.buildTreeRecursive = function (nodeArray, start, end, subtree) {
                        // calculate current bounds
                        var x1 = nodeArray[start].x;
                        var y1 = nodeArray[start].y;
                        var x2 = x1;
                        var y2 = y1;
                        for (var i = start + 1; i <= end - 1; i++) {
                            var p = nodeArray[i];
                            var x = p.x;
                            var y = p.y;
                            if (x < x1) {
                                x1 = x;
                            }
                            if (x > x2) {
                                x2 = x;
                            }
                            if (y < y1) {
                                y1 = y;
                            }
                            if (y > y2) {
                                y2 = y;
                            }
                        }
                        subtree.sizeEstimate = Math.max(x2 - x1, y2 - y1);
                        subtree.sizeEstimate = subtree.sizeEstimate * subtree.sizeEstimate + 0.1;
                        subtree.sizeEstimate *= 2;
                        var count = end - start;
                        // form a leaf if too few points
                        if (count <= this.maxLeafCount) {
                            subtree.leafCount = count;
                            var x = 0;
                            var y = 0;
                            var z = 0;
                            var r = 0;
                            for (var i = 0; i <= count - 1; i++) {
                                var node = nodeArray[i + start];
                                x += node.x;
                                y += node.y;
                                z += node.z;
                                r += node.r;
                                subtree.leaves[i] = node;
                            }
                            var invcnt_1 = 1.0 / count;
                            subtree.r = r;
                            subtree.x = x * invcnt_1;
                            subtree.y = y * invcnt_1;
                            subtree.z = z * invcnt_1;
                            return;
                        }
                        // split
                        var median;
                        if (x2 - x1 > y2 - y1) {
                            median = this.getMedianX(nodeArray, start, end);
                        }
                        else {
                            median = this.getMedianY(nodeArray, start, end);
                        }
                        median++;
                        var child = this.newNode();
                        subtree.left = child;
                        this.buildTreeRecursive(nodeArray, start, median, child);
                        child = this.newNode();
                        subtree.right = child;
                        this.buildTreeRecursive(nodeArray, median, end, child);
                        var invcnt = 1.0 / count;
                        subtree.r = subtree.right.r + subtree.left.r;
                        subtree.x = (subtree.left.x * (median - start) + subtree.right.x * (end - median)) * invcnt;
                        subtree.y = (subtree.left.y * (median - start) + subtree.right.y * (end - median)) * invcnt;
                        subtree.z = (subtree.left.z * (median - start) + subtree.right.z * (end - median)) * invcnt;
                    };
                    /** Calculates the repulsive forces among all the particles. */
                    BHTree.prototype.calculateForces = function () {
                        var queue = new Array(this.nodeCount);
                        var queueStart = 0;
                        var queueEnd = 0;
                        if (this.root.left !== null) {
                            queue[queueEnd] = this.root.left;
                            queueEnd++;
                            queue[queueEnd] = this.root.right;
                            queueEnd++;
                            this.addForceLink(this.root.left, this.root.right);
                        }
                        else {
                            queue[queueEnd] = this.root;
                            queueEnd++;
                        }
                        while (queueStart < queueEnd) {
                            var node = queue[queueStart];
                            queueStart++;
                            var invr = 1.0 / node.r;
                            if (node.left !== null) {
                                this.processTreeNode(node, node.left);
                                this.processTreeNode(node, node.right);
                                queue[queueEnd] = node.left;
                                queueEnd++;
                                queue[queueEnd] = node.right;
                                queueEnd++;
                                var factor = node.left.r * invr;
                                var forceX = node.repulsiveForceX * factor;
                                var forceY = node.repulsiveForceY * factor;
                                node.left.repulsiveForceX += forceX;
                                node.left.repulsiveForceY += forceY;
                                node.right.repulsiveForceX += node.repulsiveForceX - forceX;
                                node.right.repulsiveForceY += node.repulsiveForceY - forceY;
                                this.addForceLink(node.left, node.right);
                            }
                            else {
                                for (var i = 0; i <= node.leafCount - 1; i++) {
                                    var node1 = node.leaves[i];
                                    this.processLeafNode(node, node1);
                                    var factor = node1.r * invr;
                                    node1.repulsiveForceX += node.repulsiveForceX * factor;
                                    node1.repulsiveForceY += node.repulsiveForceY * factor;
                                    for (var k = i + 1; k <= node.leafCount - 1; k++) {
                                        var node2 = node.leaves[k];
                                        this.forceBetweenParticles(node1, node2);
                                    }
                                }
                            }
                            // cleanup
                            node.forceLinkList.length = 0;
                        }
                    };
                    /** Calculates the force on a given subdivision.
                    @param node the root of the subtree
                    @param subtree the branch for which force is to be calculated */
                    BHTree.prototype.processTreeNode = function (node, subtree) {
                        var length = node.forceLinkList.length;
                        // iteration by index is faster
                        for (var i = 0; i <= length - 1; i++) {
                            var otherNode = node.forceLinkList[i];
                            var vx = subtree.x - otherNode.x;
                            var vy = subtree.y - otherNode.y;
                            var len = vx * vx + vy * vy;
                            var threshold = subtree.sizeEstimate;
                            if (otherNode instanceof Layouts.RepulsiveTreeNode) {
                                threshold += otherNode.sizeEstimate;
                            }
                            if (threshold < len) {
                                var w = subtree.r * otherNode.r / (len * Math.sqrt(len));
                                var fx = vx * w;
                                subtree.repulsiveForceX += fx;
                                otherNode.repulsiveForceX -= fx;
                                var fy = vy * w;
                                subtree.repulsiveForceY += fy;
                                otherNode.repulsiveForceY -= fy;
                            }
                            else {
                                if (otherNode instanceof Layouts.RepulsiveTreeNode) {
                                    this.addForceLink(otherNode, subtree);
                                }
                                else {
                                    this.addForceLink(subtree, otherNode);
                                }
                            }
                        }
                    };
                    /** Calculates the force on a given leaf node.
                    @param node the root of the subtree
                    @param subtree the branch for which force is to be calculated */
                    BHTree.prototype.processLeafNode = function (node, subtree) {
                        for (var otherNodeIndex = 0; otherNodeIndex < node.forceLinkList.length; otherNodeIndex++) {
                            var otherNode = node.forceLinkList[otherNodeIndex];
                            if (!(otherNode instanceof Layouts.RepulsiveTreeNode)) {
                                this.forceBetweenParticles(subtree, otherNode);
                            }
                            else {
                                var vx = subtree.x - otherNode.x;
                                var vy = subtree.y - otherNode.y;
                                var len = vx * vx + vy * vy;
                                var threshold = otherNode.sizeEstimate;
                                if (threshold < len) {
                                    var w = subtree.r * otherNode.r / (len * Math.sqrt(len));
                                    var fx = vx * w;
                                    subtree.repulsiveForceX += fx;
                                    otherNode.repulsiveForceX -= fx;
                                    var fy = vy * w;
                                    subtree.repulsiveForceY += fy;
                                    otherNode.repulsiveForceY -= fy;
                                }
                                else {
                                    this.addForceLink(otherNode, subtree);
                                }
                            }
                        }
                    };
                    /** Calculates the force between two spring nodes. */
                    BHTree.prototype.forceBetweenParticles = function (node1, node2) {
                        var vx1 = node1.x - node2.x;
                        var vy1 = node1.y - node2.y;
                        var vz1 = node1.z - node2.z;
                        var len1 = vx1 * vx1 + vy1 * vy1 + vz1 * vz1;
                        var r = node1.r + node2.r;
                        var w;
                        if (len1 * this.temperature < r) {
                            w = 0.25 * this.temperature * Math.sqrt(this.temperature * r);
                        }
                        else {
                            w = 0.25 * r * r / (len1 * Math.sqrt(len1));
                        }
                        node1.repulsiveForceX += vx1 * w;
                        node2.repulsiveForceX -= vx1 * w;
                        node1.repulsiveForceY += vy1 * w;
                        node2.repulsiveForceY -= vy1 * w;
                        node1.repulsiveForceZ += vz1 * w;
                        node2.repulsiveForceZ -= vz1 * w;
                    };
                    return BHTree;
                }());
                Layouts.BHTree = BHTree;
            })(Layouts = NetChart.Layouts || (NetChart.Layouts = {}));
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var Layouts;
            (function (Layouts) {
                var LayoutBase = (function (_super) {
                    __extends(LayoutBase, _super);
                    function LayoutBase(chart) {
                        _super.call(this);
                        this.animationOrder = 600;
                        this.paintOrder = 10;
                        this.updateOrder = 1600; // after navigator
                        this.chart = chart;
                    }
                    LayoutBase.ConstructLayout = function (chart) {
                        switch (chart.settings.layout.mode) {
                            case "dynamic":
                                return new Layouts.TimedSpringEmbedder(chart);
                            case "radial":
                                return new Layouts.RadialLayout(chart);
                            case "hierarchy":
                                return new Layouts.HierarchyLayout(chart);
                            case "static":
                                return new Layouts.StaticLayout(chart);
                            default:
                                chart.error("Unknown layout mode: '" + chart.settings.layout.mode + "'");
                                return new Layouts.TimedSpringEmbedder(chart);
                        }
                    };
                    return LayoutBase;
                }(Internal.Base.ChartElement));
                Layouts.LayoutBase = LayoutBase;
            })(Layouts = NetChart.Layouts || (NetChart.Layouts = {}));
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="SpringNodes.ts"/>
/// <reference path="BHTree.ts" />
/// <reference path="LayoutBase.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var Layouts;
            (function (Layouts) {
                var TimedSpringEmbedder = (function (_super) {
                    __extends(TimedSpringEmbedder, _super);
                    function TimedSpringEmbedder(chart) {
                        _super.call(this, chart);
                        // --------------------------------------------------------------------
                        // Layout parameters
                        // --------------------------------------------------------------------
                        this.nodeRepulsionFactor = 15;
                        this.componentCenterFactor = 0.005;
                        this.linkForceFactor = 0.2;
                        this.nodeDegreeModifier = 1.2;
                        this.forceReductionFactor = 1;
                        this.stability = 1;
                        this.temperature = 0;
                        /** the unit temperature */
                        this.unitTemperature = 0;
                        this.randomLayoutRadius = 0;
                        /** initial value = nodeRepulsionFactor / 10 */
                        this.zAxisAttraction = 1;
                        /**
                         * Contains nodes for repulsion. Nodes with outerBounds = null are omitted
                         */
                        this.nodesForRepulsion = null;
                        /** the data structure for repulsive force calculation
                         new RepulsiveKFTree() */
                        this.repulsiveForceTree = null;
                        this.globalForceX = 0;
                        this.globalForceY = 0;
                        this.centerX = 0;
                        this.centerY = 0;
                        this.aspectRatio = null;
                        this.idleSince = 0;
                        this.noMovementSince = 0;
                        this.layoutMovement = 0;
                        this.random = new Internal.Base.Random(1);
                        // create arrays
                        this.nodeCount = 0;
                        // SpringNode
                        this.nodes = [];
                        this.forceX = [];
                        this.forceY = [];
                        this.forceZ = [];
                        this.forceSum = [];
                        this.oldForceX = [];
                        this.oldForceY = [];
                        this.oldForceZ = [];
                        this.componentX = [];
                        this.componentY = [];
                        this.componentSum = [];
                        this.componentNodeCount = [];
                        this.nodesForRepulsion = [];
                        // average height / average width
                        this.nodesAspect = 1;
                        this.idToIndex = {};
                        this.repulsiveForceTree = new Layouts.BHTree();
                    }
                    TimedSpringEmbedder.prototype.updateParams = function (spacing, nodeDegreeModifier, aspectRatio) {
                        this.aspectRatio = aspectRatio;
                        this.nodeDegreeModifier = nodeDegreeModifier;
                        this.spacing = spacing;
                    };
                    TimedSpringEmbedder.prototype.updateGraph = function (nodes, links, topologyChanges) {
                        /*
                        Node:
                          id
                          x
                          y
                          visibility
                          locked
                          outerBounds
                        Link:
                         form
                         to
                         strength
                         length
                         */
                        topologyChanges = topologyChanges || (nodes.length !== this.nodeCount);
                        if (topologyChanges) {
                            // migrate nodes to new array
                            var oldNodes = this.nodes;
                            var oldOldForceX = this.oldForceX;
                            var oldOldForceY = this.oldForceY;
                            var oldOldForceZ = this.oldForceZ;
                            var oldIdToIndex = this.idToIndex;
                            this.nodeCount = nodes.length;
                            this.oldForceX = new Array(this.nodeCount);
                            this.oldForceY = new Array(this.nodeCount);
                            this.oldForceZ = new Array(this.nodeCount);
                            this.forceX = new Array(this.nodeCount);
                            this.forceY = new Array(this.nodeCount);
                            this.forceZ = new Array(this.nodeCount);
                            this.forceSum = new Array(this.nodeCount);
                            this.nodes = new Array(this.nodeCount);
                            this.idToIndex = {};
                            var nodesAspect = 0;
                            var nodesAspectCount = 0;
                            for (var idx = 0; idx < nodes.length; idx++) {
                                var layerNode = nodes[idx];
                                var id = layerNode.id;
                                var node = new Layouts.SpringNode();
                                node.edges = [];
                                var width = layerNode.outerBounds.w();
                                var height = layerNode.outerBounds.h();
                                if (height > 0) {
                                    nodesAspect += height / width;
                                    nodesAspectCount += 1;
                                }
                                this.idToIndex[id] = idx;
                                this.nodes[idx] = node;
                                if (oldIdToIndex.hasOwnProperty(id)) {
                                    var oldIdx = oldIdToIndex[id];
                                    var oldNode = oldNodes[oldIdx];
                                    node.z = oldNode.z;
                                    this.oldForceX[idx] = oldOldForceX[oldIdx];
                                    this.oldForceY[idx] = oldOldForceY[oldIdx];
                                    this.oldForceZ[idx] = oldOldForceZ[oldIdx];
                                }
                                else {
                                    this.oldForceX[idx] = 0;
                                    this.oldForceY[idx] = 0;
                                    this.oldForceZ[idx] = 0;
                                }
                            }
                            this.nodesForRepulsion = this.nodes.slice();
                            if (nodesAspectCount > 0) {
                                this.nodesAspect = Math.max(0.3, (nodesAspect / nodesAspectCount));
                            }
                            else {
                                this.nodesAspect = 1;
                            }
                        }
                        for (var idx = 0; idx < nodes.length; idx++) {
                            var layerNode = nodes[idx];
                            var nn = this.nodes[idx];
                            var width = layerNode.outerBounds.w();
                            var height = layerNode.outerBounds.h();
                            nn.offsetX = layerNode.outerBounds.x0 + layerNode.outerBounds.x1;
                            nn.offsetY = layerNode.outerBounds.y0 + layerNode.outerBounds.y1;
                            nn.x = layerNode.x + nn.offsetX;
                            nn.y = layerNode.y + nn.offsetY;
                            nn.r = Math.max(1, width) * 0.5;
                            nn.minr = Math.max(1, (height + width * 0.5) / 3);
                            nn.zattr = layerNode.visibility;
                            nn.edges.length = 0;
                            nn.locked = layerNode.locked;
                            this.forceX[idx] = 0;
                            this.forceY[idx] = 0;
                            this.forceZ[idx] = 0;
                            this.forceSum[idx] = 0;
                        }
                        // build links
                        var directionReverse = {
                            "U": "D",
                            "null": null,
                            "D": "U",
                            "L": "R",
                            "R": "L"
                        };
                        for (var linkIndex = 0; linkIndex < links.length; linkIndex++) {
                            var link = links[linkIndex];
                            var strength = link.strength;
                            var length = link.length;
                            var vis = link.visibility;
                            var from = this.nodes[this.idToIndex[link.from.id]];
                            var to = this.nodes[this.idToIndex[link.to.id]];
                            if (!from || !to) {
                                Internal.Base.Helpers.log("Layout: missing node for link: " + link.from.id + " " + link.to.id + ", topology = " + topologyChanges);
                                continue;
                            }
                            if (from === to) {
                                continue;
                            }
                            from.edges.push(new Layouts.SpringEdge(to, strength, length, vis, link.direction));
                            to.edges.push(new Layouts.SpringEdge(from, strength, length, vis, directionReverse[link.direction]));
                        }
                        if (topologyChanges) {
                            this.computeComponents();
                        }
                        // adjust node sized depending on the degree of neighbor nodes
                        var spacing = this.spacing / 2;
                        for (var nIndex = 0; nIndex < this.nodes.length; nIndex++) {
                            var node = this.nodes[nIndex];
                            var sum = 0;
                            for (var eIndex = 0; eIndex < node.edges.length; eIndex++) {
                                var e = node.edges[eIndex];
                                sum += e.to.edges.length * e.vis;
                            }
                            var w = Math.sqrt(sum);
                            node.r += spacing;
                            node.minr += spacing;
                            if (w > 4) {
                                node.r += (w - 4) * node.r / 4 * this.nodeDegreeModifier;
                                node.minr += (w - 4) * node.minr / 4 * this.nodeDegreeModifier;
                            }
                        }
                        /* calculate edge length and spring constants
                        as well as unit temperature
                        */
                        var lenSum = 0;
                        var radSum = 0;
                        var relevantEdgeCount = 0;
                        for (var nIndex = 0; nIndex < this.nodes.length; nIndex++) {
                            var node = this.nodes[nIndex];
                            var fsum = 0;
                            for (var eIndex = 0; eIndex < node.edges.length; eIndex++) {
                                var e = node.edges[eIndex];
                                var ton = e.to;
                                if (node.locked && ton.locked || (node === ton)) {
                                    continue;
                                }
                                relevantEdgeCount++;
                                var desiredLen = (node.minr + ton.minr);
                                if (e.len > 0) {
                                    var lengthProp = e.len;
                                    var desiredStrength = Math.min(20, e.strength);
                                    e.len = Math.max(1, desiredLen * lengthProp);
                                    e.K = desiredStrength * 30 / e.len;
                                    fsum += e.K;
                                    lenSum += e.len;
                                }
                                else {
                                    // zero length links
                                    var desiredStrength = e.strength;
                                    e.K = desiredStrength;
                                    fsum += e.K;
                                    lenSum += desiredLen;
                                }
                            }
                            node.fsum = fsum;
                            radSum += node.r * node.r;
                        }
                        if (relevantEdgeCount > 0) {
                            this.randomLayoutRadius = Math.max(1, lenSum / 10);
                            this.unitTemperature = lenSum / relevantEdgeCount / 50;
                        }
                        else {
                            this.randomLayoutRadius = Math.max(1, Math.sqrt(radSum));
                            this.unitTemperature = 1;
                        }
                    };
                    TimedSpringEmbedder.prototype.computeComponents = function () {
                        this.componentX = [];
                        this.componentY = [];
                        this.componentSum = [];
                        this.componentNodeCount = [];
                        var queue = new Array(this.nodeCount);
                        for (var nodeIndex = 0; nodeIndex < this.nodes.length; nodeIndex++) {
                            var node = this.nodes[nodeIndex];
                            node.component = -1;
                        }
                        var component = 0;
                        for (var nodeIndex = 0; nodeIndex < this.nodes.length; nodeIndex++) {
                            var node = this.nodes[nodeIndex];
                            if (node.component >= 0) {
                                continue;
                            }
                            node.component = component;
                            var componentNodes = 0;
                            var start = 0;
                            var end = 0;
                            queue[end] = node;
                            end += 1;
                            while (start < end) {
                                node = queue[start];
                                start += 1;
                                componentNodes += 1;
                                // add linked nodes
                                for (var eIndex = 0; eIndex < node.edges.length; eIndex++) {
                                    var e = node.edges[eIndex];
                                    var n2 = e.to;
                                    if (n2.component === -1) {
                                        n2.component = component;
                                        queue[end] = n2;
                                        end += 1;
                                    }
                                }
                            }
                            this.componentNodeCount.push(componentNodes);
                            this.componentX.push(0);
                            this.componentY.push(0);
                            this.componentSum.push(0);
                            component += 1;
                        }
                    };
                    TimedSpringEmbedder.prototype.updateComponents = function () {
                        // compute component centers
                        for (var i = 0; i <= this.componentNodeCount.length - 1; i++) {
                            this.componentX[i] = 0;
                            this.componentY[i] = 0;
                            this.componentSum[i] = 0;
                        }
                        for (var nodeIndex = 0; nodeIndex < this.nodes.length; nodeIndex++) {
                            var node = this.nodes[nodeIndex];
                            var i = node.component;
                            this.componentX[i] += node.x * node.r;
                            this.componentY[i] += node.y * node.r;
                            this.componentSum[i] += node.r;
                        }
                        for (var i = 0; i <= this.componentNodeCount.length - 1; i++) {
                            this.componentX[i] /= this.componentSum[i];
                            this.componentY[i] /= this.componentSum[i];
                        }
                    };
                    TimedSpringEmbedder.prototype.globalLayout = function (nodes, timeout, resetPositions) {
                        // some simple cases
                        if (this.nodeCount <= 0) {
                            return;
                        }
                        // make starting layout by randomly distributing nodes on a circle
                        if (resetPositions) {
                            if (this.nodeCount === 1) {
                                nodes[0].x = nodes[0].y = 0;
                                return;
                            }
                            else {
                                this.initialRandomLayout();
                            }
                        }
                        // calculate the iteration count
                        var numberOfMovingNodes = 0;
                        for (var nodeIndex = 0; nodeIndex < this.nodes.length; nodeIndex++) {
                            var node = this.nodes[nodeIndex];
                            if (!node.locked) {
                                numberOfMovingNodes++;
                            }
                        }
                        var step = Math.floor(Math.sqrt(numberOfMovingNodes) + 10);
                        var iter = step * 2;
                        // calculate the strarting temperature
                        this.forceReductionFactor = 1;
                        this.temperature = (Math.sqrt(numberOfMovingNodes) * 2 + 20) * this.unitTemperature;
                        this.zAxisAttraction = 0.02;
                        var t0 = new Date().getTime();
                        // do the iterations
                        var i1 = 3;
                        while (this.temperature > this.unitTemperature) {
                            if ((iter--) <= 0) {
                                // decrease the temperature
                                iter = step * 3 / (i1++);
                                this.temperature = this.temperature / 1.5 - 0.5;
                                if (this.temperature < 20 * this.unitTemperature) {
                                    this.zAxisAttraction = this.zAxisAttraction * 1.5 + 0.02;
                                }
                            }
                            // randomize node order
                            this.randomnodesForRepulsion();
                            this.repulsiveForceTree.temperature = this.zAxisAttraction * 1.75;
                            this.repulsiveForceTree.buildTree(this.nodesForRepulsion);
                            // move the nodes
                            this.moveNodesGlobal();
                            if (new Date().getTime() > t0 + timeout) {
                                break;
                            }
                        }
                        if (resetPositions) {
                            this.centerNodes();
                        }
                        this.storeNodes(nodes);
                    };
                    /** make starting layout by randomly distributing nodes on a circle */
                    TimedSpringEmbedder.prototype.initialRandomLayout = function () {
                        var nc = this.nodeCount;
                        // shuffle the nodes
                        var perm = new Array(nc);
                        for (var i = 0; i <= nc - 1; i++) {
                            perm[i] = i;
                        }
                        for (var i = 0; i <= nc; i++) {
                            var i1 = Math.floor(this.random.get() * (nc - i)) + i;
                            var tmp = perm[i];
                            perm[i] = perm[i1];
                            perm[i1] = tmp;
                        }
                        var R = this.randomLayoutRadius;
                        var coef = 2 * Math.PI / this.nodeCount;
                        for (var j = 0; j < this.nodes.length; j++) {
                            var n = this.nodes[j];
                            this.oldForceX[j] = 0;
                            this.oldForceY[j] = 0;
                            this.oldForceZ[j] = 0;
                            n.z = this.random.get() - 0.5;
                            if (!n.locked) {
                                var r = R + n.r;
                                n.x = r * Math.cos(perm[j] * coef);
                                n.y = r * Math.sin(perm[j] * coef);
                            }
                        }
                    };
                    TimedSpringEmbedder.prototype.timedLayout = function (nodes, time) {
                        if (this.nodeCount <= 1 || !(time > 0)) {
                            return;
                        }
                        // calculate the iteration count
                        var iter = 0;
                        if (time < 0.1) {
                            iter = 2;
                            this.forceReductionFactor = Math.max(0.002, Math.min(this.forceReductionFactor, time * 10));
                        }
                        else {
                            iter = Math.min(6, Math.round(2 + time * 10));
                        }
                        this.zAxisAttraction = this.nodeRepulsionFactor / 28;
                        this.temperature = this.unitTemperature;
                        for (var x = 0; x <= iter - 1; x++) {
                            // randomize node order
                            this.randomnodesForRepulsion();
                            // shape repulsive force to aspect ratio
                            this.applyAspect(1 / this.nodesAspect);
                            this.repulsiveForceTree.temperature = this.zAxisAttraction * 1.75;
                            this.repulsiveForceTree.buildTree(this.nodesForRepulsion);
                            this.applyAspect(this.nodesAspect);
                            this.moveNodesIncremental();
                        }
                        // transfer back the node coordinates
                        this.storeNodes(nodes);
                    };
                    TimedSpringEmbedder.prototype.prepareAspectRatio = function (fraction) {
                        var n = this.nodes;
                        var x0 = n[0].x;
                        var y0 = n[0].y;
                        var x1 = x0;
                        var y1 = y0;
                        var ratio;
                        var side;
                        var scaleX;
                        var scaleY;
                        var incX;
                        var incY;
                        var invForce;
                        var aspectRatioPrepared = true;
                        for (var i = 1; i <= this.nodeCount - 1; i++) {
                            x0 = Math.min(x0, n[i].x);
                            x1 = Math.max(x1, n[i].x);
                            y0 = Math.min(y0, n[i].y);
                            y1 = Math.max(y1, n[i].y);
                        }
                        var cx = (x0 + x1) / 2;
                        var cy = (y0 + y1) / 2;
                        var sx = x1 - x0;
                        var sy = y1 - y0;
                        if (sx === 0 || sy === 0) {
                            // impossible to determine aspect ratio if the rect has no area
                            aspectRatioPrepared = false;
                        }
                        else {
                            ratio = Math.sqrt(this.aspectRatio);
                            side = Math.sqrt(sx * sy);
                            scaleX = side * ratio / sx;
                            scaleY = side / ratio / sy;
                            scaleX = fraction * scaleX + (1 - fraction);
                            scaleY = fraction * scaleY + (1 - fraction);
                            incX = cx - cx * scaleX;
                            incY = cy - cy * scaleY;
                            invForce = 1 / this.forceReductionFactor;
                        }
                        return {
                            scaleX: scaleX,
                            incX: incX,
                            scaleY: scaleY,
                            incY: incY,
                            invForce: invForce,
                            aspectRatioPrepared: aspectRatioPrepared
                        };
                    };
                    TimedSpringEmbedder.prototype.updateAspectRatioNode = function (params, node, i) {
                        // update forceXY to compensate next iteration
                        this.forceX[i] += (node.x * (params.scaleX - 1) + params.incX) * params.invForce;
                        this.forceY[i] += (node.y * (params.scaleY - 1) + params.incY) * params.invForce;
                    };
                    TimedSpringEmbedder.prototype.updateAspectRatio = function (fraction) {
                        var params = this.prepareAspectRatio(fraction);
                        var n = this.nodes;
                        for (var i = 0; i <= this.nodeCount - 1; i++) {
                            var node = n[i];
                            this.updateAspectRatioNode(params, node, i);
                        }
                    };
                    TimedSpringEmbedder.prototype.moveNodesGlobal = function () {
                        this.initIteration();
                        var randomness = this.temperature * 0.5;
                        var forceFactor = this.forceReductionFactor;
                        var aspectParams;
                        if (this.aspectRatio) {
                            aspectParams = this.prepareAspectRatio(0.005);
                            if (!aspectParams.aspectRatioPrepared) {
                                this.aspectRatio = null;
                            }
                        }
                        for (var i = 0; i <= this.nodeCount - 1; i++) {
                            var n1 = this.nodes[i];
                            if (n1.locked) {
                                continue;
                            }
                            this.calculateForce(i, 0.5);
                            if (this.aspectRatio) {
                                this.updateAspectRatioNode(aspectParams, n1, i);
                            }
                            // save the force
                            var fx = this.oldForceX[i] = this.forceX[i];
                            var fy = this.oldForceY[i] = this.forceY[i];
                            var fz = this.oldForceZ[i] = this.forceZ[i];
                            var fsum = this.forceSum[i];
                            // scale the force
                            fx *= fsum;
                            fy *= fsum;
                            fz *= fsum;
                            // if the force is too small then increase it
                            var len = fx * fx + fy * fy + fz * fz;
                            if (len < this.temperature * this.temperature && len > 0.001) {
                                len = this.temperature / Math.sqrt(len);
                                fx *= len;
                                fy *= len;
                                fz *= len;
                            }
                            // add some random and actually move the node
                            n1.x += fx * forceFactor + (this.random.get() - 0.5) * randomness;
                            n1.y += fy * forceFactor + (this.random.get() - 0.5) * randomness;
                            n1.z += fz * forceFactor + (this.random.get() - 0.5) * randomness;
                        }
                    };
                    TimedSpringEmbedder.prototype.moveNodesIncremental = function () {
                        this.initIteration();
                        for (var i = 0; i <= this.nodeCount - 1; i++) {
                            if (!this.nodes[i].locked) {
                                this.calculateForce(i, 0);
                            }
                        }
                        if (this.aspectRatio) {
                            var fraction = Math.min(0.4, 0.5 / Math.pow(this.nodeCount, 0.5));
                            this.updateAspectRatio(fraction);
                        }
                        // accumulate total oscillations and movement force
                        var oscilations = 0;
                        var movement = 0;
                        var scal = 0;
                        var len = 0;
                        var freezedNodes = new Array(this.nodeCount);
                        for (var i = 0; i <= this.nodeCount - 1; i++) {
                            if (this.nodes[i].locked) {
                                continue;
                            }
                            var dx = this.forceX[i];
                            var dy = this.forceY[i];
                            var dz = this.forceZ[i];
                            var fsum = this.forceSum[i];
                            var curLen = dx * dx + dy * dy + dz * dz;
                            if (curLen * fsum * fsum > this.unitTemperature * this.unitTemperature * 0.05 * 0.05) {
                                len += curLen;
                                var ss = this.oldForceX[i] * dx + this.oldForceY[i] * dy + this.oldForceZ[i] * dz;
                                scal += ss;
                                if (ss > 0) {
                                    movement += ss;
                                }
                                else {
                                    oscilations -= ss;
                                }
                            }
                            else {
                                freezedNodes[i] = true;
                            }
                        }
                        this.stability = (movement - oscilations * 5) / this.nodeCount;
                        // throttle force - increase if we have forward movement, decrease if we have oscilating movement
                        if (scal > 1e-7) {
                            this.forceReductionFactor *= 1 + 0.4 / 1.618033989;
                        }
                        else if (scal < -1e-7) {
                            this.forceReductionFactor /= 1.4;
                        }
                        // apply global force compensation (avoids drift)
                        var cfx = this.globalForceX / this.nodeCount;
                        var cfy = this.globalForceY / this.nodeCount;
                        for (var i = 0; i <= this.nodeCount - 1; i++) {
                            this.forceX[i] += cfx;
                            this.forceY[i] += cfy;
                        }
                        this.forceReductionFactor = Math.min(1, this.forceReductionFactor);
                        this.forceReductionFactor = Math.max(0.002, this.forceReductionFactor);
                        // actually move the nodes
                        for (var i = 0; i <= this.nodeCount - 1; i++) {
                            var n1 = this.nodes[i];
                            if (!n1.locked && !freezedNodes[i]) {
                                var fsum = this.forceSum[i] * this.forceReductionFactor;
                                n1.x += this.forceX[i] * fsum;
                                n1.y += this.forceY[i] * fsum;
                                n1.z += this.forceZ[i] * fsum;
                            }
                            this.oldForceX[i] = this.forceX[i];
                            this.oldForceY[i] = this.forceY[i];
                            this.oldForceZ[i] = this.forceZ[i];
                        }
                    };
                    TimedSpringEmbedder.prototype.initIteration = function () {
                        var cx = 0;
                        var cy = 0;
                        var sum = 0;
                        for (var nodeIndex = 0; nodeIndex < this.nodes.length; nodeIndex++) {
                            var node = this.nodes[nodeIndex];
                            sum += node.r;
                            cx += node.x * node.r;
                            cy += node.y * node.r;
                        }
                        this.centerX = cx / sum;
                        this.centerY = cy / sum;
                        this.updateComponents();
                        this.globalForceX = 0;
                        this.globalForceY = 0;
                    };
                    TimedSpringEmbedder.prototype.applyAspect = function (aspect) {
                        for (var nodeIndex = 0; nodeIndex < this.nodes.length; nodeIndex++) {
                            var node = this.nodes[nodeIndex];
                            node.y *= aspect;
                        }
                    };
                    TimedSpringEmbedder.prototype.calculateForce = function (nnum, fractionOfOld) {
                        // get the node
                        var n1 = this.nodes[nnum];
                        // take the reduced old force vector
                        var dx = this.oldForceX[nnum] * fractionOfOld;
                        var dy = this.oldForceY[nnum] * fractionOfOld;
                        var dz = this.oldForceZ[nnum] * fractionOfOld;
                        // add the attractive forces
                        for (var eIndex = 0; eIndex < n1.edges.length; eIndex++) {
                            var e = n1.edges[eIndex];
                            var n2 = e.to;
                            var edgeLen = e.len;
                            var vx = n1.x - n1.offsetX - n2.x + n2.offsetX;
                            var vy = n1.y - n1.offsetY - n2.y + n2.offsetY;
                            var vz = n1.z - n2.z;
                            // process direction
                            if (e.direction) {
                                if (e.direction === "U") {
                                    vy -= edgeLen;
                                    edgeLen = 0;
                                }
                                else if (e.direction === "D") {
                                    vy += edgeLen;
                                    edgeLen = 0;
                                }
                                else if (e.direction === "L") {
                                    vx -= edgeLen;
                                    edgeLen = 0;
                                }
                                else if (e.direction === "R") {
                                    vx += edgeLen;
                                    edgeLen = 0;
                                }
                            }
                            var len = Math.sqrt(vx * vx + vy * vy + vz * vz);
                            if (len < 0.01) {
                                len = 0.01;
                            }
                            var f = (edgeLen - len) * e.K / len * this.linkForceFactor;
                            dx += f * vx;
                            dy += f * vy;
                            dz += f * vz;
                        }
                        // add repulsive forces
                        dx += n1.repulsiveForceX * this.nodeRepulsionFactor;
                        dy += n1.repulsiveForceY * this.nodeRepulsionFactor;
                        dz += n1.repulsiveForceZ * this.nodeRepulsionFactor;
                        // add attraction force to the plane z = 0
                        var kz = n1.zattr * this.zAxisAttraction;
                        dz -= n1.z * kz;
                        // add attraction to center
                        var component = n1.component;
                        var cdx = this.componentX[component] - this.centerX;
                        var cdy = this.componentY[component] - this.centerY;
                        var csize = Math.min(10, Math.sqrt(this.componentNodeCount[component]));
                        var cfx = cdx * csize * this.componentCenterFactor;
                        var cfy = cdy * csize * this.componentCenterFactor;
                        dx -= cfx;
                        dy -= cfy;
                        this.globalForceX += cfx;
                        this.globalForceY += cfy;
                        if (isNaN(dx)) {
                            throw "Internal error: Nan in layout";
                        }
                        // save the force
                        this.forceX[nnum] = dx;
                        this.forceY[nnum] = dy;
                        this.forceZ[nnum] = dz;
                        if (n1.fsum + kz === 0) {
                            return;
                        }
                        this.forceSum[nnum] = 1.0 / (n1.fsum + kz);
                    };
                    TimedSpringEmbedder.prototype.storeNodes = function (nodes) {
                        for (var i = 0; i <= this.nodeCount - 1; i++) {
                            var ni = this.nodes[i];
                            if (!ni.locked) {
                                nodes[i].x = ni.x - ni.offsetX;
                                nodes[i].y = ni.y - ni.offsetY;
                            }
                        }
                    };
                    TimedSpringEmbedder.prototype.centerNodes = function () {
                        var random = new Internal.Base.Random(243178931);
                        var n = this.nodes;
                        var x0 = n[0].x;
                        var x1 = x0;
                        var y0 = n[0].y;
                        var y1 = y0;
                        for (var i = 1; i <= this.nodeCount - 1; i++) {
                            x0 = Math.min(x0, n[i].x);
                            x1 = Math.max(x1, n[i].x);
                            y0 = Math.min(y0, n[i].y);
                            y1 = Math.max(y1, n[i].y);
                        }
                        var cx = (x0 + x1) / 2;
                        var cy = (y0 + y1) / 2;
                        for (var i = 0; i <= this.nodeCount - 1; i++) {
                            var node = n[i];
                            node.x -= cx;
                            node.y -= cy;
                            if (!node.locked) {
                                var rr = node.r * 0.3;
                                node.x += random.get() * rr;
                                node.y += random.get() * rr;
                            }
                        }
                    };
                    TimedSpringEmbedder.prototype.randomnodesForRepulsion = function () {
                        for (var i = 0; i <= this.nodeCount - 1; i++) {
                            var i1 = Math.floor(this.random.get() * (this.nodeCount - i)) + i;
                            var tmp = this.nodesForRepulsion[i];
                            this.nodesForRepulsion[i] = this.nodesForRepulsion[i1];
                            this.nodesForRepulsion[i1] = tmp;
                        }
                    };
                    TimedSpringEmbedder.prototype.onSceneChange = function (event) {
                        // figure out background links
                        var sc = event.changes.settingsChanges;
                        if ((sc && sc.layout) || event.changes.navigation || this.chart.layer.hasTopologyChanges()) {
                            this.updateBackgroundLinks();
                        }
                    };
                    TimedSpringEmbedder.prototype.updateBackgroundLinks = function () {
                        var layer = this.chart.layer;
                        var links = layer.links();
                        for (var linkIndex = 0; linkIndex < links.length; linkIndex++) {
                            var link = links[linkIndex];
                            if (link.background) {
                                link.background = false;
                                layer.touchLink(link);
                            }
                        }
                    };
                    TimedSpringEmbedder.prototype.doAnimations = function (event) {
                        var settings = this.chart.settings.layout;
                        var layer = this.chart.layer;
                        var idleTimeout = settings.layoutFreezeTimeout;
                        var noMovementTimeout = settings.layoutFreezeMinTimeout;
                        var topologyChanges = layer.hasTopologyChanges();
                        var styleChanges = layer.hasStyleChanges();
                        var dt = event.dtime;
                        if (this.idleSince === 0 || event.changes.dynamicLayout || topologyChanges || event.changes.coordinates || event.changes.layout || event.changes.bounds) {
                            this.idleSince = event.timeStamp;
                            this.noMovementSince = 0;
                        }
                        var newPos = false;
                        var newNodes = {};
                        var majorChanges = false;
                        var aliveProportion = 1;
                        if (topologyChanges) {
                            this.random = new Internal.Base.Random(1);
                            var placeNewNodesResult = this.placeNewNodes();
                            newNodes = placeNewNodesResult.newNodes;
                            majorChanges = placeNewNodesResult.majorChanges;
                            newPos = true;
                        }
                        else {
                            var idleTime = event.timeStamp - this.idleSince;
                            if (this.layoutMovement < settings.advanced.adaptiveFreezeTreshold) {
                                if (this.noMovementSince !== 0) {
                                    var noMovementTime = event.timeStamp - this.noMovementSince;
                                    aliveProportion = Math.min((noMovementTimeout - noMovementTime) / noMovementTimeout, aliveProportion);
                                }
                                else {
                                    this.noMovementSince = event.timeStamp;
                                }
                            }
                            aliveProportion = Math.min((idleTimeout - idleTime) / noMovementTimeout, aliveProportion);
                        }
                        if (aliveProportion > 0) {
                            var timeout = majorChanges ? settings.initialLayoutMaxTime : settings.incrementalLayoutMaxTime;
                            this.layoutMovement = this.doForceLayout(dt * aliveProportion, topologyChanges || event.changes.layout, styleChanges, newNodes, timeout, majorChanges);
                            event.animating = true;
                            newPos = true;
                        }
                        if (newPos) {
                            event.changes.position = true;
                        }
                    };
                    TimedSpringEmbedder.prototype.placeNewNodes = function () {
                        var newNodes = {};
                        var layer = this.chart.layer;
                        // means there are new nodes not directly connected to existing nodes
                        var majorChanges = false;
                        for (var nIndex = 0, nSource = layer.nodes(); nIndex < nSource.length; nIndex++) {
                            var n = nSource[nIndex];
                            if (n.x === null || n.y === null) {
                                newNodes[n.id] = true;
                            }
                        }
                        for (var nIndex = 0, nSource = layer.nodes(); nIndex < nSource.length; nIndex++) {
                            var n = nSource[nIndex];
                            var randomness = 1;
                            if (newNodes.hasOwnProperty(n.id)) {
                                var neighborCount = 0;
                                var cx = 0;
                                var cy = 0;
                                randomness = 1;
                                var neighbor = void 0;
                                for (var linkIndex = 0; linkIndex < n.links.length; linkIndex++) {
                                    var link = n.links[linkIndex];
                                    var nn = link.otherEnd(n);
                                    if (!newNodes.hasOwnProperty(nn.id)) {
                                        neighbor = nn;
                                        cx += nn.x;
                                        cy += nn.y;
                                        neighborCount += 1;
                                    }
                                }
                                var nx = void 0;
                                var ny = void 0;
                                if (neighborCount > 1) {
                                    // place at center of neighbors
                                    nx = cx / neighborCount;
                                    ny = cy / neighborCount;
                                    randomness = 0.5;
                                }
                                else if (neighborCount === 1) {
                                    // place away from 2nd deg neighbors
                                    var count = 0;
                                    var dx = 0;
                                    var dy = 0;
                                    for (var linkIndex = 0; linkIndex < neighbor.links.length; linkIndex++) {
                                        var link = neighbor.links[linkIndex];
                                        var node = link.otherEnd(neighbor);
                                        if (node === n || newNodes.hasOwnProperty(node.id)) {
                                            continue;
                                        }
                                        dx += (node.x - neighbor.x);
                                        dy += (node.y - neighbor.y);
                                        count += 1;
                                    }
                                    if (count > 0) {
                                        var len = Math.sqrt(dx * dx + dy * dy);
                                        if (len > 0) {
                                            var iln = 1 / (len * count);
                                            dx *= iln;
                                            dy *= iln;
                                            nx = neighbor.x - dx * neighbor.hHeight * 1.2;
                                            ny = neighbor.y - dy * neighbor.hHeight * 1.2;
                                            randomness = 0.2;
                                        }
                                        else {
                                            nx = neighbor.x;
                                            ny = neighbor.y;
                                        }
                                    }
                                    else {
                                        majorChanges = true;
                                        nx = neighbor.x;
                                        ny = neighbor.y;
                                    }
                                }
                                else {
                                    majorChanges = true;
                                    // no viable neighbors, place node at 0,0 plus random
                                    nx = 0;
                                    ny = 0;
                                }
                                n.x = nx + (this.random.get() - 0.5) * randomness * (n.hHeight + 1);
                                n.y = ny + (this.random.get() - 0.5) * randomness * (n.hHeight + 1);
                            }
                        }
                        return {
                            newNodes: newNodes,
                            majorChanges: majorChanges
                        };
                    };
                    TimedSpringEmbedder.prototype.doForceLayout = function (dt, topologyChanges, styleChanges, newNodes, timeout, reset) {
                        var scene = this.chart.scene;
                        var settings = this.chart.settings.layout;
                        var layer = this.chart.layer;
                        /* global - global layout for new nodes
                        incremental - incremental layout for all nodes, if false only for new nodes */
                        var aspect = (scene.width + 1) / (scene.height + 1);
                        // filter out nans and other dumb stuff
                        if (!(aspect > 0)) {
                            aspect = null;
                        }
                        var effectiveAspect = scene.settings.layout.aspectRatio ? aspect : null;
                        var nodeSpacing = settings.nodeSpacing;
                        var degreeModifier = 1;
                        var nodes = layer.nodes();
                        var appearingNodes = false;
                        var hasLockedNodes = false;
                        for (var nIndex = 0; nIndex < nodes.length; nIndex++) {
                            var n = nodes[nIndex];
                            n.locked = n.userLock || n.locks > 0;
                            hasLockedNodes = hasLockedNodes || n.locked;
                            appearingNodes = appearingNodes || (n.visibility !== 1);
                        }
                        // build links
                        var multilinks = {};
                        var realLinks = [];
                        for (var lIndex = 0, lSource = layer.links(); lIndex < lSource.length; lIndex++) {
                            var l = lSource[lIndex];
                            var mlid = l.multiId;
                            var strength = l.targetStrength;
                            var length = l.targetLength;
                            var visibility = l.visibility;
                            if (l.removed || l.added) {
                                var hasOtherConnections = l.from.links.length > 1 && l.to.links.length > 1;
                                var s1 = void 0;
                                if (hasOtherConnections || l.removed) {
                                    s1 = 0.2;
                                }
                                else {
                                    s1 = strength;
                                }
                                if (l.added) {
                                    length = 0.2 + (length - 0.2) * visibility;
                                    strength = strength * visibility + s1 * (1 - visibility);
                                }
                            }
                            // merge into multilinks
                            if (!multilinks.hasOwnProperty(mlid)) {
                                var ml = {
                                    from: l.from,
                                    to: l.to,
                                    strength: strength,
                                    length: length,
                                    visibility: visibility,
                                    direction: l.direction
                                };
                                multilinks[mlid] = ml;
                                realLinks.push(ml);
                            }
                            else {
                                var ml = multilinks[mlid];
                                ml.strength = Math.max(strength, ml.strength);
                                ml.length = Math.max(length, ml.length);
                                ml.visibility = Math.max(visibility, ml.visibility);
                            }
                        }
                        this.updateParams(nodeSpacing, degreeModifier, effectiveAspect);
                        // do layout on new nodes
                        if (reset || Internal.Base.Helpers.hasProperties(newNodes)) {
                            for (var nIndex = 0; nIndex < nodes.length; nIndex++) {
                                var n = nodes[nIndex];
                                n.locked = n.locked || (!newNodes.hasOwnProperty(n.id));
                            }
                            this.updateGraph(nodes, realLinks, topologyChanges);
                            if (reset || scene.settings.layout.globalLayoutOnChanges) {
                                this.updateParams(nodeSpacing, degreeModifier, aspect);
                                this.globalLayout(nodes, timeout, reset && (!hasLockedNodes));
                                this.updateParams(nodeSpacing, degreeModifier, effectiveAspect);
                            }
                            else {
                                this.timedLayout(nodes, dt * 0.001);
                            }
                        }
                        // do incremental layout
                        this.updateGraph(nodes, realLinks, topologyChanges);
                        this.timedLayout(nodes, dt * 0.001);
                        // expected movement estimate
                        return this.stability;
                    };
                    TimedSpringEmbedder.prototype.resetLayout = function () {
                        this.random = new Internal.Base.Random(1);
                        var newNodes = {};
                        for (var nIndex = 0, nSource = this.chart.layer.nodes(); nIndex < nSource.length; nIndex++) {
                            var n = nSource[nIndex];
                            newNodes[n.id] = true;
                            n.x = 0;
                            n.y = 0;
                            n.userLock = false;
                        }
                        this.doForceLayout(1, true, true, newNodes, 10000, true);
                        this.idleSince = 0;
                    };
                    return TimedSpringEmbedder;
                }(Layouts.LayoutBase));
                Layouts.TimedSpringEmbedder = TimedSpringEmbedder;
            })(Layouts = NetChart.Layouts || (NetChart.Layouts = {}));
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="LayoutBase.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var Layouts;
            (function (Layouts) {
                var RadialLayout = (function (_super) {
                    __extends(RadialLayout, _super);
                    function RadialLayout() {
                        _super.apply(this, arguments);
                        /** If settings.layout.twoRingRadialLayout is set to true, this flag will keep track of whether the first level had
                            two rings or one. This is done so that on normal user interactions (such as changing radius upon hover) the layout
                            wouldn't jump forth and back between two-ring and one-ring modes. The flag is recalculated when there are serious
                            changes to the whole chart - layout settings changes, navigation, nodes coming and going, etc. */
                        this.twoCircles = false;
                    }
                    RadialLayout.getNodeSize = function (node) {
                        return Math.max(node.hHeight, node.hWidth) * node.visibility * 2;
                    };
                    RadialLayout.getNodesBounds = function (nodes) {
                        if (nodes.length < 1)
                            return new Internal.Base.Rect(0, 0, 0, 0);
                        var node = nodes[0];
                        var bounds = new Internal.Base.Rect(node.x - node.hWidth, node.y - node.hHeight, node.x + node.hWidth, node.y + node.hHeight);
                        for (var i = 1; i < nodes.length; i++) {
                            node = nodes[i];
                            bounds.addBounds(node.x - node.hWidth, node.y - node.hHeight, node.x + node.hWidth, node.y + node.hHeight);
                        }
                        return bounds;
                    };
                    RadialLayout.prototype.onSceneChange = function (event) {
                        var sc = event.changes.settingsChanges;
                        if ((sc && sc.layout) || event.changes.navigation || this.chart.layer.hasTopologyChanges() || event.changes.highlight) {
                            this.updateBackgroundLinks(this.chart.getLastFocusNode(), false);
                        }
                    };
                    RadialLayout.prototype.doAnimations = function (event) {
                        var sc = event.changes.settingsChanges;
                        var majorChanges = (sc != null && sc.layout != null) || event.changes.navigation || this.chart.layer.hasTopologyChanges();
                        var minorChanges = event.changes.position || event.changes.dynamicLayout;
                        if (majorChanges || minorChanges) {
                            this.performLayout(majorChanges);
                            event.changes.position = true;
                        }
                    };
                    RadialLayout.prototype.resetLayout = function () {
                        var nodes = this.chart.layer.nodes();
                        for (var i = 0; i < nodes.length; i++)
                            nodes[i].userLock = false;
                        this.performLayout(true);
                    };
                    RadialLayout.prototype.performLayout = function (reoptimize) {
                        // All separate node circles.
                        var nodeCircles = [];
                        this.visitedNodes = {};
                        this.subnodes = {};
                        this.minAngle = {};
                        this.radiuses = [];
                        // Lay out the graph starting from the last focused node.
                        var startNode = this.chart.getLastFocusNode();
                        if (!startNode)
                            return;
                        nodeCircles.push(this.layoutCircle(startNode, reoptimize));
                        // Then lay out whatever is remaining in separate circles.
                        var nodes = this.chart.layer.nodes();
                        for (var i = 0; i < nodes.length; i++) {
                            var node = nodes[i];
                            if (!Internal.Base.Helpers.hasProperty(this.visitedNodes, node.id)) {
                                nodeCircles.push(this.layoutCircle(node, reoptimize));
                            }
                        }
                        // Now place these circles next to each other
                        if (nodeCircles.length > 1) {
                            var spacing = this.chart.settings.layout.nodeSpacing * 2;
                            var shift = RadialLayout.getNodesBounds(nodeCircles[0]).x1 + spacing;
                            for (var i = 1; i < nodeCircles.length; i++) {
                                var circle = nodeCircles[i];
                                if (circle.length < 1)
                                    continue;
                                var bounds = RadialLayout.getNodesBounds(circle);
                                shift -= bounds.x0; // x0 is negative, and we need to shift right by that amount, so shift + -x0 is the same as shift-x0.
                                for (var j = 0; j < circle.length; j++) {
                                    circle[j].x += shift;
                                }
                                shift += bounds.x1 + spacing;
                            }
                        }
                        if (this.updateBackgroundLinks(startNode, true)) {
                            this.chart.events.notifySceneChanges({ highlight: true });
                        }
                    };
                    RadialLayout.prototype.layoutCircle = function (startNode, reoptimize) {
                        var circle = [];
                        this.visitedNodes[startNode.id] = true;
                        this.computeMaxRadius(startNode, reoptimize);
                        this.placeNodeRec(startNode, 0, -Math.PI * 0.5, Math.PI * 2, circle);
                        return circle;
                    };
                    RadialLayout.prototype.updateBackgroundLinks = function (startNode, testOnly) {
                        if (!startNode)
                            return;
                        this.visitedNodes = {};
                        if (this.updateBackgroudLinkCircle(startNode, testOnly) && testOnly)
                            return true;
                        var nodes = this.chart.layer.nodes();
                        for (var i = 0; i < nodes.length; i++) {
                            var node = nodes[i];
                            if (!Internal.Base.Helpers.hasProperty(this.visitedNodes, node.id)) {
                                if (this.updateBackgroudLinkCircle(node, testOnly) && testOnly)
                                    return true;
                            }
                        }
                        return false;
                    };
                    RadialLayout.prototype.updateBackgroudLinkCircle = function (centerNode, testOnly) {
                        var nodes = [centerNode];
                        this.visitedNodes[centerNode.id] = true;
                        var visitedLinks = {};
                        var layer = this.chart.layer;
                        while (nodes.length > 0) {
                            var subnodes = [];
                            for (var i = 0; i < nodes.length; i++) {
                                var node = nodes[i];
                                for (var j = 0; j < node.links.length; j++) {
                                    var link = node.links[j];
                                    if (Internal.Base.Helpers.hasProperty(visitedLinks, link.id))
                                        continue;
                                    visitedLinks[link.id] = true;
                                    var otherEnd = link.otherEnd(node);
                                    var bg = true;
                                    if (!Internal.Base.Helpers.hasProperty(this.visitedNodes, otherEnd.id)) {
                                        this.visitedNodes[otherEnd.id] = true;
                                        subnodes.push(otherEnd);
                                        bg = false;
                                    }
                                    if (link.background !== bg) {
                                        if (testOnly)
                                            return true;
                                        link.background = bg;
                                        layer.touchLink(link);
                                    }
                                }
                            }
                            nodes = subnodes;
                        }
                        return false;
                    };
                    RadialLayout.prototype.getSubnodes = function (node) {
                        var id = node.id;
                        if (this.subnodes[id]) {
                            return this.subnodes[id];
                        }
                        var result = [];
                        for (var linkIndex = 0; linkIndex < node.links.length; linkIndex++) {
                            var link = node.links[linkIndex];
                            var otherNode = link.otherEnd(node);
                            if (!Internal.Base.Helpers.hasProperty(this.visitedNodes, otherNode.id)) {
                                result.push(otherNode);
                                this.visitedNodes[otherNode.id] = true;
                            }
                        }
                        this.subnodes[id] = result;
                        return result;
                    };
                    RadialLayout.prototype.computeMaxRadius = function (node, reoptimize) {
                        var spacing = this.chart.settings.layout.nodeSpacing;
                        var prevRadius = 0;
                        this.radiuses[0] = prevRadius;
                        var level = 1;
                        var nodes = [node];
                        while (nodes.length > 0) {
                            // compute max distance from previous level
                            var subnodes = void 0;
                            if (level === 1 && this.chart.settings.layout.twoRingRadialLayout) {
                                node = nodes[0];
                                var nodeSize = RadialLayout.getNodeSize(node);
                                subnodes = this.getSubnodes(node);
                                var circleSize = Math.floor(subnodes.length / 2);
                                var innerCircle = new Array(circleSize);
                                var outerCircle = new Array(subnodes.length - circleSize);
                                for (var i = 0; i < subnodes.length; i++)
                                    (i % 2 === 0 ? outerCircle : innerCircle)[Math.floor(i / 2)] = subnodes[i];
                                // Calculate inner circle size.
                                var innerMaxSize = 0;
                                var innerLength = 0;
                                for (var i = 0; i < innerCircle.length; i++) {
                                    var subnode = innerCircle[i];
                                    var subSize = RadialLayout.getNodeSize(subnode);
                                    innerMaxSize = Math.max(innerMaxSize, subSize);
                                    innerLength += spacing + subSize;
                                }
                                // Calculate outer circle size
                                var outerMaxSize = 0;
                                var outerLength = 0;
                                for (var i = 0; i < outerCircle.length; i++) {
                                    var subnode = outerCircle[i];
                                    var subSize = RadialLayout.getNodeSize(subnode);
                                    outerMaxSize = Math.max(outerMaxSize, subSize);
                                    outerLength += spacing + subSize;
                                }
                                // Check if we need more than 1 circle at all
                                var oneCircleRadius = Math.max((Math.max(innerMaxSize, outerMaxSize) + nodeSize) * 0.5 + spacing, (innerLength + outerLength) / (Math.PI * 2));
                                var innerRadius = Math.max((innerMaxSize + nodeSize) * 0.5 + spacing, innerLength / (Math.PI * 2));
                                var outerRadius = Math.max(innerRadius + (outerMaxSize + innerMaxSize) * 0.5, outerLength / (Math.PI * 2));
                                if (reoptimize)
                                    this.twoCircles = outerRadius < oneCircleRadius;
                                if (this.twoCircles) {
                                    this.radiuses[1] = innerRadius;
                                    this.radiuses[2] = outerRadius;
                                }
                                else {
                                    this.radiuses[1] = oneCircleRadius;
                                    this.radiuses[2] = oneCircleRadius;
                                }
                                prevRadius = this.radiuses[2];
                                level = 3;
                            }
                            else {
                                var maxDistance = 0;
                                var maxLength = 0;
                                subnodes = [];
                                for (var nodeIndex = 0; nodeIndex < nodes.length; nodeIndex++) {
                                    node = nodes[nodeIndex];
                                    var nodeSize = RadialLayout.getNodeSize(node);
                                    for (var subnodeIndex = 0, subnodeSource = this.getSubnodes(node); subnodeIndex < subnodeSource.length; subnodeIndex++) {
                                        var subnode = subnodeSource[subnodeIndex];
                                        var subSize = RadialLayout.getNodeSize(subnode);
                                        maxDistance = Math.max(maxDistance, subSize + nodeSize);
                                        maxLength += spacing + subSize;
                                        subnodes.push(subnode);
                                    }
                                }
                                var minRadius = prevRadius + maxDistance * 0.5 + spacing;
                                var maxRadius = maxLength / (Math.PI * 2);
                                var radius = Math.max(minRadius, maxRadius);
                                this.radiuses[level] = radius;
                                prevRadius = radius;
                                level += 1;
                            }
                            nodes = subnodes;
                        }
                    };
                    RadialLayout.prototype.computeMinAngle = function (node, level) {
                        var id = node.id;
                        if (Internal.Base.Helpers.hasProperty(this.minAngle, id)) {
                            return this.minAngle[id];
                        }
                        var spacing = this.chart.settings.layout.nodeSpacing;
                        var radius = this.radiuses[level];
                        var size = RadialLayout.getNodeSize(node);
                        var minAngle = (size + spacing) / radius;
                        var subAngle = 0;
                        var nextLevel = (this.chart.settings.layout.twoRingRadialLayout && level === 1) ? 3 : level + 1;
                        for (var subnodeIndex = 0, subnodeSource = this.getSubnodes(node); subnodeIndex < subnodeSource.length; subnodeIndex++) {
                            var subnode = subnodeSource[subnodeIndex];
                            subAngle += this.computeMinAngle(subnode, nextLevel);
                        }
                        minAngle = Math.max(minAngle, subAngle);
                        this.minAngle[id] = minAngle;
                        return minAngle;
                    };
                    RadialLayout.prototype.placeNodeRec = function (node, level, startAngle, availableAngle, accumulator) {
                        var nodeAngle = startAngle + availableAngle * 0.5;
                        var radius = this.radiuses[level];
                        if (!node.userLock) {
                            node.x = radius * Math.cos(nodeAngle);
                            node.y = radius * Math.sin(nodeAngle);
                            accumulator.push(node);
                        }
                        var subnodes = this.getSubnodes(node);
                        var nextLevel = level + 1;
                        var dynamicNextLevel = false;
                        if (this.chart.settings.layout.twoRingRadialLayout) {
                            if (level === 0) {
                                dynamicNextLevel = true;
                            }
                            else if (level === 1) {
                                nextLevel = 3;
                            }
                        }
                        if (subnodes.length > 0) {
                            var subnodesAngle = 0;
                            for (var subnodeIndex = 0; subnodeIndex < subnodes.length; subnodeIndex++) {
                                var subnode = subnodes[subnodeIndex];
                                subnodesAngle += this.computeMinAngle(subnode, dynamicNextLevel ? (subnodeIndex % 2 === 0 ? 2 : 1) : nextLevel);
                            }
                            var scale = availableAngle / subnodesAngle;
                            var angle = startAngle;
                            for (var subnodeIndex = 0; subnodeIndex < subnodes.length; subnodeIndex++) {
                                var subnode = subnodes[subnodeIndex];
                                if (dynamicNextLevel) {
                                    nextLevel = (subnodeIndex % 2 === 0 ? 2 : 1);
                                }
                                var avail = this.computeMinAngle(subnode, nextLevel) * scale;
                                this.placeNodeRec(subnode, nextLevel, angle, avail, accumulator);
                                angle += avail;
                            }
                        }
                    };
                    return RadialLayout;
                }(Layouts.LayoutBase));
                Layouts.RadialLayout = RadialLayout;
            })(Layouts = NetChart.Layouts || (NetChart.Layouts = {}));
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="LayoutBase.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var Layouts;
            (function (Layouts) {
                // Helper: Calculate parent X coordinate as the center of its children.
                function calcParentX(wParent) {
                    if (wParent.children.length === 0)
                        return 0;
                    var wFirstChild = wParent.children[0];
                    var wLastChild = wParent.children[wParent.children.length - 1];
                    return ((wFirstChild.node.x - wFirstChild.hWidth) + (wLastChild.node.x + wLastChild.hWidth)) / 2;
                }
                // Helper: Lay nodes between two other nodes with equal spacings. If any of the end nodes are not specified, lays to the end of the level.
                function layEvenly(level, wNodeBefore, wNodeAfter, spacing, forwards) {
                    var startIndex = wNodeBefore === null ? 0 : wNodeBefore.levelIndex + 1;
                    var endIndex = wNodeAfter === null ? level.length : wNodeAfter.levelIndex;
                    if (forwards) {
                        var px = wNodeBefore === null ? 0 : wNodeBefore.node.x + wNodeBefore.hWidth + spacing;
                        for (var x = startIndex; x < endIndex; x++) {
                            var wNode = level[x];
                            px += wNode.hWidth;
                            wNode.node.x = px;
                            px += wNode.hWidth + spacing;
                        }
                    }
                    else {
                        var px = wNodeAfter === null ? 0 : wNodeAfter.node.x - wNodeAfter.hWidth - spacing;
                        for (var x = endIndex - 1; x >= startIndex; x--) {
                            var wNode = level[x];
                            px -= wNode.hWidth;
                            wNode.node.x = px;
                            px -= wNode.hWidth + spacing;
                        }
                    }
                }
                var WrappedNode = (function () {
                    function WrappedNode(node, level) {
                        this.children = [];
                        this.parent = null;
                        this.node = node;
                        this.level = level;
                        this.reset();
                    }
                    WrappedNode.prototype.reset = function () {
                        this.hWidth = this.node.hWidth;
                        // this.hWidth = this.node.outerBounds.w() / 2; // TODO: In future, when node size calculations are correct, move this back.
                        this.origX = this.node.x;
                        this.shift = 0;
                    };
                    return WrappedNode;
                }());
                var HierarchyLayout = (function (_super) {
                    __extends(HierarchyLayout, _super);
                    function HierarchyLayout() {
                        _super.apply(this, arguments);
                        this.forest = null;
                    }
                    /**
                     * Wraps the nodes in WrappedNode and sorts them into levels. Only visits each node once, so loops are discarded.
                     * Only 1 parent of each node is kept and that is considered it's "canonical" parent and will be used for positioning.
                     * Nodes are sorted so that children of a single parent are continuous in their level.
                     * @return Level data
                     */
                    HierarchyLayout.prototype.wrapNodes = function () {
                        var unvisitedNodes = Internal.Base.Helpers.clone(this.chart.layer.idToNode);
                        var forest = [];
                        while (true) {
                            var centerNode = null;
                            for (var id in unvisitedNodes)
                                if (Internal.Base.Helpers.hasProperty(unvisitedNodes, id)) {
                                    centerNode = unvisitedNodes[id];
                                    delete unvisitedNodes[id];
                                    break;
                                }
                            if (centerNode == null)
                                return forest;
                            var nodesById = {};
                            var allWrapped = [new WrappedNode(centerNode, 0)];
                            var minLevel = 0;
                            var maxLevel = 0;
                            nodesById[centerNode.id] = allWrapped[0];
                            // Pass 1: wrap all nodes, calculate their levels and notice the minimum/maximum level.
                            for (var i = 0; i < allWrapped.length; i++) {
                                var wNode = allWrapped[i];
                                var node = wNode.node;
                                for (var j = 0; j < node.links.length; j++) {
                                    var link = node.links[j];
                                    if (link.to === node) {
                                        var w = void 0;
                                        if (!Internal.Base.Helpers.hasProperty(nodesById, link.from.id)) {
                                            w = new WrappedNode(link.from, wNode.level - 1);
                                            if (minLevel === wNode.level)
                                                minLevel--;
                                            nodesById[link.from.id] = w;
                                            allWrapped.push(w);
                                        }
                                        else
                                            w = nodesById[link.from.id];
                                        if (wNode.parent === null && wNode.level === w.level + 1) {
                                            wNode.parent = w;
                                            w.children.push(wNode);
                                        }
                                    }
                                    else {
                                        var w = void 0;
                                        if (!Internal.Base.Helpers.hasProperty(nodesById, link.to.id)) {
                                            w = new WrappedNode(link.to, wNode.level + 1);
                                            if (maxLevel === wNode.level)
                                                maxLevel++;
                                            nodesById[link.to.id] = w;
                                            allWrapped.push(w);
                                        }
                                        else
                                            w = nodesById[link.to.id];
                                        if (w.parent === null && w.level === wNode.level + 1) {
                                            wNode.children.push(w);
                                            w.parent = wNode;
                                        }
                                    }
                                }
                            }
                            // Pass 2: iterate through all the wrapped nodes and create the levels
                            // Create the basic array of arrays.
                            var levels = new Array(maxLevel - minLevel + 1);
                            for (var i = 0; i < levels.length; i++)
                                levels[i] = [];
                            // Add to their levels all the parent-less nodes. Renumerate their levels to start at 0.
                            for (var i = 0; i < allWrapped.length; i++) {
                                var wNode = allWrapped[i];
                                delete unvisitedNodes[wNode.node.id];
                                wNode.level -= minLevel;
                                if (wNode.parent === null) {
                                    wNode.levelIndex = levels[wNode.level].length;
                                    levels[wNode.level].push(wNode);
                                }
                            }
                            // Iterate through all the levels and add all the children to the level beneath their parent.
                            for (var y = 0; y < levels.length; y++) {
                                var level = levels[y];
                                for (var x = 0; x < level.length; x++) {
                                    var wParent = level[x];
                                    for (var cx = 0; cx < wParent.children.length; cx++) {
                                        var cy = y + 1;
                                        var wChild = wParent.children[cx];
                                        wChild.level = cy;
                                        wChild.levelIndex = levels[cy].length;
                                        levels[cy].push(wChild);
                                    }
                                }
                            }
                            forest.push({ levels: levels, levelStarts: new Array(levels.length), levelEnds: new Array(levels.length) });
                        }
                    };
                    /**
                     * Positions the nodes
                     */
                    HierarchyLayout.prototype.layoutNodes = function (tree) {
                        var levels = tree.levels;
                        var ySpacing = this.chart.settings.layout.rowSpacing === null ? this.chart.settings.layout.nodeSpacing : this.chart.settings.layout.rowSpacing;
                        var xSpacing = this.chart.settings.layout.nodeSpacing;
                        // Pass 1: walk upwards from bottom. Set the X coordinates for all the nodes.
                        // Last level is a special case - there will be no parent nodes, but one or more child nodes. Space them with xSpacing distance from each other.
                        layEvenly(levels[levels.length - 1], null, null, xSpacing, true);
                        // Now process all the levels above the last level. There will ALWAYS be at least 1 parent node among them.
                        for (var y = levels.length - 2; y >= 0; y--) {
                            var level = levels[y];
                            var wLastParent = null;
                            var wThisParent = void 0;
                            // Walk through the nodes in the level, from left to right.
                            // Find the first parent node and store it in "thisParent". Store the sum of the widths of the leaf nodes before the first parent.
                            var minX = 0;
                            for (var x = 0; x < level.length; x++)
                                if (level[x].children.length > 0) {
                                    wThisParent = level[x];
                                    break;
                                }
                                else
                                    minX += level[x].hWidth * 2;
                            // Find the minimum X coordinate for the first parent.
                            minX += xSpacing * wThisParent.levelIndex + wThisParent.hWidth;
                            // Position the first parent above its children.
                            wThisParent.node.x = calcParentX(wThisParent);
                            // Check if this parent needs to be shifted.
                            if (wThisParent.levelIndex > 0) {
                                layEvenly(level, null, wThisParent, xSpacing, true);
                                var wPrevLeaf = level[wThisParent.levelIndex - 1];
                                var minX_1 = wPrevLeaf.node.x + wPrevLeaf.hWidth + xSpacing + wThisParent.hWidth;
                                if (minX_1 > wThisParent.node.x) {
                                    wThisParent.shift = minX_1 - wThisParent.node.x;
                                    wThisParent.node.x += wThisParent.shift;
                                }
                            }
                            // Any leaf nodes before the first parent get positioned before it with xSpacing between them.
                            layEvenly(level, null, wThisParent, xSpacing, false);
                            // Now process all the parents in the row, from left to right.
                            while (true) {
                                // Find the next parent and place it in "thisParent".
                                wLastParent = wThisParent;
                                wThisParent = null;
                                for (var x = wLastParent.levelIndex + 1; x < level.length; x++)
                                    if (level[x].children.length > 0) {
                                        wThisParent = level[x];
                                        break;
                                    }
                                // If there are no more parents in the row, exit the loop.
                                if (wThisParent === null)
                                    break;
                                // Calculate the default position of the parent above its children, considering already how far the row has shifted.
                                wThisParent.node.x = calcParentX(wThisParent) + wLastParent.shift;
                                wThisParent.shift = wLastParent.shift;
                                // Now calculate width of all the leaf nodes between the two parent nodes, and from that - the minimum distance between the parent nodes.
                                var leafWidth = 0;
                                for (var x = wLastParent.levelIndex + 1; x < wThisParent.levelIndex; x++)
                                    leafWidth += level[x].hWidth * 2;
                                var minDist = wLastParent.hWidth + wThisParent.hWidth + leafWidth + (wThisParent.levelIndex - wLastParent.levelIndex) * xSpacing;
                                // Now check if the parents are far enough apart
                                var nowDist = wThisParent.node.x - wLastParent.node.x;
                                if (minDist > nowDist) {
                                    var delta = minDist - nowDist;
                                    wThisParent.node.x += delta;
                                    wThisParent.shift += delta;
                                    nowDist = minDist;
                                    // Now all the leaf nodes inbetween have JUST enough space to squeeze together. Space them equally.
                                    layEvenly(level, wLastParent, wThisParent, xSpacing, true);
                                }
                                else {
                                    // If we're here, that means that the parents are pretty far apart. Likely the leaf nodes between them have more space then necessary
                                    // to distribute themselves. So what we do is that we keep the nodes that have the same parent as lastParent/thisParent close to them
                                    // and distribute the remainder equally.
                                    // Special case - lastParent and thisParent are children of the same node. In that case, space all the nodes between them equally.
                                    if (wLastParent.parent === wThisParent.parent) {
                                        var avgXSpace = (nowDist - wLastParent.hWidth - wThisParent.hWidth - leafWidth) / (wThisParent.levelIndex - wLastParent.levelIndex);
                                        layEvenly(level, wLastParent, wThisParent, avgXSpace, true);
                                    }
                                    else {
                                        var wFirstAlienNode = null;
                                        var wLastAlienNode = null;
                                        // Find the first node which is between lastParent and thisParent, which has a different parent node than lastParent.
                                        for (var x = wLastParent.levelIndex + 1; x <= wThisParent.levelIndex; x++)
                                            if (level[x].parent !== wLastParent.parent) {
                                                wFirstAlienNode = level[x];
                                                break;
                                            }
                                        // Find the last node which is between lastParent and thisParent, which has a different parent than thisParent.
                                        for (var x = wThisParent.levelIndex - 1; x >= wLastParent.levelIndex; x--)
                                            if (level[x].parent !== wThisParent.parent) {
                                                wLastAlienNode = level[x];
                                                break;
                                            }
                                        // Lay out these nodes.
                                        layEvenly(level, wLastParent, wFirstAlienNode, xSpacing, true);
                                        layEvenly(level, wLastAlienNode, wThisParent, xSpacing, false);
                                        // If there are any more nodes inbetween, calculate the distance between them and lay them out.
                                        if (wFirstAlienNode.parent !== wThisParent.parent) {
                                            var wLastLeftNode = level[wFirstAlienNode.levelIndex - 1];
                                            var wFirstRightNode = level[wLastAlienNode.levelIndex + 1];
                                            var avgXSpace = (wThisParent.node.x - wLastParent.node.x - wThisParent.hWidth - wLastParent.hWidth - leafWidth -
                                                xSpacing * (wLastLeftNode.levelIndex - wLastParent.levelIndex + wThisParent.levelIndex - wFirstRightNode.levelIndex)) / (wFirstRightNode.levelIndex - wLastLeftNode.levelIndex);
                                            layEvenly(level, wLastLeftNode, wFirstRightNode, avgXSpace, true);
                                        }
                                    }
                                }
                            }
                            // OK, so now we've processed all the parents in the row, and the final parent processed is in "lastParent".
                            // There are however some leaf nodes still left. Position them to the right of lastParent with xSpacing between.
                            layEvenly(level, wLastParent, null, xSpacing, true);
                        }
                        // Pass 2: All x coordinates are set, but there are still shifts on parents that need to be applied to their children.
                        // Also, y coordinates need to be set. So now walk downwards from top to bottom and do these things.
                        var py = 0;
                        for (var y = 0; y < levels.length; y++) {
                            var level = levels[y];
                            var maxHeight = 0;
                            for (var x = 0; x < level.length; x++)
                                maxHeight = Math.max(maxHeight, level[x].node.hHeight * 2);
                            py += maxHeight / 2;
                            // Save the furthest X coordinate occupied by the level. This will be used to lay out separate trees later.
                            tree.levelStarts[y] = level[0].node.x - level[0].hWidth;
                            tree.levelEnds[y] = level[level.length - 1].node.x + level[level.length - 1].hWidth;
                            // Walk through all the nodes in the level.
                            for (var x = 0; x < level.length; x++) {
                                var wNode = level[x];
                                // If the node is locked, restore the original coordinates (X only, since we haven't touched Y yet).
                                // If the node is not locked, set the Y coordinate.
                                if (wNode.node.userLock) {
                                    wNode.node.x = wNode.origX;
                                }
                                else {
                                    wNode.node.y = py;
                                }
                                // Shift all the children.
                                for (var cx = 0; cx < wNode.children.length; cx++) {
                                    var wChild = wNode.children[cx];
                                    wChild.node.x += wNode.shift;
                                    wChild.shift += wNode.shift;
                                }
                            }
                            py += maxHeight / 2 + ySpacing;
                        }
                    };
                    /**
                     * Lays out the separate trees.
                     */
                    HierarchyLayout.prototype.layoutTrees = function (forest) {
                        var config = this.chart.settings.layout;
                        forest.sort(function (a, b) { return b.levels.length - a.levels.length; }); // Sort trees, largest first.
                        var levelEnds = Internal.Base.Helpers.clone(forest[0].levelEnds);
                        // Simple algorithm - place all trees next to each other. Take care to have 2 * nodeSpacing betwen the trees.
                        var xSpacing = 2 * config.nodeSpacing;
                        for (var i = 1; i < forest.length; i++) {
                            var thisTree = forest[i];
                            // Calculate how much we need to shift thisTree to the right, so that at every level the distance between the
                            // first node of thisTree and the last node of lastTree is at least xSpacing.
                            var shift = 0;
                            for (var y = 0; y < thisTree.levels.length; y++) {
                                var minX = levelEnds[y] + xSpacing;
                                var curX = shift + thisTree.levelStarts[y];
                                if (curX < minX)
                                    shift += minX - curX;
                            }
                            // Apply shift to all non-locked nodes in thisTree.
                            for (var y = 0; y < thisTree.levels.length; y++) {
                                var level = thisTree.levels[y];
                                for (var x = 0; x < level.length; x++) {
                                    var node = level[x];
                                    if (!node.node.userLock)
                                        node.node.x += shift;
                                }
                                // Also shift the current end of each level.
                                levelEnds[y] = shift + thisTree.levelEnds[y];
                            }
                        }
                        // Finally, rotate if necessary.
                        var rotation = (config.rotation || 0) % 360;
                        if (rotation !== 0) {
                            rotation = rotation * Math.PI / 180;
                            var sin = Math.sin(rotation);
                            var cos = Math.cos(rotation);
                            var nodes = this.chart.layer.nodes();
                            for (var i = 0; i < nodes.length; i++) {
                                var node = nodes[i];
                                if (node.userLock)
                                    continue;
                                var x = node.x;
                                var y = node.y;
                                node.x = x * cos - y * sin;
                                node.y = x * sin + y * cos;
                            }
                        }
                    };
                    HierarchyLayout.prototype.performLayout = function (reWrap) {
                        if (reWrap || this.forest == null) {
                            this.forest = this.wrapNodes();
                        }
                        else {
                            for (var i = 0; i < this.forest.length; i++) {
                                var tree = this.forest[i];
                                for (var j = 0; j < tree.levels.length; j++) {
                                    var level = tree.levels[j];
                                    for (var k = 0; k < level.length; k++)
                                        level[k].reset();
                                }
                            }
                        }
                        if (this.forest.length < 1)
                            return;
                        for (var i = 0; i < this.forest.length; i++)
                            this.layoutNodes(this.forest[i]);
                        this.layoutTrees(this.forest);
                        if (this.setBackgroundFlag(true))
                            this.chart.events.notifySceneChanges({ highlight: true });
                    };
                    HierarchyLayout.prototype.setBackgroundFlag = function (testOnly) {
                        var unvisitedNodes = Internal.Base.Helpers.clone(this.chart.layer.idToNode);
                        while (true) {
                            var centerNode = null;
                            for (var id in unvisitedNodes)
                                if (Internal.Base.Helpers.hasProperty(unvisitedNodes, id)) {
                                    centerNode = unvisitedNodes[id];
                                    delete unvisitedNodes[id];
                                    break;
                                }
                            if (centerNode == null)
                                return false;
                            var nodesById = {};
                            var visitedLinks = {};
                            var allWrapped = [{ node: centerNode, level: 0, hasParent: false }];
                            var layer = this.chart.layer;
                            nodesById[centerNode.id] = allWrapped[0];
                            // Same algorithm as for wrapNodes(), except with the unnecessary parts removed.
                            for (var i = 0; i < allWrapped.length; i++) {
                                var wNode = allWrapped[i];
                                var node = wNode.node;
                                for (var j = 0; j < node.links.length; j++) {
                                    var link = node.links[j];
                                    if (Internal.Base.Helpers.hasProperty(visitedLinks, link.id))
                                        continue;
                                    visitedLinks[link.id] = true;
                                    var bg = true;
                                    if (link.to === node) {
                                        var w = void 0;
                                        if (!Internal.Base.Helpers.hasProperty(nodesById, link.from.id)) {
                                            w = { node: link.from, level: wNode.level - 1, hasParent: false };
                                            delete unvisitedNodes[w.node.id];
                                            nodesById[link.from.id] = w;
                                            allWrapped.push(w);
                                        }
                                        else
                                            w = nodesById[link.from.id];
                                        if (!wNode.hasParent && wNode.level === w.level + 1) {
                                            wNode.hasParent = true;
                                            bg = false;
                                        }
                                    }
                                    else {
                                        var w = void 0;
                                        if (!Internal.Base.Helpers.hasProperty(nodesById, link.to.id)) {
                                            w = { node: link.to, level: wNode.level + 1, hasParent: false };
                                            delete unvisitedNodes[w.node.id];
                                            nodesById[link.to.id] = w;
                                            allWrapped.push(w);
                                        }
                                        else
                                            w = nodesById[link.to.id];
                                        if (!w.hasParent && w.level === wNode.level + 1) {
                                            w.hasParent = true;
                                            bg = false;
                                        }
                                    }
                                    if (link.background !== bg) {
                                        if (testOnly)
                                            return true;
                                        link.background = bg;
                                        layer.touchLink(link);
                                    }
                                }
                            }
                        }
                    };
                    HierarchyLayout.prototype.onSceneChange = function (event) {
                        var sc = event.changes.settingsChanges;
                        if ((sc && sc.layout) || event.changes.navigation || this.chart.layer.hasTopologyChanges() || event.changes.highlight) {
                            this.setBackgroundFlag(false); // Sets the .background flag on links.
                        }
                    };
                    HierarchyLayout.prototype.doAnimations = function (event) {
                        var sc = event.changes.settingsChanges;
                        var topologyChanges = this.chart.layer.hasTopologyChanges();
                        if ((sc && sc.layout) || event.changes.navigation || topologyChanges || event.changes.position || event.changes.dynamicLayout) {
                            // Lay out the graph starting from the first node we find.
                            this.performLayout(topologyChanges);
                            event.changes.position = true;
                        }
                    };
                    HierarchyLayout.prototype.resetLayout = function () {
                        var nodes = this.chart.layer.nodes();
                        for (var i = 0; i < nodes.length; i++)
                            nodes[i].userLock = false;
                        this.performLayout(false);
                    };
                    return HierarchyLayout;
                }(Layouts.LayoutBase));
                Layouts.HierarchyLayout = HierarchyLayout;
            })(Layouts = NetChart.Layouts || (NetChart.Layouts = {}));
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="LayoutBase.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var Layouts;
            (function (Layouts) {
                /** Static layout does NOTHING. Except when resetting layout, it resets all the nodes to the default positions. */
                var StaticLayout = (function (_super) {
                    __extends(StaticLayout, _super);
                    function StaticLayout() {
                        _super.apply(this, arguments);
                    }
                    StaticLayout.prototype.resetLayout = function () {
                        var nodes = this.chart.layer.nodes();
                        for (var i = 0; i < nodes.length; i++) {
                            var n = nodes[i];
                            var data = n.data;
                            if (Internal.Base.Helpers.isNumber(data.x))
                                n.x = data.x;
                            if (Internal.Base.Helpers.isNumber(data.y))
                                n.y = data.y;
                            n.userLock = false;
                        }
                    };
                    return StaticLayout;
                }(Layouts.LayoutBase));
                Layouts.StaticLayout = StaticLayout;
            })(Layouts = NetChart.Layouts || (NetChart.Layouts = {}));
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="TimedSpringEmbedder.ts" />
/// <reference path="RadialLayout.ts" />
/// <reference path="HierarchyLayout.ts" />
/// <reference path="StaticLayout.ts" /> 
/// <reference path="../../base/Bar/Toolbar.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var LinearChart;
        (function (LinearChart) {
            var Bar;
            (function (Bar) {
                var LinLogButton = (function (_super) {
                    __extends(LinLogButton, _super);
                    function LinLogButton(chart, options) {
                        var localization = chart.settings.localization.toolbar;
                        options.title = options.title || localization.linLogTitle;
                        options.label = options.label || localization.linButton;
                        _super.call(this, chart, options);
                        var cl = (options.cssClass || "") + " DVSL-bar-btn DVSL-bar-btn-l";
                        this.linClass = cl + "in";
                        this.logClass = cl + "og";
                        // set initial value
                        this.logScale = this.chart.scene.settings.valueAxisDefault.logScale;
                        this.updateElements();
                    }
                    LinLogButton.prototype.onClick = function (event) {
                        this.chart.setLogScale(!this.chart.scene.settings.valueAxisDefault.logScale, "user");
                        _super.prototype.onClick.call(this, event);
                    };
                    LinLogButton.prototype.updateElements = function () {
                        var localization = this.chart.settings.localization.toolbar;
                        if (this.logScale) {
                            this.a.className = this.logClass;
                            if (this.options.showLabel) {
                                this.p.innerHTML = localization.logButton;
                            }
                        }
                        else {
                            this.a.className = this.linClass;
                            if (this.options.showLabel) {
                                this.p.innerHTML = localization.linButton;
                            }
                        }
                    };
                    LinLogButton.prototype.onSceneChange = function (changes) {
                        var curState = this.chart.scene.settings.valueAxisDefault.logScale;
                        if (changes.settings && curState !== this.logScale) {
                            this.logScale = curState;
                            this.updateElements();
                        }
                    };
                    return LinLogButton;
                }(Internal.Base.Bar.Button));
                Bar.LinLogButton = LinLogButton;
                Internal.Base.Bar.ToolbarItemNames["logScale"] =
                    function (chart, options) { return new LinearChart.Bar.LinLogButton(chart, options); };
            })(Bar = LinearChart.Bar || (LinearChart.Bar = {}));
        })(LinearChart = Internal.LinearChart || (Internal.LinearChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../base/Settings.ts" />
/// <reference path="../../base/Bar/Toolbar.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var LinearChart;
        (function (LinearChart) {
            var SettingsToolbar = (function (_super) {
                __extends(SettingsToolbar, _super);
                function SettingsToolbar() {
                    _super.apply(this, arguments);
                    this.enabled = true;
                    this.export = true;
                    this.back = true;
                    this.zoomOut = true;
                    /** Whether to show the log scale button. */
                    this.logScale = true;
                }
                return SettingsToolbar;
            }(Internal.Base.SettingsToolbar));
            LinearChart.SettingsToolbar = SettingsToolbar;
        })(LinearChart = Internal.LinearChart || (Internal.LinearChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Data.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var SettingsData = (function (_super) {
                __extends(SettingsData, _super);
                function SettingsData() {
                    _super.apply(this, arguments);
                    /** Load more chart data. */
                    this.dataFunction = null;
                    this.preloaded = null;
                }
                return SettingsData;
            }(Internal.ItemsChart.SettingsData));
            NetChart.SettingsData = SettingsData;
            /** retrieving and caching raw data */
            var Data = (function (_super) {
                __extends(Data, _super);
                function Data(chart, dataSettings) {
                    _super.call(this, chart, dataSettings);
                    /**Maps node ID to the node object*/
                    this.nodes = {};
                    /**Maps link ID to the link object*/
                    this.links = {};
                    /**Maps node ID to related link objects*/
                    this.nodeToLinks = {};
                    this.pendingNodes = {};
                    this.requestedNodes = {};
                    this.pendingAllData = false;
                    this.requestedAllData = false;
                    this.nextLinkId = 0;
                    this.hasAllData = !this.hasDataFunc();
                }
                Data.otherEnd = function (linkData, nodeId) {
                    if (nodeId === linkData.from) {
                        return linkData.to;
                    }
                    if (nodeId === linkData.to) {
                        return linkData.from;
                    }
                    return null;
                };
                Data.multiLinkId = function (linkData) {
                    if (linkData.from < linkData.to) {
                        return linkData.from + Internal.Base.Helpers.SeparatorChar + linkData.to;
                    }
                    else {
                        return linkData.to + Internal.Base.Helpers.SeparatorChar + linkData.from;
                    }
                };
                // #region Protected overrides
                /** builds a new request or returns null */
                Data.prototype.buildRequest = function () {
                    // special mode for all data
                    if (this.pendingAllData) {
                        // If all data request is in progress, suspend all other requests. Only if that doesn't return all the necessary nodes, will we resume with what is left.
                        if (this.requestedAllData)
                            return null;
                        this.requestedAllData = true;
                        return { nodes: [] };
                    }
                    var nodes = [];
                    for (var id in this.pendingNodes) {
                        nodes.push(id);
                        delete this.pendingNodes[id];
                        this.requestedNodes[id] = true;
                        if (nodes.length >= this.dataSettings.requestMaxUnits) {
                            break;
                        }
                    }
                    if (nodes.length === 0)
                        return null;
                    return { nodes: nodes };
                };
                /** calls data loading, return true or data */
                Data.prototype.dataFunc = function (request, success, fail) {
                    var config = this.dataSettings;
                    if (config.dataFunction) {
                        config.dataFunction(request.nodes || null, success, fail);
                    }
                    else if (config.url) {
                        var params = [];
                        if (request.nodes) {
                            var nr = "";
                            for (var i = 0; i < request.nodes.length; i++) {
                                if (nr.length)
                                    nr += ",";
                                nr += encodeURIComponent(request.nodes[i]);
                            }
                            params.push(["nodes", nr]);
                        }
                        Internal.Base.Data.doRequest(config.url, config, params, success, fail);
                    }
                    else {
                        fail({ error: "Chart configuration does not define data retrieval function" });
                    }
                };
                /** verifies data, returns true if data is good to add */
                Data.prototype.verifyData = function (request, data) {
                    if (!Internal.Base.Helpers.hasProperty(data, "links"))
                        data.links = [];
                    if (!Internal.Base.Helpers.hasProperty(data, "nodes"))
                        data.nodes = [];
                    var allOk = true;
                    // convert object to array, if object is passed
                    if (!Array.isArray(data.nodes)) {
                        var nodeObj = data.nodes;
                        data.nodes = [];
                        var keys = Object.keys(nodeObj);
                        for (var i = 0; i < keys.length; i++) {
                            var key = keys[i];
                            var node = nodeObj[key];
                            node.id = key;
                            data.nodes.push(node);
                        }
                    }
                    if (!Array.isArray(data.links)) {
                        var linkObj = data.links;
                        data.links = [];
                        var keys = Object.keys(linkObj);
                        for (var i = 0; i < keys.length; i++) {
                            var key = keys[i];
                            var link = linkObj[key];
                            link.id = key;
                            data.links.push(link);
                        }
                    }
                    /* check that we have results for at least one ID; check for duplicate IDs */
                    var nodeIds = {};
                    var markLoaded = !request && !this.hasDataFunc();
                    // Sanity check for nodes
                    for (var i = 0; i < data.nodes.length; i++) {
                        var node = data.nodes[i];
                        if (node.id == null) {
                            node.id = Internal.Base.Helpers.getIdentifierStr();
                            Internal.Base.Helpers.warn("Data response: `id` property is mandatory for all nodes in the NetChart data object.", null, true);
                        }
                        else {
                            node.id = node.id.toString();
                        }
                        if (nodeIds.hasOwnProperty(node.id)) {
                            Internal.Base.Helpers.warn("Data response: Multiple nodes with the same ID: \"" + node.id + "\". Data will be merged.");
                        }
                        nodeIds[node.id] = true;
                        if (markLoaded) {
                            node.loaded = true;
                        }
                        else if (!Internal.Base.Helpers.hasProperty(node, "loaded")) {
                            Internal.Base.Helpers.warn("Data response: Node with ID \"" + node.id + "\" does not have the \"loaded\" flag. Assuming \"false\".");
                            node.loaded = false;
                        }
                        else {
                            node.loaded = !!node.loaded; // Force conversion to boolean.
                        }
                        if (Internal.Base.Helpers.hasProperty(node, "className") && node.className != null && !Internal.Base.Helpers.isString(node.className)) {
                            Internal.Base.Helpers.warn("Data response: Node property \"className\" must be a string. Node ID: \"" + node.id + "\".");
                            node.className = node.className.toString();
                        }
                        if (Internal.Base.Helpers.hasProperty(node, "error") && node.error != null && !Internal.Base.Helpers.isString(node.error)) {
                            Internal.Base.Helpers.warn("Data response: Node property \"error\" must be a string. Node ID: \"" + node.id + "\".");
                            node.error = node.error.toString();
                        }
                        if (Internal.Base.Helpers.hasProperty(node, "x") && node.x != null && !Internal.Base.Helpers.isNumber(node.x)) {
                            Internal.Base.Helpers.warn("Data response: Node property \"x\" must be a number. Node ID: \"" + node.id + "\".");
                            node.x = Internal.Base.Helpers.tryParseFloat(node.x, null);
                        }
                        if (Internal.Base.Helpers.hasProperty(node, "y") && node.y != null && !Internal.Base.Helpers.isNumber(node.y)) {
                            Internal.Base.Helpers.warn("Data response: Node property \"y\" must be a number. Node ID: \"" + node.id + "\".");
                            node.y = Internal.Base.Helpers.tryParseFloat(node.y, null);
                        }
                    }
                    // Sanity check for links
                    var linkIds = {};
                    for (var i = 0; i < data.links.length; i++) {
                        var link = data.links[i];
                        if (link.from == null) {
                            Internal.Base.Helpers.warn("Data response: Link missing property \"from\" and will be ignored. Link id: \"" + link.id + "\"");
                            continue;
                        }
                        else {
                            link.from = link.from.toString();
                        }
                        if (link.to == null) {
                            Internal.Base.Helpers.warn("Data response: Link missing property \"to\" and will be ignored. Link id: \"" + link.id + "\"");
                            continue;
                        }
                        else {
                            link.to = link.to.toString();
                        }
                        if (link.id == null) {
                            // generate internal ID for links with no ID
                            link.id = Internal.Base.Helpers.SeparatorChar + this.nextLinkId;
                            this.nextLinkId += 1;
                        }
                        else {
                            link.id = link.id.toString();
                        }
                        if (linkIds.hasOwnProperty(link.id)) {
                            Internal.Base.Helpers.warn("Data response: Multiple links with the same ID: \"" + link.id + "\". Data will be merged.");
                        }
                        linkIds[link.id] = true;
                        if (Internal.Base.Helpers.hasProperty(link, "className") && link.className != null && !Internal.Base.Helpers.isString(link.className)) {
                            Internal.Base.Helpers.warn("Data response: Link property \"className\" must be a string. Link ID: \"" + link.id + "\".");
                            link.className = link.className.toString();
                        }
                        if (Internal.Base.Helpers.hasProperty(link, "error") && link.error != null && !Internal.Base.Helpers.isString(link.error)) {
                            Internal.Base.Helpers.warn("Data response: Link property \"error\" must be a string. Link ID: \"" + link.id + "\".");
                            link.error = link.error.toString();
                        }
                        if (!Internal.Base.Helpers.hasProperty(this.nodes, link.from) && !Internal.Base.Helpers.hasProperty(nodeIds, link.from)) {
                            data.nodes.push({ id: link.from, loaded: markLoaded });
                        }
                        if (!Internal.Base.Helpers.hasProperty(this.nodes, link.to) && !Internal.Base.Helpers.hasProperty(nodeIds, link.to)) {
                            data.nodes.push({ id: link.to, loaded: markLoaded });
                        }
                    }
                    if (request) {
                        this.chart.log("Got " + data.nodes.length + " nodes on [" + request.nodes.join(", ") + "]");
                    }
                    else {
                        this.chart.log("Got " + data.nodes.length + " nodes on all nodes");
                    }
                    if (request && request.nodes.length > 0) {
                        var hasResultsOnRequestedNodes = false;
                        var hasLoadedRequestedNodes = false;
                        for (var nIndex = 0; nIndex < data.nodes.length; nIndex++) {
                            var node = data.nodes[nIndex];
                            if (request.nodes.indexOf(node.id) > -1) {
                                hasResultsOnRequestedNodes = true;
                                hasLoadedRequestedNodes = hasLoadedRequestedNodes || node.loaded;
                            }
                        }
                        if (!hasResultsOnRequestedNodes) {
                            this.chart.error("Data response: Results set did not contain any of requested nodes!", request.nodes);
                            allOk = false;
                        }
                        else if (!hasLoadedRequestedNodes) {
                            this.chart.error("Data response: loaded field was not set on any of the requested nodes!");
                            allOk = false;
                        }
                    }
                    return allOk;
                };
                /** add data, return scene changes object */
                Data.prototype.addVerifiedData = function (request, data) {
                    var ret = this.updateGraph(data);
                    for (var nIndex = 0; nIndex < data.nodes.length; nIndex++) {
                        var node = data.nodes[nIndex];
                        if (node.loaded || node.error) {
                            delete this.requestedNodes[node.id];
                            delete this.pendingNodes[node.id]; // Also delete from pending nodes and not re-request again.
                        }
                    }
                    if (request) {
                        if (request.nodes.length === 0) {
                            this.hasAllData = true;
                            this.pendingAllData = false;
                            this.requestedAllData = false;
                        }
                        else {
                            // put not loaded nodes back in pending
                            for (var nIndex = 0; nIndex < request.nodes.length; nIndex++) {
                                var nid = request.nodes[nIndex];
                                if (this.requestedNodes[nid]) {
                                    this.pendingNodes[nid] = true;
                                    delete this.requestedNodes[nid];
                                }
                            }
                        }
                    }
                    return ret;
                };
                Data.prototype.requestFailedPermanently = function (request) {
                    if (request.nodes) {
                        var nodes = [];
                        for (var idIndex = 0; idIndex < request.nodes.length; idIndex++) {
                            var id = request.nodes[idIndex];
                            nodes.push({
                                id: id,
                                error: "Bad response",
                                loaded: true
                            });
                        }
                        var changes = this.addVerifiedData(request, { nodes: nodes, links: [] });
                        if (!changes.dataArrived)
                            changes.dataArrived = {};
                        changes.dataArrived[this.dataSettings.id] = true;
                        this.chart.events.notifySceneChanges(changes);
                    }
                    this.chart.error("Failed data request, giving up on nodes: ", request.nodes);
                };
                // #endregion
                // #region Public overrides
                Data.prototype.removeData = function (data) {
                    var nodes = {};
                    var linksToRemove = [];
                    if (data.nodes) {
                        for (var nodeIndex = 0; nodeIndex < data.nodes.length; nodeIndex++) {
                            var node = data.nodes[nodeIndex];
                            nodes[node.id] = true;
                            linksToRemove = this.removeNode(node.id, linksToRemove);
                        }
                    }
                    if (data.links) {
                        for (var linkIndex = 0; linkIndex < data.links.length; linkIndex++) {
                            var link = data.links[linkIndex];
                            var l = this.links[link.id];
                            if (l) {
                                nodes[l.from] = true;
                                nodes[l.to] = true;
                                this.removeLink(l);
                            }
                        }
                    }
                    for (var link2Index = 0; link2Index < linksToRemove.length; link2Index++) {
                        var l = linksToRemove[link2Index];
                        nodes[l.from] = true;
                        nodes[l.to] = true;
                        this.removeLink(l);
                    }
                    return {
                        netChartDataNodes: nodes
                    };
                };
                Data.prototype.exportData = function () {
                    var nodes = [];
                    var links = [];
                    for (var id in this.nodes) {
                        var n = this.nodes[id];
                        nodes.push(n);
                    }
                    for (var id in this.links) {
                        var l = this.links[id];
                        links.push(l);
                    }
                    return {
                        nodes: nodes,
                        links: links
                    };
                };
                /** Applies preloaded data from settings or generates a random graph. Does not clear existing data. */
                Data.prototype.applyPreloadedData = function () {
                    if (this.dataSettings.randomNodes > 0) {
                        this.addData(this.genRandomGraph(this.dataSettings));
                    }
                    else {
                        _super.prototype.applyPreloadedData.call(this);
                    }
                };
                // #endregion
                /** Gets node data from cache and checks it with the node filter. If the node was found and filter returned true, the node is returned.
                    Otherwise null is returned. Partially loaded nodes are also returned, if the filter allows it. */
                Data.prototype.getNode = function (
                    /** ID of the node to get */
                    nodeId, 
                    /** Optional. Whether or not to attempt to asynchronously load the node if it was not found or the data was incomplete. Defaults to true.*/
                    request, 
                    /** Optional. If not null, will set extraInfo.loading=true if an asynchronous load operation was triggered. */
                    extraInfo) {
                    if (request === void 0) { request = true; }
                    if (extraInfo === void 0) { extraInfo = null; }
                    var node = Internal.Base.Helpers.hasProperty(this.nodes, nodeId) ? this.nodes[nodeId] : null;
                    if (extraInfo)
                        extraInfo.loading = false;
                    if (node) {
                        if (this.settings.legend.enabled && !this.chart.legend.isNodeVisible(node))
                            return null;
                        var nodeFilter = this.settings.filters.nodeFilter;
                        if (nodeFilter) {
                            var links = Internal.Base.Helpers.hasProperty(this.nodeToLinks, nodeId) ? this.nodeToLinks[nodeId] : null;
                            if (!nodeFilter(node, links))
                                return null;
                        }
                        if (!node.loaded && request) {
                            if (extraInfo)
                                extraInfo.loading = true;
                            this.requestNodeData(nodeId);
                        }
                    }
                    else if (request) {
                        if (extraInfo)
                            extraInfo.loading = true;
                        this.requestNodeData(nodeId);
                    }
                    else if (extraInfo) {
                        extraInfo.loading = this.isNodeLoading(nodeId);
                    }
                    return node;
                };
                /** Returns true if the node data has been requested, but has not yet arrived. */
                Data.prototype.isNodeLoading = function (nodeId) {
                    return this.pendingAllData
                        || this.requestedAllData
                        || Internal.Base.Helpers.hasProperty(this.pendingNodes, nodeId)
                        || Internal.Base.Helpers.hasProperty(this.requestedNodes, nodeId);
                };
                /** Gets node link data from cache and checks it with the filters. If the node and links were found and filters returned true, the links are returned.
                    Otherwise null is returned. Partially loaded links are also returned, if the filter allows it. If the node or links were not found or were not
                    fully loaded, checks the request parameter. If it is true, schedules a full data request. */
                Data.prototype.getLinks = function (
                    /** ID of the node whose links to retrieve. */
                    nodeId, 
                    /** Optional. Whether or not to attempt to asynchronously load the link data if it was not found or the data was incomplete. Defaults to true.*/
                    request) {
                    if (request === void 0) { request = true; }
                    var legendEnabled = this.settings.legend.enabled;
                    // Get node from cache. If not found, request node and return.
                    var node = Internal.Base.Helpers.hasProperty(this.nodes, nodeId) ? this.nodes[nodeId] : null;
                    if (!node) {
                        if (request)
                            this.requestNodeData(nodeId);
                        return [];
                    }
                    if (legendEnabled && !this.chart.legend.isNodeVisible(node))
                        return [];
                    // Get links from cache and check the node filter. If the source node is rejected, return.
                    var links = Internal.Base.Helpers.hasProperty(this.nodeToLinks, nodeId) ? this.nodeToLinks[nodeId] : [];
                    var nodeFilter = this.settings.filters.nodeFilter;
                    if (nodeFilter && !nodeFilter(node, links))
                        return [];
                    // Check if more data are needed and request if necessary.
                    if (!node.loaded && request)
                        this.requestNodeData(nodeId);
                    // OK, now process the links we've got through all the filters.
                    var linkFilter = this.settings.filters.linkFilter;
                    var nodeLinksProcessor = this.settings.filters.nodeLinksProcessor;
                    var multiLinkProcessor = this.settings.filters.multilinkProcessor;
                    // Also cache the results of nodeFilter(), for better performance.
                    var nodeFilterCache = {};
                    nodeFilterCache[nodeId] = true;
                    // First, node filter and link filter will check individual links. Also do a bit of sanity checks inbetween.
                    if (links.length > 0 && (nodeFilter || linkFilter || legendEnabled)) {
                        var filtered = new Array(links.length);
                        var p = 0;
                        for (var i = 0; i < links.length; i++) {
                            var link = links[i];
                            var otherNodeId = Data.otherEnd(link, nodeId);
                            if (otherNodeId == null) {
                                Internal.Base.Helpers.error("Invalid situation: link data found from '" + link.from + "' to '" + link.to + "' in the collection of links for '" + nodeId + "'");
                                continue;
                            }
                            if (!Internal.Base.Helpers.hasProperty(this.nodes, otherNodeId)) {
                                Internal.Base.Helpers.error("Invalid situation: link data found from '" + nodeId + "' to '" + otherNodeId + "', but no node data found for '" + otherNodeId + "'");
                                continue;
                            }
                            var otherNodeData = this.nodes[otherNodeId];
                            // Check passed, now check the far end node with the node filter.
                            if (nodeFilter || legendEnabled) {
                                if (Internal.Base.Helpers.hasProperty(nodeFilterCache, otherNodeId)) {
                                    if (!nodeFilterCache[otherNodeId])
                                        continue;
                                }
                                else {
                                    var filterResult = legendEnabled ? this.chart.legend.isNodeVisible(otherNodeData) : true;
                                    if (filterResult && nodeFilter)
                                        filterResult = nodeFilter(otherNodeData, Internal.Base.Helpers.hasProperty(this.nodeToLinks, otherNodeId) ? this.nodeToLinks[otherNodeId] : null);
                                    nodeFilterCache[otherNodeId] = filterResult;
                                    if (!filterResult)
                                        continue;
                                }
                            }
                            // Both nodes and the link are known. Check with the link filter.
                            if (linkFilter || legendEnabled) {
                                var d1 = void 0;
                                var d2 = void 0;
                                if (link.from === nodeId) {
                                    d1 = node;
                                    d2 = otherNodeData;
                                }
                                else {
                                    d1 = otherNodeData;
                                    d2 = node;
                                }
                                if (legendEnabled && !this.chart.legend.isLinkVisible(link))
                                    continue;
                                if (linkFilter && !linkFilter(link, d1, d2))
                                    continue;
                            }
                            // All checks passed, add to results.
                            filtered[p++] = link;
                        }
                        filtered.length = p;
                        links = filtered;
                    }
                    // OK, nodeFilter and linkFilter checks are passed. Now check against the bulk filter.
                    if (nodeLinksProcessor)
                        links = nodeLinksProcessor(node, links);
                    // If nodeLinksProcessor returned something that is not an array (including null), abort the rest.
                    if (!Array.isArray(links))
                        return [];
                    // Final part, aggregate multilinks. That is, several links between the same pair of nodes may be merged in a single link via the multiLinkProcessor callback.
                    if (multiLinkProcessor) {
                        // Check if there are any multilinks at all.
                        var otherNodes = {};
                        var hasMultiLinks = false;
                        for (var i = 0; i < links.length; i++) {
                            var otherEnd = Data.otherEnd(links[i], nodeId);
                            if (!otherEnd)
                                continue;
                            if (Internal.Base.Helpers.hasProperty(otherNodes, otherEnd)) {
                                hasMultiLinks = true;
                                break;
                            }
                            otherNodes[otherEnd] = true;
                        }
                        if (hasMultiLinks) {
                            var filtered = [];
                            var multiIds = {};
                            var multiLists = {};
                            // First, find all the multilinks and store them in multiLists.
                            for (var i = 0; i < links.length; i++) {
                                var l = links[i];
                                var multiId = Data.multiLinkId(l);
                                if (multiIds.hasOwnProperty(multiId)) {
                                    if (!multiLists.hasOwnProperty(multiId)) {
                                        multiLists[multiId] = [multiIds[multiId], l];
                                    }
                                    else {
                                        multiLists[multiId].push(l);
                                    }
                                }
                                else {
                                    multiIds[multiId] = l;
                                }
                            }
                            // Now find all the links that are NOT multilinks, and add them to the result.
                            for (var i = 0; i < links.length; i++) {
                                var l = links[i];
                                var multiId = Data.multiLinkId(l);
                                if (!multiLists.hasOwnProperty(multiId)) {
                                    filtered.push(l);
                                }
                            }
                            // Last, iterate through all the MultiIds, pass them through multiLinkProcessor and add them to the result.
                            var multiListsKeys = Object.keys(multiLists);
                            for (var i = 0; i < multiListsKeys.length; i++) {
                                var mlinks = multiLists[multiListsKeys[i]];
                                var l = mlinks[0];
                                var processedLinks = multiLinkProcessor(mlinks, this.nodes[l.from], this.nodes[l.to]);
                                if (Array.isArray(processedLinks)) {
                                    filtered = filtered.concat(processedLinks);
                                }
                                else if (processedLinks) {
                                    filtered.push(processedLinks);
                                }
                            }
                            links = filtered;
                        }
                    }
                    // And we're done! Phew! Return the results.
                    return links;
                };
                /** Gets all nodes that are currently in the cache and pass the node filter. If all data was not loaded before, schedules a full data request. */
                Data.prototype.getAllNodes = function (request) {
                    if (request === void 0) { request = true; }
                    var nodeFilter = this.settings.filters.nodeFilter;
                    var keys = Object.keys(this.nodes);
                    var ret = new Array(keys.length);
                    var p = 0;
                    for (var i = 0; i < keys.length; i++) {
                        var nodeId = keys[i];
                        var node = this.nodes[nodeId];
                        if (this.settings.legend.enabled && !this.chart.legend.isNodeVisible(node))
                            continue;
                        if (nodeFilter && !nodeFilter(node, Internal.Base.Helpers.hasProperty(this.nodeToLinks, nodeId) ? this.nodeToLinks[nodeId] : null))
                            continue;
                        ret[p++] = node;
                    }
                    ret.length = p;
                    if (!this.hasAllData && !this.pendingAllData && request) {
                        this.pendingAllData = true;
                        this.scheduleRequests();
                    }
                    return ret;
                };
                // #region Private functions
                Data.prototype.requestNodeData = function (nodeId) {
                    if (!this.hasDataFunc()) {
                        this.chart.error("Cannot request node data! Please specify either data function or data URL in the settings!");
                        return;
                    }
                    if (this.pendingNodes.hasOwnProperty(nodeId) || this.requestedNodes.hasOwnProperty(nodeId)) {
                        return;
                    }
                    this.pendingNodes[nodeId] = true;
                    this.scheduleRequests();
                };
                Data.prototype.hasDataFunc = function () {
                    return this.dataSettings.dataFunction != null || this.dataSettings.url != null;
                };
                Data.prototype.updateGraph = function (data) {
                    var updatedNodes = {};
                    for (var nodeIndex = 0; nodeIndex < data.nodes.length; nodeIndex++) {
                        var node = data.nodes[nodeIndex];
                        if (Internal.Base.Helpers.hasProperty(this.nodes, node.id)) {
                            var orig = this.nodes[node.id];
                            // Loaded=true responses are considered authorative and will not be overriden by subsequent loaded=false responses.
                            if (!node.error && (!orig.loaded || node.loaded)) {
                                Internal.Base.Helpers.extendDataItem(orig, node);
                                orig.resetCoordinates = (node.x != null || node.y != null) && orig.x != null && orig.y != null;
                                updatedNodes[node.id] = true;
                            }
                        }
                        else {
                            var newNode = Internal.Base.Helpers.extendDataItem({}, node);
                            newNode.resetCoordinates = newNode.x != null && newNode.y != null;
                            this.nodes[node.id] = newNode;
                            this.nodeToLinks[node.id] = [];
                            updatedNodes[node.id] = true;
                        }
                    }
                    for (var i = 0; i < data.links.length; i++) {
                        var link = data.links[i];
                        if (Internal.Base.Helpers.hasProperty(this.links, link.id)) {
                            var orig = this.links[link.id];
                            if ((link.from && orig.from !== link.from) || (link.to && orig.to !== link.to)) {
                                this.chart.error("Changing link from/to not supported. Link ignored. Link ID: \"" + link.id + "\"");
                                continue;
                            }
                            else {
                                Internal.Base.Helpers.extendDataItem(orig, link);
                            }
                        }
                        else {
                            if (!link.from || !link.to) {
                                continue;
                            }
                            this.links[link.id] = link;
                            this.nodeToLinks[link.from].push(link);
                            if (link.from !== link.to)
                                this.nodeToLinks[link.to].push(link);
                        }
                        updatedNodes[link.from] = true;
                        updatedNodes[link.to] = true;
                    }
                    return {
                        netChartDataNodes: updatedNodes
                    };
                };
                Data.prototype.removeNode = function (nodeId, linksToRemove) {
                    delete this.pendingNodes[nodeId];
                    delete this.requestedNodes[nodeId];
                    if (Internal.Base.Helpers.hasProperty(this.nodes, nodeId))
                        delete this.nodes[nodeId];
                    if (Internal.Base.Helpers.hasProperty(this.nodeToLinks, nodeId)) {
                        linksToRemove = linksToRemove.concat(this.nodeToLinks[nodeId]);
                        delete this.nodeToLinks[nodeId];
                    }
                    return linksToRemove;
                };
                Data.prototype.removeLink = function (link) {
                    delete this.links[link.id];
                    if (Internal.Base.Helpers.hasProperty(this.nodeToLinks, link.from))
                        Internal.Base.Helpers.removeFromArrayHasty(this.nodeToLinks[link.from], link);
                    if (Internal.Base.Helpers.hasProperty(this.nodeToLinks, link.to))
                        Internal.Base.Helpers.removeFromArrayHasty(this.nodeToLinks[link.to], link);
                };
                Data.prototype.genRandomGraph = function (settings) {
                    var numNodes = settings.randomNodes;
                    var numLinks = settings.randomLinks;
                    var data;
                    if (settings.random === "grid") {
                        data = this.genRandomGrid(numNodes, settings.randomGridLinkProbability);
                    }
                    else if (settings.random === "tree") {
                        data = this.genRandomTree(numNodes, settings.randomTreeDensity);
                    }
                    else {
                        data = this.genRandomUniform(numNodes, numLinks);
                    }
                    for (var nodeIndex = 0; nodeIndex < data.nodes.length; nodeIndex++) {
                        var node = data.nodes[nodeIndex];
                        node.style = { label: ("Node " + node.id) };
                    }
                    for (var linkIndex = 0; linkIndex < data.links.length; linkIndex++) {
                        var link = data.links[linkIndex];
                        link.style = { label: ("Link " + link.id) };
                    }
                    return data;
                };
                Data.prototype.genRandomGrid = function (numNodes, linkProbability) {
                    var nodes = [];
                    var links = [];
                    for (var i = 0; i <= numNodes - 1; i++) {
                        var n = {
                            id: ("n" + i),
                            loaded: true
                        };
                        nodes.push(n);
                    }
                    var gridSize = Math.ceil(Math.sqrt(numNodes));
                    var random = new Internal.Base.Random(32131);
                    for (var y = 0; y <= gridSize - 1; y++) {
                        for (var x = 0; x <= gridSize - 1; x++) {
                            var ind = x + y * gridSize;
                            if (ind >= numNodes) {
                                continue;
                            }
                            if (x > 0 && random.get() <= linkProbability) {
                                links.push({
                                    from: "n" + ind,
                                    to: "n" + (ind - 1)
                                });
                            }
                            if (y > 0 && random.get() <= linkProbability) {
                                links.push({
                                    from: "n" + ind,
                                    to: "n" + (ind - gridSize)
                                });
                            }
                        }
                    }
                    for (var ind2 = 0; ind2 < links.length; ind2++) {
                        var l = links[ind2];
                        l.id = "" + ind2;
                    }
                    return { nodes: nodes, links: links };
                };
                Data.prototype.genRandomUniform = function (numNodes, numLinks) {
                    var random = new Internal.Base.Random(32131);
                    var nodes = [];
                    var links = [];
                    for (var i = 0; i < numNodes; i++) {
                        var n = {
                            id: ("n" + i),
                            loaded: true
                        };
                        if (nodes.length > 0) {
                            var l = {
                                id: "l" + i,
                                from: n.id,
                                to: nodes[random.get() * nodes.length | 0].id
                            };
                            links.push(l);
                        }
                        nodes.push(n);
                    }
                    for (var i = links.length; i <= numLinks - 1; i++) {
                        var l = {
                            id: ("l" + (i + 1)),
                            from: nodes[(random.get() * nodes.length) | 0].id,
                            to: nodes[(random.get() * nodes.length) | 0].id
                        };
                        links.push(l);
                    }
                    return { nodes: nodes, links: links };
                };
                Data.prototype.genRandomTree = function (numNodes, maxBranches) {
                    var random = new Internal.Base.Random(31927832);
                    var root = { id: "n0", loaded: true };
                    var freeNodes = [root];
                    var nodes = [root];
                    var links = [];
                    while (nodes.length < numNodes) {
                        var node = random.getArrayElement(freeNodes);
                        Internal.Base.Helpers.removeFromArrayHasty(freeNodes, node);
                        var linkCount = Math.max(1, Math.ceil(random.get() * maxBranches));
                        for (var i = 0; i < linkCount; i++) {
                            var nn = {
                                id: "n" + nodes.length,
                                loaded: true
                            };
                            var l = {
                                id: "l" + nodes.length,
                                from: node.id,
                                to: nn.id
                            };
                            links.push(l);
                            nodes.push(nn);
                            freeNodes.push(nn);
                        }
                    }
                    return { nodes: nodes, links: links };
                };
                return Data;
            }(Internal.Base.Data));
            NetChart.Data = Data;
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../base/core/ChartEvents.ts" />
/// <reference path="../Data.ts" />
/// <reference path="../../base/Navigator.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            /** Navigation class, responsible for showing and hiding nodes in response to various user actions and API calls. */
            var Navigator = (function (_super) {
                __extends(Navigator, _super);
                function Navigator(chart) {
                    _super.call(this);
                    this.updateOrder = 150; // After legend
                    this.chart = chart;
                }
                Navigator.CreateNavigator = function (chart) {
                    switch (chart.settings.navigation.mode) {
                        case "manual":
                            return new NetChart.ManualNavigator(chart);
                        case "showall":
                            return new NetChart.ShowAllNavigator(chart);
                        case "focusnodes":
                            return new NetChart.FocusNodesNavigator(chart);
                        default:
                            chart.error("Unknown navigation mode: '" + chart.settings.navigation.mode + "'");
                            return new NetChart.ShowAllNavigator(chart);
                    }
                };
                //#endregion
                //#region Common protected methods
                /** Updates graph nodes and links with new data when it arrives. Removes nodes that doesn't exist anymore. */
                Navigator.prototype.updateGraphWithNewData = function (nodesWithNewData, event) {
                    var layer = this.chart.layer;
                    var data = this.chart.scene.mainData;
                    var layerNodes = layer.idToNode;
                    var allIds = Object.keys(nodesWithNewData ? nodesWithNewData : layerNodes);
                    var extraInfo = { loading: false };
                    for (var i = 0; i < allIds.length; i++) {
                        var id = allIds[i];
                        if (!Internal.Base.Helpers.hasProperty(layerNodes, id))
                            continue;
                        var node = layerNodes[id];
                        if (node.removed)
                            continue;
                        // Get data, but only from cache, don't request it here. Filters still get applied though.
                        var newData = data.getNode(id, false, extraInfo);
                        if (newData) {
                            this.updateNodeWithNewData(node, newData, data.getLinks(id, false));
                            layer.touchNode(node);
                        }
                        else if (extraInfo.loading) {
                            if (!node.loading) {
                                node.loading = true;
                                layer.touchNode(node);
                            }
                        }
                        else {
                            this.ensureNodeRemoved(node);
                        }
                    }
                };
                /** Calculates whether or not a node is expanded. Returns whether any changes were made */
                Navigator.prototype.calcExpanded = function (node) {
                    var old = node.expanded;
                    if (node.links.length < node.dataLinks.length) {
                        node.expanded = false;
                        return old;
                    }
                    for (var i = 0; i < node.links.length; i++)
                        if (node.links[i].removed) {
                            node.expanded = false;
                            return old;
                        }
                    node.expanded = true;
                    return !old;
                };
                /** Synchronizes a node's .links with .dataLinks. Removes or adds links as necessary, as well as updating data. */
                Navigator.prototype.syncNodeLinks = function (node) {
                    var layer = this.chart.layer;
                    var links = node.links;
                    var dataLinks = node.dataLinks;
                    var dataLinksById = {};
                    for (var i = 0; i < dataLinks.length; i++)
                        dataLinksById[dataLinks[i].id] = dataLinks[i];
                    // Remove or update visible links
                    for (var j = 0; j < links.length; j++) {
                        var link = links[j];
                        if (link.removed)
                            continue;
                        if (Internal.Base.Helpers.hasProperty(dataLinksById, link.id)) {
                            link.data = dataLinksById[link.id];
                            layer.touchLink(link);
                            delete dataLinksById[link.id];
                        }
                        else {
                            this.ensureLinkRemoved(link);
                        }
                    }
                    // Add new links to visible nodes.
                    var linkIds = Object.keys(dataLinksById);
                    var id = node.id;
                    for (var i = 0; i < linkIds.length; i++) {
                        var link = dataLinksById[linkIds[i]];
                        var otherId = NetChart.Data.otherEnd(link, id);
                        if (Internal.Base.Helpers.hasProperty(layer.idToNode, otherId) && !layer.idToNode[otherId].removed)
                            this.ensureLink(link);
                    }
                    this.calcExpanded(node);
                };
                Navigator.prototype.updateNodeWithNewData = function (node, newData, newLinkData) {
                    node.data = newData;
                    if (newData.resetCoordinates) {
                        node.x = newData.x;
                        node.y = newData.y;
                        newData.resetCoordinates = false;
                    }
                    if (newData.loaded)
                        node.loading = false;
                    node.dataLinks = newLinkData;
                    this.syncNodeLinks(node);
                };
                /** Ensure that a node referenced by the nodeDate/nodeLinksData is there. Don't update anything if it is - that will be done by updateGraphWithNewData().
                    Returns whether or not any changes were made. */
                Navigator.prototype.ensureNode = function (nodeData, nodeLinksData) {
                    var layer = this.chart.layer;
                    var node = Internal.Base.Helpers.hasProperty(layer.idToNode, nodeData.id) ? layer.idToNode[nodeData.id] : null;
                    if (node && !node.removed)
                        return false;
                    node = layer.addNode(nodeData.id);
                    if (nodeData.x)
                        node.x = nodeData.x;
                    if (nodeData.y)
                        node.y = nodeData.y;
                    nodeData.resetCoordinates = false;
                    node.loading = !nodeData.loaded;
                    node.data = nodeData;
                    node.dataLinks = nodeLinksData;
                    this.chart.graph.applyRestoredCoordinates(node);
                    this.syncNodeLinks(node);
                    return true;
                };
                /** Ensure that a link referenced by the linkData is there. Don't update anything if it is - that will be done by updateGraphWithNewData().
                    Also check that both nodes exist before adding the link, and maintain .expanded on both nodes.
                    Returns whether or not any changes were made. */
                Navigator.prototype.ensureLink = function (linkData) {
                    var layer = this.chart.layer;
                    var link = Internal.Base.Helpers.hasProperty(layer.idToLink, linkData.id) ? layer.idToLink[linkData.id] : null;
                    if (link && !link.removed)
                        return false;
                    var node1 = Internal.Base.Helpers.hasProperty(layer.idToNode, linkData.from) ? layer.idToNode[linkData.from] : null;
                    var node2 = Internal.Base.Helpers.hasProperty(layer.idToNode, linkData.to) ? layer.idToNode[linkData.to] : null;
                    if (!node1 || node1.removed || !node2 || node2.removed)
                        return false;
                    link = layer.addLink(linkData.id, linkData.from, linkData.to);
                    link.data = linkData;
                    this.calcExpanded(node1);
                    this.calcExpanded(node2);
                    return true;
                };
                /** Ensures that a node is removed. Also removes links to this node and updates .expanded of linked nodes.
                    Returns whether or not any changes were made. */
                Navigator.prototype.ensureNodeRemoved = function (node) {
                    if (!node || node.removed)
                        return false;
                    var layer = this.chart.layer;
                    var links = node.links;
                    for (var i = links.length - 1; i >= 0; i--) {
                        var link = links[i];
                        if (link.removed)
                            continue;
                        var otherNode = link.otherEnd(node);
                        if (otherNode !== node && !otherNode.removed && otherNode.expanded) {
                            otherNode.expanded = false;
                            layer.touchNode(otherNode);
                        }
                        layer.removeLink(link);
                    }
                    layer.removeNode(node);
                    return true;
                };
                /** Ensures that a link is removed. Updates .expanded of endpoint nodes. */
                Navigator.prototype.ensureLinkRemoved = function (link) {
                    if (!link || link.removed)
                        return false;
                    var layer = this.chart.layer;
                    if (!link.from.removed && link.from.expanded) {
                        link.from.expanded = false;
                        layer.touchNode(link.from);
                    }
                    if (!link.to.removed && link.to.expanded) {
                        link.to.expanded = false;
                        layer.touchNode(link.to);
                    }
                    layer.removeLink(link);
                    return true;
                };
                return Navigator;
            }(Internal.Base.Navigator));
            NetChart.Navigator = Navigator;
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../base/core/ChartEvents.ts" />
/// <reference path="../Data.ts" />
/// <reference path="NavigatorBase.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            /** Extra flags for the nodes that the user has explicitly expanded or hidden. */
            var ExtraFlags;
            (function (ExtraFlags) {
                /** Node is hidden and does not participate in relevance calculations. */
                ExtraFlags[ExtraFlags["Hidden"] = 1] = "Hidden";
                /** Node is expanded and has a minimum guaranteed relevance of 2. */
                ExtraFlags[ExtraFlags["Expanded"] = 2] = "Expanded";
            })(ExtraFlags || (ExtraFlags = {}));
            /** Navigator for the FocusNodes algorithm. */
            var FocusNodesNavigator = (function (_super) {
                __extends(FocusNodesNavigator, _super);
                function FocusNodesNavigator() {
                    _super.apply(this, arguments);
                    this.focusNodes = [];
                    this.extraFlags = {};
                    this.needsFullRecalculate = false;
                    this.wasReset = false;
                }
                FocusNodesNavigator.prototype.expandNode = function (nodeId, origin) {
                    var nodes = this.chart.layer.idToNode;
                    var node = Internal.Base.Helpers.hasProperty(nodes, nodeId) ? nodes[nodeId] : null;
                    var hasChanges = false;
                    if (!node || node.removed)
                        return;
                    // Assign the Expanded flag if the node needs it.
                    if (node.relevance < 2) {
                        this.extraFlags[nodeId] = ExtraFlags.Expanded;
                        hasChanges = true;
                    }
                    // Remove the Hidden flag from any linked nodes.
                    for (var i = 0; i < node.dataLinks.length; i++) {
                        var otherId = NetChart.Data.otherEnd(node.dataLinks[i], nodeId);
                        if (otherId && otherId !== nodeId && Internal.Base.Helpers.hasProperty(this.extraFlags, otherId) && this.extraFlags[otherId] === ExtraFlags.Hidden) {
                            delete this.extraFlags[otherId];
                            hasChanges = true;
                        }
                    }
                    if (hasChanges) {
                        // Schedule a full recalculate of the relevances. This will show the newly visible nodes.
                        this.scheduleFullRecalculate();
                        this.chart.notifyChartUpdate(origin);
                    }
                };
                FocusNodesNavigator.prototype.collapseNode = function (nodeId, origin) {
                    var nodes = this.chart.layer.idToNode;
                    var node = Internal.Base.Helpers.hasProperty(nodes, nodeId) ? nodes[nodeId] : null;
                    var hasChanges = false;
                    if (!node || node.removed)
                        return;
                    if (Internal.Base.Helpers.hasProperty(this.extraFlags, nodeId)) {
                        delete this.extraFlags[nodeId];
                        hasChanges = true;
                    }
                    for (var i = 0; i < node.links.length; i++) {
                        var otherNode = node.links[i].otherEnd(node);
                        if (otherNode && otherNode !== node && !otherNode.removed && otherNode.baseRelevance < node.baseRelevance) {
                            this.extraFlags[otherNode.id] = ExtraFlags.Hidden;
                            hasChanges = true;
                        }
                    }
                    if (hasChanges) {
                        // Schedule a full recalculate of the relevances. This will show the newly visible nodes.
                        this.scheduleFullRecalculate();
                        this.chart.notifyChartUpdate(origin);
                    }
                };
                FocusNodesNavigator.prototype.closeNode = function (nodeId, origin) { };
                FocusNodesNavigator.prototype.focusNode = function (nodeId, relevance, origin) {
                    for (var i = 0; i < this.focusNodes.length; i++) {
                        if (this.focusNodes[i].id === nodeId)
                            return;
                    }
                    if (this.focusNodes.length >= this.chart.settings.navigation.numberOfFocusNodes) {
                        if (!this.chart.settings.navigation.autoUnfocus)
                            return;
                        this.focusNodes.pop();
                    }
                    this.focusNodes.unshift({ id: nodeId, assignedRelevance: relevance, calculatedRelevance: null });
                    // Remove Hidden flag from the node (shouldn't normally happen, but possible through an API call)
                    if (Internal.Base.Helpers.hasProperty(this.extraFlags, nodeId) && this.extraFlags[nodeId] === ExtraFlags.Hidden)
                        delete this.extraFlags[nodeId];
                    // Also remove any Hidden flags from neighbor nodes.
                    var allLinks = this.chart.scene.mainData.getLinks(nodeId, false);
                    if (allLinks)
                        for (var i = 0; i < allLinks.length; i++) {
                            var otherId = NetChart.Data.otherEnd(allLinks[i], nodeId);
                            if (otherId && otherId !== nodeId && Internal.Base.Helpers.hasProperty(this.extraFlags, otherId) && this.extraFlags[otherId] === ExtraFlags.Hidden)
                                delete this.extraFlags[otherId];
                        }
                    this.chart.notifyChartUpdate(origin);
                    this.scheduleFullRecalculate();
                };
                FocusNodesNavigator.prototype.unfocusNode = function (nodeId, origin) {
                    if (this.focusNodes.length <= Math.max(this.chart.settings.navigation.minNumberOfFocusNodes, 1))
                        return;
                    for (var i = 0; i < this.focusNodes.length; i++) {
                        if (this.focusNodes[i].id === nodeId) {
                            this.focusNodes.splice(i, 1);
                            this.chart.notifyChartUpdate(origin);
                            this.scheduleFullRecalculate();
                            return;
                        }
                    }
                };
                FocusNodesNavigator.prototype.clearFocusNodes = function (origin) {
                    this.focusNodes = [];
                    this.extraFlags = {};
                    this.wasReset = true;
                    this.chart.notifyChartUpdate(origin);
                    this.scheduleFullRecalculate();
                };
                FocusNodesNavigator.prototype.hideNode = function (nodeId, origin) {
                    var nodes = this.chart.layer.idToNode;
                    var node = Internal.Base.Helpers.hasProperty(nodes, nodeId) ? nodes[nodeId] : null;
                    if (!node || node.removed || !this.canHideNode(node))
                        return;
                    this.extraFlags[nodeId] = ExtraFlags.Hidden;
                    this.chart.notifyChartUpdate(origin);
                    this.scheduleFullRecalculate();
                };
                FocusNodesNavigator.prototype.showNode = function (nodeId, origin) {
                    // For FocusNodes navigator, all possible nodes are already shown. The only exception is if a node was
                    // explicitly hidden by the user. If so, remove the Hidden flag and call for relevance recalculation.
                    if (!Internal.Base.Helpers.hasProperty(this.extraFlags, nodeId) || this.extraFlags[nodeId] !== ExtraFlags.Hidden)
                        return;
                    delete this.extraFlags[nodeId];
                    this.scheduleFullRecalculate();
                };
                FocusNodesNavigator.prototype.showInitialNodes = function () {
                    this.extraFlags = {};
                    var initialNodes = this.chart.settings.navigation.initialNodes;
                    if (initialNodes) {
                        var duplicates = {};
                        this.focusNodes = new Array(initialNodes.length);
                        var p = 0;
                        for (var i = 0; i < initialNodes.length; i++) {
                            var id = initialNodes[i];
                            if (Internal.Base.Helpers.hasProperty(duplicates, id))
                                continue;
                            duplicates[id] = true;
                            this.focusNodes[p++] = { id: id, assignedRelevance: -1, calculatedRelevance: null };
                        }
                        if (p < this.chart.settings.navigation.minNumberOfFocusNodes)
                            this.chart.error("Too few initialNodes. minNumberOfFocusNodes is " +
                                this.chart.settings.navigation.minNumberOfFocusNodes + " but there are only " + p + " nodes in initialNodes");
                        if (p > this.chart.settings.navigation.numberOfFocusNodes) {
                            this.chart.error("Too many initialNodes. numberOfFocusNodes is " +
                                this.chart.settings.navigation.numberOfFocusNodes + " but there are " + p + " nodes in initialNodes. Discarding excess focus nodes.");
                            p = this.chart.settings.navigation.numberOfFocusNodes;
                        }
                        this.focusNodes.length = p;
                    }
                    else {
                        this.focusNodes = [];
                    }
                    this.wasReset = true;
                    this.chart.notifyChartUpdate("init");
                    this.scheduleFullRecalculate();
                };
                FocusNodesNavigator.prototype.save = function () {
                    return { focusNodes: this.focusNodes, extraFlags: this.extraFlags };
                };
                FocusNodesNavigator.prototype.restore = function (state) {
                    this.focusNodes = Internal.Base.Helpers.realClone(state.focusNodes);
                    this.extraFlags = Internal.Base.Helpers.clone(state.extraFlags);
                    this.scheduleFullRecalculate();
                    this.chart.notifyChartUpdate("restore");
                };
                FocusNodesNavigator.prototype.onNewDataObject = function () {
                    // Schedule data requests for all visible nodes.
                    var data = this.chart.scene.mainData;
                    var keys = Object.keys(this.chart.layer.idToNode);
                    for (var i = 0; i < keys.length; i++)
                        data.getNode(keys[i]);
                };
                FocusNodesNavigator.prototype.onSceneChange = function (event) {
                    if (event.changes.filters) {
                        this.updateGraphWithNewData(null, event);
                        this.needsFullRecalculate = true;
                    }
                    else if (event.changes.dataArrived || event.changes.data) {
                        this.updateGraphWithNewData(event.changes.netChartDataNodes, event);
                        this.needsFullRecalculate = true;
                    }
                    else if (event.changes.settings && event.changes.settingsChanges.navigation) {
                        this.needsFullRecalculate = true;
                    }
                    if (this.needsFullRecalculate) {
                        this.needsFullRecalculate = false;
                        this.fullRecalculate(event.timeStamp, event);
                    }
                };
                FocusNodesNavigator.prototype.scheduleFullRecalculate = function () {
                    this.needsFullRecalculate = true;
                    this.chart.events.notifySceneChanges({ navigation: true });
                };
                /** Main method for relevance calculations. Implements the algorithm described in the documentation. */
                FocusNodesNavigator.prototype.fullRecalculate = function (timestamp, event) {
                    var _this = this;
                    var settings = this.chart.settings.navigation;
                    var layer = this.chart.layer;
                    var data = this.chart.scene.mainData;
                    // If we don't have any focus nodes, clear everything and return.
                    if (this.focusNodes.length < 1) {
                        layer.clearObjects();
                        if (this.wasReset)
                            event.changes.newGraph = true;
                        this.wasReset = false;
                        return;
                    }
                    var maxAllowedExpansionTimestamp = timestamp - this.chart.settings.navigation.expandDelay;
                    // First, set all relevances to all visible nodes to -Infinity and remove the .focused flag.
                    var layerNodes = layer.idToNode;
                    var layerNodeIds = Object.keys(layerNodes);
                    var layerLinks = layer.idToLink;
                    for (var i = 0; i < layerNodeIds.length; i++) {
                        var node = layerNodes[layerNodeIds[i]];
                        node.baseRelevance = -Infinity;
                        node.relevance = -Infinity;
                        node.focused = false;
                        layer.touchNode(node);
                    }
                    if (settings.numberOfFocusNodes > 1) {
                        var tailRadius = settings.focusNodeTailExpansionRadius == null ? settings.focusNodeExpansionRadius : settings.focusNodeTailExpansionRadius;
                        var maxRelevance = Math.max(settings.focusNodeExpansionRadius + 1, 1);
                        var minRelevance = Math.max(tailRadius + 1, 1);
                        // Then calculate relevances for the focus nodes. Distribute them equally between "focusNodeExpansionRadius + 1" and "focusNodeTailExpansionRadius + 1".
                        // If there are less than numberOfFocusNodes focus nodes, assign the existing ones with the same values as they would be assigned if there was a full set.
                        var deltaRelevance = (maxRelevance - minRelevance) / (settings.numberOfFocusNodes - 1);
                        for (var i = 0; i < this.focusNodes.length; i++)
                            this.focusNodes[i].calculatedRelevance = maxRelevance - i * deltaRelevance;
                    }
                    else {
                        this.focusNodes[0].calculatedRelevance = Math.max(settings.focusNodeExpansionRadius + 1, 1);
                    }
                    var queue = []; // BFS queue
                    var queueById = {}; // A dictionary with all nodes in the queue, for quick checking if a node is in the queue or not.
                    var reachableNodes = {}; // A collection with all the nodes that can be reached from the focus nodes.
                    // Get the focus nodes (create if necessary) and add them to the BFS queue. Set the .focused flag on thenm.
                    for (var i = 0; i < this.focusNodes.length; i++) {
                        var fn = this.focusNodes[i];
                        var node = Internal.Base.Helpers.hasProperty(layerNodes, fn.id) ? layerNodes[fn.id] : null;
                        // If node doesn't exist, attempt to create it.
                        if (!node || node.removed) {
                            var nodeData = data.getNode(fn.id);
                            if (!nodeData)
                                continue; // Couldn't get node data. Oh, well, it's scheduled to arrive later, which will trigger a recalculate. Ignore for now.
                            this.ensureNode(nodeData, data.getLinks(fn.id));
                            node = layerNodes[fn.id];
                        }
                        // Now we have an existing node, assign its relevances.
                        node.focused = true;
                        node.baseRelevance = fn.assignedRelevance >= 1 ? fn.assignedRelevance : fn.calculatedRelevance;
                        node.relevance = node.baseRelevance;
                        // Focus nodes always have showTimestamp of -Infinity, so that the first layer of nodes around them is displayed immediately. 
                        node.showTimestamp = -Infinity;
                        queue.push(node);
                        queueById[fn.id] = true;
                        reachableNodes[fn.id] = true;
                        if (this.wasReset) {
                            this.wasReset = false;
                            event.changes.newGraph = true;
                        }
                    }
                    // For all the expanded nodes, set their relevances to 2, and their (non-hidden) neighbor's relevances to 1.
                    // For all the hidden nodes, set their relevances to -100.
                    var keys = Object.keys(this.extraFlags);
                    for (var i = 0; i < keys.length; i++) {
                        var id = keys[i];
                        var node = Internal.Base.Helpers.hasProperty(layerNodes, id) ? layerNodes[id] : null;
                        if (!node || node.removed)
                            continue;
                        if (this.extraFlags[id] === ExtraFlags.Hidden) {
                            node.relevance = -100; // Special value for hidden nodes.
                        }
                        else {
                            // A focus node is likely to have releveance higher than 2; don't change that.
                            if (node.relevance < 2) {
                                node.relevance = 2;
                                for (var j = 0; j < node.links.length; j++) {
                                    var otherNode = node.links[j].otherEnd(node);
                                    if (otherNode && otherNode !== node && otherNode.relevance < 1 && otherNode.relevance !== -100)
                                        otherNode.relevance = 1;
                                }
                            }
                            else {
                                // If a node is focused and has relevance of at least 2, delete the expanded flag.
                                delete this.extraFlags[id];
                            }
                        }
                    }
                    var expandTimestamp = Infinity;
                    // Now go through the BFS queue and for each node update the baseRelevance, relevance, and reachability of its neighbors.
                    for (var i = 0; i < queue.length; i++) {
                        // Take a node from the queue.
                        var node = queue[i];
                        delete queueById[node.id];
                        var id = node.id;
                        // Remember - this node's relevance and baseRelevance are already calculated.
                        // Calculate minimum baseRelevance and relevance of this node's neighbors.
                        var nextBaseRelevance = node.baseRelevance - 1;
                        var nextRelevance = node.relevance - 1;
                        var isReachable = Internal.Base.Helpers.hasProperty(reachableNodes, id) && node.relevance > 0;
                        for (var j = 0; j < node.dataLinks.length; j++) {
                            var dataLink = node.dataLinks[j];
                            var otherId = NetChart.Data.otherEnd(dataLink, id);
                            if (!otherId || otherId === id)
                                continue;
                            // Relevances will be propagated throughout the visible node network, even if negative, however a node is only
                            // counted as "reachable" if it has a visible, reachable neighbor. Mind you, even hidden nodes need their reachability
                            // calculated, because unreachable nodes lose all flags.
                            if (isReachable)
                                reachableNodes[otherId] = true;
                            // Get its flags, if any.
                            var otherFlags = Internal.Base.Helpers.hasProperty(this.extraFlags, otherId) ? this.extraFlags[otherId] : null;
                            // If the node on the far end of the link is hidden, ignore it.
                            if (otherFlags === ExtraFlags.Hidden)
                                continue;
                            var nextActualRelevance = nextRelevance;
                            // If the node would already naturally receive a relevance of 2 or more, delete the Expanded flag.
                            if (otherFlags === ExtraFlags.Expanded && nextRelevance >= 2)
                                delete this.extraFlags[otherId];
                            var otherNode = Internal.Base.Helpers.hasProperty(layerNodes, otherId) ? layerNodes[otherId] : null;
                            var needsUpdate = false;
                            //  Node isn't there. Try to add it.
                            if (!otherNode || otherNode.removed) {
                                // If the actual relevance of the node would be non-positive, don't attempt to create it. It would be invisible anyway.
                                if (nextActualRelevance <= 0)
                                    continue;
                                // Get the data
                                var nodeData = data.getNode(otherId);
                                if (!nodeData)
                                    continue;
                                // If expandDelay is set, then new nodes can be spawned from this node no sooner than this long after showing this node.
                                // If there are nodes that WOULD be shown, but aren't because of this reason, mark the soonest time when a new expand will
                                // occur. Although note just the node.showTimestamp here, add the expandDelay later.
                                if (node.showTimestamp > maxAllowedExpansionTimestamp) {
                                    if (expandTimestamp > node.showTimestamp)
                                        expandTimestamp = node.showTimestamp;
                                    continue;
                                }
                                // Create the node and set its relevances.
                                this.ensureNode(nodeData, data.getLinks(otherId));
                                otherNode = layerNodes[otherId];
                                otherNode.relevance = nextActualRelevance;
                                otherNode.baseRelevance = nextBaseRelevance;
                                otherNode.showTimestamp = timestamp;
                                needsUpdate = true;
                            }
                            else {
                                if (otherNode.relevance < nextActualRelevance) {
                                    otherNode.relevance = nextActualRelevance;
                                    layer.touchNode(otherNode);
                                    needsUpdate = true;
                                }
                                if (otherNode.baseRelevance < nextBaseRelevance) {
                                    otherNode.baseRelevance = nextBaseRelevance;
                                    layer.touchNode(otherNode);
                                    needsUpdate = true;
                                }
                            }
                            var link = layerLinks[dataLink.id];
                            var linkRelevance = Math.min(node.relevance, otherNode.relevance);
                            if (link.relevance !== linkRelevance) {
                                link.relevance = linkRelevance;
                                layer.touchLink(link);
                            }
                            // Node's relevance needs updating. Do it and add to queue.
                            if (needsUpdate && !Internal.Base.Helpers.hasProperty(queueById, otherId)) {
                                queueById[otherId] = true;
                                queue.push(otherNode);
                            }
                        }
                    }
                    // Now hide all nodes that are not reachable or have a negative relevance. Only consider nodes that were there from the start
                    // (that is, don't recalculate layerNodeIds). Any nodes added later will need to be visible anyway.
                    for (var i = 0; i < layerNodeIds.length; i++) {
                        var id = layerNodeIds[i];
                        var node = layerNodes[id];
                        if (node.removed)
                            continue; // Node is already being removed, all bookkeeping has been done already.
                        if (!Internal.Base.Helpers.hasProperty(reachableNodes, id)) {
                            this.ensureNodeRemoved(node);
                            delete this.extraFlags[id]; // If the node is unreachable, then also delete any flags it had on it.
                        }
                        else if (node.relevance <= 0) {
                            this.ensureNodeRemoved(node);
                        }
                    }
                    // We need to expand some more nodes after a short delay. Schedule a full recalculate later.
                    if (expandTimestamp < Infinity)
                        window.setTimeout(function () { return _this.scheduleFullRecalculate(); }, expandTimestamp + this.chart.settings.navigation.expandDelay - timestamp);
                };
                FocusNodesNavigator.prototype.canFocusNode = function (node) {
                    return !node.focused && (this.focusNodes.length < this.chart.settings.navigation.numberOfFocusNodes
                        || this.chart.settings.navigation.autoUnfocus);
                };
                FocusNodesNavigator.prototype.canUnfocusNode = function (node) {
                    return node.focused && this.focusNodes.length > Math.max(this.chart.settings.navigation.minNumberOfFocusNodes, 1);
                };
                FocusNodesNavigator.prototype.canExpandNode = function (node) { return !node.expanded; };
                FocusNodesNavigator.prototype.canCollapseNode = function (node) {
                    for (var i = 0; i < node.links.length; i++) {
                        var otherNode = node.links[i].otherEnd(node);
                        if (otherNode && otherNode !== node && !otherNode.removed && otherNode.baseRelevance < node.baseRelevance)
                            return true;
                    }
                    return false;
                };
                FocusNodesNavigator.prototype.canHideNode = function (node) { return !node.focused || this.canUnfocusNode(node); };
                FocusNodesNavigator.prototype.canCloseNode = function (node) { return false; };
                return FocusNodesNavigator;
            }(NetChart.Navigator));
            NetChart.FocusNodesNavigator = FocusNodesNavigator;
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../base/core/ChartEvents.ts" />
/// <reference path="../Data.ts" />
/// <reference path="NavigatorBase.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var ManualNavigator = (function (_super) {
                __extends(ManualNavigator, _super);
                function ManualNavigator() {
                    _super.apply(this, arguments);
                    this.saveHack = null; // See restore()
                    this.retryList = [];
                }
                ManualNavigator.prototype.executeAllSceneChanges = function (event) {
                    var retries = this.retryList;
                    this.retryList = [];
                    for (var i = 0; i < retries.length; i++) {
                        var result = retries[i].fun(event);
                        if (result === null) {
                            this.retryList.push(retries[i]);
                        }
                        else if (result && retries[i].origin) {
                            this.chart.notifyChartUpdate(retries[i].origin);
                        }
                    }
                };
                /** All navigation operations are postponed to onSceneChange event, which is the safe place to manipulate layer contents. This is done with
                    callback functions that are execute on onSceneChange.
                    
                    If the callback returns true, notify the chart of update (saves the resulting navigation state in the undo stack).
                    If the callback returns false, do nothing.
                    If the callback returns null, retry the callback on next onScheneChange.*/
                ManualNavigator.prototype.notifyNavigation = function (origin, fun) {
                    this.chart.events.notifySceneChanges({ navigation: true });
                    this.retryList.push({ fun: fun, origin: origin });
                };
                ManualNavigator.prototype.clearFocusNodes = function (origin) {
                    var _this = this;
                    this.notifyNavigation(origin, function () {
                        var hasChanges = false;
                        var layer = _this.chart.layer;
                        var idToNode = layer.idToNode;
                        var keys = Object.keys(idToNode);
                        for (var i = 0; i < keys.length; i++) {
                            var node = idToNode[keys[i]];
                            if (node.focused && !node.removed) {
                                hasChanges = true;
                                node.focused = false;
                                layer.touchNode(node);
                            }
                        }
                        return hasChanges;
                    });
                };
                ManualNavigator.prototype.hideNode = function (nodeId, origin) {
                    var _this = this;
                    this.notifyNavigation(origin, function () {
                        return _this.ensureNodeRemoved(Internal.Base.Helpers.hasProperty(_this.chart.layer.idToNode, nodeId) ? _this.chart.layer.idToNode[nodeId] : null);
                    });
                };
                ManualNavigator.prototype.showNode = function (nodeId, origin) {
                    var _this = this;
                    this.notifyNavigation(origin, function () {
                        var extraInfo = { loading: false };
                        var data = _this.chart.scene.mainData;
                        var nodeData = data.getNode(nodeId, true, extraInfo);
                        if (nodeData) {
                            _this.ensureNode(nodeData, data.getLinks(nodeId));
                            return true;
                        }
                        if (extraInfo.loading)
                            return null;
                        return false;
                    });
                };
                ManualNavigator.prototype.collapseNode = function (nodeId, origin) {
                    var _this = this;
                    this.notifyNavigation(origin, function () {
                        var layer = _this.chart.layer;
                        // If node isn't visible or is being removed, there's nothing to collapse.
                        var node = Internal.Base.Helpers.hasProperty(layer.idToNode, nodeId) ? layer.idToNode[nodeId] : null;
                        if (!node || node.removed)
                            return false;
                        var hasChanges = false;
                        // Hide all surrounding nodes.
                        for (var i = 0; i < node.links.length; i++) {
                            var link = node.links[i];
                            if (link.removed)
                                continue;
                            var other = link.otherEnd(node);
                            if (other !== node)
                                hasChanges = _this.ensureNodeRemoved(other) || hasChanges; // Keep this.ensureNode() first, otherwise it doesn't execute if hasChanges=true.
                        }
                        // If there are more nodes visible out there, hide this node.
                        if (_this.canHideNode(node))
                            hasChanges = _this.ensureNodeRemoved(node) || hasChanges; // Keep this.ensureNode() first, otherwise it doesn't execute if hasChanges=true.
                        return hasChanges;
                    });
                };
                ManualNavigator.prototype.calculateCloseNodes = function (node) {
                    var cloud = {};
                    var candidates = [];
                    for (var i = 0; i < node.links.length; i++) {
                        var link = node.links[i];
                        if (link.removed)
                            continue;
                        var otherEnd = link.otherEnd(node);
                        if (otherEnd === node || otherEnd.removed)
                            continue;
                        candidates.push(otherEnd);
                        cloud[otherEnd.id] = true;
                    }
                    cloud[node.id] = true;
                    var ret = [];
                    for (var i = 0; i < candidates.length; i++) {
                        var candidate = candidates[i];
                        var isGood = true;
                        for (var j = 0; j < candidate.links.length; j++) {
                            var otherEnd = candidate.links[j].otherEnd(candidate);
                            if (!Internal.Base.Helpers.hasProperty(cloud, otherEnd.id)) {
                                isGood = false;
                                break;
                            }
                        }
                        if (isGood)
                            ret.push(candidate);
                    }
                    return ret;
                };
                ManualNavigator.prototype.closeNode = function (nodeId, origin) {
                    var _this = this;
                    this.notifyNavigation(origin, function () {
                        var layer = _this.chart.layer;
                        // If node isn't visible or is being removed, there's nothing to collapse.
                        var node = Internal.Base.Helpers.hasProperty(layer.idToNode, nodeId) ? layer.idToNode[nodeId] : null;
                        if (!node || node.removed)
                            return false;
                        var hasChanges = false;
                        var closeNodes = _this.calculateCloseNodes(node);
                        // Hide all surrounding nodes.
                        for (var i = 0; i < closeNodes.length; i++) {
                            hasChanges = _this.ensureNodeRemoved(closeNodes[i]) || hasChanges; // Keep this.ensureNode() first, otherwise it doesn't execute if hasChanges=true.
                        }
                        return hasChanges;
                    });
                };
                ManualNavigator.prototype.focusNode = function (nodeId, relevance, origin) {
                    var _this = this;
                    // ManualNavigator ignores relevance
                    this.notifyNavigation(origin, function () {
                        // If node isn't visible or is being removed, the we cannot focus it.
                        var node = _this.chart.layer.idToNode[nodeId];
                        if (!(node instanceof Internal.ItemsChart.Node) || node.removed)
                            return false;
                        if (!node.focused) {
                            // Focus it.
                            node.focused = true;
                            _this.chart.layer.touchNode(node);
                            return true;
                        }
                        return false;
                    });
                };
                ManualNavigator.prototype.expandNode = function (nodeId, origin) {
                    var _this = this;
                    var linksExpanded = {};
                    var hasChanges = false;
                    this.notifyNavigation(origin, function () {
                        var layer = _this.chart.layer;
                        // If node isn't visible or is being removed, the we cannot expand it.
                        var node = layer.idToNode[nodeId];
                        if (!(node instanceof Internal.ItemsChart.Node) || node.removed)
                            return false;
                        // Get all links, filtered, as far as we've got them at this point. Don't worry if they aren't completely loaded -
                        // if the node is visible, then it is also loading its data.
                        var data = _this.chart.scene.mainData;
                        var links = node.dataLinks;
                        if (links != null) {
                            for (var i = 0; i < links.length; i++) {
                                var link = links[i];
                                // Don't try to expand a single link twice. If loading times are large, a user might have already collapsed this link
                                // while something else is still loading.
                                if (Internal.Base.Helpers.hasProperty(linksExpanded, link.id))
                                    continue;
                                linksExpanded[link.id] = true; // Mark the link as processed. If we're this far, we either show the link or don't, but never come back to it.
                                // If link is already present, do nothing.
                                var existingLink = Internal.Base.Helpers.hasProperty(layer.idToLink, link.id) ? layer.idToLink[link.id] : null;
                                if (existingLink && !existingLink.removed)
                                    continue;
                                // Link is either not present or in the process of being removed. Re-add it. Start with the other node.
                                var otherId = NetChart.Data.otherEnd(link, nodeId);
                                if (otherId !== nodeId) {
                                    // OK, it's a link to something else. Ensure node.
                                    var otherNode = Internal.Base.Helpers.hasProperty(layer.idToNode, otherId) ? layer.idToNode[otherId] : null;
                                    if (!otherNode || otherNode.removed) {
                                        // First get data from the data layer
                                        var nodeData = data.getNode(otherId);
                                        if (!nodeData) {
                                            // Couldn't get it. This is very odd, if the link was there, the node should have been too.
                                            // Don't try to do anything smart in this case, just skip it.
                                            continue;
                                        }
                                        _this.ensureNode(nodeData, data.getLinks(otherId));
                                    }
                                }
                                hasChanges = true;
                            }
                        }
                        // OK, we've added as many of the nodes and links as we could. Now time to end this.
                        if (!node.data.loaded)
                            return null; // This node is still loading (so more links may still arrive), schedule a retry.
                        return hasChanges; // Signal that we're done and navigation has been updated.
                    });
                };
                ManualNavigator.prototype.unfocusNode = function (nodeId, origin) {
                    var _this = this;
                    this.notifyNavigation(origin, function () {
                        // If node isn't visible or is being removed, the we cannot unfocus it.
                        var node = _this.chart.layer.idToNode[nodeId];
                        if (!(node instanceof Internal.ItemsChart.Node) || node.removed)
                            return false;
                        // Unfocus it.
                        if (node.focused) {
                            node.focused = false;
                            _this.chart.layer.touchNode(node);
                            return true;
                        }
                        return false;
                    });
                };
                ManualNavigator.prototype.save = function () {
                    if (this.saveHack)
                        return this.saveHack; // See restore()
                    var ret = {};
                    var nodes = this.chart.layer.idToNode;
                    var keys = Object.keys(nodes);
                    for (var i = 0; i < keys.length; i++) {
                        var node = nodes[keys[i]];
                        if (!node.removed)
                            ret[node.id] = node.focused;
                    }
                    return ret;
                };
                ManualNavigator.prototype.restore = function (stateAny) {
                    var _this = this;
                    var state = stateAny;
                    if (!state)
                        return;
                    // This is a hack to work around Undo stack logic in Base.Impl. When the Undo button is clicked, the .restore() method is called and it is expected that
                    // it will IMMEDIATELY call notifyChartUpdate(), which in turn will call the .save() method to remember the restored (and possibly modified) state.
                    // Because the restoring process happens asynchronously on the next onSceneUpdate() and can even involve loading nodes, it cannot do this. Instead it just
                    // calls notifyChartUpdate() immediately and makes sure that .save() returns the same state as was restored.
                    this.saveHack = state;
                    this.chart.notifyChartUpdate("restore");
                    this.saveHack = null;
                    var nodesProcessed = {};
                    var hasChanges = false;
                    var hideComplete = false;
                    this.notifyNavigation(null, function () {
                        var layer = _this.chart.layer;
                        var data = _this.chart.scene.mainData;
                        var needsRetry = false;
                        var extraInfo = { loading: false };
                        var nodes = layer.idToNode;
                        var keys;
                        // Hide all nodes that are not in state, but do it only once.
                        if (!hideComplete) {
                            keys = Object.keys(nodes);
                            for (var i = 0; i < keys.length; i++) {
                                var id = keys[i];
                                if (Internal.Base.Helpers.hasProperty(state, id))
                                    continue;
                                if (!nodes[id].removed)
                                    hasChanges = _this.ensureNodeRemoved(nodes[id]) || hasChanges;
                            }
                            hideComplete = true;
                        }
                        // Iterate through all saved nodes and put them in previous state.
                        keys = Object.keys(state);
                        for (var i = 0; i < keys.length; i++) {
                            var id = keys[i];
                            // Process each node just once.
                            if (Internal.Base.Helpers.hasProperty(nodesProcessed, id))
                                continue;
                            var node = Internal.Base.Helpers.hasProperty(layer.idToNode, id) ? layer.idToNode[id] : null;
                            if (!node || node.removed) {
                                // Node lost from graph. Restore it.
                                var nodeData = data.getNode(id, true, extraInfo);
                                if (!nodeData) {
                                    if (extraInfo.loading) {
                                        needsRetry = true;
                                    }
                                    else {
                                        nodesProcessed[id] = true; // If node was filtered away, skip it.
                                    }
                                    continue;
                                }
                                _this.ensureNode(nodeData, data.getLinks(id));
                                layer.idToNode[id].focused = state[id];
                                hasChanges = true;
                            }
                            else if (node && node.focused !== state[id]) {
                                node.focused = state[id];
                                layer.touchNode(node);
                                hasChanges = true;
                            }
                            nodesProcessed[id] = true;
                        }
                        return needsRetry ? null : hasChanges;
                    });
                };
                ManualNavigator.prototype.onNewDataObject = function () {
                    var _this = this;
                    var state = this.save(); // Get current state.
                    var data = this.chart.scene.mainData;
                    // Iterate through all current nodes and request new data for them.
                    var stateKeys = Object.keys(state);
                    for (var i = 0; i < stateKeys.length; i++)
                        data.getNode(stateKeys[i]);
                    this.notifyNavigation(null, function () {
                        var layer = _this.chart.layer;
                        var nodes = layer.idToNode;
                        var keys;
                        var extraInfo = { loading: false };
                        // Iterate through all current nodes and check if data has arrived yet.
                        keys = Object.keys(state);
                        for (var i = 0; i < keys.length; i++) {
                            var id = keys[i];
                            // If node is removed, ignore it.
                            if (!Internal.Base.Helpers.hasProperty(nodes, id) || nodes[id].removed) {
                                delete state[id];
                                continue;
                            }
                            var nodeData = data.getNode(id, true, extraInfo);
                            if (nodeData) {
                                delete state[id];
                            }
                            else if (extraInfo.loading) {
                                return null;
                            }
                        }
                        return true;
                    });
                };
                ManualNavigator.prototype.showInitialNodes = function () {
                    var _this = this;
                    var layerCleared = false;
                    var nodesToAdd = this.chart.settings.navigation.initialNodes;
                    var hasChanges = false;
                    var firstNodesAdded = false;
                    // Abort all retries, show initial nodes again.
                    this.retryList = [];
                    this.notifyNavigation("init", function (event) {
                        var layer = _this.chart.layer;
                        // Start off by clearing everything. Do this only once at the start.
                        if (!layerCleared) {
                            if (Internal.Base.Helpers.hasProperties(layer.nodes)) {
                                layer.clearObjects();
                                hasChanges = true;
                            }
                            layerCleared = true;
                        }
                        // Get the initial nodes and check if there's anything to do at all.
                        if (nodesToAdd == null || nodesToAdd.length < 1)
                            return hasChanges;
                        var extraInfo = { loading: false };
                        var data = _this.chart.scene.mainData;
                        var needsRetry = false;
                        // Go through all initial nodes and show them.
                        var nodesThisPass = nodesToAdd;
                        nodesToAdd = [];
                        for (var i = 0; i < nodesThisPass.length; i++) {
                            var id = nodesThisPass[i];
                            var nodeData = data.getNode(id, true, extraInfo);
                            if (nodeData) {
                                hasChanges = _this.ensureNode(nodeData, data.getLinks(id)) || hasChanges;
                                if (!firstNodesAdded) {
                                    firstNodesAdded = true;
                                    event.changes.newGraph = true;
                                }
                            }
                            else if (extraInfo.loading) {
                                nodesToAdd.push(id);
                                needsRetry = true;
                            }
                        }
                        return needsRetry ? null : hasChanges;
                    });
                };
                ManualNavigator.prototype.onSceneChange = function (event) {
                    if (event.changes.filters) {
                        this.updateGraphWithNewData(null, event);
                    }
                    else if (event.changes.dataArrived || event.changes.data) {
                        this.updateGraphWithNewData(event.changes.netChartDataNodes, event);
                    }
                    if (this.retryList.length > 0 && (event.changes.navigation || event.changes.dataArrived))
                        this.executeAllSceneChanges(event);
                };
                ManualNavigator.prototype.canFocusNode = function (node) { return !node.focused; };
                ManualNavigator.prototype.canUnfocusNode = function (node) { return node.focused; };
                ManualNavigator.prototype.canExpandNode = function (node) { return !node.expanded; };
                ManualNavigator.prototype.canCollapseNode = function (node) { return this.canHideNode(node); };
                ManualNavigator.prototype.canHideNode = function (node) {
                    // Can hide all except the last remaining node.
                    var layer = this.chart.layer;
                    var keys = Object.keys(layer.idToNode);
                    for (var i = 0; i < keys.length; i++) {
                        var other = layer.idToNode[keys[i]];
                        if (other !== node && !other.removed)
                            return true;
                    }
                    return false;
                };
                ManualNavigator.prototype.canCloseNode = function (node) { return this.calculateCloseNodes(node).length > 0; };
                return ManualNavigator;
            }(NetChart.Navigator));
            NetChart.ManualNavigator = ManualNavigator;
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../base/core/ChartEvents.ts" />
/// <reference path="../Data.ts" />
/// <reference path="ManualNavigator.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var ShowAllNavigator = (function (_super) {
                __extends(ShowAllNavigator, _super);
                function ShowAllNavigator() {
                    _super.apply(this, arguments);
                    this.hiddenNodes = {}; // Nodes which the user has explicitly hidden
                    this.isInitialized = false;
                }
                ShowAllNavigator.prototype.showNode = function (nodeId, origin) {
                    delete this.hiddenNodes[nodeId];
                    _super.prototype.showNode.call(this, nodeId, origin);
                };
                ShowAllNavigator.prototype.hideNode = function (nodeId, origin) {
                    var layerNodes = this.chart.layer.idToNode;
                    if (!Internal.Base.Helpers.hasProperty(layerNodes, nodeId))
                        return;
                    this.hiddenNodes[nodeId] = true;
                    _super.prototype.hideNode.call(this, nodeId, origin);
                };
                ShowAllNavigator.prototype.collapseNode = function (nodeId, origin) {
                    var layerNodes = this.chart.layer.idToNode;
                    if (!Internal.Base.Helpers.hasProperty(layerNodes, nodeId))
                        return;
                    this.hiddenNodes[nodeId] = true;
                    var node = layerNodes[nodeId];
                    for (var i = 0; i < node.links.length; i++) {
                        var link = node.links[i];
                        if (link.removed)
                            continue;
                        var other = link.otherEnd(node);
                        if (other !== node)
                            this.hiddenNodes[other.id] = true;
                    }
                    _super.prototype.collapseNode.call(this, nodeId, origin);
                };
                ShowAllNavigator.prototype.closeNode = function (nodeId, origin) {
                    var layerNodes = this.chart.layer.idToNode;
                    if (!Internal.Base.Helpers.hasProperty(layerNodes, nodeId))
                        return;
                    var nodes = this.calculateCloseNodes(layerNodes[nodeId]);
                    for (var i = 0; i < nodes.length; i++) {
                        this.hiddenNodes[nodes[i].id] = true;
                    }
                    _super.prototype.closeNode.call(this, nodeId, origin);
                };
                ShowAllNavigator.prototype.save = function () {
                    if (this.saveHack)
                        return this.saveHack;
                    var focused;
                    focused = [];
                    var nodes = this.chart.layer.idToNode;
                    var keys = Object.keys(nodes);
                    for (var i = 0; i < keys.length; i++) {
                        var node = nodes[keys[i]];
                        if (!node.removed && node.focused)
                            focused.push(node.id);
                    }
                    return { hidden: Object.keys(this.hiddenNodes), focused: focused };
                };
                ShowAllNavigator.prototype.restore = function (stateAny) {
                    var _this = this;
                    var state = stateAny;
                    this.hiddenNodes = {};
                    for (var i = 0; i < state.hidden.length; i++)
                        this.hiddenNodes[state.hidden[i]] = true;
                    // See ManualNavigator.restore() for more details.
                    this.saveHack = state;
                    this.chart.notifyChartUpdate("restore");
                    this.saveHack = null;
                    this.notifyNavigation(null, function (event) {
                        // Recalculate all visible nodes.
                        _this.updateGraphWithNewData(null, event);
                        // Move focused node ids into a dictionary for easier lookup.
                        var focusedDict = {};
                        for (var i = 0; i < state.focused.length; i++)
                            focusedDict[state.focused[i]] = true;
                        // Apply focused state to the nodes which are visible. Don't bother about focus state of invisible nodes - 
                        // that's a rare edge case for when data source has changed between restores.
                        var layer = _this.chart.layer;
                        var nodes = layer.idToNode;
                        var keys = Object.keys(nodes);
                        for (var i = 0; i < keys.length; i++) {
                            var node = nodes[keys[i]];
                            var focusedNew = Internal.Base.Helpers.hasProperty(focusedDict, keys[i]);
                            if (!node.removed && node.focused !== focusedNew) {
                                node.focused = focusedNew;
                                layer.touchNode(node);
                            }
                        }
                        return false;
                    });
                };
                ShowAllNavigator.prototype.expandNode = function (nodeId, origin) {
                    var layerNodes = this.chart.layer.idToNode;
                    if (!Internal.Base.Helpers.hasProperty(layerNodes, nodeId))
                        return;
                    var node = layerNodes[nodeId];
                    for (var i = 0; i < node.dataLinks.length; i++) {
                        var link = node.dataLinks[i];
                        var otherId = NetChart.Data.otherEnd(link, nodeId);
                        if (otherId !== nodeId)
                            delete this.hiddenNodes[otherId];
                    }
                    _super.prototype.expandNode.call(this, nodeId, origin);
                };
                ShowAllNavigator.prototype.showInitialNodes = function () {
                    var _this = this;
                    // Abort all retries, show initial nodes again.
                    this.retryList = [];
                    this.notifyNavigation("init", function (event) {
                        var layer = _this.chart.layer;
                        var data = _this.chart.scene.mainData;
                        _this.hiddenNodes = {};
                        layer.clearObjects();
                        _this.isInitialized = true;
                        var initialNodes = _this.chart.settings.navigation.initialNodes;
                        var queue;
                        var queueById = {};
                        // Get starting nodes and put them in queue.
                        if (initialNodes == null || initialNodes.length < 1) {
                            queue = data.getAllNodes();
                            for (var i = 0; i < queue.length; i++)
                                queueById[queue[i].id] = true;
                        }
                        else {
                            queue = data.getAllNodes(false); // All nodes that are already loaded need to be displayed too.
                            for (var i = 0; i < queue.length; i++)
                                queueById[queue[i].id] = true;
                            for (var i = 0; i < initialNodes.length; i++) {
                                var id = initialNodes[i];
                                if (Internal.Base.Helpers.hasProperty(queueById, id))
                                    continue;
                                var node = data.getNode(id);
                                if (!node)
                                    continue;
                                queue.push(node);
                                queueById[id] = true;
                            }
                        }
                        // Iterate through the queue, BFS-style, and add any new nodes to it.
                        for (var i = 0; i < queue.length; i++) {
                            var nodeData = queue[i];
                            var nodeLinks = data.getLinks(nodeData.id);
                            _this.ensureNode(nodeData, nodeLinks);
                            for (var j = 0; j < nodeLinks.length; j++) {
                                var otherId = NetChart.Data.otherEnd(nodeLinks[j], nodeData.id);
                                if (otherId && otherId !== nodeData.id && !Internal.Base.Helpers.hasProperty(queueById, otherId)) {
                                    // Even if we don't get the data later, mark this as processed so we don't uselessly try to call data.getNode() again and again as we
                                    // find other links to this node.
                                    queueById[otherId] = true;
                                    var otherData = data.getNode(otherId);
                                    if (otherData)
                                        queue.push(otherData);
                                }
                            }
                        }
                        if (queue.length > 0)
                            event.changes.newGraph = true;
                        return true;
                    });
                };
                ShowAllNavigator.prototype.onNewDataObject = function () {
                    var _this = this;
                    var initialNodes = this.chart.settings.navigation.initialNodes;
                    // Shortcut: if all nodes were displayed at the start, request all nodes here too.
                    if (initialNodes == null || initialNodes.length < 1)
                        this.chart.scene.mainData.getAllNodes();
                    this.notifyNavigation(null, function (event) {
                        _this.updateGraphWithNewData(null, event);
                        return false;
                    });
                };
                ShowAllNavigator.prototype.updateGraphWithNewData = function (nodesWithNewData, event) {
                    if (!this.isInitialized)
                        return;
                    var layer = this.chart.layer;
                    var data = this.chart.scene.mainData;
                    var layerNodes = layer.idToNode;
                    var allData = {}; // All the data for nodes that need to be checked
                    var allIds; // All the IDs of the nodes that need to be checked.
                    // Data has changed. If nodesWithNewData is set, then the affected nodes are listed there and we only need to check those. Otherwise
                    // we need to re-check all visible nodes, and then see if any new data is available.
                    if (nodesWithNewData) {
                        allIds = Object.keys(nodesWithNewData);
                        for (var i = 0; i < allIds.length; i++)
                            allData[allIds[i]] = data.getNode(allIds[i], false);
                    }
                    else {
                        // Check all nodes that we have data for (perhaps there's some that need to be added)
                        var allNodes = data.getAllNodes(false);
                        for (var i = 0; i < allNodes.length; i++)
                            allData[allNodes[i].id] = allNodes[i];
                        // Check all nodes that are visible (perhaps there's some that need to be hidden)
                        var keys_1 = Object.keys(layerNodes);
                        for (var i = 0; i < keys_1.length; i++)
                            if (!Internal.Base.Helpers.hasProperty(allData, keys_1[i]))
                                allData[keys_1[i]] = null;
                        // Check hidden nodes (perhaps there's some that need to be removed from hidden nodes).
                        keys_1 = Object.keys(this.hiddenNodes);
                        for (var i = 0; i < keys_1.length; i++)
                            if (!Internal.Base.Helpers.hasProperty(allData, keys_1[i]))
                                allData[keys_1[i]] = null;
                        allIds = Object.keys(allData);
                    }
                    var hadNodes = false;
                    var keys = Object.keys(layerNodes);
                    for (var i = 0; i < keys.length; i++)
                        if (!layerNodes[keys[i]].removed) {
                            hadNodes = true;
                            break;
                        }
                    var nodeAdded = false;
                    for (var i = 0; i < allIds.length; i++) {
                        var id = allIds[i];
                        var newData = allData[id];
                        var existingNode = Internal.Base.Helpers.hasProperty(layerNodes, id) ? layerNodes[id] : null;
                        if (newData) {
                            // Node has new data or even has newly arrived. Add/update the node and check the links if there's a hint of a yet unknown node.
                            // If the node is hidden though, just make sure it's gone.
                            if (Internal.Base.Helpers.hasProperty(this.hiddenNodes, id)) {
                                this.ensureNodeRemoved(existingNode);
                                continue;
                            }
                            var newLinks = data.getLinks(id, false);
                            // First make sure that the node itself exists and has the latest data.
                            if (existingNode && !existingNode.removed) {
                                this.updateNodeWithNewData(existingNode, newData, newLinks);
                                layer.touchNode(existingNode);
                            }
                            else {
                                this.ensureNode(newData, newLinks);
                                existingNode = layerNodes[id];
                                nodeAdded = true;
                            }
                            // Then iterate through the node's links in search for new unknown non-hidden nodes.
                            for (var i_1 = 0; i_1 < newLinks.length; i_1++) {
                                var otherId = NetChart.Data.otherEnd(newLinks[i_1], id);
                                if (!otherId || otherId === id || Internal.Base.Helpers.hasProperty(this.hiddenNodes, otherId))
                                    continue;
                                var otherNode = Internal.Base.Helpers.hasProperty(layerNodes, otherId) ? layerNodes[otherId] : null;
                                if (otherNode && !otherNode.removed)
                                    continue;
                                var otherData = data.getNode(otherId); // Request node loading, if data not yet there.
                                if (otherData)
                                    this.ensureNode(otherData, data.getLinks(otherId));
                            }
                        }
                        else {
                            if (data.isNodeLoading(id)) {
                                if (existingNode && !existingNode.loading) {
                                    existingNode.loading = true;
                                    layer.touchNode(existingNode);
                                }
                            }
                            else {
                                // Node doesn't have data anymore. Purge all we know of it.
                                this.ensureNodeRemoved(existingNode);
                                delete this.hiddenNodes[id];
                            }
                        }
                    }
                    if (!hadNodes && nodeAdded)
                        event.changes.newGraph = true;
                };
                return ShowAllNavigator;
            }(NetChart.ManualNavigator));
            NetChart.ShowAllNavigator = ShowAllNavigator;
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="ManualNavigator.ts" />
/// <reference path="ShowAllNavigator.ts" />
/// <reference path="FocusNodesNavigator.ts" /> 
/// <reference path="../base/core/ChartEvents.ts" />
/// <reference path="../base/Graphics.ts" />
/// <reference path="../base/Helpers.ts" />
/// <reference path="../base/Label.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var TimeChart;
        (function (TimeChart) {
            var SettingsMarker = (function () {
                function SettingsMarker() {
                    /** Show/hide the marker. */
                    this.enabled = true;
                    /** Style settings for the drawing the time line text on the chart. You can also use `label.text` property
                    to specify additional text that will be shown next to the time or by setting `showTime` to `false` (the default)
                    display only the specified text. */
                    this.label = {
                        padding: 3,
                        margin: 3,
                        aspectRatio: 3,
                        align: "center",
                        textStyle: {
                            fillColor: "white",
                            font: "12px Arial"
                        },
                        backgroundStyle: {
                            lineColor: "#0099cc",
                            fillColor: "#0099cc"
                        }
                    };
                    /** Align label relative to the line */
                    this.align = "left";
                    /** Align label relative to chart top or bottom side */
                    this.side = "top";
                    /** The style for the vertical time marker line. */
                    this.style = {
                        lineColor: "#0099cc"
                    };
                    /** Timestamp in UTC milliseconds to locate time marker on chart. If this is specified, the
                    marker does not automatically move.
                    @type integer
                    @units milliseconds */
                    this.time = null;
                    /** Specifies if the time marker is always included when limiting scrolling. If this is `true`, then the user will always
                    be able to scroll to the current time even if the data is not available. */
                    this.overrideLimits = false;
                    /** Show the milestone time along with the label text */
                    this.showTime = false;
                }
                return SettingsMarker;
            }());
            TimeChart.SettingsMarker = SettingsMarker;
            var Marker = (function () {
                function Marker(scene, settings, defaultMarkerText) {
                    this.labelCacheUnit = null;
                    this.labelCacheTime = null;
                    this.initialText = null;
                    /** Specifies that the marker was created from the milestone settings and thus can be
                    remove once the milestone configuration changes. */
                    this.isMilestone = true;
                    this.settings = settings;
                    this.label = new Internal.Base.Label(settings.label);
                    if (defaultMarkerText) {
                        // merge the default style with the marker specific
                        var tstyle = Internal.Base.Helpers.clone(defaultMarkerText);
                        Internal.Base.Helpers.extendStyleTo(this.label.style.textStyle, tstyle);
                        if (!tstyle.fillColor)
                            tstyle.fillColor = settings.style.lineColor;
                        this.label.style.textStyle = tstyle;
                    }
                    if (settings.time != null) {
                        this.time = scene.timestampToInternal(settings.time, true);
                    }
                    else {
                        this.time = null;
                    }
                    this.initialText = this.label.text || null;
                }
                return Marker;
            }());
            TimeChart.Marker = Marker;
            var Markers = (function (_super) {
                __extends(Markers, _super);
                function Markers(chart) {
                    _super.call(this);
                    this.animationOrder = 2000;
                    this.paintOrder = 40;
                    this.updateOrder = 800;
                    this.scene = null;
                    this._initialized = false;
                    this.chart = chart;
                    this.scene = this.chart.scene;
                }
                Markers.prototype.onSceneChange = function (event) {
                    if (!this.chart.assetsLoaded)
                        return;
                    var ch = event.changes;
                    var sc = ch.settingsChanges;
                    var markerChanges = sc && sc.milestones;
                    // the `ch.assets` check is there because createMarkers is dependent on moment.tz which might have not been loaded initially.
                    if (!this._initialized || markerChanges || ch.assets) {
                        this.createMarkers();
                        this._initialized = true;
                    }
                    if (ch.time || markerChanges) {
                        this.scene.markers.sort(function (a, b) { return a.time - b.time; });
                    }
                };
                Markers.prototype.paintScene = function (event) {
                    var scene = this.scene;
                    var markers = scene.markers;
                    var labelRenderer = event.labelRenderer;
                    var g = event.context;
                    if (markers.length === 0 || !scene.displayUnit) {
                        return;
                    }
                    var y0 = Math.round(scene.y0);
                    g.textBaseline = "middle";
                    Internal.Base.Graphics.pushClip(event, scene.x0, Math.round(scene.y0), scene.width, scene.height + scene.bottomAxisSize);
                    // Milestones
                    var parts = this.getRenderingParts(event, markers);
                    // drawing lines
                    var lines = parts.lines;
                    for (var lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                        var line = lines[lineIndex];
                        var gr = Internal.Base.Graphics.beginStrokeAndFill(g, line.style);
                        var y1 = (line.side === "bottom") ? this.getTopPos(line.x, 0) : y0 + scene.height;
                        y1 = Math.round(y1);
                        gr.moveTo(line.x, y1);
                        gr.lineTo(line.x, line.y);
                        Internal.Base.Graphics.endStrokeAndFill(g, gr, line.style);
                    }
                    // drawing labels
                    var labels = parts.labels;
                    for (var labelIndex = 0; labelIndex < labels.length; labelIndex++) {
                        var lab = labels[labelIndex];
                        labelRenderer.paint(g, lab.x, lab.y, 1, lab.label);
                    }
                    // note that popClip also calls restore
                    Internal.Base.Graphics.popClip(event);
                };
                Markers.prototype.getRenderingParts = function (event, markers) {
                    var g = event.context;
                    var scene = this.scene;
                    var labelRenderer = event.labelRenderer;
                    var sceneUnit = scene.displayUnit.unit;
                    var format = scene.settings.localization.markerDates.timeFormats[sceneUnit];
                    var x0 = scene.x0;
                    var x1 = x0 + scene.width;
                    var y0 = Math.round(scene.y0);
                    var y1 = Math.round(y0 + scene.height);
                    var lefts = [];
                    var rights = [];
                    var upsides = [];
                    var downsides = [];
                    var heights = [];
                    var widths = [];
                    var lines = [];
                    var labels = [];
                    var momentLocale = this.scene.momentLocale;
                    for (var markerIndex = 0; markerIndex < markers.length; markerIndex++) {
                        var marker = markers[markerIndex];
                        var lineX = scene.timeToX(marker.time);
                        lineX = Math.floor(lineX) + 0.5;
                        if (marker.labelCacheUnit !== sceneUnit || marker.labelCacheTime !== marker.time) {
                            if (marker.initialText !== null) {
                                marker.label.text = marker.initialText;
                                if (marker.settings.showTime)
                                    marker.label.text += " " + TimeChart.moment(marker.time).locale(momentLocale).utc().format(format).replace(/ /g, "\u00a0");
                            }
                            else if (marker.settings.showTime) {
                                marker.label.text = TimeChart.moment(marker.time).locale(momentLocale).utc().format(format).replace(/ /g, "\u00a0");
                            }
                            labelRenderer.measure(g, marker.label);
                            marker.labelCacheUnit = sceneUnit;
                            marker.labelCacheTime = marker.time;
                        }
                        var margin = (marker.label.style.margin || 0);
                        var hw = marker.label.hwidth + margin;
                        var hh = marker.label.hheight + margin;
                        var w = hw * 2;
                        var h = hh * 2;
                        if (!(lineX + hw >= x0 - 1 && lineX - hw <= x1 + 1)) {
                            continue;
                        }
                        // figuring out chart edges
                        var alignment = marker.settings.align;
                        var additionalSpace = (alignment === "center") ? hw : w;
                        if (lineX + additionalSpace >= x1) {
                            alignment = "left";
                            lineX -= 2;
                        }
                        else if (lineX - additionalSpace <= x0) {
                            alignment = "right";
                            lineX += 2;
                        }
                        var left = lineX - hw;
                        var right = lineX + hw;
                        var labelX = lineX;
                        if (alignment === "left") {
                            labelX = lineX - hw + margin;
                            right = lineX;
                            left = lineX - w;
                        }
                        else if (alignment === "right") {
                            labelX = lineX + hw - margin;
                            right = lineX + w;
                            left = lineX;
                        }
                        // relative marker positioning in relation to other markers and toolbars
                        var previous = [];
                        var next = -1;
                        var computedLeft = (left < x0) ? Math.max(x0, left) : (left > x1) ? Math.min(x1, left) : left;
                        var topY = this.getTopPos(computedLeft, additionalSpace);
                        var destY = (marker.settings.side === "top") ? topY : Math.round(scene.height + scene.bottomAxisSize * 0.5);
                        if (lefts.length !== 0) {
                            while (true) {
                                var up = (next !== -1) ? upsides[next] + heights[next] : destY;
                                var down = up + h;
                                next = -1;
                                for (var i = 0; i < lefts.length; i++) {
                                    if (previous.indexOf(i) !== -1)
                                        continue;
                                    var sqR = rights[i];
                                    var sqL = lefts[i];
                                    var sqU = upsides[i];
                                    var sqD = downsides[i];
                                    var vertical = (left >= sqL && left <= sqR) || (right >= sqL && right <= sqR) || (left <= sqL && right >= sqR); // verticales lines overlap
                                    var horisontal = (up >= sqU && up <= sqD) || (down >= sqU && down <= sqD) || (up <= sqU && down >= sqD); // horizontales lines overlap
                                    if (vertical && horisontal) {
                                        previous.push(i);
                                        destY = upsides[i] + heights[i];
                                        next = i;
                                        break;
                                    }
                                }
                                if (next === -1)
                                    break;
                            }
                        }
                        // calculate y based on available space
                        var labelY = void 0;
                        if (marker.settings.side === "top") {
                            labelY = destY + hh;
                        }
                        else {
                            y1 = y0 + scene.height - hh + margin;
                            labelY = Math.min(destY, scene.height + scene.bottomAxisSize * 0.5);
                        }
                        labelY = (labelY | 0) + 0.5;
                        heights.push(h);
                        widths.push(w);
                        upsides.push(destY);
                        downsides.push(destY + h);
                        lefts.push(left);
                        rights.push(left + w);
                        var curY = { value: y1, changes: false };
                        if (marker.animator != null) {
                            curY = marker.animator.updateAndGet(labelY, event.timeStamp);
                        }
                        lines.push({ x: lineX, y: curY.value + hh - margin, style: marker.settings.style, side: marker.settings.side });
                        labels.push({ x: labelX, y: curY.value, label: marker.label });
                        if (curY.changes)
                            event.animating = true;
                    }
                    return { lines: lines, labels: labels };
                };
                /** Get to know if top position changes because of toolbars */
                Markers.prototype.getTopPos = function (x, w) {
                    var x1 = this.scene.x0 + this.scene.width;
                    var chartArea = this.chart.shell.getChartInnerArea();
                    return chartArea.findTopPosition(x, Math.min(x + w, x1));
                };
                Markers.prototype.createMarkers = function () {
                    var scene = this.scene;
                    var markers = scene.markers.filter(function (o) { return !o.isMilestone; });
                    var settings = scene.settings;
                    var mileStones = settings.milestones;
                    for (var mIndex in mileStones) {
                        var conf = mileStones[mIndex];
                        if (conf.enabled) {
                            var marker = new Marker(scene, conf, settings.area.style.markerText);
                            marker.animator = new Internal.Base.Animator(0, 0, 200);
                            markers.push(marker);
                        }
                    }
                    scene.markers = markers;
                };
                return Markers;
            }(Internal.Base.ChartElement));
            TimeChart.Markers = Markers;
        })(TimeChart = Internal.TimeChart || (Internal.TimeChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Legend.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            (function (LegendItemType) {
                LegendItemType[LegendItemType["NodeClass"] = 0] = "NodeClass";
                LegendItemType[LegendItemType["LinkClass"] = 1] = "LinkClass";
                LegendItemType[LegendItemType["Aura"] = 2] = "Aura";
            })(NetChart.LegendItemType || (NetChart.LegendItemType = {}));
            var LegendItemType = NetChart.LegendItemType;
            var LegendEntry = (function (_super) {
                __extends(LegendEntry, _super);
                function LegendEntry(itemId, label, textColor, textColorDisabled, groupId, enabled, node, link, aura) {
                    _super.call(this, label, textColor, textColorDisabled, groupId);
                    this.itemId = itemId;
                    this.enabled = enabled;
                    this.node = node;
                    this.link = link;
                    this.aura = aura;
                }
                return LegendEntry;
            }(Internal.Base.LegendEntry));
            var LegendShape = (function (_super) {
                __extends(LegendShape, _super);
                function LegendShape(node, halfSize) {
                    _super.call(this, node, null);
                    this.halfSize = halfSize;
                }
                LegendShape.prototype.distanceToEdge = function () {
                    return this.halfSize;
                };
                return LegendShape;
            }(Internal.ItemsChart.Shape));
            var LegendNode = (function (_super) {
                __extends(LegendNode, _super);
                function LegendNode(halfSize, isFrom) {
                    _super.call(this, null, null, true);
                    this.data = { id: null, loaded: true };
                    this.hHeight = halfSize;
                    this.hWidth = halfSize;
                    this.renderHheight = halfSize;
                    this.renderHwidth = halfSize;
                    this.x = isFrom ? -halfSize * 2 : halfSize + halfSize / 2;
                    this.y = 0;
                    this.shape = new LegendShape(this, halfSize);
                }
                return LegendNode;
            }(Internal.ItemsChart.Node));
            var SettingsLegendAdvanced = (function (_super) {
                __extends(SettingsLegendAdvanced, _super);
                function SettingsLegendAdvanced() {
                    _super.apply(this, arguments);
                    /** Style for legend entry text when a disabled item is displayed.
                        @version 1.15.0
                    */
                    this.textColorDisabled = "rgba(64,62,62,0.3)";
                    /** When an item (node or link) has several classes applied, and the legend
                        has some of them enabled, and some of the disabled, this governs whether
                        that element is visible. If an element has no classes applied, it is
                        always visible. If a class is applied to an element but is not shown in the
                        legend (showInLegend=false), then this class is ignored for the calculation.
                        @type enum
                        @value any An item is visible if at least one of its classes is enabled
                        @value all An item is visible only if all its classes are enabled
                    */
                    this.showItemsWithClasses = "any";
                }
                return SettingsLegendAdvanced;
            }(Internal.Base.SettingsLegendAdvanced));
            NetChart.SettingsLegendAdvanced = SettingsLegendAdvanced;
            var SettingsLegend = (function (_super) {
                __extends(SettingsLegend, _super);
                function SettingsLegend() {
                    _super.call(this);
                    this.panel = new Internal.Base.SettingsLegendPanel("bottom", "left");
                    this.advanced = new SettingsLegendAdvanced();
                    this.marker.size = 30;
                    this.padding = 15;
                }
                return SettingsLegend;
            }(Internal.Base.SettingsLegend));
            NetChart.SettingsLegend = SettingsLegend;
            var Legend = (function (_super) {
                __extends(Legend, _super);
                function Legend() {
                    _super.apply(this, arguments);
                    this.paintOrder = 51;
                    this.updateOrder = 100;
                    this.linkClassState = Object.create(null);
                    this.nodeClassState = Object.create(null);
                    this.nodeAuraState = Object.create(null);
                    this.allNodeClassesEnabled = true;
                    this.allLinkClassesEnabled = true;
                }
                Legend.prototype.onSceneChange = function (event) {
                    _super.prototype.onSceneChange.call(this, event);
                    var changes = event.changes.settingsChanges;
                    if (!changes)
                        return;
                    if ((changes.style && (changes.style.nodeClasses || changes.style.linkClasses)) || changes.auras || (changes.legend && changes.legend.text)) {
                        this.rebuildItems();
                        event.changes.bounds = true;
                        event.changes.filters = true;
                    }
                };
                Legend.prototype.doAnimations = function () { return 1; };
                Legend.prototype.paintMarker = function (event, cx, cy, radius, item) {
                    if (item.node) {
                        var setup = {
                            geometry: this.getGeometry(cx, cy, .6),
                            paintDetails: false
                        };
                        this.chart.renderer.paintNodes(event, [item.node], setup, 0);
                    }
                    else if (item.link) {
                        var setup = {
                            geometry: this.getGeometry(cx, cy, 1),
                            paintDetails: true
                        };
                        this.chart.renderer.paintLinks(event, [item.link], {}, setup);
                    }
                    else {
                        this.paintAuraMarker(event.context, cx, cy, radius, item.aura);
                    }
                };
                Legend.prototype.paintAuraMarker = function (graphics, cx, cy, radius, style) {
                    /* Original source: this SVG file. Converted by an online SVG->Canvas convertor and optimized by hand.
        
                        <?xml version="1.0" encoding="utf-8"?>
                        <!-- Generator: Adobe Illustrator 19.2.1, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
                        <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
                        <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                             viewBox="0 0 1111 1111" style="enable-background:new 0 0 1111 1111;" xml:space="preserve">
                        <style type="text/css">
                            .st0{fill:#0099CC;}
                        </style>
                        <g>
                            <path class="st0" d="M926.4,445.8c-22-9.6-61.3-24.9-108.7-35.6c-73.6-16.7-90.2-54.1-93-69.4c-2.3-12.7-23.8-120.4-86.8-201.8
                                C591,74.5,514.9,32.6,429,32.6c-142.6,0-258.2,115.6-258.2,258.2c0,5.9,0.2,11.7,0.6,17.5l-0.6,0.6c0,0,4.2,56.9,13.9,112.4
                                c9.7,55.5,1.4,111.1-30.5,154.1c-31.9,43-104.1,145.8-101.3,211c0.1,1.5,0.3,2.9,0.5,4.4c-1.3,10.4-1.9,21-1.9,31.7
                                c0,142.6,115.6,258.2,258.2,258.2c87.9,0,165.6-44,212.2-111.1l0.2,0c0,0,36.1-45.8,44.4-52.8c8.3-6.9,50-30.5,90.2-15.3
                                c23,8.7,66.9,24.7,110.4,35.5c24.3,7.6,50.2,11.7,77,11.7c142.6,0,258.2-115.6,258.2-258.2C1102.3,576.8,1028.6,480.1,926.4,445.8z
                                 M844.1,857.2c-77.3,0-142.3-52.6-161.1-124L471.3,782c3.2,13,5,26.5,5,40.5c0,92-74.6,166.6-166.6,166.6s-166.6-74.6-166.6-166.6
                                s74.6-166.6,166.6-166.6c9,0,17.7,0.7,26.3,2.1l43.2-208.2c-67.6-21.2-116.7-84.4-116.7-159c0-92,74.6-166.6,166.6-166.6
                                s166.6,74.6,166.6,166.6c0,39.3-13.6,75.3-36.3,103.8L732,567.3c29.6-26.9,68.9-43.3,112.1-43.3c92,0,166.6,74.6,166.6,166.6
                                S936.1,857.2,844.1,857.2z"/>
                            <path class="st0" d="M429,457.4c-6.8,0-13.4-0.4-20-1.2l-43.5,209.3c42.4,15.1,76.8,46.9,95.5,87.5L678,703
                                c-0.3-4.1-0.5-8.2-0.5-12.4c0-37.8,12.6-72.7,33.9-100.7L538.2,416.6C508.9,442,470.8,457.4,429,457.4z"/>
                        </g>
                        </svg>
                    */
                    var m = radius / 527; // Scaling factor. 527 comes from the fact that the original shape precisely fits inside a square of 1054*1054px.
                    var tx = cx - radius; // Displacement on X axis
                    var ty = cy - radius; // Displacement on Y axis
                    // First part - overall shape with fill and shadow.
                    var ctx = Internal.Base.Graphics.beginStrokeAndFill(graphics, style);
                    ctx.moveTo(878.4 * m + tx, 413.8 * m + ty);
                    ctx.bezierCurveTo(856.4 * m + tx, 404.2 * m + ty, 817.1 * m + tx, 388.9 * m + ty, 769.7 * m + tx, 378.2 * m + ty);
                    ctx.bezierCurveTo(696.1 * m + tx, 361.5 * m + ty, 679.5 * m + tx, 324.1 * m + ty, 676.7 * m + tx, 308.7 * m + ty);
                    ctx.bezierCurveTo(674.4 * m + tx, 296.1 * m + ty, 652.9 * m + tx, 188.3 * m + ty, 589.9 * m + tx, 107 * m + ty);
                    ctx.bezierCurveTo(543 * m + tx, 42.5 * m + ty, 466.9 * m + tx, 0.6 * m + ty, 381 * m + tx, 0.6 * m + ty);
                    ctx.bezierCurveTo(238.4 * m + tx, 0.6 * m + ty, 122.8 * m + tx, 116.2 * m + ty, 122.8 * m + tx, 258.8 * m + ty);
                    ctx.bezierCurveTo(122.8 * m + tx, 264.7 * m + ty, 123 * m + tx, 270.5 * m + ty, 123.4 * m + tx, 276.3 * m + ty);
                    ctx.lineTo(122.8 * m + tx, 276.9 * m + ty);
                    ctx.bezierCurveTo(122.8 * m + tx, 276.9 * m + ty, 127 * m + tx, 333.8 * m + ty, 136.7 * m + tx, 389.3 * m + ty);
                    ctx.bezierCurveTo(146.4 * m + tx, 444.8 * m + ty, 138.1 * m + tx, 500.4 * m + ty, 106.2 * m + tx, 543.4 * m + ty);
                    ctx.bezierCurveTo(74.3 * m + tx, 586.4 * m + ty, 2.1 * m + tx, 689.2 * m + ty, 4.9 * m + tx, 754.4 * m + ty);
                    ctx.bezierCurveTo(5 * m + tx, 755.9 * m + ty, 5.2 * m + tx, 757.3 * m + ty, 5.4 * m + tx, 758.8 * m + ty);
                    ctx.bezierCurveTo(4.1 * m + tx, 769.2 * m + ty, 3.5 * m + tx, 779.8 * m + ty, 3.5 * m + tx, 790.5 * m + ty);
                    ctx.bezierCurveTo(3.5 * m + tx, 933.1 * m + ty, 119.1 * m + tx, 1048.7 * m + ty, 261.7 * m + tx, 1048.7 * m + ty);
                    ctx.bezierCurveTo(349.6 * m + tx, 1048.7 * m + ty, 427.2 * m + tx, 1004.7 * m + ty, 473.9 * m + tx, 937.6 * m + ty);
                    ctx.lineTo(474.1 * m + tx, 937.6 * m + ty);
                    ctx.bezierCurveTo(474.1 * m + tx, 937.6 * m + ty, 510.2 * m + tx, 891.8 * m + ty, 518.5 * m + tx, 884.8 * m + ty);
                    ctx.bezierCurveTo(526.8 * m + tx, 877.9 * m + ty, 568.5 * m + tx, 854.3 * m + ty, 608.7 * m + tx, 869.5 * m + ty);
                    ctx.bezierCurveTo(631.7 * m + tx, 878.2 * m + ty, 675.6 * m + tx, 894.2 * m + ty, 719.1 * m + tx, 905 * m + ty);
                    ctx.bezierCurveTo(743.4 * m + tx, 912.6 * m + ty, 769.3 * m + tx, 916.7 * m + ty, 796.1 * m + tx, 916.7 * m + ty);
                    ctx.bezierCurveTo(938.7 * m + tx, 916.7 * m + ty, 1054.3 * m + tx, 801.1 * m + ty, 1054.3 * m + tx, 658.5 * m + ty);
                    ctx.bezierCurveTo(1054.3 * m + tx, 544.8 * m + ty, 980.6 * m + tx, 448.1 * m + ty, 878.4 * m + tx, 413.8 * m + ty);
                    ctx.closePath();
                    Internal.Base.Graphics.endStrokeAndFill(graphics, ctx, style);
                    // Second part - inside "nodes".
                    ctx = Internal.Base.Graphics.beginStrokeAndFill(graphics, { fillColor: "white" });
                    // Subpart one - node shapes
                    ctx.moveTo(796.1 * m + tx, 825.2 * m + ty);
                    ctx.bezierCurveTo(718.8 * m + tx, 825.2 * m + ty, 653.8 * m + tx, 772.6 * m + ty, 635 * m + tx, 701.2 * m + ty);
                    ctx.lineTo(423.3 * m + tx, 750 * m + ty);
                    ctx.bezierCurveTo(426.5 * m + tx, 763 * m + ty, 428.3 * m + tx, 776.5 * m + ty, 428.3 * m + tx, 790.5 * m + ty);
                    ctx.bezierCurveTo(428.3 * m + tx, 882.5 * m + ty, 353.7 * m + tx, 957.1 * m + ty, 261.7 * m + tx, 957.1 * m + ty);
                    ctx.bezierCurveTo(169.7 * m + tx, 957.1 * m + ty, 95.1 * m + tx, 882.5 * m + ty, 95.1 * m + tx, 790.5 * m + ty);
                    ctx.bezierCurveTo(95.1 * m + tx, 698.5 * m + ty, 169.7 * m + tx, 623.9 * m + ty, 261.7 * m + tx, 623.9 * m + ty);
                    ctx.bezierCurveTo(270.7 * m + tx, 623.9 * m + ty, 279.4 * m + tx, 624.6 * m + ty, 288 * m + tx, 626 * m + ty);
                    ctx.lineTo(331.2 * m + tx, 417.8 * m + ty);
                    ctx.bezierCurveTo(263.6 * m + tx, 396.6 * m + ty, 214.5 * m + tx, 333.4 * m + ty, 214.5 * m + tx, 258.8 * m + ty);
                    ctx.bezierCurveTo(214.5 * m + tx, 166.8 * m + ty, 289.1 * m + tx, 92.2 * m + ty, 381.1 * m + tx, 92.2 * m + ty);
                    ctx.bezierCurveTo(473.1 * m + tx, 92.2 * m + ty, 547.7 * m + tx, 166.8 * m + ty, 547.7 * m + tx, 258.8 * m + ty);
                    ctx.bezierCurveTo(547.7 * m + tx, 298.1 * m + ty, 534.1 * m + tx, 334.1 * m + ty, 511.4 * m + tx, 362.6 * m + ty);
                    ctx.lineTo(684 * m + tx, 535.3 * m + ty);
                    ctx.bezierCurveTo(713.6 * m + tx, 508.4 * m + ty, 752.9 * m + tx, 492 * m + ty, 796.1 * m + tx, 492 * m + ty);
                    ctx.bezierCurveTo(888.1 * m + tx, 492 * m + ty, 962.7 * m + tx, 566.6 * m + ty, 962.7 * m + tx, 658.6 * m + ty);
                    ctx.bezierCurveTo(962.7 * m + tx, 750.6 * m + ty, 888.1 * m + tx, 825.2 * m + ty, 796.1 * m + tx, 825.2 * m + ty);
                    ctx.closePath();
                    // Subpart two - "hole" inside the node shapes.
                    ctx.moveTo(381 * m + tx, 425.4 * m + ty);
                    ctx.bezierCurveTo(374.2 * m + tx, 425.4 * m + ty, 367.6 * m + tx, 425 * m + ty, 361 * m + tx, 424.2 * m + ty);
                    ctx.lineTo(317.5 * m + tx, 633.5 * m + ty);
                    ctx.bezierCurveTo(359.9 * m + tx, 648.6 * m + ty, 394.3 * m + tx, 680.4 * m + ty, 413 * m + tx, 721 * m + ty);
                    ctx.lineTo(630 * m + tx, 671 * m + ty);
                    ctx.bezierCurveTo(629.7 * m + tx, 666.9 * m + ty, 629.5 * m + tx, 662.8 * m + ty, 629.5 * m + tx, 658.6 * m + ty);
                    ctx.bezierCurveTo(629.5 * m + tx, 620.8 * m + ty, 642.1 * m + tx, 585.9 * m + ty, 663.4 * m + tx, 557.9 * m + ty);
                    ctx.lineTo(490.2 * m + tx, 384.6 * m + ty);
                    ctx.bezierCurveTo(460.9 * m + tx, 410 * m + ty, 422.8 * m + tx, 425.4 * m + ty, 381 * m + tx, 425.4 * m + ty);
                    ctx.closePath();
                    Internal.Base.Graphics.endStrokeAndFill(graphics, ctx, { fillColor: "white" });
                };
                Legend.prototype.rebuildItems = function () {
                    var style = this.chart.scene.settings.style;
                    var items = [];
                    var halfSize = this.settings.marker.size / 2;
                    var baseTextColor = this.settings.text.fillColor;
                    var baseTextColorDisabled = this.settings.advanced.textColorDisabled;
                    var oldNodeClassState = this.nodeClassState;
                    var oldLinkClassState = this.linkClassState;
                    var oldNodeAuraState = this.nodeAuraState;
                    this.nodeClassState = Object.create(null);
                    this.linkClassState = Object.create(null);
                    this.nodeAuraState = Object.create(null);
                    this.allLinkClassesEnabled = true;
                    this.allNodeClassesEnabled = true;
                    for (var nodeClassIndex = 0; nodeClassIndex < style.nodeClasses.length; nodeClassIndex++) {
                        var nodeClass = style.nodeClasses[nodeClassIndex];
                        if (!nodeClass.showInLegend || nodeClass.style == null)
                            continue;
                        var mergedStyle = Internal.Base.Helpers.clone(style.node);
                        Internal.Base.Helpers.extendStyleTo(nodeClass.style, mergedStyle);
                        var node = new LegendNode(halfSize, false);
                        Internal.Base.Helpers.extendStyleTo(mergedStyle, node);
                        this.chart.layer.styleUpdater.postprocessNode(node);
                        var enabled = !Internal.Base.Helpers.hasProperty(oldNodeClassState, nodeClass.className) || oldNodeClassState[nodeClass.className];
                        this.nodeClassState[nodeClass.className] = enabled;
                        if (!enabled)
                            this.allNodeClassesEnabled = false;
                        items.push(new LegendEntry(nodeClass.className, nodeClass.nameLegend || nodeClass.className, baseTextColor, baseTextColorDisabled, nodeClass.legendGroupId, enabled, node, null, null));
                    }
                    for (var linkClassIndex = 0; linkClassIndex < style.linkClasses.length; linkClassIndex++) {
                        var linkClass = style.linkClasses[linkClassIndex];
                        if (!linkClass.showInLegend || linkClass.style == null)
                            continue;
                        var mergedStyle = Internal.Base.Helpers.clone(style.link);
                        Internal.Base.Helpers.extendStyleTo(linkClass.style, mergedStyle);
                        // Itemschart_Link
                        var link = new Internal.ItemsChart.Link(null, null);
                        Internal.Base.Helpers.extendStyleTo(mergedStyle, link);
                        link.currentRadius = link.radius;
                        link.from = new LegendNode(halfSize, true);
                        link.to = new LegendNode(halfSize, false);
                        var enabled = !Internal.Base.Helpers.hasProperty(oldLinkClassState, linkClass.className) || oldLinkClassState[linkClass.className];
                        this.linkClassState[linkClass.className] = enabled;
                        this.allLinkClassesEnabled = this.allLinkClassesEnabled && enabled;
                        items.push(new LegendEntry(linkClass.className, linkClass.nameLegend || linkClass.className, baseTextColor, baseTextColorDisabled, linkClass.legendGroupId, enabled, null, link, null));
                    }
                    var auras = this.chart.settings.auras.style;
                    var auraIds = Object.keys(auras);
                    for (var i = 0; i < auraIds.length; i++) {
                        var id = auraIds[i];
                        var aura = auras[id];
                        var enabled = !Internal.Base.Helpers.hasProperty(oldNodeAuraState, id) || oldNodeAuraState[id];
                        this.nodeAuraState[id] = enabled;
                        if (!enabled)
                            this.allNodeClassesEnabled = false;
                        if (aura.showInLegend || aura.showInLegend == null)
                            items.push(new LegendEntry(id, aura.nameLegend || id, baseTextColor, baseTextColorDisabled, aura.legendGroupId, enabled, null, null, aura));
                    }
                    this.resetEntries(items);
                };
                Legend.prototype.getGeometry = function (xc, yc, zoom) {
                    var halfSize = this.settings.marker.size;
                    var x0w = -halfSize;
                    var x1w = halfSize;
                    var y0w = -halfSize;
                    var y1w = halfSize;
                    var txm = zoom;
                    var tym = zoom;
                    var txa = xc;
                    var tya = yc;
                    var x0s = xc - halfSize;
                    var x1s = xc + halfSize;
                    var y0s = yc - halfSize;
                    var y1s = yc + halfSize;
                    return {
                        txm: txm,
                        txa: txa,
                        tym: tym,
                        tya: tya,
                        zoom: zoom,
                        x0s: x0s,
                        x1s: x1s,
                        y0s: y0s,
                        y1s: y1s,
                        x0w: x0w,
                        y0w: y0w,
                        x1w: x1w,
                        y1w: y1w,
                        linkZoom: zoom
                    };
                };
                Legend.prototype.itemClicked = function (event, item) {
                    _super.prototype.itemClicked.call(this, event, item);
                    this.nodeClassState = Object.create(null);
                    this.linkClassState = Object.create(null);
                    this.allLinkClassesEnabled = true;
                    this.allNodeClassesEnabled = true;
                    for (var i = 0; i < this.entries.length; i++) {
                        var entry = this.entries[i];
                        if (entry.node) {
                            this.nodeClassState[entry.itemId] = entry.enabled;
                            if (!entry.enabled)
                                this.allNodeClassesEnabled = false;
                        }
                        else if (entry.link) {
                            this.linkClassState[entry.itemId] = entry.enabled;
                            if (!entry.enabled)
                                this.allLinkClassesEnabled = false;
                        }
                        else {
                            this.nodeAuraState[entry.itemId] = entry.enabled;
                            entry.aura.enabled = entry.enabled;
                            if (!entry.enabled)
                                this.allNodeClassesEnabled = false;
                        }
                    }
                    this.chart.events.notifySceneChanges({ filters: true });
                };
                Legend.prototype.isNodeVisible = function (node) {
                    if (this.allNodeClassesEnabled)
                        return true;
                    var className = node.className;
                    var aura = node.style ? node.style.aura : null;
                    if (!className && !aura)
                        return true;
                    var classes = Internal.ItemsChart.ItemsStyle.getClasses(className);
                    var auras = Array.isArray(aura) ? aura : [aura];
                    if (this.settings.advanced.showItemsWithClasses === "any") {
                        var hasDisabled = false;
                        var hasEnabled = false;
                        for (var i = 0; i < classes.length; i++) {
                            if (!Internal.Base.Helpers.hasProperty(this.nodeClassState, classes[i]))
                                continue;
                            if (this.nodeClassState[classes[i]]) {
                                hasEnabled = true;
                                break;
                            }
                            else {
                                hasDisabled = true;
                            }
                        }
                        for (var i = 0; i < auras.length; i++) {
                            if (!Internal.Base.Helpers.hasProperty(this.nodeAuraState, auras[i]))
                                continue;
                            if (this.nodeAuraState[auras[i]]) {
                                hasEnabled = true;
                                break;
                            }
                            else {
                                hasDisabled = true;
                            }
                        }
                        return hasEnabled || !hasDisabled;
                    }
                    else {
                        for (var i = 0; i < classes.length; i++) {
                            if (!Internal.Base.Helpers.hasProperty(this.nodeClassState, classes[i]))
                                continue;
                            if (!this.nodeClassState[classes[i]]) {
                                return false;
                            }
                        }
                        for (var i = 0; i < auras.length; i++) {
                            if (!Internal.Base.Helpers.hasProperty(this.nodeAuraState, auras[i]))
                                continue;
                            if (!this.nodeAuraState[auras[i]]) {
                                return false;
                            }
                        }
                        return true;
                    }
                };
                Legend.prototype.isLinkVisible = function (link) {
                    if (this.allLinkClassesEnabled)
                        return true;
                    var className = link.className;
                    if (!className)
                        return true;
                    var classes = Internal.ItemsChart.ItemsStyle.getClasses(className);
                    if (this.settings.advanced.showItemsWithClasses === "any") {
                        var hasDisabled = false;
                        var hasEnabled = false;
                        for (var i = 0; i < classes.length; i++) {
                            if (!Internal.Base.Helpers.hasProperty(this.linkClassState, classes[i]))
                                continue;
                            if (this.linkClassState[classes[i]]) {
                                hasEnabled = true;
                                break;
                            }
                            else {
                                hasDisabled = true;
                            }
                        }
                        return hasEnabled || !hasDisabled;
                    }
                    else {
                        for (var i = 0; i < classes.length; i++) {
                            if (!Internal.Base.Helpers.hasProperty(this.linkClassState, classes[i]))
                                continue;
                            if (!this.linkClassState[classes[i]]) {
                                return false;
                            }
                        }
                        return true;
                    }
                };
                return Legend;
            }(Internal.Base.Legend));
            NetChart.Legend = Legend;
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../base/Bar/Toolbar.ts" />
/// <reference path="../../base/Bar/Button.ts" />
/// <reference path="../../base/core/MouseEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var Bar;
            (function (Bar) {
                var ZoomControl = (function (_super) {
                    __extends(ZoomControl, _super);
                    function ZoomControl(chart, options) {
                        var _this = this;
                        _super.call(this, chart, options);
                        this.scene = chart.scene;
                        this.events = chart.events;
                        var cont = Internal.Base.Helpers.createDom("li", null, null, null);
                        var zoom = Internal.Base.Helpers.createDom("span", "DVSL-NC-zoom", null, cont);
                        this.handle = Internal.Base.Helpers.createDom("em", null, null, zoom);
                        this.mouse = new Internal.Base.MouseEvents(cont, this.scene.settings.advanced.pointer);
                        this.mouse.listen("drag", function (event) { return _this.zoomMove(event); });
                        this.mouse.listen("down", function (event) { return _this.zoomDown(event); });
                        this.domElement = cont;
                    }
                    ZoomControl.prototype.zoomDown = function (event) {
                        if (event.y < 100) {
                            this.zoomMove(event);
                        }
                    };
                    ZoomControl.prototype.zoomMove = function (event) {
                        var pos = event.y - 10;
                        pos = Math.max(0, Math.min(80, pos));
                        this.handle.style.top = (pos + "px");
                        var newZoom = this.getZoomValue(pos / 80);
                        this.chart.autoZoom.manualZoom(newZoom / this.scene.zoom);
                        this.events.notifySceneChanges({ position: true });
                        event.consumed = true;
                    };
                    ZoomControl.prototype.getSliderPosition = function () {
                        var stngs = this.scene.settings.interaction.zooming.zoomExtent;
                        var min = Math.min(stngs[0], this.chart.autoZoom.minimumAutoZoom);
                        var max = stngs[1];
                        var zoom = Math.log(Math.max(min, Math.min(max, this.scene.zoom)));
                        min = Math.log(min);
                        max = Math.log(max);
                        return 1 - (zoom - min) / (max - min);
                    };
                    ZoomControl.prototype.getZoomValue = function (pos) {
                        var stngs = this.scene.settings.interaction.zooming.zoomExtent;
                        var min = Math.min(stngs[0], this.chart.autoZoom.minimumAutoZoom);
                        var max = stngs[1];
                        min = Math.log(min);
                        max = Math.log(max);
                        var prop = (1 - pos) * (max - min) + min;
                        return Math.exp(prop);
                    };
                    ZoomControl.prototype.doAnimations = function (event) {
                        var value = this.getSliderPosition();
                        this.handle.style.top = ((80 * value) + "px");
                    };
                    ZoomControl.prototype.remove = function () {
                        this.mouse.remove();
                    };
                    return ZoomControl;
                }(Internal.Base.Bar.Item));
                Bar.ZoomControl = ZoomControl;
                Internal.Base.Bar.ToolbarItemNames["zoomControl"] =
                    Internal.Base.Bar.ToolbarItemNames["zoomcontrol"] =
                        function (chart, options) { return new NetChart.Bar.ZoomControl(chart, options); };
            })(Bar = NetChart.Bar || (NetChart.Bar = {}));
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../base/Bar/Toolbar.ts" />
/// <reference path="../../base/Bar/Fullscreen.ts" />
/// <reference path="../../base/Bar/BackButton.ts" />
/// <reference path="ZoomControl.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var Bar;
            (function (Bar) {
                Internal.Base.Bar.ToolbarItemNames["rearrange"] = function (chart, options) {
                    var localization = chart.settings.localization.toolbar;
                    options.label = options.label || localization.rearrangeButton;
                    options.title = options.title || localization.rearrangeTitle;
                    options.cssClass = options.cssClass || "DVSL-bar-btn-rearrange";
                    var userClick = options.onClick;
                    options.onClick = function (ev, api) {
                        chart.resetLayout();
                        if (userClick)
                            userClick(ev, api);
                    };
                    return new Internal.Base.Bar.Button(chart, options);
                };
                Internal.Base.Bar.ToolbarItemNames["freeze"] = function (chart, options) {
                    var localization = chart.settings.localization.toolbar;
                    return new Internal.Base.Bar.ToggleButton(chart, options, {
                        labelDisabled: options.label || localization.freezeButton,
                        cssClassEnabled: "DVSL-bar-btn-lock-all-active",
                        cssClassDisabled: options.cssClass || "DVSL-bar-btn-lock-all",
                        titleEnabled: localization.unfreezeTitle,
                        titleDisabled: localization.freezeTitle,
                        getChartState: function () { return chart.isLayoutFrozen; },
                        onEnable: function () { return chart.freezeLayout(); },
                        onDisable: function () { return chart.unfreezeLayout(); }
                    });
                };
                Internal.Base.Bar.ToolbarItemNames["fit"] = function (chart, options) {
                    var localization = chart.settings.localization.toolbar;
                    return new Internal.Base.Bar.ToggleButton(chart, options, {
                        labelDisabled: options.label || localization.fitButton,
                        cssClassEnabled: "DVSL-bar-btn-fit-active",
                        cssClassDisabled: options.cssClass || "DVSL-bar-btn-fit",
                        titleDisabled: options.title || localization.fitTitle,
                        getChartState: function () { return chart.scene.autoZoomMode === "overview"; },
                        onEnable: function () { return chart.autoZoom.setZoom("overview"); },
                        onDisable: function () { return chart.autoZoom.setZoom("auto"); }
                    });
                };
                var SettingsToolbar = (function (_super) {
                    __extends(SettingsToolbar, _super);
                    function SettingsToolbar() {
                        _super.call(this);
                        /** Whether to show the zoom slider control.
                        @version 1.9.0 */
                        this.zoomControl = true;
                        this.enabled = true;
                        this.side = "bottom";
                        this.align = "left";
                        this.showLabels = false;
                        this.items = [
                            new Internal.Base.SettingsToolbarItem("fit"),
                            new Internal.Base.SettingsToolbarItem("rearrange"),
                            new Internal.Base.SettingsToolbarItem("freeze"),
                            new Internal.Base.SettingsToolbarItem("back"),
                            new Internal.Base.SettingsToolbarItem("fullscreen"),
                            new Internal.Base.SettingsToolbarItem("zoomControl", "bottom", "left"),
                        ];
                    }
                    return SettingsToolbar;
                }(Internal.Base.SettingsToolbar));
                Bar.SettingsToolbar = SettingsToolbar;
                var SettingsLocalizationToolbar = (function (_super) {
                    __extends(SettingsLocalizationToolbar, _super);
                    function SettingsLocalizationToolbar() {
                        _super.apply(this, arguments);
                        this.rearrangeButton = "Rearrange";
                        this.rearrangeTitle = "Rearrange elements";
                        this.freezeButton = "Freeze";
                        this.freezeTitle = "Lock all";
                        this.unfreezeTitle = "Unlock all";
                        this.fitButton = "Fit";
                        this.fitTitle = "Fit to screen";
                    }
                    return SettingsLocalizationToolbar;
                }(Internal.Base.SettingsLocalizationToolbar));
                Bar.SettingsLocalizationToolbar = SettingsLocalizationToolbar;
            })(Bar = NetChart.Bar || (NetChart.Bar = {}));
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../itemschart/Settings.ts" />
/// <reference path="../itemschart/layers/NodesStyle.ts" />
/// <reference path="Legend.ts" />
/// <reference path="Bar/Toolbar.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var Settings = (function (_super) {
                __extends(Settings, _super);
                function Settings(settings) {
                    _super.call(this, Internal.Base.SettingsMapping.NetChartSettings);
                    /** Theme to apply. You can either use this to share configuration objects between multiple charts or use one of the predefined
                    themes.
                    @see Documentation: [Pre-defined themes](net-chart/api-reference/api.html#doc_themes)
                    */
                    this.theme = Settings.FlatTheme;
                    this.data = [];
                    this.area = new SettingsArea();
                    /** Chart style settings.
                    @see Documentation: [NetChart style settings](net-chart/introductory-topics/style.html) */
                    this.style = new SettingsStyle();
                    /** Contains settings for the auras drawn beneath the nodes.
                    @version 1.15.0 */
                    this.auras = new Internal.ItemsChart.SettingsNodesLayerAuras();
                    /** Adjustable settings to get desired net chart layout style and animation while and before interacting. */
                    this.layout = new SettingsLayout();
                    /** Configurable conditions to filter the raw data values for subset of drawing nodes and links. */
                    this.filters = {
                        /** Determine if node can be displayed. Invoked whenever a node or one of its links is about to be shown, or if data for the node (or its links) has changed.
                        @returns true if the node should be shown, false otherwise */
                        nodeFilter: null,
                        /** Determine if link can be displayed. Invoked whenever a link is about to be shown or its data has changed.
                            Only links that have been allowed by nodeFilter for both end nodes will be passed here.
                        @returns true if the link should be shown, false otherwise */
                        linkFilter: null,
                        /** From links that were allowed by nodeFilter and linkFilter, select the ones that will be displayed. This is basically a bulk version of linkFilter.
                            It is also allowed to return a completely new set of links, however link IDs MUST be unique in this case
                            (links passed in are guaranteed to have unique IDs).
                            @returns Array of links to show. */
                        nodeLinksProcessor: null,
                        /** Function called whenever there is more than one link between two nodes. Only links that were allowed by nodeFilter, linkFilter and nodeLinksProcessor
                            will be passed here. The function can return either some of the original links, or create completely new links.
                            In the latter case, link IDs MUST be unique (links passed in are guaranteed to have unique IDs).
                            @returns One or more links to be used in place of the original links */
                        multilinkProcessor: null
                    };
                    /** Customise chart resize handles or animation duration settings. */
                    this.interaction = new SettingsInteraction();
                    /** Settings for NetChart navigation (expanding/collapsing/focusing/unfocusing/showing/hiding). The main setting is "mode" which determines the overall
                        algorithm for navigation. Other parameters can tweak this algorithm, but not all parameters apply to all algorithms. */
                    this.navigation = new SettingsNavigation();
                    this.toolbar = new NetChart.Bar.SettingsToolbar();
                    /** Localizeable strings including export type options and useful default buttons used for chart interaction.
                    Buttons like to navigate back, set the chart on full screen and others. */
                    this.localization = new SettingsLocalization();
                    /** The chart legend representing classes attached to nodes or links.
                    The legend will display the visual styles specified in `style.nodeClasses` and `style.linkClasses` - by default these are not defined
                    so the legend will be empty. */
                    this.legend = new NetChart.SettingsLegend();
                    this.nodeMenu.buttons = ["hide", "expand", "focus", "lock"];
                    this.apply(settings);
                    this._initializing = false;
                }
                Settings.prototype.apply = function (settings) {
                    this.applyCompatibility(settings, [
                        { from: "navigation.nodeExpansionRadius", to: "navigation.focusNodeExpansionRadius" },
                        { from: "localization.menu.dynaminc", to: "localization.menu.dynamic" }
                    ]);
                    return _super.prototype.apply.call(this, settings);
                };
                Settings.FlatTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-flat"
                    }
                };
                Settings.DarkTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-dark"
                    },
                    area: {
                        style: {
                            fillColor: "rgba(28,26,28,1)"
                        }
                    },
                    title: {
                        margin: 15,
                        style: {
                            fillColor: "#A8A7A8"
                        }
                    },
                    legend: {
                        text: {
                            fillColor: "#A8A7A8"
                        }
                    },
                    style: {
                        node: {
                            fillColor: "gray"
                        },
                        link: {
                            fillColor: "#09c"
                        },
                        linkHovered: {
                            shadowColor: "#09c"
                        },
                        hiddenLinks: {
                            lineColor: "#A8A7A8"
                        },
                        nodeHovered: {
                            shadowColor: "#fff",
                            shadowOffsetY: 0,
                            shadowBlur: 12,
                        },
                        nodeLabel: {
                            padding: 4,
                            borderRadius: 10,
                            textStyle: { fillColor: "rgba(180,180,180,1)" },
                            backgroundStyle: { fillColor: "rgba(60,60,60,0.8)", lineColor: null }
                        },
                        linkLabel: {
                            padding: 0.6,
                            backgroundStyle: {
                                lineColor: "#09c",
                                fillColor: "#333333"
                            },
                            textStyle: {
                                fillColor: "#A8A7A8"
                            }
                        },
                        selection: {
                            fillColor: "#09c",
                            shadowColor: "rgba(255,255,255,0.6)",
                            sizeConstant: 4,
                            shadowBlur: 24,
                            shadowOffsetY: 4
                        }
                    }
                };
                return Settings;
            }(Internal.ItemsChart.Settings));
            NetChart.Settings = Settings;
            var SettingsLocalization = (function (_super) {
                __extends(SettingsLocalization, _super);
                function SettingsLocalization() {
                    _super.apply(this, arguments);
                    /** Strings used in toolbars. */
                    this.toolbar = new NetChart.Bar.SettingsLocalizationToolbar();
                    /** Node/link menu by using localizeable strings. */
                    this.menu = {
                        /** The text for the button that unlock the node position.
                        @version 1.12.0 - fixed spelling (previous name was 'dynaminc').*/
                        dynamic: "Dynamic",
                        fixed: "Fixed",
                        focus: "Focus",
                        unfocus: "Unfocus",
                        collapse: "Collapse",
                        close: "Close",
                        expand: "Expand",
                        hide: "Hide"
                    };
                }
                return SettingsLocalization;
            }(Internal.Base.SettingsLocalization));
            NetChart.SettingsLocalization = SettingsLocalization;
            var SettingsArea = (function (_super) {
                __extends(SettingsArea, _super);
                function SettingsArea() {
                    _super.apply(this, arguments);
                    /** The center of the chart. Fraction of chart width. 0 = left side, 1 = right side.
                    @deprecated - this property is no longer used
                    @version 1.12.0 - deprecated the property
                    @type float */
                    this.centerX = 0.5;
                    /** The center of the chart. Fraction of chart height, 0 = top, 1 = botom.
                    @deprecated - this property is no longer used
                    @version 1.12.0 - deprecated the property
                    @type float */
                    this.centerY = 0.5;
                    /** Inner top padding, nodes will avoid this area.
                    If the value is <= 1 then the value represents the fraction from the chart width.
                    Otherwise it represents the padding value in pixels.
                    @deprecated - this property is no longer used
                    @version 1.12.0 - deprecated the property
                    @type float
                    @units pixels */
                    this.paddingTop = 0;
                    /** Inner left padding, nodes will avoid this area.
                    If the value is <= 1 then the value represents the fraction from the chart width.
                    Otherwise it represents the padding value in pixels.
                    @deprecated - this property is no longer used
                    @version 1.12.0 - deprecated the property
                    @type float
                    @units pixels */
                    this.paddingLeft = 0;
                    /** Inner right padding, nodes will avoid this area.
                    If the value is <= 1 then the value represents the fraction from the chart width.
                    Otherwise it represents the padding value in pixels.
                    @deprecated - this property is no longer used
                    @version 1.12.0 - deprecated the property
                    @type float
                    @units pixels */
                    this.paddingRight = 0;
                    /** Inner bottom padding, nodes will avoid this area.
                    If the value is <= 1 then the value represents the fraction from the chart width.
                    Otherwise it represents the padding value in pixels.
                    @deprecated - this property is no longer used
                    @version 1.12.0 - deprecated the property
                    @type float
                    @units pixels */
                    this.paddingBottom = 0;
                }
                return SettingsArea;
            }(Internal.Base.SettingsArea));
            NetChart.SettingsArea = SettingsArea;
            var SettingsInteraction = (function (_super) {
                __extends(SettingsInteraction, _super);
                function SettingsInteraction() {
                    _super.apply(this, arguments);
                    /** Zoom in or out by swiping up or down with mouse scroll pad or by using the Zoom-out feature at the top left. */
                    this.zooming = new SettingsInteractionZooming();
                    /** Select node to expand it or getting path. */
                    this.selection = new SettingsInteractionSelection();
                    /** The ability to rotate the chart with the pinch gesture, using 2 fingers */
                    this.rotation = {
                        /** Enables/disables chart rotation via the multitouch gesture events */
                        fingers: false
                    };
                }
                return SettingsInteraction;
            }(Internal.ItemsChart.SettingsInteraction));
            NetChart.SettingsInteraction = SettingsInteraction;
            var SettingsInteractionSelection = (function (_super) {
                __extends(SettingsInteractionSelection, _super);
                function SettingsInteractionSelection() {
                    _super.apply(this, arguments);
                    /** Enable/disable rectangular dragging selection. This has no effect if `enabled=false`. */
                    this.dragSelect = true;
                }
                return SettingsInteractionSelection;
            }(Internal.ItemsChart.SettingsInteractionSelection));
            NetChart.SettingsInteractionSelection = SettingsInteractionSelection;
            var SettingsInteractionZooming = (function (_super) {
                __extends(SettingsInteractionZooming, _super);
                function SettingsInteractionZooming() {
                    _super.apply(this, arguments);
                    /** Auto zoom mode on chart initialization.
                    @type enum
                    @value overview - show whole network
                    @value true - use basic auto zoom
                    @value false - no auto zoom. */
                    this.initialAutoZoom = "overview";
                    /** Zoom value limits while for manual zooming. Contains array of [min, max] values.
            
                    Note that if the minimum for `autoZoomExtent` is `null` (the default) then it can override the minimum in this value if the auto zoom level is smaller.
            
                    @version 1.12.0 - the minimum value is now always enforced even if the chart does not fit with it applied
                    @version 1.13.0 - if `autoZoomExtent` minimum is `null` and the actual auto zoom level is less than this minimum, the auto zoom level is used instead.
                    @baseType float */
                    this.zoomExtent = [0.5, 4];
                    /** Zoom value limits for automatic zooming (for example, "Fit to screen"). Contains array of [min, max] values.
            
                    If the minimum (the first value) is specified as `null`, the chart will not enforce it, instead it will be adjusted as needed
                    if the network grows very large. Note that specifying `null` as the minimum also overrides the minimum for the `zoomExtent`
                    value.
            
                    @version 1.12.0 - the min value is no longer ignored when "Fit to screen" is active.
                    @version 1.13.0 - the default of the minimum value is changed to `null`.
                    @baseType float */
                    this.autoZoomExtent = [null, 1];
                    /** Controls the percentage of how much of the chart width/height the nodes can move around without
                    triggering automatic zoom adjustment. A value of 0.9 means that the target is to leave 10% padding
                    on all sides of the chart. However once the target  is reached, if the nodes move within these 10%
                    on either side, the zoom adjustment is not performed.
                    @version 1.12.0 - default changed from 0.98 to 0.9.
                    @type float */
                    this.autoZoomSize = 0.9;
                    /** The acceleration of scene movement, when trying to contain all nodes within the view,
                    when autozoom is enabled. Increasing the value decreases latency, and makes the animation
                    more responsive. Decreasing the value makes the animation more fluid
                    @type float */
                    this.autoZoomPositionEllasticity = 2.5e-7;
                }
                return SettingsInteractionZooming;
            }(Internal.ItemsChart.SettingsInteractionZooming));
            NetChart.SettingsInteractionZooming = SettingsInteractionZooming;
            /** Settings for NetChart navigation (expanding/collapsing/focusing/unfocusing/showing/hiding). The main setting is `mode` which determines the overall
                algorithm for navigation. Other parameters can tweak this algorithm, but not all parameters apply to all algorithms. */
            var SettingsNavigation = (function () {
                function SettingsNavigation() {
                    /* tslint:disable:max-line-length */
                    /** Navigation mode - the algorithm that determines the expanding/collapsing logic.
                    @type enum
                    @value manual - Fully manual mode. At the start, only the nodes mentioned in `initialNodes` will be shown. Other nodes can be shown by expanding the initial nodes. Collapsing hides the collapsed node and all surrounding nodes, except for the very last visible node. Focusing/unfocusing nodes changes the node status, but does not do anything else. Node [relevance](full-reference/ItemsChartNode.html#doc_relevance) is not used.
                    @value showall - The same as manual, but automatically shows ALL nodes at the start. **CAUTION - if the network is large this will bring down the chart!** If `initialNodes` contains any nodes, then additional nodes will be requested recursively starting from these. If `initialNodes` is null or empty, all nodes will be requested at the start.
                    @value focusnodes - Algorithm for exploring the graph by "walking" through it. Focusing a node expands surrounding nodes and unfocusing a node collapses them. Only nodes that are connected to a focused node are shown. Collapsing a node only hides nodes which are further away from a focus node. Node [relevances](full-reference/ItemsChartNode.html#doc_relevance) are calculated. */
                    this.mode = "showall";
                    /* tslint:enable:max-line-length */
                    /** Initially visible/focused nodes. Array of node identifiers. The precise effect depends on the navigation mode.
                      * * For `manual` this specifies the initially visible nodes and must contain at least 1 node.
                      * * For `showall` this specifies which nodes to show first, and other nodes are then requested recursively from these until all nodes are visible.
                      * * If this setting is left empty or `null`, the chart will directly request ALL nodes (this is more efficient if your data source supports it).
                      * * For `focusnodes` this specifies the initially focused nodes. The count of node IDs in this array must be between `minNumberOfFocusNodes` and
                      *    `numberOfFocusNodes`
                      *
                      * _Used by modes: all modes_*/
                    this.initialNodes = null;
                    /** Number of "levels" to automatically expand around the most recently focused node. If set to 1, all nodes directly linked to the focused node will be shown.
                        If set to 2, all nodes directly connected to these nodes will be shown as well. Etc. Also used for calculating
                        [node relevance](full-reference/ItemsChartNode.html#doc_relevance). _Used by modes: `focusnodes`_
                        @see Documentation: [ItemsChartNode.relevance](full-reference/ItemsChartNode.html#doc_relevance)
                        @units expanding levels */
                    this.focusNodeExpansionRadius = 2;
                    /** Similar to `focusNodeExpansionRadius`, but for the least recently focused node. This allows to create an effect, where the most recently focused node has
                        many expanded nodes around it, while the least recently node has only a few (or vice versa). Intermediate focused nodes will have their expansion radius
                        linearly interpolated between `focusNodeExpansionRadius` and `focusNodeTailExpansionRadius`. Also used to calculate
                        [node relevance](full-reference/ItemsChartNode.html#doc_relevance). _Used by modes: `focusnodes`_
                        @see Documentation: [ItemsChartNode.relevance](full-reference/ItemsChartNode.html#doc_relevance)
                        @units expanding levels
                        @version 1.10.0 - the default value changed from `0.3` to `2`
                        @version 1.11.4 - the default value changed from `2` to `null` which means "the same as `focusNodeExpansionRadius`.
                    */
                    this.focusNodeTailExpansionRadius = null;
                    /** If set to true, nodes and links with [relevance](full-reference/ItemsChartNode.html#doc_relevance) < 1 will be drawn with a smaller radius and a faded out
                        color (both multiplied by [relevance](full-reference/ItemsChartNode.html#doc_relevance)). _Used by modes: `focusnodes`_
                        @see Documentation: [ItemsChartNode.relevance](full-reference/ItemsChartNode.html#doc_relevance)
                    @version 1.10.0
                    */
                    this.focusAutoFadeout = false;
                    /** Maximum number of focused nodes. The `autoUnfocus` setting determines what happens when more nodes are focused.  _Used by modes: all modes_
                    @type integer */
                    this.numberOfFocusNodes = 3;
                    /** Minimum number of focused nodes. Prevents user from unfocusing nodes if there are `minNumberOfFocusNodes` or less nodes focused.
                        If the `focusnodes` navigation is used, this setting has a minimum value of 1. _Used by modes: all modes_
                    @type integer */
                    this.minNumberOfFocusNodes = 1;
                    /** If focusing a node would display several levels of nodes (due to `focusNodeExpansionRadius` or `focusNodeTailExpansionRadius`), each level is shown after
                        the specified delay (milliseconds). Set to 0 to disable. _Used by modes: `focusnodes`_
                    @type integer
                    @units milliseconds */
                    this.expandDelay = 0;
                    /** Whether to expand node on click. _Used by modes: all modes_*/
                    this.expandOnClick = true;
                    /** Whether to auto-zoom to a node when it is focused. _Used by modes: all modes_*/
                    this.autoZoomOnFocus = false;
                    /** Determines what happens if the user has reached maximum number of focus nodes (`numberOfFocusNodes`) and focuses another node.
                        If this setting is `true`, then the least recently focused node will be unfocused. If this setting is `false`, then the user
                        will not be able to focus the node. _Used by modes: all modes_
                    @version 1.10.0 */
                    this.autoUnfocus = true;
                }
                return SettingsNavigation;
            }());
            NetChart.SettingsNavigation = SettingsNavigation;
            var SettingsLayout = (function () {
                function SettingsLayout() {
                    /** Layout mode.
                    @type enum
                    @value dynamic - incrementally update whole network when user moves nodes
                    @value radial - Position graph nodes in concentric rings, starting form initial node.
                    @value hierarchy - Position graph nodes top-down, starting from initial node
                    @value static - other nodes stay fixed while user moves nodes. */
                    this.mode = "dynamic";
                    /** The layout mode currently being used by the chart. */
                    this._currentMode = "dynamic";
                    /** Desired distance between nodes.
                    @type integer
                    @units pixels */
                    this.nodeSpacing = 16;
                    /** Desired vertical distance between node rows in the hierarchy layout.
                    @type integer
                    @units pixels */
                    this.rowSpacing = null;
                    /** Maximum time to wait for incremental layout to be completed. Note that bigger value will get nicer placement on network updates at the cost of longer delay.
                    @type integer
                    @units milliseconds */
                    this.incrementalLayoutMaxTime = 300;
                    /** Maximum time to wait for initial layout to be completed. Note that bigger value will get nicer placement of big networks at the cost of long initial delay.
                    @type integer
                    @units milliseconds */
                    this.initialLayoutMaxTime = 2000;
                    /** Dynamic layout is stopped after user is inactive for this time.
                    @type integer
                    @units milliseconds */
                    this.layoutFreezeTimeout = 10000;
                    /** Dynamic layout can be stopped faster if no more movement is detected.
                    @type integer
                    @units milliseconds */
                    this.layoutFreezeMinTimeout = 1500;
                    /** Whether to fit network in aspect ratio of chart viewport. Useful for small networks that always fit in chart and are not intended to be zoomed in / out. */
                    this.aspectRatio = false;
                    /** Whether to perform global layout on network changes. Use it for better node placement at the cost of chart slowdown on network changes. */
                    this.globalLayoutOnChanges = true;
                    /** Advanced chart settings. Be advised that they are subject to change, backwards compatibility is not guaranteed. */
                    this.advanced = {
                        adaptiveFreezeTreshold: 1.2
                    };
                    /** For radial layout, whether to lay out the first level in two rings, if necessary */
                    this.twoRingRadialLayout = false;
                    /** For hierarhy layout, clockwise rotation of the tree(s), measured in degrees.
                        0 = top-down tree; 90 = right-left tree; 180 = bottom-up tree, etc. Also affects placement of multiple trees the same way.
                        @version 1.14.0
                    */
                    this.rotation = 0;
                }
                return SettingsLayout;
            }());
            NetChart.SettingsLayout = SettingsLayout;
            var SettingsStyle = (function (_super) {
                __extends(SettingsStyle, _super);
                function SettingsStyle() {
                    _super.apply(this, arguments);
                    this.dragSelection = {
                        fillColor: "rgba(30,160,220,0.15)",
                        lineColor: "#000000",
                        lineWidth: 1,
                        lineDash: [1, 2]
                    };
                }
                return SettingsStyle;
            }(Internal.ItemsChart.SettingsNodesLayerStyle));
            NetChart.SettingsStyle = SettingsStyle;
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../itemschart/Scene.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var Scene = (function (_super) {
                __extends(Scene, _super);
                function Scene() {
                    _super.apply(this, arguments);
                }
                return Scene;
            }(Internal.ItemsChart.Scene));
            NetChart.Scene = Scene;
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/core/ChartEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var Renderer = (function (_super) {
                __extends(Renderer, _super);
                function Renderer(chart) {
                    _super.call(this);
                    this.animationOrder = 500;
                    this.paintOrder = 35;
                    /** after layout */
                    this.updateOrder = 1800;
                    this.chart = chart;
                    this.scene = chart.scene;
                    this.events = chart.events;
                }
                Renderer.prototype.doAnimations = function (event) {
                    var layer = this.chart.layer;
                    layer.updateStyle(event);
                    layer.postprocessStyle(event);
                };
                Renderer.prototype.paintScene = function (event) {
                    Internal.Base.Graphics.pushClip(event, this.scene.x0, this.scene.y0, this.scene.width, this.scene.height);
                    var layer = this.chart.layer;
                    layer.setBounds(this.scene.x0, this.scene.y0, this.scene.x0 + this.scene.width, this.scene.y0 + this.scene.height);
                    layer.paint(event);
                    Internal.Base.Graphics.popClip(event);
                };
                /** TODO: migrate to layer.getLegendItems... */
                Renderer.prototype.paintLinks = function (event, links, multiLinks, setup) {
                    this.chart.layer.paintLinksImpl(event, links, multiLinks, setup);
                };
                Renderer.prototype.paintNodes = function (event, nodes, setup, time) {
                    this.chart.layer.paintNodesImpl(event, nodes, setup, time);
                };
                Renderer.prototype.findObjectAt = function (displayX, displayY, tolerance) {
                    return this.chart.layer.findObjectAt(displayX, displayY, tolerance);
                };
                return Renderer;
            }(Internal.Base.ChartElement));
            NetChart.Renderer = Renderer;
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var Graph = (function () {
                function Graph(chart) {
                    /** Data for nodes that aren't visible (this data is loaded from save/restore) */
                    this.restoredState = {};
                    this.chart = chart;
                }
                /** Add current (x;y) coordinates to the nodes in the supplied list. */
                Graph.prototype.exportCoordinates = function (nodesDataList) {
                    var layerNodes = this.chart.layer.idToNode;
                    for (var nodeIndex = 0; nodeIndex < nodesDataList.length; nodeIndex++) {
                        var node = nodesDataList[nodeIndex];
                        var id = node.id;
                        if (!Internal.Base.Helpers.hasProperty(layerNodes, id))
                            continue;
                        var layerNode = layerNodes[id];
                        if (layerNode.removed)
                            continue;
                        node.x = layerNode.x;
                        node.y = layerNode.y;
                    }
                };
                /** Export current size & coordinates of all visible nodes. */
                Graph.prototype.save = function () {
                    var state = {};
                    var nodes = this.chart.layer.idToNode;
                    var keys = Object.keys(nodes);
                    for (var i = 0; i < keys.length; i++) {
                        var node = nodes[keys[i]];
                        if (node.removed)
                            continue;
                        state[node.id] = {
                            x: node.x,
                            y: node.y,
                            r: node.hHeight,
                            w: node.hWidth
                        };
                    }
                    return state;
                };
                /** Restore current size & coordinates of all nodes previously exported by save(). If a node is not present, remember the data for later. */
                Graph.prototype.restore = function (state) {
                    this.restoredState = {};
                    var nodes = this.chart.layer.idToNode;
                    var keys = Object.keys(state);
                    for (var i = 0; i < keys.length; i++) {
                        var id = keys[i];
                        var s = state[id];
                        if (Internal.Base.Helpers.hasProperty(nodes, id)) {
                            var n = nodes[id];
                            n.x = s.x;
                            n.y = s.y;
                            n.hHeight = s.r;
                            n.hWidth = s.w ? s.w : s.r;
                        }
                        else {
                            this.restoredState[id] = s;
                        }
                    }
                };
                Graph.prototype.applyRestoredCoordinates = function (node) {
                    if (!Internal.Base.Helpers.hasProperty(this.restoredState, node.id))
                        return;
                    var state = this.restoredState[node.id];
                    delete this.restoredState[node.id];
                    node.x = state.x;
                    node.y = state.y;
                    node.hHeight = state.r;
                    node.hWidth = state.w ? state.w : state.r;
                };
                /** Locks a node in its place, optionally with supplied coordinates. */
                Graph.prototype.lockNode = function (nodeId, x, y) {
                    if (x === void 0) { x = null; }
                    if (y === void 0) { y = null; }
                    var nodes = this.chart.layer.idToNode;
                    if (!Internal.Base.Helpers.hasProperty(nodes, nodeId)) {
                        this.chart.error("Locking nonexistant node: " + nodeId);
                    }
                    else {
                        var n = nodes[nodeId];
                        n.userLock = true;
                        if (x !== null && y !== null) {
                            n.x = x;
                            n.y = y;
                        }
                        this.chart.layer.touchNode(n);
                    }
                };
                /** Unlock a previously locked node. */
                Graph.prototype.unlockNode = function (nodeId) {
                    var nodes = this.chart.layer.idToNode;
                    if (!Internal.Base.Helpers.hasProperty(nodes, nodeId)) {
                        this.chart.error("Unlocking nonexistant node: " + nodeId);
                    }
                    else {
                        var n = nodes[nodeId];
                        if (n.userLock) {
                            n.userLock = false;
                            this.chart.layer.touchNode(n);
                            this.chart.events.notifySceneChanges({ dynamicLayout: true });
                        }
                    }
                };
                /** Gets a data object for all currently visible nodes and links. */
                Graph.prototype.exportData = function () {
                    var layerNodes = this.chart.layer.idToNode;
                    var keys = Object.keys(layerNodes);
                    var nodes = new Array(keys.length);
                    var p = 0;
                    for (var i = 0; i < keys.length; i++) {
                        var node = layerNodes[keys[i]];
                        if (!node.removed)
                            nodes[p++] = node.data;
                    }
                    nodes.length = p;
                    var layerLinks = this.chart.layer.idToLink;
                    keys = Object.keys(layerLinks);
                    var links = new Array(keys.length);
                    p = 0;
                    for (var i = 0; i < keys.length; i++) {
                        var link = layerLinks[keys[i]];
                        if (!link.removed)
                            links[p++] = link.data;
                    }
                    links.length = p;
                    return {
                        nodes: nodes,
                        links: links
                    };
                };
                return Graph;
            }());
            NetChart.Graph = Graph;
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Base;
        (function (Base) {
            var Inertia = (function () {
                /**
                 * Inertia constructor
                 * @param acceleration
                 * @param initialValue
                 * @param {boolean} [preventOvershoot=false] - Allows creation of an inertia instance that will not slide over the target
                 */
                function Inertia(acceleration, initialValue, preventOvershoot) {
                    if (preventOvershoot === void 0) { preventOvershoot = false; }
                    this._direction = 1;
                    this._endTime = 0; // The point in time, where the target has been reached
                    this._midTime = 0; // The point in time, where speed would switch from acceleration to deceleration
                    this._startTime = 0; // The point where acceleration would start, assuming velocity 0
                    this._preventOvershoot = false; // If set to true, the inertia will adjust the friction within retarget, so that the target can always be reached
                    // Values when the setTarget call gets deferred
                    this._setTargetPending = false;
                    this._settableTargetValue = 0;
                    this._settableAcceleration = 0;
                    this._acceleration = acceleration;
                    this._initialValue = this._targetValue = initialValue;
                    this._preventOvershoot = preventOvershoot;
                }
                /**
                 * The target value set by this method will be reached,
                 * using a constant acceleration and an equal deceleration
                 * @param targetValue
                 * @param [time] - If the time value isn't passed, the execution of setTarget will be deferred to the next getValue() call
                 * @param [newAcceleration] - The acceleration may also be updated during a retarget
                 */
                Inertia.prototype.setTarget = function (targetValue, time, newAcceleration, maxLength) {
                    if (time == null) {
                        this._settableTargetValue = targetValue;
                        this._settableAcceleration = newAcceleration;
                        this._setTargetPending = true;
                        return;
                    }
                    else {
                        this._settableAcceleration = null;
                        this._setTargetPending = false;
                    }
                    if (newAcceleration != null) {
                        this.setAcceleration(newAcceleration, time);
                    }
                    var deltaT = this._getDeltaT(time);
                    var distanceToV0 = this._getDistanceToV0(deltaT);
                    var currentValue = this._composeValue(time, distanceToV0);
                    var distanceToTarget = Math.abs(targetValue - currentValue);
                    var targetDirection = targetValue > currentValue ? 1 : -1;
                    if (time < this._startTime) {
                        // In the phase before starttime the direction is opposite to the intended direction. Let's keep that in mind:
                        this._direction *= -1;
                    }
                    this._targetValue = targetValue;
                    if (time < this._endTime) {
                        // The element is being retargeted and already has a velocity
                        // Check, if the desired target can be reached without overshooting (due to current velocity)
                        if (distanceToV0 > distanceToTarget || this._direction !== targetDirection) {
                            // with the current deceleration it would not be possible to stop until the desired target
                            if (this._preventOvershoot) {
                                if (this._direction === targetDirection) {
                                    // The instance is moving in the same direction as it should but with current deceleration it's not possible to stop in time
                                    // deceleration needs to be increased
                                    var v = this._getCurrentVelocity(deltaT);
                                    this._acceleration = (v * v) / (distanceToTarget * 2);
                                    this._startTime = time - v / this._acceleration;
                                    this._initialValue = currentValue - distanceToTarget * this._direction;
                                }
                                else {
                                    // Overshoot is not permitted, however the requested target is in the opposite direction of current velocity
                                    this._startTime = time;
                                    this._initialValue = currentValue;
                                }
                            }
                            else {
                                // In case of a permitted overshoot the startTime is when deceleration finishes, and new acceleration starts
                                this._startTime = time + deltaT;
                                this._initialValue = currentValue + distanceToV0 * this._direction;
                            }
                        }
                        else if (time >= this._midTime || time <= this._startTime) {
                            // The stop can be reached.
                            // The element is already in the deceleration stage,
                            // so a new imaginary starting point will be assigned
                            this._startTime = time - deltaT;
                            this._initialValue = currentValue - distanceToV0 * this._direction;
                        }
                    }
                    else {
                        // A new inertia animation starts at this point
                        this._startTime = time;
                        this._initialValue = currentValue;
                    }
                    this._direction = this._targetValue > this._initialValue ? 1 : -1;
                    var distance = Math.abs(this._targetValue - this._initialValue);
                    var phaseDuration = Math.sqrt(distance / this._acceleration);
                    this._midTime = this._startTime + phaseDuration;
                    this._endTime = this._startTime + phaseDuration * 2;
                    // Override acceleration if the animation would take too long
                    if (maxLength != null && this._endTime - this._startTime > maxLength) {
                        this._endTime = this._startTime + maxLength;
                        this._midTime = (this._startTime + this._endTime) / 2;
                        phaseDuration = this._endTime - this._midTime;
                        this._acceleration = distance / (phaseDuration * phaseDuration);
                    }
                };
                /**
                 * Returns the current value at the given point of time in animation
                 * @param time
                 * @returns {number}
                 */
                Inertia.prototype.getValue = function (time) {
                    if (this._setTargetPending) {
                        this.setTarget(this._settableTargetValue, time, this._settableAcceleration);
                    }
                    if (this.finished(time)) {
                        return this._targetValue;
                    }
                    return this._composeValue(time, this._getDistanceToV0(this._getDeltaT(time)));
                };
                Inertia.prototype.getTargetValue = function () {
                    return this._targetValue;
                };
                Inertia.prototype.finished = function (time) {
                    if (this._setTargetPending)
                        return false;
                    return time >= this._endTime;
                };
                /**
                 * Sets the position without animating and resets animations
                 * @param newValue
                 * @param [velocity] - The current velocity that is to be assigned (units/ms)
                 * @param [time] - If velocity is supplied, current time must be supplied with it, in order to create animations
                 * @returns number - If velocity was supplied, the target position, where momentum will reach 0 is returned
                 */
                Inertia.prototype.jump = function (newValue, velocity, time) {
                    this._initialValue = this._targetValue = newValue;
                    this._startTime = this._midTime = this._endTime = 0;
                    if (velocity != null && time != null && velocity !== 0) {
                        var direction = velocity > 0 ? 1 : -1;
                        var deltaT = Math.abs(velocity / this._acceleration);
                        this._direction = direction;
                        this._midTime = time;
                        this._endTime = time + deltaT;
                        this._targetValue = newValue + (this._getDistanceToV0(deltaT) * direction);
                    }
                    return this._targetValue;
                };
                /**
                 * Updates the acceleration to a new value. If an animation is in progress, updates the state,
                 * to retain the same velocity
                 * The resulting state does not retain the target value
                 * @param newAcceleration
                 * @param time
                 */
                Inertia.prototype.setAcceleration = function (newAcceleration, time) {
                    if (newAcceleration === this._acceleration) {
                        return;
                    }
                    var animationRunning = time < this._endTime;
                    if (animationRunning) {
                        var deltaT = this._getDeltaT(time);
                        var v = this._getCurrentVelocity(deltaT);
                        var s = this._composeValue(time, this._getDistanceToV0(deltaT));
                        if (time < this._startTime) {
                            v = -v;
                        }
                        this._acceleration = newAcceleration;
                        this.jump(s, v * this._direction, time);
                    }
                    else {
                        this._acceleration = newAcceleration;
                    }
                };
                /**
                 * If the distance to V0 is already known, it can be used to get currentValue
                 * @param time
                 * @param distanceToV0
                 * @returns {number}
                 */
                Inertia.prototype._composeValue = function (time, distanceToV0) {
                    if (time < this._startTime) {
                        // This is the case of overshoot
                        return this._initialValue + distanceToV0 * this._direction;
                    }
                    else if (time < this._midTime) {
                        // value during acceleration
                        return this._initialValue + distanceToV0 * this._direction;
                    }
                    else if (time < this._endTime) {
                        return this._targetValue - distanceToV0 * this._direction;
                    }
                    // When the animation has ended, return the target position
                    return this._targetValue;
                };
                /**
                 * Returns the distance required to decelerate to V0, having the current acceleration
                 * s = (1/2) * a * t^2
                 * @param deltaT
                 * @returns {number}
                 */
                Inertia.prototype._getDistanceToV0 = function (deltaT) {
                    return this._acceleration * deltaT * deltaT / 2;
                };
                /**
                 * Returns the duration from the given time, to time, where velocity is 0
                 * @param time
                 * @returns {number} - The duration (always positive)
                 */
                Inertia.prototype._getDeltaT = function (time) {
                    if (time < this._startTime) {
                        // In case of an overshoot the element needs to decelerate before
                        // starting to accelerate again
                        return this._startTime - time;
                    }
                    else if (time < this._midTime) {
                        // time since acceleration has started
                        return time - this._startTime;
                    }
                    else if (time < this._endTime) {
                        // time until deceleration would stop
                        return this._endTime - time;
                    }
                    // The animation has ended
                    return 0;
                };
                /**
                 * As the acceleration is constant, the velocity can be calculated given the duration until v = 0
                 * The velocity returned should always be positive, since it doesn't include direction
                 * @param deltaT
                 * @returns {number}
                 */
                Inertia.prototype._getCurrentVelocity = function (deltaT) {
                    return deltaT * this._acceleration;
                };
                return Inertia;
            }());
            Base.Inertia = Inertia;
        })(Base = Internal.Base || (Internal.Base = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Inertia.ts" />
/// <reference path="../base/core/ChartEvents.ts" />
/// <reference path="../base/Helpers.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var AutoZoom = (function (_super) {
                __extends(AutoZoom, _super);
                function AutoZoom(chart) {
                    _super.call(this);
                    this.numPointers = 0;
                    /**if true, reset zoom on next update*/
                    this.resetZoom = false;
                    /** The minimum zoom value the auto zoom has set so far. */
                    this.minimumAutoZoom = Infinity;
                    /** after layout */
                    this.animationOrder = 700;
                    this.paintOrder = 20;
                    this.updateOrder = 2000;
                    this.chart = chart;
                    this.scene = chart.scene;
                    this.layer = chart.layer;
                    this.events = chart.events;
                    this.settings = this.scene.settings;
                    var ia = this._getInertiaAccelerations();
                    this.inertiaX = new Internal.Base.Inertia(ia.x, 0);
                    this.inertiaY = new Internal.Base.Inertia(ia.y, 0);
                    // inertiaZ doesn't animate the zoom value directly, but the visible radius of the viewport so the animated value is inverted
                    this.inertiaZ = new Internal.Base.Inertia(ia.z, 1);
                }
                AutoZoom.prototype.setZoom = function (zoom, animate) {
                    if (animate === void 0) { animate = true; }
                    var zoomFactor = 1 + this.scene.settings.interaction.zooming.sensitivity;
                    if (zoom === "auto") {
                        this.scene.autoZoomMode = true;
                        this.autoZoom(animate);
                    }
                    else if (zoom === "overview") {
                        this.scene.autoZoomMode = "overview";
                        this.autoZoom(animate);
                    }
                    else {
                        var newZoom = void 0;
                        if (zoom === "in") {
                            newZoom = (1 / this.inertiaZ.getTargetValue()) * zoomFactor;
                        }
                        else if (zoom === "out") {
                            newZoom = (1 / this.inertiaZ.getTargetValue()) / zoomFactor;
                        }
                        else if (null === (newZoom = Internal.Base.Helpers.tryParseFloat(zoom, null))) {
                            this.chart.error("Invalid zoom value: " + zoom);
                            newZoom = 1 / this.inertiaZ.getTargetValue();
                        }
                        this.manualZoom(newZoom / this.scene.zoom, void 0, void 0, animate);
                    }
                    this.chart.events.notifySceneChanges({ position: true });
                };
                AutoZoom.prototype.previewPointerDown = function () {
                    this.numPointers += 1;
                };
                AutoZoom.prototype.previewPointerUp = function () {
                    this.numPointers -= 1;
                };
                AutoZoom.prototype.previewPointerCancel = function () {
                    this.numPointers -= 1;
                };
                AutoZoom.prototype.doAnimations = function (event) {
                    var sc = event.changes.settingsChanges;
                    if (sc && sc.interaction && sc.interaction.zooming) {
                        this.minimumAutoZoom = Infinity;
                        var x = sc.interaction.zooming.initialAutoZoom;
                        if (x) {
                            if (x === "true") {
                                x = true;
                            }
                            else if (x === "false") {
                                x = false;
                            }
                            this.scene.autoZoomMode = x;
                        }
                    }
                    if (this.resetZoom || event.changes.newGraph) {
                        this.resetZoom = false;
                        this.setZoom("overview", false);
                    }
                    else if (this.numPointers === 0 && this.layer.nodes().length > 0) {
                        if (this.scene.autoZoomMode && this.autoZoom(true)) {
                            event.changes.position = true;
                        }
                        // do animations
                        var time = event.timeStamp;
                        var cx = this.inertiaX.getValue(time);
                        var cy = this.inertiaY.getValue(time);
                        var zz = 1 / this.inertiaZ.getValue(time);
                        if (cx !== this.scene.centerX || cy !== this.scene.centerY || zz !== this.scene.zoom) {
                            this.scene.centerX = cx;
                            this.scene.centerY = cy;
                            this.scene.zoom = zz;
                            event.changes.position = true;
                        }
                        if (!(this.inertiaX.finished(time)) || !(this.inertiaY.finished(time)) || !(this.inertiaZ.finished(time))) {
                            event.animating = true;
                        }
                    }
                    else {
                        // manual mode
                        this.inertiaX.jump(this.scene.centerX);
                        this.inertiaY.jump(this.scene.centerY);
                        this.inertiaZ.jump(1 / this.scene.zoom);
                    }
                };
                AutoZoom.prototype._getInertiaAccelerations = function () {
                    var e = this.scene.settings.interaction.zooming.autoZoomPositionEllasticity;
                    var x = (this.scene.width + this.scene.height) * 0.5 * e; // X & Y axis movements should both have the same acceleration
                    return {
                        x: x,
                        y: x,
                        z: e * 2
                    };
                };
                AutoZoom.prototype.autoZoom = function (animate, time) {
                    var changes = false;
                    var computeAutoZoomResult = this.computeAutoZoom(this.scene.autoZoomMode === "overview");
                    if (computeAutoZoomResult == null)
                        return false;
                    var cx = computeAutoZoomResult.centerX;
                    var cy = computeAutoZoomResult.centerY;
                    var z = computeAutoZoomResult.zoom;
                    var autoZoomTreshold = 0.01;
                    var autoZoomUpperTreshold = 1 + autoZoomTreshold;
                    var autoZoomLowerTreshold = 1 - autoZoomTreshold;
                    var zoomDiff = (1 / this.inertiaZ.getTargetValue()) / z;
                    var zoomAccelerations = this._getInertiaAccelerations();
                    if (zoomDiff > autoZoomUpperTreshold || zoomDiff < autoZoomLowerTreshold) {
                        if (animate) {
                            this.inertiaZ.setTarget(1 / z, time, zoomAccelerations.z);
                        }
                        else {
                            this.inertiaZ.jump(1 / z);
                            this.scene.zoom = z;
                        }
                        changes = true;
                    }
                    var width = this.scene.width;
                    var xDiff = (this.inertiaX.getTargetValue() - cx) * z / width;
                    if (xDiff > autoZoomTreshold || xDiff < -autoZoomTreshold) {
                        if (animate) {
                            this.inertiaX.setTarget(cx, time, zoomAccelerations.x);
                        }
                        else {
                            this.inertiaX.jump(cx);
                            this.scene.centerX = cx;
                        }
                        changes = true;
                    }
                    var height = this.scene.height;
                    var yDiff = (this.inertiaY.getTargetValue() - cy) * z / height;
                    if (yDiff > autoZoomTreshold || yDiff < -autoZoomTreshold) {
                        if (animate) {
                            this.inertiaY.setTarget(cy, time, zoomAccelerations.y);
                        }
                        else {
                            this.inertiaY.jump(cy);
                            this.scene.centerY = cy;
                        }
                        changes = true;
                    }
                    return changes;
                };
                /**
                 * Computes the target position of the scene, to contain all the bounds
                 * @param showAll - A parameter that sets whether autozoom should zoom in,
                 *  so that the whole viewport is filled. If set to false, the chart will only
                 *  pan around so that to nodes wouldn't exit the viewport.
                 * @param nodeList - An optional array of nodes that should be included in the viewport.
                 *  If omitted, all visible nodes will be used.
                 * @returns {{centerX: number, centerY: number, zoom: number}}
                 */
                AutoZoom.prototype.computeAutoZoom = function (showAll, nodeList, margins) {
                    var scene = this.scene;
                    var nodeBounds;
                    if (showAll) {
                        nodeBounds = this.layer.getGraphBounds(nodeList);
                    }
                    else {
                        nodeBounds = this.layer.getNodeNeighborsBounds(scene.lastClickedNode);
                    }
                    var x0 = nodeBounds.x0;
                    var y0 = nodeBounds.y0;
                    var x1 = nodeBounds.x1;
                    var y1 = nodeBounds.y1;
                    if (x0 === 0 && x1 === 0 && y0 === 0 && y1 === 0) {
                        // this is basically the case where no nodes exist - leave the zoom as is.
                        return null;
                    }
                    if (margins) {
                        nodeBounds.y0 -= margins[0];
                        nodeBounds.x1 += margins[1];
                        nodeBounds.y1 += margins[2];
                        nodeBounds.x0 -= margins[3];
                    }
                    var currentBounds = scene.getVisibleBounds();
                    // the main idea is that paddings are used to reduce the trembling of the chart when the nodes
                    // are moving in an arc close to the edge. When the zoom-in is performed, it always leaves
                    // the padding area empty but when the zoom-out is required, the chart first verifies if it 
                    // fits within the visible area, excluding paddings. If it does, the zoom is not changed.
                    var config = scene.settings.interaction.zooming;
                    var sensitivity = (1 - config.autoZoomSize) / 2;
                    var maxDeltaX = sensitivity * nodeBounds.w();
                    var maxDeltaY = sensitivity * nodeBounds.h();
                    // calculate how much the current bounds have to be moved to accomodate the target nodes
                    var dx0 = Math.abs(currentBounds.x0 - nodeBounds.x0 + maxDeltaX);
                    var dx1 = Math.abs(currentBounds.x1 - nodeBounds.x1 - maxDeltaX);
                    var dy0 = Math.abs(currentBounds.y0 - nodeBounds.y0 + maxDeltaY);
                    var dy1 = Math.abs(currentBounds.y1 - nodeBounds.y1 - maxDeltaY);
                    if (dx0 < maxDeltaX && dx1 < maxDeltaX && dy0 < maxDeltaY && dy1 < maxDeltaY) {
                        // the adjustment would be within the specified padding - as such do not perform it
                        // to avoid unneeded trembling of the chart.
                        // console.log("autoZoom within paddings", dx0, dx1, dy0, dy1, maxDeltaX, maxDeltaY);
                        return null;
                    }
                    var targetZoom = Math.min((scene.width / (nodeBounds.w() + maxDeltaX * 2)), (scene.height / (nodeBounds.h() + maxDeltaY * 2)));
                    var extents = config.autoZoomExtent;
                    if (extents) {
                        targetZoom = Math.min(extents[1], targetZoom);
                        if (extents[0] === null) {
                            this.minimumAutoZoom = Math.min(targetZoom, this.minimumAutoZoom);
                        }
                        else {
                            targetZoom = Math.max(extents[0], targetZoom);
                        }
                    }
                    return {
                        centerX: (nodeBounds.x0 + nodeBounds.x1) / 2,
                        centerY: (nodeBounds.y0 + nodeBounds.y1) / 2,
                        zoom: targetZoom
                    };
                };
                AutoZoom.prototype.manualZoom = function (zoomChange, displayX, displayY, animate) {
                    if (displayX === void 0) { displayX = null; }
                    if (displayY === void 0) { displayY = null; }
                    if (animate === void 0) { animate = false; }
                    var scene = this.scene;
                    var extents = this.settings.interaction.zooming.zoomExtent;
                    var getGraphBoundsResult = this.layer.getGraphBounds();
                    var x0 = getGraphBoundsResult.x0;
                    var y0 = getGraphBoundsResult.y0;
                    var x1 = getGraphBoundsResult.x1;
                    var y1 = getGraphBoundsResult.y1;
                    // apply the zoom extents
                    var newZoom = scene.zoom * zoomChange;
                    newZoom = Math.min(newZoom, Math.max(scene.zoom, extents[1]));
                    newZoom = Math.max(newZoom, Math.min(scene.zoom, Math.min(this.minimumAutoZoom, extents[0])));
                    zoomChange = newZoom / scene.zoom;
                    var scx;
                    var scy;
                    if (displayX !== null && displayY !== null) {
                        var fromDisplayResult = scene.fromDisplay(displayX, displayY);
                        scx = fromDisplayResult.x;
                        scy = fromDisplayResult.y;
                    }
                    else if (scene.selection.length > 0) {
                        var xx = 0;
                        var yy = 0;
                        var n = 0;
                        for (var oIndex = 0; oIndex < scene.selection.length; oIndex++) {
                            var o = scene.selection[oIndex];
                            if (o instanceof Internal.ItemsChart.Node) {
                                xx += o.x;
                                yy += o.y;
                                n += 1;
                            }
                        }
                        if (n > 0) {
                            scx = xx / n;
                            scy = yy / n;
                        }
                    }
                    var centerX;
                    var centerY;
                    if (scx && scy) {
                        centerX = (scene.centerX - scx) / zoomChange + scx;
                        centerY = (scene.centerY - scy) / zoomChange + scy;
                    }
                    else {
                        centerX = scx = scene.centerX;
                        centerY = scy = scene.centerY;
                    }
                    var zoom = scene.zoom * zoomChange;
                    // prevent moving graph off-screen
                    var bounds = scene.getVisibleBounds();
                    if (scx < x0 || scx > x1) {
                        var dx = void 0;
                        if (bounds.x0 > x0 && bounds.x1 > x1) {
                            dx = Math.max(x1 - bounds.x1, x0 - bounds.x0);
                        }
                        else if (bounds.x1 < x1 && bounds.x0 < x0) {
                            dx = Math.min(x1 - bounds.x1, x0 - bounds.x0);
                        }
                        else {
                            dx = 0;
                        }
                        centerX += dx;
                    }
                    if (scy < y0 || scy > y1) {
                        var dy = void 0;
                        if (bounds.y0 > y0 && bounds.y1 > y1) {
                            dy = Math.max(y1 - bounds.y1, y0 - bounds.y0);
                        }
                        else if (bounds.y1 < y1 && bounds.y0 < x0) {
                            dy = Math.min(y1 - bounds.y1, y0 - bounds.y0);
                        }
                        else {
                            dy = 0;
                        }
                        centerY += dy;
                    }
                    if (animate && zoom !== scene.zoom) {
                        this.inertiaZ.setTarget(1 / zoom);
                    }
                    else {
                        this.inertiaZ.jump(1 / zoom);
                        scene.zoom = zoom;
                    }
                    if (animate && (centerX !== scene.centerX || centerY !== scene.centerY)) {
                        var zoomAccelerations = this._getInertiaAccelerations();
                        this.inertiaX.setTarget(centerX, null, zoomAccelerations.x);
                        this.inertiaY.setTarget(centerY, null, zoomAccelerations.y);
                    }
                    else {
                        scene.centerX = centerX;
                        scene.centerY = centerY;
                        this.inertiaX.jump(centerX);
                        this.inertiaY.jump(centerY);
                    }
                    scene.autoZoomMode = false;
                };
                /**
                 * Animates the netchart bounds to a position, so that the given nodes are zoomed in and visible
                 * @param items - An array of nodes that should be included in the viewport
                 */
                AutoZoom.prototype.scrollIntoView = function (items, margins) {
                    var time = Internal.Base.Helpers.performanceNow();
                    this.scene.autoZoomMode = false;
                    var acc = this._getInertiaAccelerations();
                    var zoomResult = this.computeAutoZoom(true, items, margins);
                    this.inertiaX.setTarget(zoomResult.centerX, time, acc.x);
                    this.inertiaY.setTarget(zoomResult.centerY, time, acc.y);
                    this.inertiaZ.setTarget(1 / zoomResult.zoom, time, acc.z);
                    this.chart.events.notifySceneChanges({ position: true });
                };
                return AutoZoom;
            }(Internal.Base.ChartElement));
            NetChart.AutoZoom = AutoZoom;
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../itemschart/Menu.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var Menu = (function (_super) {
                __extends(Menu, _super);
                function Menu() {
                    _super.apply(this, arguments);
                }
                Menu.prototype.buildDefaultButton = function (target, button) {
                    var chart = this.chart;
                    if (target instanceof Internal.ItemsChart.Node) {
                        var localization = this.scene.settings.localization.menu;
                        var showHide_1 = function (e, show) {
                            e.style.display = show ? "" : "none";
                        };
                        if (button === "expand") {
                            this.buildButton(target, "DVSL-NC-button-expand", localization.expand, null, function (t, e) { chart.expandNode(t.id); }, function (t, e) { showHide_1(e, chart.navigator.canExpandNode(t)); });
                            this.buildButton(target, "DVSL-NC-button-collapse", localization.collapse, null, function (t, e) { chart.collapseNode(t.id); }, function (t, e) { showHide_1(e, chart.navigator.canCollapseNode(t)); });
                            this.buildButton(target, "DVSL-NC-button-collapse", localization.close, null, function (t, e) { chart.closeNode(t.id); }, function (t, e) { showHide_1(e, chart.navigator.canCloseNode(t)); });
                        }
                        else if (button === "focus") {
                            this.buildButton(target, "DVSL-NC-button-focus", localization.focus, null, function (t, e) { chart.addFocusNode(t.id, -1); }, function (t, e) { showHide_1(e, chart.navigator.canFocusNode(t)); });
                            this.buildButton(target, "DVSL-NC-button-unfocus", localization.unfocus, null, function (t, e) { chart.removeFocusNode(t.id); }, function (t, e) { showHide_1(e, chart.navigator.canUnfocusNode(t)); });
                        }
                        else if (button === "lock") {
                            this.buildButton(target, "DVSL-NC-button-lock", localization.fixed, null, function (t, e) { chart.unlockNode(t.id); }, function (t, e) { showHide_1(e, t.userLock); });
                            this.buildButton(target, "DVSL-NC-button-unlock", localization.dynamic, null, function (t, e) { chart.lockNode(t.id); }, function (t, e) { showHide_1(e, !t.userLock); });
                        }
                        else if (button === "hide") {
                            this.buildButton(target, "DVSL-NC-button-hide", localization.hide, null, function (t, e) { chart.hideNode(t.id); }, function (t, e) { showHide_1(e, chart.navigator.canHideNode(t)); });
                        }
                        else {
                            chart.error("The node menu button with name `" + button + "` was not recognized. Valid values are: expand, focus, lock, hide.");
                        }
                    }
                    else {
                        chart.error("The link menu does not support any named buttons.");
                    }
                };
                return Menu;
            }(Internal.ItemsChart.Menu));
            NetChart.Menu = Menu;
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Random.ts" />
/// <reference path="../itemschart/Impl.ts" />
/// <reference path="Scene.ts" />
/// <reference path="Layouts/Layout.ts" />
/// <reference path="Renderer.ts" />
/// <reference path="Settings.ts" />
/// <reference path="Data.ts" />
/// <reference path="Graph.ts" />
/// <reference path="AutoZoom.ts" />
/// <reference path="Bar/Toolbar.ts" />
/// <reference path="Navigation/Navigator.ts" />
/// <reference path="Gestures/GestureManager.ts" />
/// <reference path="Menu.ts" />
/// <reference path="Legend.ts" />
/// <reference path="Menu.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var NetChart;
        (function (NetChart) {
            var Impl = (function (_super) {
                __extends(Impl, _super);
                function Impl(settings, api) {
                    _super.call(this, new NetChart.Settings(settings), new NetChart.Scene(), api);
                    this.isLayoutFrozen = false;
                    this.focusNodeStack = [];
                    var useFadeout = this.settings.navigation.mode === "focusnodes" && this.settings.navigation.focusAutoFadeout;
                    this.layer = new Internal.ItemsChart.NodesLayer(this, this.settings, useFadeout);
                    this.graph = new NetChart.Graph(this);
                    this.navigator = this.events.addElement(NetChart.Navigator.CreateNavigator(this));
                    this.gestures = this.events.addElement(new NetChart.Gestures.GestureManager(this));
                    this.layout = this.events.addElement(NetChart.Layouts.LayoutBase.ConstructLayout(this));
                    this.info = this.events.addElement(new Internal.ItemsChart.InfoPopup(this));
                    this.menu = this.events.addElement(new NetChart.Menu(this));
                    this.autoZoom = this.events.addElement(new NetChart.AutoZoom(this));
                    this.renderer = this.events.addElement(new NetChart.Renderer(this));
                    this.legend = this.events.addElement(new NetChart.Legend(this));
                    this.autoZoom.resetZoom = true;
                    this.scene.loading = false;
                    this.navigator.showInitialNodes();
                    this.finalInitialize();
                }
                Impl.prototype.createDataObj = function (settings) {
                    return new NetChart.Data(this, settings);
                };
                Impl.prototype.getData = function (id) {
                    return _super.prototype.getData.call(this, id);
                };
                Impl.prototype.onSettingsChanged = function (changes) {
                    var ch = {};
                    this.layer.onSettingsChanged(changes);
                    if (changes.navigation && changes.navigation.mode) {
                        this.events.removeElement(this.navigator);
                        this.navigator = NetChart.Navigator.CreateNavigator(this);
                        this.events.addElement(this.navigator);
                    }
                    // update data
                    var reinitChart = !!(changes.navigation && (changes.navigation.mode || changes.navigation.initialNodes));
                    if (changes.data && changes.data.length) {
                        var chd = changes.data[0];
                        if (chd.dataFunction || chd.format || chd.preloaded || chd.url || chd.randomNodes) {
                            reinitChart = true;
                        }
                    }
                    if (reinitChart) {
                        this.navigator.showInitialNodes();
                        this.autoZoom.resetZoom = true;
                    }
                    if (changes.filters) {
                        ch.filters = true;
                    }
                    if (changes.style) {
                        ch.style = true;
                    }
                    if (changes.layout && changes.layout.mode) {
                        this.events.removeElement(this.layout);
                        this.layout = NetChart.Layouts.LayoutBase.ConstructLayout(this);
                        this.events.addElement(this.layout);
                        this.isLayoutFrozen = false;
                    }
                    this.events.notifySceneChanges(ch);
                };
                Impl.prototype.save = function () {
                    var xy = this.graph.save();
                    var nav = this.navigator.save();
                    return JSON.stringify({ xy: xy, nav: nav });
                };
                Impl.prototype.restore = function (stateStr, animate) {
                    if (!stateStr) {
                        return;
                    }
                    var state = JSON.parse(stateStr);
                    var xy = state.xy;
                    var nav = state.nav;
                    if (nav) {
                        this.navigator.restore(nav);
                    }
                    if (xy) {
                        this.graph.restore(xy);
                    }
                    this.autoZoom.resetZoom = true;
                };
                Impl.prototype.saveNavigation = function () {
                    var s = JSON.stringify(this.navigator.save());
                    if (s === "{}")
                        return null;
                    return s;
                };
                Impl.prototype.restoreNavigation = function (state) {
                    this.navigator.restore(JSON.parse(state));
                };
                Impl.prototype.getCurrentNodes = function () {
                    /* TODO:
                    @navigator.commitChanges(@events.sceneChanges) */
                    var nodes = [];
                    for (var nIndex = 0, nSource = this.layer.nodes(); nIndex < nSource.length; nIndex++) {
                        var n = nSource[nIndex];
                        if (!n.removed) {
                            nodes.push(n);
                        }
                    }
                    return nodes;
                };
                Impl.prototype.getCurrentLinks = function () {
                    /* TODO:
                    @navigator.commitChanges(@events.sceneChanges) */
                    var links = [];
                    for (var nIndex = 0, nSource = this.layer.links(); nIndex < nSource.length; nIndex++) {
                        var n = nSource[nIndex];
                        if (!n.removed) {
                            links.push(n);
                        }
                    }
                    return links;
                };
                Impl.prototype.getNodeDimensions = function (id) {
                    var node;
                    if (Internal.Base.Helpers.isString(id)) {
                        node = this.getNode(id);
                    }
                    else {
                        node = id;
                    }
                    if (!node) {
                        return null;
                    }
                    var toDisplayResult = this.scene.toDisplay(node.x, node.y);
                    var x = toDisplayResult.x;
                    var y = toDisplayResult.y;
                    var r = node.hHeight * this.scene.zoom;
                    var w = node.hWidth * this.scene.zoom;
                    return {
                        x: x,
                        y: y,
                        radius: r,
                        hwidth: w
                    };
                };
                Impl.prototype.lockNode = function (id, x, y) {
                    if (x === void 0) { x = null; }
                    if (y === void 0) { y = null; }
                    if (Internal.Base.Helpers.isObjectOrArray(id)) {
                        id = id.id;
                    }
                    this.graph.lockNode(id, x, y);
                };
                Impl.prototype.unlockNode = function (id) {
                    if (id.id)
                        id = id.id;
                    this.graph.unlockNode(id);
                };
                Impl.prototype.addFocusNode = function (id, relevance) {
                    if (id.id)
                        id = id.id;
                    if (this.settings.navigation.autoZoomOnFocus) {
                        this.scene.autoZoomMode = true;
                    }
                    this.focusNodeStack.push(id);
                    return this.navigator.focusNode(id, relevance, "api");
                };
                /** Gets the most recently focused node which is still focused. If no such nodes are found, returns the first node, if any are visible at all. */
                Impl.prototype.getLastFocusNode = function () {
                    // Get the most recently focused node
                    while (this.focusNodeStack.length > 0) {
                        var id = this.focusNodeStack[this.focusNodeStack.length - 1];
                        var node = Internal.Base.Helpers.hasProperty(this.layer.idToNode, id) ? this.layer.idToNode[id] : null;
                        if (node && node.focused)
                            return node;
                        this.focusNodeStack.pop();
                    }
                    // No recently focused nodes. Try initialNodes.
                    if (this.settings.navigation.initialNodes)
                        for (var i = 0; i < this.settings.navigation.initialNodes.length; i++) {
                            var id = this.settings.navigation.initialNodes[i];
                            var node = Internal.Base.Helpers.hasProperty(this.layer.idToNode, id) ? this.layer.idToNode[id] : null;
                            if (node)
                                return node;
                        }
                    // Try ANY nodes.
                    var nodes = this.layer.nodes();
                    if (nodes.length > 0)
                        return nodes[0];
                    // FAIL! NOOOO!
                    return null;
                };
                Impl.prototype.clearFocus = function () {
                    this.navigator.clearFocusNodes("api");
                };
                Impl.prototype.removeFocusNode = function (id) {
                    if (id.id)
                        id = id.id;
                    return this.navigator.unfocusNode(id, "api");
                };
                Impl.prototype.expandNode = function (id) {
                    if (id.id)
                        id = id.id;
                    return this.navigator.expandNode(id, "api");
                };
                Impl.prototype.collapseNode = function (id) {
                    if (id.id)
                        id = id.id;
                    return this.navigator.collapseNode(id, "api");
                };
                Impl.prototype.closeNode = function (id) {
                    if (id.id)
                        id = id.id;
                    return this.navigator.closeNode(id, "api");
                };
                Impl.prototype.hideNode = function (id) {
                    if (id.id)
                        id = id.id;
                    return this.navigator.hideNode(id, "api");
                };
                Impl.prototype.showNode = function (id) {
                    return this.navigator.showNode(id, "api");
                };
                Impl.prototype.getNode = function (id) {
                    return this.layer.idToNode[id];
                };
                Impl.prototype.getLink = function (id) {
                    return this.layer.idToLink[id];
                };
                Impl.prototype.touchObjects = function (objects) {
                    for (var i = 0; i < objects.length; i++) {
                        var l = this.layer;
                        var obj = l.findObjectById(objects[i]);
                        if (obj)
                            l.touchNodeOrLink(obj);
                    }
                };
                Impl.prototype.setZoom = function (zoomValue, animate) {
                    this.autoZoom.setZoom(zoomValue, animate);
                };
                Impl.prototype.zoomIn = function (objects, animate) {
                    // TODO: implement
                    throw new Error("Not implemented.");
                };
                Impl.prototype.resetLayout = function () {
                    this.layout.resetLayout();
                    this.autoZoom.setZoom("overview", false);
                    this.events.notifySceneChanges({ layout: true });
                };
                Impl.prototype.removeData = function (data, sourceId) {
                    if (sourceId === void 0) { sourceId = "default"; }
                    if (sourceId == null)
                        sourceId = "default"; // ported from CoffeeScript;
                    if (this.removed) {
                        return;
                    }
                    // remove the data
                    var dataObj = this.getData(sourceId);
                    var sceneChanges = dataObj.removeData(data);
                    sceneChanges.data = {};
                    sceneChanges.data[sourceId] = true;
                    this.events.notifySceneChanges(sceneChanges);
                };
                Impl.prototype.exportData = function (visibleOnly, exportCoords) {
                    var r;
                    if (visibleOnly) {
                        r = this.graph.exportData();
                    }
                    else {
                        r = this.scene.mainData.exportData();
                    }
                    if (exportCoords) {
                        this.graph.exportCoordinates(r.nodes);
                    }
                    return r;
                };
                Impl.prototype.hideMenu = function () {
                    this.menu.hideMenu();
                };
                Impl.prototype.createEventArguments = function (event, origin) {
                    var args = _super.prototype.createEventArguments.call(this, event, origin);
                    var layer = this.layer;
                    if (layer) {
                        args.nodes = layer.nodes();
                        args.links = layer.links();
                    }
                    return args;
                };
                Impl.prototype.defaultClick = function (event, args) {
                    if (event.shiftKey || event.ctrlKey) {
                        return;
                    }
                    var node = args.clickNode;
                    if (node) {
                        if (this.scene.settings.navigation.expandOnClick) {
                            if (!node.expanded) {
                                this.expandNode(node.id);
                                event.preventDefault();
                            }
                        }
                    }
                };
                Impl.prototype.defaultRightClick = function (event, args) {
                    if (args.clickNode) {
                        // toggle loading full data
                        this.scene.mainData.getLinks(args.clickNode.id);
                        this.menu.toggleNodeMenu(args.clickNode);
                        event.preventDefault();
                    }
                    if (args.clickLink) {
                        this.menu.toggleLinkMenu(event.x, event.y, args.clickLink);
                        event.preventDefault();
                    }
                };
                Impl.prototype.defaultDoubleClick = function (event, args) {
                    var node = args.clickNode;
                    if (node) {
                        this.addFocusNode(node.id, -1);
                        event.preventDefault();
                    }
                };
                Impl.prototype.scrollIntoView = function (nodes, margins) {
                    var includedItems = [];
                    var foundNode;
                    for (var i = 0; i < nodes.length; i++) {
                        var n = nodes[i];
                        if (n instanceof Internal.ItemsChart.Node) {
                            includedItems.push(n);
                        }
                        else if (foundNode = this.getNode(n)) {
                            includedItems.push(foundNode);
                        }
                        else {
                            this.error("scrollIntoView: Non chart object has been passed: " + n);
                        }
                    }
                    this.autoZoom.scrollIntoView(includedItems, margins);
                };
                Impl.prototype.freezeLayout = function () {
                    if (!this.isLayoutFrozen) {
                        this.events.removeElement(this.layout);
                        this.isLayoutFrozen = true;
                        this.events.notifySceneChanges({ layout: true });
                    }
                };
                Impl.prototype.unfreezeLayout = function () {
                    if (this.isLayoutFrozen) {
                        this.events.addElement(this.layout);
                        this.isLayoutFrozen = false;
                        this.events.notifySceneChanges({ layout: true });
                    }
                };
                return Impl;
            }(Internal.ItemsChart.Impl));
            NetChart.Impl = Impl;
        })(NetChart = Internal.NetChart || (Internal.NetChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="ZoomCharts.d.ts" />
/// <reference path="netchart/Settings.ts" />
/// <reference path="netchart/Impl.ts" />
/// <reference path="base/Api.ts" />
/// <reference path="itemschart/Impl.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    /** @api-class */
    var NetChart = (function (_super) {
        __extends(NetChart, _super);
        function NetChart(settings) {
            var _this = this;
            _super.call(this);
            this.typeName = "NetChart";
            if (NetChart.chartFactoryMethod) {
                this._impl = NetChart.chartFactoryMethod(function (stngs) { return new ZoomCharts.Internal.NetChart.Impl(stngs, _this); }, settings);
            }
            else {
                this._impl = new ZoomCharts.Internal.NetChart.Impl(settings, this);
            }
        }
        NetChart.prototype.updateSettings = function (changes) {
            _super.prototype.updateSettings.call(this, changes);
            return this;
        };
        NetChart.prototype.replaceSettings = function (changes) {
            _super.prototype.replaceSettings.call(this, changes);
            return this;
        };
        NetChart.prototype.addData = function (data, sourceId) {
            if (sourceId == null)
                sourceId = "default";
            this._impl.addData(data, sourceId);
        };
        /** Removes the given nodes and links from the chart. Note that only the ID values have to be given, all other properties are ignored. */
        NetChart.prototype.removeData = function (data, sourceId) {
            if (sourceId == null)
                sourceId = "default";
            this._impl.removeData(data, sourceId);
        };
        NetChart.prototype.replaceData = function (data, sourceId) {
            if (sourceId == null)
                sourceId = "default";
            this._impl.replaceData(data, sourceId);
        };
        NetChart.prototype.hideMenu = function () {
            this._impl.hideMenu();
            return this;
        };
        /** Updates (recalculates) the style for the whole chart or specific objects matching the given IDs.
        @param objects - A list of IDs for the nodes and links which need their style recalculated */
        NetChart.prototype.updateStyle = function (objects) {
            if (!objects) {
                this._impl.updateStyle(null);
            }
            else {
                this._impl.touchObjects(objects);
                this._impl.events.requestPaint();
            }
        };
        /** Gets a visible node by its ID */
        NetChart.prototype.getNode = function (/** Node ID */ id) {
            return this._impl.getNode(id);
        };
        /** Gets a visible link by its ID */
        NetChart.prototype.getLink = function (/** Link ID */ id) {
            return this._impl.getLink(id);
        };
        /** Shows a node by its ID. The data for the node gets requested in the standard manner.
            Whether or not the node will get actually shown depends on the navigation mode. */
        NetChart.prototype.showNode = function (/** Node ID */ id) {
            return this._impl.showNode(id);
        };
        /** Hides a visible node. Whether or not the node will get actually hidden depends on the navigation mode. */
        NetChart.prototype.hideNode = function (/** Node ID or object */ id) {
            return this._impl.hideNode(id);
        };
        /** Expands a visible node. */
        NetChart.prototype.expandNode = function (/** Node ID or object */ id) {
            return this._impl.expandNode(id);
        };
        /** Focuses a node. Whether or not the node will get actually focused depends no the navigation mode. */
        NetChart.prototype.addFocusNode = function (
            /** Node ID or object */
            id, 
            /** Explicitly assigned relevance (used only by Focusnodes navigation mode).
                For more information, see the [Focusnodes algorithm](net-chart/advanced-topics/focusnodes-algorithm-details.html)
                @see Documentation: [Focusnodes algorithm](net-chart/advanced-topics/focusnodes-algorithm-details.html)*/
            relevance) {
            if (relevance === void 0) { relevance = -1; }
            if (relevance == null)
                relevance = -1; // ported from CoffeeScript;
            return this._impl.addFocusNode(id, relevance);
        };
        /** Removes focus from a node. Whether or not the node will get actually unfocused depends on the navigation mode. */
        NetChart.prototype.removeFocusNode = function (/** Node ID or object */ id) {
            return this._impl.removeFocusNode(id);
        };
        /** Removes focus from all nodes. The exact effect depends on the navigation mode. */
        NetChart.prototype.clearFocus = function () {
            return this._impl.clearFocus();
        };
        /** Collapses a node. The exact effect depends on the navigation mode. */
        NetChart.prototype.collapseNode = function (/** Node ID or object */ id) {
            return this._impl.collapseNode(id);
        };
        /** Closes a node. The exact effect depends on the navigation mode. */
        NetChart.prototype.closeNode = function (/** Node ID or object */ id) {
            return this._impl.closeNode(id);
        };
        /** Fixates a node in place. */
        NetChart.prototype.lockNode = function (
            /** Node ID or object */
            id, 
            /* X position, in scene coordinates*/
            x, 
            /** Y position, in scene coordinates */
            y) {
            return this._impl.lockNode(id, x, y);
        };
        /** Unfixates a node and allows it to be repositioned by the layout algorithms. */
        NetChart.prototype.unlockNode = function (/** Node ID or object */ id) {
            return this._impl.unlockNode(id);
        };
        /**
         * Gets or sets the current zoom level of the chart. A zoom level of `1` means that all nodes are rendered
         * with the radius that is set in their configuration. A zoom level of `2` means that all nodes are twice
         * the size and `0.5` means that all nodes are two times smaller than their specified radiuses.
         *
         * The zoom level is limited by [`interaction.zooming.zoomExtent` setting][zoomextent].
         *
         * [zoomextent]: https://zoomcharts.com/developers/en/net-chart/api-reference/settings/interaction/zooming/zoomExtent.html
         *
         * @param zoomValue - if specified and greater than zero, the zoom level will be updated to this value.
         * @param animate - specifies if the zoom change should be animated. The default is `true`.
         * @returns - the current zoom level. Note that if the zoom level is changed with an animation, the method returns the current and not the target level.
         * @version 1.13.2 - added the `animate` parameter
         */
        NetChart.prototype.zoom = function (zoomValue, animate) {
            if (animate === void 0) { animate = true; }
            if (zoomValue > 0) {
                this._impl.setZoom(zoomValue, !!animate);
            }
            return this._impl.scene.zoom;
        };
        NetChart.prototype.resetLayout = function () {
            return this._impl.resetLayout();
        };
        /**
         * Set/Get selected objects.
         * @param selected - array of objects identifiers to select. Do not pass this parameter if you don't want to change current selection.
         * @returns currently selected objects.
         */
        NetChart.prototype.selection = function (selected) {
            /* Set/get selection in javascript timestamp (milliseconds).
            Use null, null to remove selection.
            returns [from, to] in list form. */
            if (selected) {
                this._impl.setSelection(selected);
            }
            return this._impl.scene.selection;
        };
        NetChart.prototype.zoomIn = function (objects, animate) {
            if (animate === void 0) { animate = true; }
            // Zooms in to list of objects
            return this._impl.zoomIn(objects, !!animate);
        };
        NetChart.prototype.nodes = function () {
            // Returns list of visible nodes
            return this._impl.getCurrentNodes();
        };
        NetChart.prototype.links = function () {
            // Returns list of visible links
            return this._impl.getCurrentLinks();
        };
        NetChart.prototype.getNodeDimensions = function (node) {
            /* returns dimensions object on screen
            x, y, radius, hwidth */
            return this._impl.getNodeDimensions(node);
        };
        NetChart.prototype.exportData = function (visibleOnly, exportCoordinates) {
            if (visibleOnly === void 0) { visibleOnly = true; }
            if (exportCoordinates === void 0) { exportCoordinates = true; }
            // exports all data in object so it can be parsed back later on
            return this._impl.exportData(!!visibleOnly, !!exportCoordinates);
        };
        /** Animates the viewport to zoom into and contain the nodes specified in the given array */
        NetChart.prototype.scrollIntoView = function (
            /** Nodes to zoom to */
            nodes, 
            /** Optionally, additional margins (in scene coordinates) to leave free on the sides. Order: top, right, bottom, left */
            margins) {
            this._impl.scrollIntoView(nodes, margins);
        };
        NetChart.prototype.on = function (name, listener) {
            _super.prototype.on.call(this, name, listener);
        };
        NetChart.themes = {
            "flat": ZoomCharts.Internal.NetChart.Settings.FlatTheme,
            "dark": ZoomCharts.Internal.NetChart.Settings.DarkTheme,
        };
        /**
         * An internal method that is used by the test runner engine to automatically pass the generated settings when a new chart instance is created.
         * @ignore
         */
        NetChart.chartFactoryMethod = null;
        return NetChart;
    }(ZoomCharts.Internal.Base.Api));
    ZoomCharts.NetChart = NetChart;
    ZoomCharts.Internal.Base.Helpers.exportSymbol("NetChart", ZoomCharts.NetChart);
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var Resources;
        (function (Resources) {
            /* tslint:disable:max-line-length */
            /** Image used in PieChart to show the 'go back' action. */
            Resources.PiechartBack = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC8AAAA1CAMAAADmtEJjAAAAYFBMVEVMaXEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIAgUIAAAAH3RSTlMACbeu3XUBgH/vy+gqMRghOfqXYUpWwkDGihCfgmebkGEUkgAAAQVJREFUeNqV0ttugzAURNEx2BADBMItTXqZ///Lyi0qrXOkZvajtcbyg2F1gtSJIqfIKXKKnCKnyClyipwip8gpcmo8FaNvitewdtV/PB8WYRD4V83sBJ5q50rgqW2QOBlHiZOXUeJkewZQ8/kKiIOrOCigDS5ncbBCG9ygDUqYgxhpt8EcALh3Syjb3L/AHAB7/a3N7jcHOHIhZu83BvjduTj8BHOAP1XTjw8wB8gG5fGBzAGynN//g4M5QN7y7Rs8VJu+8ky9wR7gocBUD2tg+TFxD7Pa8C75GnbWeSQ54Pk8WULzV8VHNgp35Kr4nk2l+JkLlD42SPle4t0Eqfe75jvsfQLbYGzTrP2yIAAAAABJRU5ErkJggg==";
        })(Resources = Internal.Resources || (Internal.Resources = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Legend.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var PieChart;
        (function (PieChart) {
            var SettingsLegend = (function (_super) {
                __extends(SettingsLegend, _super);
                function SettingsLegend() {
                    _super.apply(this, arguments);
                    /** Visual element of legend entry with appropriate style to a slice color it corresponds.
                    The content of each legend marker is the same as info popup appearing while hovering on slice. */
                    this.marker = new SettingsLegendMarker();
                    /** Specifies if the Others and Previous slices should be shown in the legend.
                    @version 1.14.0 */
                    this.showOthers = false;
                }
                return SettingsLegend;
            }(Internal.Base.SettingsLegend));
            PieChart.SettingsLegend = SettingsLegend;
            var SettingsLegendMarker = (function (_super) {
                __extends(SettingsLegendMarker, _super);
                function SettingsLegendMarker() {
                    _super.apply(this, arguments);
                    /** Specifies the shape for color markers in the legend.
                    @type enum
                    @value circle - draws circles
                    @value square - draws rectangles
                    @value rhombus - draws rhombus (diamonds)
                    @value triangle - draws triangles, pointing up
                    @value triangle2 - draws triangles, pointing down */
                    this.shape = "square";
                }
                return SettingsLegendMarker;
            }(Internal.Base.SettingsLegendMarker));
            PieChart.SettingsLegendMarker = SettingsLegendMarker;
            var LegendEntry = (function (_super) {
                __extends(LegendEntry, _super);
                function LegendEntry(label, textColor, data) {
                    _super.call(this, label, textColor, null, null);
                    this.sliceHovered = false;
                    this.data = data;
                }
                LegendEntry.prototype.isHovered = function () {
                    return this.hoverCount > 0 || this.sliceHovered;
                };
                return LegendEntry;
            }(Internal.Base.LegendEntry));
            var Legend = (function (_super) {
                __extends(Legend, _super);
                function Legend(chart) {
                    _super.call(this, chart);
                    this.paintOrder = 20;
                    this.updateOrder = 1000;
                }
                Legend.prototype.onSceneChange = function (event) {
                    _super.prototype.onSceneChange.call(this, event);
                    var ch = event.changes;
                    if (ch.pie) {
                        this.rebuildItems();
                        ch.bounds = true;
                    }
                };
                Legend.prototype.getLastHoveredSlice = function () {
                    var entry = this.getLastHoveredEntry();
                    return entry ? entry.data : null;
                };
                Legend.prototype.doAnimations = function () {
                    var hoverSlice = this.chart.scene.hoverSlice;
                    for (var i = 0; i < this.entries.length; i++) {
                        this.entries[i].sliceHovered = this.entries[i].data === hoverSlice;
                    }
                    var selection = this.chart.scene.selection;
                    for (var i = 0; i < selection.length; i++) {
                        var entry = this.entryIndex[selection[i].id];
                        if (entry)
                            entry.sliceHovered = true;
                    }
                };
                Legend.prototype.paintMarker = function (event, cx, cy, radius, item) {
                    var slice = item.data;
                    var markerStyle = {
                        fillColor: slice.currentFillColor,
                        lineColor: this.settings.marker.lineColor
                    };
                    var context = event.context;
                    context.beginPath();
                    Internal.Base.Graphics.strokeMarker(context, this.settings.marker.shape, cx, cy, radius);
                    Internal.Base.Graphics.paint(context, markerStyle);
                };
                Legend.prototype.rebuildItems = function () {
                    var items = [];
                    var activePie = this.chart.scene.peek();
                    if (activePie) {
                        var textColor_1 = this.settings.text.fillColor;
                        var convertSlice = function (slice) { return new LegendEntry(slice.data.nameLegend || slice.label.text || slice.data.name, textColor_1, slice); };
                        var showOthers = this.settings.showOthers;
                        var slices = activePie.slices;
                        var prev = activePie.previousSlice;
                        var others = activePie.othersSlice;
                        if (showOthers && prev && !prev.removed)
                            items.push(convertSlice(prev));
                        items.push.apply(items, slices.map(convertSlice));
                        if (showOthers && others && !others.removed)
                            items.push(convertSlice(others));
                    }
                    this.entryIndex = {};
                    for (var i = 0; i < items.length; i++)
                        this.entryIndex[items[i].data.id] = items[i];
                    this.resetEntries(items);
                };
                Legend.prototype.itemClicked = function (event, item) {
                    // Don't do anything here, not even the default behavior. Selection.ts will take care of the click.
                };
                return Legend;
            }(Internal.Base.Legend));
            PieChart.Legend = Legend;
        })(PieChart = Internal.PieChart || (Internal.PieChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Scene.ts" />
/// <reference path="../base/Label.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var PieChart;
        (function (PieChart) {
            var Icon = (function () {
                function Icon() {
                    this.hwidth = 0;
                    this.hheight = 0;
                    this.x = null;
                    this.y = null;
                    this.userPlaced = false;
                    this.inside = true;
                }
                return Icon;
            }());
            PieChart.Icon = Icon;
            var Slice = (function () {
                function Slice(pie, index) {
                    this.id = null;
                    this.pie = null;
                    this.data = null;
                    this.index = 0;
                    this.value = 0;
                    /** The percentage of the value of this slice against the total value of the pie.
                    
                    Note that value is already multiplied by 100, so if there are two equal slices, both would have the value of `50`, instead of `0.5`. */
                    this.percent = null;
                    /** The fraction of the pie the slice covers. Note that this is represents the visual size,
                    not the value - for that you need to use `percent` field. */
                    this.fraction = 0;
                    this.cutoutDistance = 0;
                    /** Swipe distance towards the center of the pie */
                    this.selectDistance = 15;
                    /** Slice partial swipe distance */
                    this.selection = 0;
                    this.brightness = 1;
                    /** Whether to expand the slice as a default click behavior. */
                    this.expandable = true;
                    this.selected = false;
                    this.active = false;
                    this.removed = false;
                    this.icon = null;
                    this.iconOffset = null;
                    this.url = null;
                    this.urlTarget = null;
                    this.userPlaced = false;
                    this.inside = true;
                    this.x = 0;
                    this.y = 0;
                    /** Contains the original ID that is populated when the slice is being removed. This property
                    is important since once the removal animation starts, the `id` property contains an auto-generated
                    ID. */
                    this.originalId = null;
                    /**@ignore*/ this.currentCutoutDistance = null;
                    /**@ignore*/ this.currentFraction = null;
                    /**@ignore*/ this.currentInsideLabel = null;
                    /**@ignore*/ this.currentLabel = null;
                    /**@ignore*/ this.currentIcon = null;
                    /**@ignore*/ this.currentLineColor = null;
                    /**@ignore*/ this.currentFillColor = null;
                    /**@ignore*/ this.targetFillColor = null;
                    /**@ignore*/ this.targetLineColor = null;
                    /** To provide partial backward compatiblity with previous versions where setting styleFunction would not provide the default label
                    it is cleared when the insideLabel is set. */
                    this._resetLabelText = false;
                    this._label = { textStyle: {} };
                    this._insideLabel = { textStyle: {} };
                    this.lineColor = null;
                    this.fillColor = null;
                    this.fillColor2 = null;
                    this.lineWidth = 1;
                    this.lineDash = null;
                    this.lineBrightness = 0;
                    this._animatorF = null;
                    this._animatorLineColor = null;
                    this._animatorFillColor = null;
                    this._animatorCutout = null;
                    // TODO: convert to object
                    /** [innerRadius, outerRadius, outLeft, outerRight, innerLeft, innerRight] */
                    this._renderParams = null;
                    this.index = index;
                    this.pie = pie;
                }
                Object.defineProperty(Slice.prototype, "label", {
                    /** Gets or sets the style of the external label. Use `label.text` to specify the text that will be displayed. */
                    get: function () { return this._label; },
                    set: function (value) {
                        // backward compatibility since previously Slice.label was a string
                        if (!Internal.Base.Helpers.isObjectOrArray(value)) {
                            Internal.Base.Helpers.warn("Slice.label should no longer be set to the text value - instead use Slice.label.text.");
                            this._label.text = value ? "" + value : null;
                            this._resetLabelText = false;
                        }
                        else {
                            this._label = value;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Slice.prototype, "insideLabel", {
                    /** Gets or sets the style of the label shown inside the slice. Use `insideLabel.text` to specify the text that will be displayed.
                    Note that for backwards compatibility it is possible to set this property to a string directly - in this case the value will be
                    written the `insideLabel.text` but also `label.text` will be cleared. */
                    get: function () { return this._insideLabel; },
                    set: function (value) {
                        // backward compatibility since previously Slice.insideLabel was a string
                        if (!Internal.Base.Helpers.isObjectOrArray(value)) {
                            Internal.Base.Helpers.warn("Slice.insideLabel should no longer be set to the text value - instead use Slice.insideLabel.text.");
                            this._insideLabel.text = value ? "" + value : null;
                            if (this._resetLabelText) {
                                this._resetLabelText = false;
                                this._label.text = null;
                            }
                        }
                        else {
                            this._insideLabel = value;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Slice.prototype, "labelStyle", {
                    /** @deprecated - use `label` instead. */
                    get: function () {
                        Internal.Base.Helpers.warn("Slice.labelStyle is deprecated - use Slice.label instead.");
                        return this._label;
                    },
                    set: function (value) {
                        Internal.Base.Helpers.warn("Slice.labelStyle is deprecated - use Slice.label instead.");
                        if (value) {
                            if (!value.text)
                                value.text = this._label.text;
                            Internal.Base.Helpers.extendDeep(this._label, value);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Slice.prototype, "insideLabelStyle", {
                    /** @deprecated - use `insideLabel` instead. */
                    get: function () {
                        Internal.Base.Helpers.warn("Slice.insideLabelStyle is deprecated - use Slice.insideLabel instead.");
                        return this._insideLabel;
                    },
                    set: function (value) {
                        Internal.Base.Helpers.warn("Slice.insideLabelStyle is deprecated - use Slice.insideLabel instead.");
                        if (value) {
                            if (!value.text)
                                value.text = this._insideLabel.text;
                            Internal.Base.Helpers.extendDeep(this._insideLabel, value);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                return Slice;
            }());
            PieChart.Slice = Slice;
            var Pie = (function () {
                function Pie() {
                    this.id = null;
                    this.data = null;
                    this.total = 1;
                    this.parentSlice = null;
                    this.othersSlice = null;
                    this.previousSlice = null;
                    /** Contains the list of slices that excludes the Others/Previous and any slices that are being animated for removal. */
                    this.slices = [];
                    /** Includes all slices that are shown on the screen (including Others/Previous and slices pending removal). */
                    this.allSlices = [];
                    /** Number of slices in the "previous" slice */
                    this.offset = 0;
                    this.count = 0;
                    this.background = false;
                    this.activeSliceId = null;
                    this.brightness = 1;
                    this.loading = false;
                    /** Fraction of the total, describing how far the pie has been scrolled with rotational scrolling. */
                    this.scrollOffset = 0;
                    this.fillColor = null;
                    this.x = 0;
                    this.y = 0;
                    this.startAngle = 0;
                    this.endAngle = 0;
                    /** The speed of the rotation for the pie. Set to `0` to disable rotation and return the pie
                    to its specified `startAngle`.
                    @version 1.12.0
                    @experimental
                    @type float */
                    this.rotationSpeed = 0;
                    /** Specifies if during the last frame the `rotationSpeed` was not equal to 0. This means that
                    the next frame will use the default transition animation to reset the start/end angles.
                    @ignore */
                    this.currentlyRotating = false;
                    /**@ignore*/
                    this.currentStartAngle = null;
                    /**@ignore*/
                    this.currentEndAngle = null;
                    /**@ignore*/
                    this.currentRadius = 0;
                    this.innerRadius = 0;
                    this.radius = 0;
                    /**@ignore*/
                    this.currentInnerRadius = 0;
                    this.colorDistribution = null;
                    this.sliceColors = null;
                    this.removed = false;
                    this.visibleFraction = 1;
                    /** The time when the animator will remove the pie completely.
                    @ignore */
                    this.removeTime = null;
                    this._animatorA0 = null;
                    this._animatorA1 = null;
                    this._animatorR0 = null;
                    this._animatorR1 = null;
                }
                Pie.prototype.getActiveSlice = function () {
                    if (!this.activeSliceId) {
                        return null;
                    }
                    for (var sliceIndex = 0; sliceIndex < this.slices.length; sliceIndex++) {
                        var slice = this.slices[sliceIndex];
                        if (slice.id === this.activeSliceId) {
                            return slice;
                        }
                    }
                    return null;
                };
                return Pie;
            }());
            PieChart.Pie = Pie;
            var Scene = (function (_super) {
                __extends(Scene, _super);
                function Scene() {
                    _super.apply(this, arguments);
                    this.radius = 100;
                    this.innerRadius = 0;
                    this.currentRadius = null;
                    this.currentInnerRadius = null;
                    /** all pies to render */
                    this.pies = [];
                    /** stack of current, not removed pies */
                    this.stack = [];
                    /** array of IDs to select when they become visible */
                    this.selectionIds = [];
                    this.hoverBack = false; // If true, hovering on central back arrow.
                    this.hoverSlice = null;
                    this.hoverLabel = null;
                    this.hoverPie = null;
                    this.view = null;
                    this.selection = [];
                    /** "previous", "next", null */
                    this.pendingAction = null;
                    /** offset to scroll to */
                    this.pendingOffset = null;
                }
                Scene.prototype.addPie = function (pie) {
                    this.pies.push(pie);
                    this.stack.push(pie);
                    return pie;
                };
                Scene.prototype.removePie = function (pie) {
                    if (pie === null)
                        return;
                    pie.removed = true;
                    pie.removeTime = null;
                    Internal.Base.Helpers.removeFromArray(this.stack, pie);
                    // clear selection
                    var i = 0;
                    while (i < this.selection.length) {
                        var slice = this.selection[i];
                        if (slice.pie === pie) {
                            Internal.Base.Helpers.removeFromArray(this.selection, slice);
                        }
                        else {
                            i++;
                        }
                    }
                };
                Scene.prototype.deletePie = function (pie) {
                    Internal.Base.Helpers.removeFromArray(this.pies, pie);
                    return Internal.Base.Helpers.removeFromArray(this.stack, pie);
                };
                Scene.prototype.length = function () {
                    return this.stack.length;
                };
                Scene.prototype.peek = function () {
                    if (this.stack.length === 0)
                        return null;
                    return this.stack[this.stack.length - 1];
                };
                Scene.prototype.push = function (pie, originSlice) {
                    if (originSlice === void 0) { originSlice = null; }
                    var parent = this.peek();
                    if (parent && !originSlice) {
                        // try to find origin slice
                        for (var sliceIndex = 0; sliceIndex < parent.slices.length; sliceIndex++) {
                            var slice = parent.slices[sliceIndex];
                            if (slice.id === pie.id) {
                                originSlice = slice;
                                break;
                            }
                        }
                    }
                    if (originSlice) {
                        pie.parentSlice = originSlice;
                        var originPie = originSlice.pie;
                        var getSliceAnglesResult = this.getSliceAngles(originSlice);
                        pie.currentStartAngle = getSliceAnglesResult.a0;
                        pie.currentEndAngle = getSliceAnglesResult.a1;
                        pie.currentRadius = originPie.currentRadius;
                        pie.currentInnerRadius = originPie.currentInnerRadius;
                        parent.activeSliceId = originSlice.id;
                        for (var sliceIndex = 0; sliceIndex < pie.allSlices.length; sliceIndex++) {
                            var slice = pie.allSlices[sliceIndex];
                            slice.currentFillColor = originSlice.currentFillColor;
                            slice.currentLineColor = originSlice.currentLineColor;
                        }
                    }
                    else if (parent) {
                        parent.activeSliceId = null;
                    }
                    if (parent) {
                        parent.background = true;
                    }
                    return this.addPie(pie);
                };
                Scene.prototype.pop = function () {
                    if (this.stack.length === 0)
                        return;
                    this.removePie(this.peek());
                    var pie = this.peek();
                    if (pie) {
                        pie.background = false;
                        pie.brightness = 1;
                    }
                };
                Scene.prototype.getParent = function (pie) {
                    var parent = null;
                    for (var pi = 0; pi < this.stack.length; pi++) {
                        var p = this.stack[pi];
                        if (p === pie)
                            return parent;
                        parent = p;
                    }
                    return null;
                };
                Scene.prototype.getChild = function (pie) {
                    var parent = null;
                    for (var pIndex = 0; pIndex < this.stack.length; pIndex++) {
                        var p = this.stack[pIndex];
                        if (parent === pie)
                            return p;
                        parent = p;
                    }
                    return null;
                };
                Scene.prototype.updateOnPieChanged = function (pie) {
                    var parent = this.getParent(pie);
                    var child = this.getChild(pie);
                    if (parent && !pie.parentSlice) {
                        for (var sliceIndex = 0; sliceIndex < parent.slices.length; sliceIndex++) {
                            var slice = parent.slices[sliceIndex];
                            if (slice.id === pie.id) {
                                pie.parentSlice = slice;
                                parent.activeSliceId = slice.id;
                                break;
                            }
                        }
                    }
                    if (child && !child.parentSlice) {
                        for (var sliceIndex = 0; sliceIndex < pie.slices.length; sliceIndex++) {
                            var slice = pie.slices[sliceIndex];
                            if (slice.id === child.id) {
                                child.parentSlice = slice;
                                pie.activeSliceId = slice.id;
                                break;
                            }
                        }
                    }
                };
                Scene.prototype.findPieAt = function (x, y, tolerance) {
                    return this.view.findPieAt(x, y, tolerance);
                };
                Scene.prototype.findSliceAt = function (x, y, tolerance, coverCenter) {
                    return this.view.findSliceAt(x, y, tolerance, coverCenter);
                };
                Scene.prototype.findLabelAt = function (x, y, tolerance) {
                    return this.view.findLabelAt(x, y, tolerance);
                };
                Scene.prototype.getSliceAngles = function (slice) {
                    var f1 = 0;
                    var pie = slice.pie;
                    var f0 = 0;
                    for (var sIndex = 0; sIndex < pie.allSlices.length; sIndex++) {
                        var s = pie.allSlices[sIndex];
                        f0 = f1;
                        f1 = f1 + s.currentFraction;
                        if (s.id === slice.id) {
                            break;
                        }
                    }
                    var da = pie.currentEndAngle - pie.currentStartAngle;
                    var a0 = pie.currentStartAngle;
                    return {
                        a0: a0 + da * f0,
                        a1: a0 + da * f1
                    };
                };
                Scene.prototype.getSliceTargetAngles = function (slice) {
                    var f1 = 0;
                    var pie = slice.pie;
                    var f0 = 0;
                    for (var sIndex = 0; sIndex < pie.allSlices.length; sIndex++) {
                        var s = pie.allSlices[sIndex];
                        f0 = f1;
                        f1 = f1 + s.currentFraction;
                        if (s.id === slice.id) {
                            break;
                        }
                    }
                    var da = pie.currentEndAngle - pie.currentStartAngle;
                    var a0 = pie.currentStartAngle;
                    return {
                        a0: a0 + da * f0,
                        a1: a0 + da * f1
                    };
                };
                return Scene;
            }(Internal.Base.Scene));
            PieChart.Scene = Scene;
        })(PieChart = Internal.PieChart || (Internal.PieChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Settings.ts" />
/// <reference path="../base/Label.ts" />
/// <reference path="Images.ts" />
/// <reference path="Data.ts" />
/// <reference path="Legend.ts" />
/// <reference path="Scene.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var PieChart;
        (function (PieChart) {
            var Settings = (function (_super) {
                __extends(Settings, _super);
                function Settings(settings) {
                    _super.call(this, Internal.Base.SettingsMapping.PieChartSettings);
                    /** Theme to apply. You can either use this to share configuration objects between multiple charts or use one of the predefined
                    themes.
                    @see Documentation: [Pre-defined themes](pie-chart/api-reference/api.html#doc_themes)
                    */
                    this.theme = Settings.FlatTheme;
                    this.data = [];
                    /** The chart legend by additional interactivity to navigate between the slices or hilight each of them. Note that click on entries
                    acts the same way as click on slice and is dependant of chart interaction mode. */
                    this.legend = new PieChart.SettingsLegend();
                    /** Settings to specify initial pie and visible slice offset once the page loaded. */
                    this.navigation = {
                        /** Initial pie drilldown to show. For example ['', 'Firefox', 'Firefox 2.5'] denotes to various browsers grouped by versions. */
                        initialDrilldown: [""],
                        /** Initial offset, number of items from start.
                        @type integer */
                        initialOffset: 0,
                    };
                    /** Data values arranged in a circular manner. */
                    this.pie = {
                        /** Pie outer radius. If not specified, the radius is determined automatically.
                        @type float
                        @units pixels */
                        radius: null,
                        /** Whether to adapt pie outer radius dynamically to allow enough space for labels. */
                        adaptiveRadius: true,
                        /** Pie outer margin.
                        @type float
                        @units pixels */
                        outerMargin: 1,
                        /** Pie margin.
                        @type float
                        @units pixels */
                        margin: 2,
                        /** Pie center margin.
                        @type integer
                        @units pixels */
                        centerMargin: 5,
                        /** Whether to show inner pies on exported image. */
                        showInnerPiesExport: true,
                        /** Whether to show inner pies on chart. */
                        showInnerPies: true,
                        /** Pie inner radius. Inner pies are drawn inside this radius. If the value is less than 1, it is multiplied
                        by current pie radius to get inner radius. Otherwise it represents the inner radius in pixels.
                        @type float
                        @units pixels*/
                        innerRadius: 0.3,
                        // next setting should be advanced
                        /** Inner radius is extended to radius * innerRadiusWhenDrilldown when drilled down.
                        @type float */
                        innerRadiusWhenDrilldown: 0.2,
                        /** Start angle of the pie.
                        @type float */
                        startAngle: -Math.PI / 2,
                        /** End angle of the pie.
                        @type float */
                        endAngle: Math.PI * 1.5,
                        /** The speed of the rotation for the pie. Set to `0` to disable rotation and return the pie
                        to its specified `startAngle`.
                        @version 1.12.0
                        @experimental
                        @type float */
                        rotationSpeed: 0,
                        /** Default pie rendering theme.
                        @see Example: [PieChart themes](pie-chart/examples/style/themes.html)
                        @type enum
                        @value flat
                        @value bevel
                        @value can
                        @value smoothy */
                        theme: "flat",
                        /** Pie depth - used for raised theme.
                        @type integer */
                        depth: 0,
                        /** Center X coordinate of the pie chart.
                        If the value is 'null' - coordinate is calculated automatically.
                        If the value is >1 - it specifies the exact x value in pixels.
                        If the value is <=1 - it specifies a fraction of chart width.
                        @type float
                        @units pixels */
                        x: null,
                        /** Center Y coordinate of the pie chart.
                        If the value is 'null' - coordinate is calculated automatically.
                        If the value is >1 - it specifies the exact x value in pixels.
                        If the value is <=1 - it specifies a fraction of chart height.
                        @type float
                        @units pixels */
                        y: null,
                        /** Default pie rendering style. */
                        style: {
                            fillColor: "transparent",
                            sliceColors: [
                                "#2fc32f",
                                "#b0dc0b",
                                "#eab404",
                                "#de672c",
                                "#ec2e2e",
                                "#d5429b",
                                "#6f52b8",
                                "#1c7cd5",
                                "#56b9f7",
                                "#0ae8eb"
                            ],
                            colorDistribution: "list",
                            brightness: 1
                        },
                        /** Pie style when no data is present. */
                        noDataStyle: { fillColor: "#ddd" },
                        /** Pie background style. */
                        backgroundStyle: {},
                        /** Hovered pie background style. */
                        backgroundHoveredStyle: { brightness: 0.7 },
                        /** Dynamically determine pie style from data. */
                        styleFunction: null
                    };
                    /** Represents settings for individual slices within each pie. */
                    this.slice = {
                        /** Slice margin.
                        @type float
                        @units pixels */
                        margin: 2,
                        /** Controls minimal visual size of slice. Use this to make very small sizes visually bigger. The value represents
                        smallest fraction of a full pie a slice will take. The range is between 0 and 1. For example using 0.05, all slices
                        smaller than 5% will be grown up to 5%. Other slices will be made proportionally smaller to accommodate for extra
                        size of small slices.
                        @type float */
                        minFraction: 0.0,
                        /** Slice style settings */
                        style: {
                            lineBrightness: 0,
                            brightness: 1,
                            // fillColor: null #overrides pie.sliceColors
                            lineWidth: 1,
                            /** Outside labels style. */
                            label: {
                                // 'null' for painting background balloon
                                backgroundStyle: null,
                                textStyle: { fillColor: "#000", font: "12px Arial" },
                                lineSpacing: 0.2,
                                margin: 4,
                                padding: 0,
                                borderRadius: 999,
                                text: null
                            },
                            /** Inside labels style. */
                            insideLabel: {
                                textStyle: { fillColor: "#fff", font: "12px Arial" },
                                lineSpacing: 0.2,
                                margin: 4,
                                padding: 0,
                                borderRadius: 0,
                                text: null
                            },
                        },
                        /** Hovered slices style. */
                        hoverStyle: {
                            brightness: 1.2,
                            lineBrightness: 2,
                            lineWidth: 0.35
                        },
                        /** Selected slices style. */
                        selectedStyle: null,
                        /** Slice style on background (back navigation) pies. */
                        backgroundStyle: {
                            fillColor: "#e2e2e2",
                            /** Extra property to alternate fill colors on backgrond slices.
                            @type color */
                            fillColor2: "#e0e0e0"
                        },
                        /** Style to active slices in background (back navigation) pies */
                        backgroundActiveStyle: { brightness: 1.3 },
                        /** Style for "Others" slice. */
                        othersStyle: {
                            fillColor: "#ccc",
                            /** Circumference decoration of 'others' slice.
                            @type enum
                            @value zigzag */
                            lineDecoration: "zigzag"
                        },
                        /** Style for the "Previous" slice. */
                        previousStyle: {
                            fillColor: "#ccc",
                            /** Circumference decoration of 'previous' slice.
                            @type enum
                            @value zigzag */
                            lineDecoration: "zigzag"
                        },
                        /** Label connector line style. */
                        connectorStyle: {
                            lineColor: "#333",
                            lineWidth: 1
                        },
                        /** Expandable slice mark line style */
                        expandableMarkStyle: {
                            lineWidth: 1,
                            lineColor: "rgba(255,255,255,0.8)",
                            distance: 4,
                            lineDash: null
                        },
                        /** Dynamically determine slice style from data. */
                        styleFunction: null
                    };
                    /** Configurable conditions to filter the raw data values for subset of drawing slices. */
                    this.filters = {
                        /** Function to filter visible slices.
                        @returns true to show the slice, false to hide the slice. */
                        sliceFilter: null,
                        /** Determines if zero values are automatically filtered from the data or if they will be displayed.
            
                        Note that if you want to show the empty values in the piechart, it might be useful to set
                        [`interaction.others.minSliceFraction`][1] to `0` or [`slice.minFraction`][2] to a value larger than `0`.
            
                        [1]: pie-chart/api-reference/settings/interaction/others/minSliceFraction.html
                        [2]: pie-chart/api-reference/settings/slice/minFraction.html
                        @version 1.14.0 */
                        allowZeroValues: false
                    };
                    /** Label settings related to internal and external slice text and their connectors. */
                    this.labels = new SettingsLabels();
                    /** Slice icons as an additional element of style to highlight each individual slice or groups. */
                    this.icons = {
                        /** Min and max value of icon size. The icon size is automatically computed from available space. */
                        sizeExtent: [16, 64],
                        /** Icon placement method
                        @type enum
                        @value auto - maximize icon size
                        @value center - always place in center of slice */
                        placement: "auto",
                        /** Whether to render icons if smaller than min value of sizeExtent. */
                        autohideWhenTooSmall: true
                    };
                    /** Advanced chart settings. Be advised that they are subject to change, backwards compatibility is not guaranteed. */
                    this.advanced = new SettingsAdvanced();
                    /** Configurable interactivity options to navigate among the slices and pie levels to facilitate analysis of the grouped data in different ways. */
                    this.interaction = new SettingsInteraction();
                    /** Rising content field while hovering over slice. Content returned in a form of html and is relevant to context of slice hovered. */
                    this.info = {
                        /** Show/hide info popup. */
                        enabled: true,
                        /** Prepare custom info popup contents. May return null and call callback(contents) later. */
                        contentsFunction: null
                    };
                    this.events = new SettingsEvents();
                    this.toolbar = new Internal.Base.SettingsToolbar(false, [
                        new Internal.Base.SettingsToolbarItem("back"),
                        new Internal.Base.SettingsToolbarItem("export"),
                        new Internal.Base.SettingsToolbarItem("zoomOut"),
                    ]);
                    this.localization = new SettingsLocalization();
                    this.toolbar.zoomOut = false;
                    this.apply(settings);
                    this._initializing = false;
                }
                Settings.prototype.apply = function (settings) {
                    // COMPATIBILITY:
                    this.applyCompatibility(settings, [
                        { from: "slice.labelStyle", to: "slice.style.label" },
                        { from: "slice.insideLabelStyle", to: "slice.style.insideLabel" },
                        { from: "labels.connectorStyle", to: "slice.connectorStyle" },
                        { from: "labels.textStyle", to: "slice.style.label.textStyle" },
                        { from: "labels.backgroundStyle", to: "slice.style.label.backgroundStyle" },
                        { from: "labels.insideTextStyle", to: "slice.style.insideLabel.textStyle" },
                        { from: "labels.padding", to: "slice.style.label.padding" },
                        { from: "labels.borderRadius", to: "slice.style.label.borderRadius" },
                        { from: "area.initialPieId", to: "navigation.initialDrilldown" },
                        { from: "area.initialPieOffset", to: "navigation.initialOffset" },
                        { from: "area.initialAnimation", to: "advanced.initialAnimation" },
                        { from: "advanced.iconMinSize", alternative: "icons.sizeExtent[0]" },
                        { from: "advanced.pointer.dragSensitivity", to: "interaction.selection.swipeSensitivity" }
                    ]);
                    var changes = _super.prototype.apply.call(this, settings);
                    return changes;
                };
                Settings.FlatTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-flat",
                        assets: []
                    },
                    pie: { theme: "flat", depth: 0 }
                };
                Settings.DarkTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-dark",
                        assets: []
                    },
                    area: {
                        style: {
                            fillColor: "rgba(28,26,28,1)"
                        }
                    },
                    title: {
                        margin: 15,
                        style: {
                            fillColor: "#A8A7A8"
                        }
                    },
                    pie: {
                        theme: "flat",
                        depth: 0,
                        style: {
                            sliceColors: [
                                "#32CD32",
                                "#36BEFF",
                                "#FBBD30",
                                "#EE3431",
                                "#894BBC",
                                "#0EC9AC",
                                "#524BBC",
                                "#0b83ea",
                                "#3ca20d",
                                "#BC438F"
                            ],
                        }
                    },
                    slice: {
                        connectorStyle: {
                            lineColor: "#4C4C4C"
                        },
                        style: {
                            label: {
                                textStyle: {
                                    fillColor: "#A8A7A8"
                                }
                            }
                        }
                    },
                    legend: {
                        text: {
                            fillColor: "#A8A7A8"
                        },
                        marker: {
                            lineColor: null
                        }
                    }
                };
                Settings.BevelTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-flat",
                        assets: []
                    },
                    pie: { theme: "bevel", depth: 0 }
                };
                Settings.GradientTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-flat",
                        assets: []
                    },
                    pie: { theme: "smoothy", depth: 0 }
                };
                Settings.CanTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-flat",
                        assets: []
                    },
                    pie: { theme: "can", depth: 10 }
                };
                return Settings;
            }(Internal.Base.Settings));
            PieChart.Settings = Settings;
            var SettingsLabels = (function () {
                function SettingsLabels() {
                    /** Show/hide labels. */
                    this.enabled = true;
                    /** Whether to show connector lines for labels. */
                    this.connectors = true;
                    /** Minimal connector length from slice to label.
                    @type integer
                    @units pixels */
                    this.connectorLength = 20;
                    /** Label rotation angle.
                    @type integer */
                    this.angle = 0;
                    /** Inside label placement method.
                    @type enum
                    @value always - always show
                    @value auto - show only when available area is at least insideLabelVisibilityFraction from label size
                    @value append - same as auto, but append inside label to normal label when it cannot be shown inside. */
                    this.insideLabel = "append";
                    // next setting should be advanced
                    /** Inside label is not shown if the fraction of label that fits inside slice is smaller than this.
                    @type float */
                    this.insideLabelVisibilityFraction = 0.8;
                    /** Min distance between labels, as a fraction of line height.
                    @type float */
                    this.interLabelSpacing = 0.6;
                    /** Outside labels placement method.
                    @type enum
                    @value aligned - align labels in vertical lines
                    @value wrap - wrap labels tightly around pie */
                    this.placement = "aligned";
                }
                return SettingsLabels;
            }());
            PieChart.SettingsLabels = SettingsLabels;
            var SettingsEvents = (function (_super) {
                __extends(SettingsEvents, _super);
                function SettingsEvents() {
                    _super.apply(this, arguments);
                    /** @deprecated Use onChartUpdate instead */
                    this.onPieChange = null;
                    /** @deprecated Use onChartUpdate instead */
                    this.onPieReadyStateChanged = null;
                }
                return SettingsEvents;
            }(Internal.Base.SettingsEvents));
            PieChart.SettingsEvents = SettingsEvents;
            var SettingsLocalization = (function (_super) {
                __extends(SettingsLocalization, _super);
                function SettingsLocalization() {
                    _super.apply(this, arguments);
                    this.othersLabel = "Others";
                    this.previousLabel = "Previous";
                }
                return SettingsLocalization;
            }(Internal.Base.SettingsLocalization));
            PieChart.SettingsLocalization = SettingsLocalization;
            var SettingsInteraction = (function (_super) {
                __extends(SettingsInteraction, _super);
                function SettingsInteraction() {
                    _super.apply(this, arguments);
                    /** Interaction mode. Note that `selection.enabled` can be used to disable the selection completely.
                    @type enum
                    @value drilldown - performs drill down on click, if item is not expandable, selects it
                    @value select - selects items
                    @value toggle - toggle selects items. */
                    this.mode = "drilldown";
                    /**
                     * If true, empty donut center area reacts to clicks.
                     */
                    this.coverCenter = false;
                    /** One of interactivity option to use the data selection. */
                    this.selection = {
                        /** Enable/disable selection. */
                        enabled: true,
                        /** Selection distance tolerance.
                        @type float
                        @units pixels */
                        tolerance: 2,
                        /** Wether to select slice by swipe. Note that it works independently of selection mode.*/
                        swipe: false,
                        /** Pixels the pointer has to be moved before the motion is recognized as a swipe.
                        @type float
                        @units pixels */
                        swipeSensitivity: 10,
                        /** Allows partial selecting of slices by gradually dragging them outwards. If this is set to `true`, the slices will not snap to true/false positions
                        instead the API will provide information on how far they were pulled out.*/
                        partialSwipe: false,
                        /** Max cutout distance on swipe.
                        @type float */
                        maxSwipeDistance: 45
                    };
                    /** Chart animation settings. */
                    this.animation = {
                        /** Duration of scroll animation.
                        @type integer
                        @units milliseconds */
                        scrollDuration: 500,
                        /** Duration of hover animation.
                        @type integer
                        @units milliseconds */
                        hoverDuration: 200
                    };
                    /** Slice including all the values that can not be displayed as a separate slice. Use them to configure 'others' slice rendering space. */
                    this.others = {
                        /** Enable/Disable Others/Previous slices. */
                        enabled: true,
                        /** If true, when offset > 0 click on center acts as click on previous slice. */
                        centerGoesToPrevious: false,
                        /**
                         * Others and Previous slice size as fraction of full pie.
                         * Previous will always be this big.
                         * Other will be at least this big but no bigger than maxOthersFraction.
                        @version 1.12.0 - the settings correctly applies to `Others` slice.
                        @type float */
                        navigationFraction: 0.15,
                        /** Max number of slices to show. All remaining slices will be replaced by 'Others' slice.
                        @type integer */
                        maxSlicesVisible: 15,
                        /** Minimum number of slices the pie needs to have for it to show the `Others` slice. Note that
                        once this limit is reached the `Others` slice may also contain all but one of the slices - this
                        setting does not limit the minimum number of slices that are shown at once in such case.
            
                        If you set this property to a value greater than 1, it might be useful to set [`slice.minFraction`][doc]
                        to a value of `0.01` or greater.
            
                        [doc]: pie-chart/api-reference/settings.html#slice.minFraction
                        @version 1.12.0 */
                        minSlices: 1,
                        /** Max size of others slice, as a fraction of 1. If others slice is bigger than this, it will be made smaller and other slices proportionally expanded.
                        @type float */
                        maxOthersFraction: 0.6,
                        /** Minimum slice size as fraction of full pie. All slices smaller than that are replaced with 'Others' slice.
                        @type float */
                        minSliceFraction: 0.01
                    };
                    /** One of interactivity option to scroll among data. */
                    this.scrolling = {
                        /** Enable/disable scrolling the Other/Previous slices by rotating the chart. */
                        enabled: false
                    };
                }
                return SettingsInteraction;
            }(Internal.Base.SettingsInteraction));
            PieChart.SettingsInteraction = SettingsInteraction;
            var SettingsAdvanced = (function (_super) {
                __extends(SettingsAdvanced, _super);
                function SettingsAdvanced() {
                    _super.call(this);
                    /** @deprecated - use the first value of `icons.sizeExtent` setting instead. */
                    this.iconMinSize = null;
                    /** Enables/disables initial zoom-in animation. */
                    this.initialAnimation = true;
                    /** Chart rendering quality. Note that it affects render performance for raised and gradient themes. Range 0 .. 1.
                    @type integer */
                    this.renderQuality = 1;
                    /** Image to display for back navigation.
                    @type imageUrl */
                    this.backImage = "builtin://piechart-back";
                    /** Background color of the back navigation button.
                    @version 1.12.0 */
                    this.backImageBackground = null;
                    /** Controls visibility of the back icon at the center of pie chart. If true, the back button is always visible, otherwise only on hover. */
                    this.backAlwaysVisible = false;
                    /** Inside labels are not rendered if there is not enough space. So if available space is less than label size * treshold.
                    @type integer */
                    this.labelInsideTreshold = 1;
                    this.builtinAssets["piechart-back"] = Internal.Resources.PiechartBack;
                    this.pointer.noClickOnDoubleClick = false;
                }
                return SettingsAdvanced;
            }(Internal.Base.SettingsAdvanced));
            PieChart.SettingsAdvanced = SettingsAdvanced;
        })(PieChart = Internal.PieChart || (Internal.PieChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/core/ChartEvents.ts" />
/// <reference path="../base/Geometry.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var PieChart;
        (function (PieChart) {
            var Selection = (function (_super) {
                __extends(Selection, _super);
                function Selection(chart) {
                    _super.call(this);
                    /** after layout */
                    this.animationOrder = 1100;
                    this.paintOrder = 10;
                    this.updateOrder = 1200;
                    this.currentSlice = null;
                    this.currentLabel = null;
                    this.currentPie = null;
                    this.hoveringLegend = false;
                    this.draggedLabelSlice = null;
                    this.draggedLabel = null;
                    this.hoverEvent = null;
                    this.dragStartConditions = {
                        angle: Infinity,
                        distance: Infinity,
                        slice: null,
                        pie: null
                    };
                    this.isScrolling = false;
                    this.px = 0;
                    this.py = 0;
                    this.chart = chart;
                    this.scene = chart.scene;
                    this.events = chart.events;
                    // Since swipe-selection and scrolling drag events can be handled by both classes simultaneously,
                    // they can't be added as separate chart elements, because of event consumption.
                    // Thus selection handles the events, and forwards them to the respective interactions.
                    this.scrolling = new PieChart.Scrolling(chart);
                }
                Selection.prototype.doAnimations = function (event) {
                    // update hover
                    if (this.hoverEvent) {
                        this.onPointerMove(this.hoverEvent);
                    }
                };
                Selection.prototype.previewPointerDrag = function (event) {
                    this.hoverEvent = event;
                };
                Selection.prototype.onPointerMove = function (event) {
                    this.hoverEvent = event;
                    this.updateCurrentObject(event);
                };
                Selection.prototype.onPointerOut = function (event) {
                    this.updateCurrentObject(event);
                    this.switchCurrentSlice(null, null, false, event);
                    this.hoverEvent = null;
                };
                Selection.prototype.onPointerDown = function (event) {
                    this.handlePointerDown(event);
                    this.scrolling.handlePointerDown(event);
                };
                Selection.prototype.handlePointerDown = function (event) {
                    this.updateCurrentObject(event);
                    var current = this.currentSlice;
                    if (current || this.currentPie)
                        event.consumed = true;
                    this.px = event.x;
                    this.py = event.y;
                    var selectiion = this.scene.settings.interaction.selection;
                    if (selectiion.swipe || selectiion.partialSwipe) {
                        var isettings = this.scene.settings.interaction;
                        var pie = this.scene.pies[0];
                        var useCenterForPrevious = pie && isettings.others.centerGoesToPrevious && pie.previousSlice;
                        var useCenterForSlices = isettings.coverCenter && !useCenterForPrevious && (!pie || !pie.background);
                        var pieSlice = this.scene.findSliceAt(event.x, event.y, isettings.selection.tolerance, useCenterForSlices);
                        this.dragStartConditions.slice = null;
                        this.dragStartConditions.pie = null;
                        this.dragStartConditions.distance = Infinity;
                        this.dragStartConditions.angle = 0;
                        if (pieSlice && pieSlice.id !== null) {
                            this.dragStartConditions.slice = current;
                            this.dragStartConditions.pie = pie;
                            var dx = event.x - pie.x;
                            var dy = event.y - pie.y;
                            var distance = Math.sqrt(dx * dx + dy * dy);
                            this.dragStartConditions.distance = distance - current.currentCutoutDistance;
                            this.dragStartConditions.angle = Math.atan2(dy, dx) * 180 / Math.PI;
                        }
                    }
                    var findLabelAtResult = this.scene.findLabelAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
                    this.draggedLabelSlice = findLabelAtResult.slice;
                    this.draggedLabel = findLabelAtResult.label;
                    this.draggedLabel = null;
                    this.draggedLabelSlice = null;
                };
                Selection.prototype.onPointerDrag = function (event) {
                    this.handlePointerDrag(event);
                    this.scrolling.handlePointerDrag(event);
                };
                Selection.prototype.handlePointerDrag = function (event) {
                    var selection = this.scene.settings.interaction.selection;
                    if (!this.isScrolling) {
                        // tolerance for pointer movements
                        if (event.distance({ x: this.px, y: this.py }) < selection.swipeSensitivity) {
                            return;
                        }
                        this.isScrolling = true;
                    }
                    if ((selection.swipe || selection.partialSwipe) && (this.currentSlice || this.dragStartConditions.slice)) {
                        var dragStartSlice = this.dragStartConditions.slice;
                        if (dragStartSlice !== null) {
                            var pie = this.dragStartConditions.pie;
                            var startDistance = this.dragStartConditions.distance;
                            var startAngle = this.dragStartConditions.angle;
                            if (startAngle === Infinity) {
                                startAngle = Math.atan2(event.y - pie.y, event.x - pie.x) * 180 / Math.PI;
                            }
                            var dx = event.x - pie.x;
                            var dy = event.y - pie.y;
                            var currAngle = Math.atan2(dy, dx) * 180 / Math.PI;
                            var midAngle = Math.abs(startAngle - currAngle);
                            if (midAngle <= 90) {
                                var dragLength = Math.sqrt(dx * dx + dy * dy);
                                if (this.dragStartConditions.distance === Infinity)
                                    startDistance = dragLength - dragStartSlice.currentCutoutDistance;
                                var dragInside = (this.scene.innerRadius >= dragStartSlice.selectDistance / 2) ? -dragStartSlice.selectDistance / 2 : 0;
                                var projToDragStart = dragLength * Math.cos(midAngle * Math.PI / 180);
                                var dragOverAllowable = projToDragStart - startDistance > selection.maxSwipeDistance;
                                var dragOutside = projToDragStart - startDistance > dragInside;
                                // handle user defined position
                                dragStartSlice.userPlaced = true;
                                if (dragOverAllowable) {
                                    dragStartSlice.currentCutoutDistance = selection.maxSwipeDistance;
                                }
                                else if (dragOutside) {
                                    dragStartSlice.currentCutoutDistance = (projToDragStart - startDistance > dragInside) ? (projToDragStart - startDistance) | 0 : 0;
                                }
                                dragStartSlice.selection = dragStartSlice.currentCutoutDistance > 0
                                    ? (dragStartSlice.currentCutoutDistance / selection.maxSwipeDistance) * 100
                                    : 0;
                                event.changes.pie = true;
                            }
                        }
                    }
                    if (this.draggedLabel) {
                        var label = this.draggedLabel;
                        label.userPlaced = true;
                        label.x += event.dx;
                        label.y += event.dy;
                        event.consumed = true;
                        event.changes.pie = true;
                    }
                };
                Selection.prototype.onPointerUp = function (event) {
                    this.handlePointerUp(event);
                    this.scrolling.handlePointerUp(event);
                };
                Selection.prototype.handlePointerUp = function (event) {
                    this.isScrolling = false;
                    var selection = this.scene.settings.interaction.selection;
                    if (selection.swipe || selection.partialSwipe) {
                        var lastActive = this.dragStartConditions.slice;
                        if (lastActive) {
                            var shouldSelect = lastActive.currentCutoutDistance >= lastActive.selectDistance / 2 && !lastActive.selected;
                            var shouldDeselect = lastActive.currentCutoutDistance < lastActive.selectDistance / 2 && lastActive.selected;
                            if (selection.swipe || (lastActive.currentCutoutDistance <= 0 && selection.partialSwipe)) {
                                lastActive.userPlaced = false;
                            }
                            else if (selection.partialSwipe) {
                                lastActive.userPlaced = true;
                            }
                            if (shouldDeselect || shouldSelect) {
                                this.updateSelection(event, lastActive, false);
                            }
                            else if (lastActive.currentCutoutDistance >= lastActive.selectDistance / 2 && lastActive.selected) {
                                this.setSelection([lastActive], [], true);
                            }
                        }
                    }
                    if (this.draggedLabel) {
                        this.draggedLabel = null;
                        event.consumed = true;
                    }
                };
                Selection.prototype.onPointerCancel = function (event) {
                    this.onPointerUp(event);
                };
                Selection.prototype.onClick = function (event) {
                    this.onPointerMove(event);
                    var args = this.createClickArgs(event);
                    if (args.clickOrigin !== "legend" || this.chart.settings.legend.interaction.click) {
                        this.chart.notifyClick(event, this.createClickArgs(event));
                        if (this.currentSlice || this.currentPie) {
                            event.consumed = true;
                        }
                        if (!event.defaultPrevented) {
                            this.updateSelection(event, this.currentSlice, false);
                        }
                    }
                    if (event.touch) {
                        // clear the hover state on touch click.
                        var origX = event.x;
                        event.x = 1e9;
                        this.onPointerOut(event);
                        // revert, otherwise the event is broken if the parent chart still has to process it.
                        event.x = origX;
                    }
                };
                Selection.prototype.onRightClick = function (event) {
                    this.onPointerMove(event);
                    if (this.currentSlice || this.currentPie) {
                        event.consumed = true;
                    }
                    this.chart.notifyRightClick(event, this.createClickArgs(event));
                    if (event.defaultPrevented) {
                        event.consumed = true;
                    }
                };
                Selection.prototype.onDoubleClick = function (event) {
                    this.onPointerMove(event);
                    this.chart.notifyDoubleClick(event, this.createClickArgs(event));
                    event.consumed = true;
                };
                Selection.prototype.onTripleClick = function (event) {
                    this.onPointerMove(event);
                    this.chart.notifyTripleClick(event, this.createClickArgs(event));
                    event.consumed = true;
                };
                Selection.prototype.createClickArgs = function (event) {
                    var args = this.chart.createEventArguments(event, "user");
                    var n = args.hoverSlice;
                    args.clickSlice = n;
                    args.clickPie = n ? n.pie : args.hoverPie;
                    args.clickLabel = args.hoverLabel;
                    if (n) {
                        var label = args.clickLabel;
                        if (this.hoveringLegend) {
                            args.clickOrigin = "legend";
                        }
                        else if (label) {
                            if (label === n.currentInsideLabel) {
                                args.clickOrigin = "insideLabel";
                            }
                            else {
                                args.clickOrigin = "label";
                            }
                        }
                        else {
                            args.clickOrigin = "slice";
                        }
                    }
                    else if (this.scene.hoverBack) {
                        args.clickOrigin = "back";
                    }
                    return args;
                };
                Selection.prototype.updateSelection = function (event, target, softDeselect) {
                    if (!this.scene.settings.interaction.selection.enabled) {
                        return;
                    }
                    var shift = event.shiftKey;
                    var toggle = this.scene.settings.interaction.mode === "toggle" || event.ctrlKey;
                    if (target) {
                        if (shift || (softDeselect && target.selected) || (toggle && !target.selected)) {
                            if (!target.selected) {
                                this.scene.selection.push(target);
                                target.selected = true;
                                this.setSelection(this.scene.selection, this.scene.selectionIds, true);
                            }
                        }
                        else if (toggle && target.selected) {
                            Internal.Base.Helpers.removeFromArray(this.scene.selection, target);
                            target.selected = false;
                            this.setSelection(this.scene.selection, this.scene.selectionIds, true);
                        }
                        else if (!target.selected || this.scene.selection.length > 1) {
                            this.setSelection([target]);
                        }
                        else {
                            this.setSelection([]);
                        }
                    }
                    else {
                        // no target
                        if (!shift && !toggle) {
                            this.setSelection([]);
                        }
                    }
                };
                Selection.prototype.switchCurrentSlice = function (obj, label, hoveringLegend, event) {
                    if (obj === this.currentSlice && label === this.currentLabel && this.hoveringLegend === hoveringLegend) {
                        return;
                    }
                    event.changes.current = true;
                    if (this.scene.hoverSlice) {
                        this.scene.hoverSlice.active = false;
                    }
                    if (this.scene.hoverPie) {
                        this.scene.hoverPie.active = false;
                    }
                    this.scene.hoverSlice = obj;
                    this.scene.hoverPie = null;
                    this.scene.hoverLabel = label;
                    this.currentSlice = obj;
                    this.currentLabel = label;
                    this.currentPie = null;
                    this.hoveringLegend = hoveringLegend;
                    if (obj) {
                        obj.active = true;
                    }
                    this.events.notifySceneChanges({ pie: true });
                    this.chart.notifyHoverChanged(event, this.chart.createEventArguments(event, "user"));
                };
                Selection.prototype.switchCurrentPie = function (obj, event) {
                    if (obj === this.currentPie) {
                        return;
                    }
                    event.changes.current = true;
                    if (this.scene.hoverSlice) {
                        this.scene.hoverSlice.active = false;
                    }
                    if (this.scene.hoverPie) {
                        this.scene.hoverPie.active = false;
                    }
                    this.scene.hoverPie = obj;
                    this.scene.hoverSlice = null;
                    this.currentSlice = null;
                    this.currentPie = obj;
                    this.hoveringLegend = false;
                    if (obj) {
                        obj.active = true;
                    }
                    this.events.notifySceneChanges({ pie: true });
                    this.chart.notifyHoverChanged(event, this.chart.createEventArguments(event, "user"));
                };
                Selection.prototype.onSceneChange = function (event) {
                    if (event.changes.pie) {
                        if (this.updateSelectionIds()) {
                            this.events.notifySceneChanges({ selection: true });
                            this.chart.notifySelectionChanged(this.chart.createEventArguments(null, "api"));
                        }
                    }
                };
                Selection.prototype.updateSelectionIds = function () {
                    /* process selectionIds
                    add to selected if seen on the main pie */
                    var slicesToSelect = [];
                    for (var idIndex = 0; idIndex < this.scene.selectionIds.length; idIndex++) {
                        var id = this.scene.selectionIds[idIndex];
                        for (var pieIndex = 0; pieIndex < this.scene.pies.length; pieIndex++) {
                            var pie = this.scene.pies[pieIndex];
                            if (pie.background) {
                                continue;
                            }
                            for (var sliceIndex = 0; sliceIndex < pie.slices.length; sliceIndex++) {
                                var slice = pie.slices[sliceIndex];
                                if (slice.id === id) {
                                    slicesToSelect.push(slice);
                                    break;
                                }
                            }
                        }
                    }
                    if (slicesToSelect.length > 0) {
                        for (var sliceIndex = 0; sliceIndex < slicesToSelect.length; sliceIndex++) {
                            var slice = slicesToSelect[sliceIndex];
                            if (!slice.selected) {
                                slice.selected = true;
                                this.scene.selection.push(slice);
                            }
                            Internal.Base.Helpers.removeFromArray(this.scene.selectionIds, slice.id);
                        }
                    }
                    return slicesToSelect.length > 0;
                };
                Selection.prototype.setSelection = function (selection, selectionIds, alreadyChanged, origin) {
                    if (selectionIds === void 0) { selectionIds = []; }
                    if (alreadyChanged === void 0) { alreadyChanged = false; }
                    if (origin === void 0) { origin = "user"; }
                    this.scene.selectionIds = selectionIds;
                    var hasChanges;
                    if (alreadyChanged) {
                        hasChanges = true;
                    }
                    else {
                        for (var sIndex = 0; sIndex < this.scene.selection.length; sIndex++) {
                            var s = this.scene.selection[sIndex];
                            if (selection.indexOf(s) < 0) {
                                s.selected = false;
                                hasChanges = true;
                            }
                        }
                        for (var sIndex = 0; sIndex < selection.length; sIndex++) {
                            var s = selection[sIndex];
                            if (!s.selected) {
                                s.selected = true;
                                hasChanges = true;
                            }
                        }
                        this.scene.selection = selection;
                    }
                    var changedIds = this.updateSelectionIds();
                    hasChanges = hasChanges || changedIds;
                    if (hasChanges) {
                        this.events.notifySceneChanges({ selection: true });
                        this.chart.notifySelectionChanged(this.chart.createEventArguments(null, origin));
                    }
                };
                Selection.prototype.updateCurrentObject = function (event) {
                    var scene = this.scene;
                    var isettings = scene.settings.interaction;
                    var pie = scene.findPieAt(event.x, event.y, isettings.selection.tolerance);
                    var useCenterForPrevious = pie && isettings.others.centerGoesToPrevious && pie.previousSlice;
                    var useCenterForSlices = isettings.coverCenter && !useCenterForPrevious && (!pie || !pie.background);
                    var slice;
                    var label = scene.findLabelAt(event.x, event.y, isettings.selection.tolerance);
                    var legend = false;
                    if (label.slice) {
                        slice = label.slice;
                    }
                    else {
                        slice = scene.findSliceAt(event.x, event.y, isettings.selection.tolerance, useCenterForSlices);
                    }
                    var chartLegend = this.chart.legend;
                    if (!slice && chartLegend) {
                        slice = chartLegend.getLastHoveredSlice();
                        if (slice)
                            legend = true;
                    }
                    if (slice) {
                        if (this.chart.settings.legend.interaction.click)
                            event.cursor = "pointer";
                        event.hovered = true;
                    }
                    this.switchCurrentSlice(slice, label.label, legend, event);
                    if (pie && (pie.background || useCenterForPrevious) && !slice) {
                        event.cursor = "pointer";
                        event.hovered = true;
                        if (pie.background) {
                            this.switchCurrentPie(pie, event);
                        }
                        else {
                            this.switchCurrentSlice(pie.previousSlice, null, false, event);
                            this.switchCurrentPie(null, event);
                        }
                        scene.hoverBack = true;
                    }
                    else {
                        this.switchCurrentPie(null, event);
                        scene.hoverBack = false;
                    }
                };
                return Selection;
            }(Internal.Base.ChartElement));
            PieChart.Selection = Selection;
        })(PieChart = Internal.PieChart || (Internal.PieChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Scene.ts" />
/// <reference path="../base/core/ChartEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var PieChart;
        (function (PieChart) {
            var Styles = (function (_super) {
                __extends(Styles, _super);
                function Styles(chart) {
                    _super.call(this);
                    this.animationOrder = 100;
                    this.paintOrder = 25;
                    this.updateOrder = 900;
                    this.chart = chart;
                    this.scene = chart.scene;
                }
                Styles.needStyleUpdate = function (changes) {
                    return changes.settings || changes.pie || changes.selection || changes.style;
                };
                Styles.prototype.onSceneChange = function (event) {
                    if (!Styles.needStyleUpdate(event.changes))
                        return;
                    for (var pieIndex = 0; pieIndex < this.scene.pies.length; pieIndex++) {
                        var pie = this.scene.pies[pieIndex];
                        this.updatePie(pie);
                        this.computePieColors(pie);
                        for (var sliceIndex = 0; sliceIndex < pie.allSlices.length; sliceIndex++) {
                            var slice = pie.allSlices[sliceIndex];
                            this.updateSlice(slice, sliceIndex);
                        }
                    }
                };
                Styles.prototype.updatePie = function (pie) {
                    Internal.Base.Helpers.extendStyleTo(this.scene.settings.pie.style, pie);
                    if (pie.slices.length === 0)
                        Internal.Base.Helpers.extendStyleTo(this.scene.settings.pie.noDataStyle, pie);
                    if (pie.background)
                        Internal.Base.Helpers.extendStyleTo(this.scene.settings.pie.backgroundStyle, pie);
                    if (this.scene.hoverPie === pie)
                        Internal.Base.Helpers.extendStyleTo(this.scene.settings.pie.backgroundHoveredStyle, pie);
                    if (this.scene.settings.pie.styleFunction)
                        this.scene.settings.pie.styleFunction.call(this.chart.api, pie, pie.data);
                };
                /** default colors assingment */
                Styles.prototype.computePieColors = function (pie) {
                    var colors = pie.sliceColors;
                    var colorMode = pie.colorDistribution;
                    var sliceCount = 0;
                    for (var sliceIndex = 0; sliceIndex < pie.slices.length; sliceIndex++) {
                        var slice = pie.slices[sliceIndex];
                        if (!slice.removed) {
                            sliceCount += 1;
                        }
                    }
                    if (sliceCount === 1) {
                        pie.slices[0].fillColor = colors[0];
                        return;
                    }
                    if (colors.length === 1) {
                        var col = colors[0];
                        // using the fast blending on purpose since blending to #FFF looks better on RGB
                        colors = [
                            col,
                            Internal.Base.Colors.blend(col, "#fff", 0.8)
                        ];
                    }
                    var colorCount = colors.length;
                    if (colorMode === "gradient") {
                        var pos = 0;
                        for (var sliceIndex = 0; sliceIndex < pie.slices.length; sliceIndex++) {
                            var slice = pie.slices[sliceIndex];
                            if (slice.removed) {
                                continue;
                            }
                            var c0 = colors[(pos * (colorCount - 1)) | 0];
                            var c1 = colors[(pos * (colorCount - 1) + 1) | 0];
                            var cp = pos * (colorCount - 1);
                            cp = cp - Math.floor(cp);
                            var col = Internal.Base.Colors.blend(c0, c1, cp, false);
                            slice.fillColor = col;
                            pos += 1 / (sliceCount - 0.9);
                        }
                    }
                    else if (colorMode === "gradientProportional") {
                        var pos = 0;
                        for (var sliceIndex = 0; sliceIndex < pie.slices.length; sliceIndex++) {
                            var slice = pie.slices[sliceIndex];
                            if (slice.removed) {
                                continue;
                            }
                            var c0 = colors[(pos * (colorCount - 1)) | 0];
                            var c1 = colors[(pos * (colorCount - 1) + 1) | 0];
                            var cp = pos * (colorCount - 1);
                            cp = cp - Math.floor(cp);
                            var col = Internal.Base.Colors.blend(c0, c1, cp, false);
                            slice.fillColor = col;
                            pos += slice.fraction;
                        }
                    }
                    else {
                        // list
                        for (var i = 0; i < pie.slices.length; i++) {
                            var slice = pie.slices[i];
                            if (slice.removed) {
                                continue;
                            }
                            var col = colors[(pie.offset + i) % colorCount];
                            var round = (i / colorCount) | 0;
                            if (round === 1) {
                                col = Internal.Base.Colors.derive(col, 1.5, 1);
                            }
                            else if (round >= 2) {
                                col = Internal.Base.Colors.derive(col, 0.5, 1);
                            }
                            slice.fillColor = col;
                        }
                    }
                };
                Styles.prototype.updateSlice = function (slice, index) {
                    if (slice.removed) {
                        return;
                    }
                    var pie = slice.pie;
                    var config = this.scene.settings.slice;
                    var styleFunc = config.styleFunction;
                    slice.expandable = this.scene.mainData.canExpand(slice.id);
                    Internal.Base.Helpers.extendDeep(slice, config.style);
                    // color special slices
                    if (slice === pie.othersSlice) {
                        Internal.Base.Helpers.extendDeep(slice, config.othersStyle);
                    }
                    else if (slice === pie.previousSlice) {
                        Internal.Base.Helpers.extendDeep(slice, config.previousStyle);
                    }
                    if (pie.total > 0) {
                        slice.percent = slice.value / pie.total * 100;
                    }
                    else {
                        slice.percent = 0;
                    }
                    var label = slice.label;
                    if (label.text) {
                        label.text += " ";
                    }
                    else {
                        label.text = "";
                    }
                    if (slice.data.name)
                        label.text += slice.data.name + " ";
                    label.text += slice.percent.toFixed(1) + "%";
                    slice.cutoutDistance = (slice.selected) ? slice.selectDistance : 0;
                    if (this.scene.hoverSlice === slice) {
                        Internal.Base.Helpers.extendDeep(slice, config.hoverStyle);
                    }
                    if (slice.data.style) {
                        Internal.Base.SettingsHelper.updateRecursive(slice, slice.data.style, Internal.Base.SettingsMapping.PieChartSettingsSliceStyle, {});
                    }
                    if (styleFunc) {
                        slice._resetLabelText = true;
                        styleFunc.call(this.chart.api, slice, slice.data);
                    }
                    if (pie.background) {
                        if (pie.activeSliceId !== slice.id) {
                            Internal.Base.Helpers.extendDeep(slice, config.backgroundStyle);
                            if (index % 2 === 1) {
                                slice.fillColor = slice.fillColor2;
                            }
                        }
                        else {
                            Internal.Base.Helpers.extendDeep(slice, config.backgroundActiveStyle);
                        }
                    }
                    // compute targetLineColor and targetFillColor
                    var targetFillColor = "rgba(255,255,255,0)";
                    if (slice.fillColor) {
                        targetFillColor = slice.fillColor;
                    }
                    var targetLineColor = "rgba(255,255,255,0)";
                    if (slice.lineColor) {
                        targetLineColor = slice.lineColor;
                    }
                    else if (slice.lineBrightness) {
                        targetLineColor = Internal.Base.Colors.derive(targetFillColor, slice.lineBrightness, 1);
                    }
                    var brightness = slice.brightness * pie.brightness;
                    if (brightness !== 1) {
                        targetFillColor = Internal.Base.Colors.derive(targetFillColor, brightness, 1);
                        targetLineColor = Internal.Base.Colors.derive(targetLineColor, brightness, 1);
                        if (targetFillColor.indexOf("255,255,255") !== -1 && targetLineColor.indexOf("255,255,255") !== -1) {
                            targetLineColor = "rgb(200,200,200)";
                        }
                    }
                    if (pie.removed && pie.parentSlice) {
                        // if removed set fill colors to that of parent slice
                        slice.targetFillColor = pie.parentSlice.targetFillColor;
                        slice.targetLineColor = pie.parentSlice.targetLineColor;
                    }
                    else {
                        slice.targetFillColor = Internal.Base.Colors.normalize(targetFillColor);
                        slice.targetLineColor = Internal.Base.Colors.normalize(targetLineColor);
                    }
                };
                return Styles;
            }(Internal.Base.ChartElement));
            PieChart.Styles = Styles;
        })(PieChart = Internal.PieChart || (Internal.PieChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/DomLayer.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var PieChart;
        (function (PieChart) {
            var DomLayer = (function (_super) {
                __extends(DomLayer, _super);
                function DomLayer(chart) {
                    _super.call(this, chart);
                }
                DomLayer.prototype.createDom = function (shell) {
                    _super.prototype.createDom.call(this, shell);
                    this.backgroundImage.className += " DVSL-PC-background-image";
                    this.backgroundImage.style.display = "none";
                };
                DomLayer.prototype.doAnimations = function (event) {
                    _super.prototype.doAnimations.call(this, event);
                    // Place the background image inside the center of the pie.
                    // note that currently no check for `event.changes` is done since the size has to be changed during animations.
                    if (this.scene.settings.area.style.image && this.scene.pies.length > 0) {
                        var r = this.scene.currentInnerRadius - this.scene.settings.pie.margin;
                        var x = this.scene.pies[0].x;
                        var y = this.scene.pies[0].y;
                        // prevent the background from rendering while the data is not initialized
                        if ((x !== 0 || y !== 0) && r > 0) {
                            this.backgroundImage.style.left = Math.round(x - r) + "px";
                            this.backgroundImage.style.top = Math.round(y - r) + "px";
                            this.backgroundImage.style.width = Math.round(r * 2) + "px";
                            this.backgroundImage.style.height = Math.round(r * 2) + "px";
                            this.backgroundImage.style.display = "";
                        }
                        else {
                            this.backgroundImage.style.display = "none";
                        }
                    }
                };
                return DomLayer;
            }(Internal.Base.DomLayer));
            PieChart.DomLayer = DomLayer;
        })(PieChart = Internal.PieChart || (Internal.PieChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/core/ChartEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var PieChart;
        (function (PieChart) {
            var Scrolling = (function () {
                function Scrolling(chart) {
                    this.pie = null;
                    this.chart = chart;
                    this.scene = chart.scene;
                    this.events = chart.events;
                }
                Scrolling.prototype.handlePointerDown = function (event) {
                    if (!this.scene.settings.interaction.scrolling.enabled) {
                        return;
                    }
                    if (this.pointer) {
                        // On multi touch events, only the 1st pointer would be taken in account
                        return;
                    }
                    this.pointer = event.identifier;
                    this.pie = this.scene.peek();
                };
                Scrolling.prototype.handlePointerDrag = function (event) {
                    if (!this.pie) {
                        return;
                    }
                    if (!this.scene.settings.interaction.scrolling.enabled) {
                        return;
                    }
                    event.consumed = true;
                    // Only one pointer is taken in account while scrolling
                    if (event.identifier !== this.pointer) {
                        return;
                    }
                    this.pie.scrollOffset += this.scene.view.getMovement(this.pie, event).dfraction;
                    this.updatePieScrolling(this.pie);
                    event.changes.pie = true;
                };
                Scrolling.prototype.handlePointerUp = function (event) {
                    if (!this.scene.settings.interaction.scrolling.enabled) {
                        return;
                    }
                    if (event.identifier !== this.pointer) {
                        return;
                    }
                    this.updatePieAfterScroll(this.pie);
                    this.pie = null;
                    this.pointer = null;
                };
                Scrolling.prototype.updatePieScrolling = function (pie) {
                    if (pie.scrollOffset > 0 && pie.offset === 0) {
                        pie.scrollOffset = 0;
                    }
                    if (pie.scrollOffset !== 0) {
                        return this.scene.view.updatePie(this.pie, false);
                    }
                };
                Scrolling.prototype.updatePieAfterScroll = function (pie) {
                    /* animate/snap to full slices (with animation) */
                    pie.scrollOffset = 0;
                    return this.scene.view.updatePie(pie, true);
                };
                return Scrolling;
            }());
            PieChart.Scrolling = Scrolling;
        })(PieChart = Internal.PieChart || (Internal.PieChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/core/ChartEvents.ts" />
/// <reference path="../base/Navigator.ts" />
/// <reference path="Scene.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var PieChart;
        (function (PieChart) {
            var Navigator = (function (_super) {
                __extends(Navigator, _super);
                function Navigator(chart) {
                    _super.call(this);
                    this.animationOrder = 250;
                    this.paintOrder = 30;
                    this.updateOrder = 650;
                    this.chart = chart;
                    this.scene = chart.scene;
                    this.events = chart.events;
                }
                Navigator.prototype.onNewDataObject = function () {
                    // nothing here
                };
                Navigator.prototype.setPie = function (id, offset, origin) {
                    if (!Array.isArray(id)) {
                        id = [id];
                    }
                    this.scene.pendingAction = null;
                    var changes = 0;
                    while (this.scene.length() > id.length) {
                        this.scene.pop();
                        changes++;
                    }
                    while (this.scene.length() > 0 && this.scene.peek().id !== id[this.scene.length() - 1]) {
                        this.scene.pop();
                        changes++;
                    }
                    while (this.scene.length() < id.length) {
                        // try to find origin slice
                        var pie_1 = new PieChart.Pie();
                        pie_1.id = id[this.scene.length()];
                        pie_1.offset = (this.scene.length() + 1 === id.length) ? offset : 0;
                        this.scene.push(pie_1);
                        this.scene.view.updatePie(pie_1);
                        changes++;
                    }
                    var pie = this.scene.peek();
                    if (pie && pie.offset !== offset) {
                        this.scroll(pie, offset);
                        changes++;
                    }
                    else {
                        if (changes && pie) {
                            this.scene.view.updatePie(pie);
                        }
                    }
                    if (changes) {
                        this.chart.notifyChartUpdate(origin);
                        this.events.notifySceneChanges({ pie: true });
                    }
                };
                Navigator.prototype.getPie = function () {
                    return this.scene.stack.map(function (pie) { return pie.id; });
                };
                Navigator.prototype.getPieOffset = function () {
                    return this.scene.peek().offset;
                };
                Navigator.prototype.goBack = function (origin) {
                    var len = this.scene.length();
                    if (len === 1) {
                        this.goPrevious(this.scene.peek(), origin, 0);
                    }
                    else if (len > 1) {
                        this.scene.pop();
                        this.scene.pendingAction = null;
                        this.updateAndNotifyCurrent(origin);
                    }
                };
                Navigator.prototype.goCenter = function (origin) {
                    var pie = this.scene.peek();
                    if (pie.offset > 0 && this.scene.settings.interaction.others.centerGoesToPrevious) {
                        this.goPrevious(pie, origin);
                    }
                    else if (this.scene.length() > 1) {
                        this.scene.pop();
                        this.scene.pendingAction = null;
                        this.updateAndNotifyCurrent(origin);
                    }
                };
                Navigator.prototype.drillDown = function (pieId, origin) {
                    this.scene.pendingAction = null;
                    var pie = new PieChart.Pie();
                    pie.id = pieId;
                    pie.offset = 0;
                    this.scene.push(pie);
                    this.updateAndNotifyCurrent(origin);
                };
                Navigator.prototype.goOthers = function (pie, origin) {
                    var ready = this.scene.view.scrollForward(pie, pie.offset + pie.count);
                    if (!ready) {
                        this.scene.pendingAction = "forward";
                        this.scene.pendingOffset = null;
                    }
                    this.events.notifySceneChanges({ pie: true });
                    this.chart.notifyChartUpdate(origin);
                };
                Navigator.prototype.goPrevious = function (pie, origin, newOffset) {
                    if (newOffset === void 0) { newOffset = null; }
                    if (pie.offset <= 0) {
                        return;
                    }
                    var ready = this.scene.view.scrollBackward(pie, newOffset);
                    if (!ready) {
                        this.scene.pendingAction = "back";
                        this.scene.pendingOffset = null;
                    }
                    this.chart.notifyChartUpdate(origin);
                    this.events.notifySceneChanges({ pie: true });
                };
                Navigator.prototype.scroll = function (pie, offset) {
                    var ready = true;
                    if (pie.offset > offset) {
                        ready = this.scene.view.scrollBackward(pie, offset);
                        if (!ready) {
                            this.scene.pendingAction = "back";
                            this.scene.pendingOffset = offset;
                        }
                    }
                    else if (pie.offset < offset) {
                        ready = this.scene.view.scrollForward(pie, offset);
                        if (!ready) {
                            this.scene.pendingAction = "forward";
                            this.scene.pendingOffset = offset;
                        }
                    }
                };
                Navigator.prototype.updateAndNotifyCurrent = function (origin) {
                    var pie = this.scene.peek();
                    this.scene.view.updatePie(pie);
                    this.chart.notifyChartUpdate(origin);
                    this.events.notifySceneChanges({ pie: true });
                };
                Navigator.prototype.expandSlice = function (slice, origin) {
                    var pie = slice.pie;
                    if (pie === this.scene.peek()) {
                        if (slice === pie.othersSlice) {
                            this.chart.setSelection([]);
                            this.goOthers(pie, origin);
                            return true;
                        }
                        else if (slice === pie.previousSlice) {
                            this.chart.setSelection([]);
                            this.goPrevious(pie, origin);
                            return true;
                        }
                        else {
                            var id = slice.id;
                            if (slice.expandable && this.scene.mainData.canExpand(id)) {
                                this.chart.setSelection([]);
                                this.drillDown(id, origin);
                                return true;
                            }
                        }
                    }
                    else {
                        this.chart.setSelection([]);
                        this.goBack(origin);
                        return true;
                    }
                    return false;
                };
                Navigator.prototype.onSceneChange = function (event) {
                    var activePieReady = false;
                    var activePie = this.scene.peek();
                    if (event.changes.data || event.changes.pieChartPieIds || event.changes.dataArrived) {
                        var ids = event.changes.pieChartPieIds || Object.create(null);
                        // new data object is set
                        for (var pieIndex = 0; pieIndex < this.scene.stack.length; pieIndex++) {
                            var pie = this.scene.stack[pieIndex];
                            if (ids[pie.id] || !pie.data || pie === activePie || event.changes.dataDeep) {
                                if (pie === activePie) {
                                    var ready = void 0;
                                    if (this.scene.pendingAction === "forward") {
                                        ready = this.scene.view.scrollForward(pie, this.scene.pendingOffset);
                                    }
                                    else if (this.scene.pendingAction === "back") {
                                        ready = this.scene.view.scrollBackward(pie, this.scene.pendingOffset);
                                    }
                                    else {
                                        ready = this.scene.view.updatePie(pie);
                                    }
                                    if (ready) {
                                        this.scene.pendingAction = null;
                                        this.scene.pendingOffset = null;
                                    }
                                    activePieReady = ready;
                                }
                                else {
                                    this.scene.view.updatePie(pie);
                                }
                                event.changes.pie = true;
                            }
                        }
                    }
                    if (activePieReady) {
                        this.chart.notifyChartUpdate("data", true);
                    }
                };
                return Navigator;
            }(Internal.Base.Navigator));
            PieChart.Navigator = Navigator;
        })(PieChart = Internal.PieChart || (Internal.PieChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/InfoPopup.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var PieChart;
        (function (PieChart) {
            var InfoPopup = (function (_super) {
                __extends(InfoPopup, _super);
                function InfoPopup(chart) {
                    _super.call(this);
                    this.currentSlice = null;
                    this.animationOrder = 500;
                    this.paintOrder = 15;
                    this.updateOrder = 1100;
                    this.activePointer = null;
                    this.chart = chart;
                    this.scene = chart.scene;
                    this.options = this.scene.settings;
                    this.events = chart.events;
                    this.popup = new Internal.Base.InfoPopup(chart);
                }
                InfoPopup.prototype.previewPointerMove = function (event) {
                    if (this.activePointer !== null && this.activePointer !== event.identifier) {
                        return;
                    }
                    var y = event.y;
                    var x = event.x;
                    if (!this.options.info.enabled)
                        return;
                    // when the hover originates from the legend, do not show info popup since it duplicates the information shown
                    // potentially this could be configured in the settings - could be useful if the info popup contents are customized.
                    if (this.chart.legend && this.chart.legend.containsCoordinate(x, y))
                        return;
                    var slice = this.scene.hoverSlice;
                    var pie = this.scene.hoverPie;
                    if (pie && !slice) {
                        slice = pie.getActiveSlice();
                    }
                    this.setCurrentObject(x, y, slice);
                };
                InfoPopup.prototype.previewRightClick = function (event) {
                    if (event.touch) {
                        this.activePointer = event.identifier;
                        this.previewPointerMove(event);
                    }
                };
                InfoPopup.prototype.previewPointerCancel = function (event) {
                    if (this.activePointer !== null && this.activePointer === event.identifier) {
                        this.activePointer = null;
                    }
                };
                InfoPopup.prototype.previewPointerUp = function (event) {
                    if (this.activePointer !== null && this.activePointer === event.identifier) {
                        this.activePointer = null;
                    }
                };
                InfoPopup.prototype.previewPointerDown = function (event) {
                    if (this.activePointer !== null) {
                        return;
                    }
                    this.activePointer = event.identifier;
                    this.hide();
                };
                InfoPopup.prototype.previewPointerDrag = function (event) {
                    if (this.activePointer !== null && this.activePointer !== event.identifier) {
                        return;
                    }
                    this.hide();
                };
                InfoPopup.prototype.previewPointerOut = function (event) {
                    if ((this.activePointer !== null && this.activePointer !== event.identifier) || event.touch) {
                        return;
                    }
                    this.hide();
                };
                InfoPopup.prototype.hide = function () {
                    this.activePointer = null;
                    this.setCurrentObject(0, 0, null);
                };
                InfoPopup.prototype.setCurrentObject = function (x, y, obj) {
                    if (!obj) {
                        this.currentSlice = null;
                        this.popup.hide();
                    }
                    else {
                        if (obj !== this.currentSlice) {
                            var contents = this.buildContents(obj);
                            this.popup.show(x, x, y, contents);
                        }
                        else {
                            this.popup.updateXY(x, x, y);
                        }
                        this.currentSlice = obj;
                    }
                };
                InfoPopup.prototype.buildContents = function (slice) {
                    var _this = this;
                    if (this.options.info.contentsFunction) {
                        var callback = function (contents) {
                            if (slice === _this.currentSlice) {
                                return _this.popup.updateContents(contents);
                            }
                        };
                        return this.options.info.contentsFunction.call(this.chart.api, slice.data, slice, callback);
                    }
                    else {
                        return slice.label.text;
                    }
                };
                return InfoPopup;
            }(Internal.Base.ChartElement));
            PieChart.InfoPopup = InfoPopup;
        })(PieChart = Internal.PieChart || (Internal.PieChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/core/ChartEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var PieChart;
        (function (PieChart) {
            var Animations = (function () {
                function Animations(chart) {
                    this.prevTime = 0;
                    this.radiusAnimator = null;
                    this.innerRadiusAnimator = null;
                    this.chart = chart;
                    this.scene = chart.scene;
                    this.events = chart.events;
                }
                Animations.prototype.doAnimations = function (event) {
                    var dt = 0;
                    if (this.prevTime) {
                        dt = Math.min(30, event.timeStamp - this.prevTime);
                    }
                    var transitionDuration = this.scene.settings.interaction.animation.scrollDuration;
                    var hoverDuration = this.scene.settings.interaction.animation.hoverDuration;
                    var time = event.timeStamp;
                    var piesToRemove = [];
                    var changedPies = [];
                    var radiusChanges = false;
                    if (this.scene.settings.pie.adaptiveRadius) {
                        if (!this.innerRadiusAnimator) {
                            this.innerRadiusAnimator = new Internal.Base.Animator(0, this.scene.innerRadius, transitionDuration, "<>", time);
                            this.radiusAnimator = new Internal.Base.Animator(0, this.scene.radius, transitionDuration, "<>", time);
                        }
                        var updateAndGetResult = this.radiusAnimator.updateAndGet(this.scene.radius, time);
                        this.scene.currentRadius = updateAndGetResult.value;
                        var c0 = updateAndGetResult.changes;
                        updateAndGetResult = this.innerRadiusAnimator.updateAndGet(this.scene.innerRadius, time);
                        this.scene.currentInnerRadius = updateAndGetResult.value;
                        var c1 = updateAndGetResult.changes;
                        radiusChanges = radiusChanges || (c0 || c1);
                        event.animating = event.animating || radiusChanges;
                    }
                    else if (this.scene.currentRadius !== this.scene.radius || this.scene.currentInnerRadius !== this.scene.innerRadius) {
                        radiusChanges = true;
                        this.scene.currentRadius = this.scene.radius;
                        this.scene.currentInnerRadius = this.scene.innerRadius;
                    }
                    // let diff = this.scene.currentRadius - this.scene.currentInnerRadius;
                    // let minRad = (diff > 0) ? (-this.scene.currentInnerRadius / diff) : 0;
                    for (var pieIndex = 0; pieIndex < this.scene.pies.length; pieIndex++) {
                        var pie = this.scene.pies[pieIndex];
                        // when Styles.needStyleUpdate() == true, the styleFunction-s are called and those can change any
                        // number of important properties on pies and slices.
                        var pieChanges = event.changes.bounds || PieChart.Styles.needStyleUpdate(event.changes);
                        // removal
                        var removePie = false;
                        if (pie.removed === true && pie.removeTime === null) {
                            pie.removeTime = time + transitionDuration;
                        }
                        if (pie.removed) {
                            event.animating = true;
                            removePie = pie.removeTime < time;
                        }
                        if (!removePie) {
                            if (!pie._animatorA0) {
                                pieChanges = true;
                                pie._animatorA0 = new Internal.Base.Animator(pie.currentStartAngle, pie.startAngle, transitionDuration, "<>", time);
                                pie._animatorA1 = new Internal.Base.Animator(pie.currentEndAngle, pie.endAngle, transitionDuration, "<>", time);
                                pie._animatorR0 = new Internal.Base.Animator(pie.currentInnerRadius, pie.innerRadius, transitionDuration, "<>", time);
                                pie._animatorR1 = new Internal.Base.Animator(pie.currentRadius, pie.radius, transitionDuration, "<>", time);
                                if (!this.scene.settings.advanced.initialAnimation) {
                                    pie._animatorA0.jump(pie.startAngle);
                                    pie._animatorA1.jump(pie.endAngle);
                                    pie._animatorR0.jump(pie.innerRadius);
                                    pie._animatorR1.jump(pie.radius);
                                }
                            }
                            if (pie.rotationSpeed) {
                                if (pie.currentStartAngle === null) {
                                    // the initial setup (happens in the first frame).
                                    pie.currentStartAngle = pie.startAngle;
                                    pie.currentEndAngle = pie.endAngle;
                                }
                                else {
                                    var delta = event.dtime * pie.rotationSpeed / 1000;
                                    pie.currentStartAngle += delta;
                                    pie.currentEndAngle += delta;
                                }
                                pie.currentlyRotating = true;
                                pieChanges = true;
                            }
                            else if (pie.currentlyRotating) {
                                var pi2 = 2 * Math.PI;
                                pie._animatorA0.reset(pie.currentStartAngle % pi2 - pi2, pie.startAngle, event.timeStamp);
                                pie._animatorA1.reset(pie.currentEndAngle % pi2, pie.endAngle, event.timeStamp);
                                pie.currentlyRotating = false;
                                pieChanges = true;
                            }
                            else {
                                var startAngleAnim = pie._animatorA0.updateAndGet(pie.startAngle, time);
                                pie.currentStartAngle = startAngleAnim.value;
                                pieChanges = pieChanges || startAngleAnim.changes;
                                var endAngleAnim = pie._animatorA1.updateAndGet(pie.endAngle, time);
                                pie.currentEndAngle = endAngleAnim.value;
                                pieChanges = pieChanges || endAngleAnim.changes;
                            }
                            var radiusAnim = pie._animatorR1.updateAndGet(pie.radius, time);
                            pie.currentRadius = radiusAnim.value;
                            pieChanges = pieChanges || radiusAnim.changes;
                            radiusAnim = pie._animatorR0.updateAndGet(pie.innerRadius, time);
                            pie.currentInnerRadius = radiusAnim.value;
                            pieChanges = pieChanges || radiusAnim.changes;
                            pie.currentInnerRadius = Math.min(pie.currentInnerRadius, pie.currentRadius);
                            var slicesToRemove = [];
                            var totalCurrentFraction = 0;
                            for (var sliceIndex = 0; sliceIndex < pie.allSlices.length; sliceIndex++) {
                                var slice = pie.allSlices[sliceIndex];
                                if (!slice._animatorF) {
                                    pieChanges = true;
                                    slice._animatorF = new Internal.Base.Animator(slice.currentFraction, slice.fraction, transitionDuration, "<>", time);
                                }
                                var updateAndGetFixedResult = slice._animatorF.updateAndGetFixed(slice.fraction, time);
                                slice.currentFraction = updateAndGetFixedResult.value;
                                pieChanges = pieChanges || updateAndGetFixedResult.changes;
                                if (slice.removed && slice.currentFraction === 0) {
                                    slicesToRemove.push(slice);
                                }
                                totalCurrentFraction += slice.currentFraction;
                            }
                            if (Math.abs(totalCurrentFraction - 1) > 0.001) {
                                // this check handles situations when the current animations are of different
                                // durations and thus the sum of currentFractions does not cover the whole pie.
                                totalCurrentFraction = 1 / totalCurrentFraction;
                                for (var sliceIndex = 0; sliceIndex < pie.allSlices.length; sliceIndex++) {
                                    var slice = pie.allSlices[sliceIndex];
                                    slice.currentFraction *= totalCurrentFraction;
                                }
                            }
                            if (slicesToRemove.length > 0) {
                                pieChanges = true;
                                for (var sliceIndex = 0; sliceIndex < slicesToRemove.length; sliceIndex++) {
                                    var slice = slicesToRemove[sliceIndex];
                                    Internal.Base.Helpers.removeFromArray(pie.slices, slice);
                                    Internal.Base.Helpers.removeFromArray(pie.allSlices, slice);
                                    if (slice === pie.othersSlice) {
                                        pie.othersSlice = null;
                                    }
                                    if (slice === pie.previousSlice) {
                                        pie.previousSlice = null;
                                    }
                                }
                            }
                            for (var sliceIndex = 0; sliceIndex < pie.allSlices.length; sliceIndex++) {
                                var slice = pie.allSlices[sliceIndex];
                                if (!slice._animatorLineColor) {
                                    pieChanges = true;
                                    slice._animatorLineColor = new Internal.Base.ColorAnimator(slice.currentLineColor, slice.targetLineColor, hoverDuration, "<>", time);
                                    slice._animatorFillColor = new Internal.Base.ColorAnimator(slice.currentFillColor, slice.targetFillColor, hoverDuration, "<>", time);
                                    slice._animatorCutout = new Internal.Base.Animator(slice.currentCutoutDistance, slice.cutoutDistance, hoverDuration, "<>", time);
                                }
                                var lineAnimator = slice._animatorLineColor;
                                var fillAnimator = slice._animatorFillColor;
                                var cutoutAnimator = slice._animatorCutout;
                                var updateColorAndGetResult = lineAnimator.updateAndGet(slice.targetLineColor, time);
                                slice.currentLineColor = updateColorAndGetResult.value;
                                pieChanges = pieChanges || updateColorAndGetResult.changes;
                                updateColorAndGetResult = fillAnimator.updateAndGet(slice.targetFillColor, time);
                                slice.currentFillColor = updateColorAndGetResult.value;
                                pieChanges = pieChanges || updateColorAndGetResult.changes;
                                if (!slice.userPlaced) {
                                    var updateAndGetResult = cutoutAnimator.updateAndGet(slice.cutoutDistance, time);
                                    slice.currentCutoutDistance = updateAndGetResult.value;
                                    pieChanges = pieChanges || updateAndGetResult.changes;
                                }
                                else {
                                    cutoutAnimator.jump(slice.currentCutoutDistance);
                                }
                            }
                            if (pieChanges || radiusChanges) {
                                changedPies.push(pie);
                            }
                            event.animating = event.animating || pieChanges;
                        }
                        else {
                            piesToRemove.push(pie);
                        }
                    }
                    for (var pieIndex = 0; pieIndex < piesToRemove.length; pieIndex++) {
                        var pie = piesToRemove[pieIndex];
                        this.scene.deletePie(pie);
                    }
                    this.prevTime = time;
                    return changedPies;
                };
                return Animations;
            }());
            PieChart.Animations = Animations;
        })(PieChart = Internal.PieChart || (Internal.PieChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/core/ChartEvents.ts" />
/// <reference path="../base/Animator.ts" />
/// <reference path="../base/Geometry.ts" />
/// <reference path="Scene.ts" />
/// <reference path="../base/Label.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var PieChart;
        (function (PieChart) {
            var PieLayout = (function () {
                function PieLayout(chart, view) {
                    this.view = view;
                    this.chart = chart;
                    this.scene = chart.scene;
                    this.events = chart.events;
                }
                PieLayout.prototype.placeStack = function (pie, context) {
                    var scene = this.scene;
                    var settings = scene.settings;
                    var pieSettings = settings.pie;
                    var stack = scene.stack;
                    var depth = pieSettings.depth;
                    var pieChanges = false;
                    var height = scene.height - depth * 2;
                    height = Math.max(2, height);
                    var x = pieSettings.x;
                    var y = pieSettings.y;
                    if (x === null) {
                        x = scene.x0 + scene.width / 2;
                    }
                    else if (x >= 0 && x <= 1) {
                        x = scene.x0 + scene.width * x;
                    }
                    if (y === null) {
                        y = scene.y0 + height / 2;
                    }
                    else if (y >= 0 && y <= 1) {
                        y = scene.y0 + scene.height * y;
                    }
                    var startAngle = settings.pie.startAngle;
                    var endAngle = settings.pie.endAngle;
                    var rotationSpeed = settings.pie.rotationSpeed;
                    if (pie.x !== x
                        || pie.y !== y
                        || startAngle !== pie.startAngle
                        || endAngle !== pie.endAngle
                        || rotationSpeed !== pie.rotationSpeed) {
                        pieChanges = true;
                        pie.x = x;
                        pie.y = y;
                        pie.startAngle = startAngle;
                        pie.endAngle = endAngle;
                        pie.rotationSpeed = rotationSpeed;
                    }
                    var maxR = Math.min(height / 2, scene.width / 2);
                    maxR -= settings.pie.outerMargin;
                    var radius = settings.pie.radius;
                    if (!radius) {
                        if (settings.labels.enabled && settings.pie.adaptiveRadius) {
                            var chartR = this.computeDesiredRadiusFromLabels(pie, context);
                            chartR = Math.min(maxR, chartR);
                            chartR -= settings.labels.connectorLength;
                            chartR = Math.max(chartR, maxR / 3);
                            radius = chartR;
                        }
                        else {
                            radius = maxR;
                        }
                    }
                    else if (radius <= 1) {
                        radius = maxR * radius;
                    }
                    var innerRadius = settings.pie.innerRadius;
                    if (innerRadius < 1) {
                        innerRadius = radius * innerRadius;
                    }
                    if (stack.length > 1) {
                        var innerMinRadius = settings.pie.innerRadiusWhenDrilldown;
                        if (innerMinRadius < 1) {
                            innerMinRadius = radius * innerMinRadius;
                        }
                        innerRadius = Math.max(innerRadius, innerMinRadius);
                    }
                    var mul = 0;
                    var add = 0;
                    if (radius !== innerRadius) {
                        mul = 1 / (radius - innerRadius);
                        add = -innerRadius * mul;
                    }
                    if (scene.radius !== radius || scene.innerRadius !== innerRadius) {
                        pieChanges = true;
                        scene.radius = radius;
                        scene.innerRadius = innerRadius;
                    }
                    pie.radius = 1;
                    pie.innerRadius = innerRadius * mul + add;
                    // place subpies inside master pie
                    var pieIndex = stack.length - 1;
                    if (pieIndex > 0) {
                        innerRadius = innerRadius - settings.pie.margin;
                        var remainingSlices = pieIndex;
                        var radiusStep = Math.max(0, Math.min(radius - innerRadius, (innerRadius - settings.pie.centerMargin) / remainingSlices));
                        for (var i = pieIndex - 1; i >= 0; i--) {
                            radius = innerRadius;
                            innerRadius -= radiusStep;
                            pie = stack[i];
                            y += depth;
                            pie.x = x;
                            pie.y = y;
                            pie.radius = radius * mul + add;
                            pie.innerRadius = (innerRadius + settings.pie.margin) * mul + add;
                            pie.brightness = 0.8 - 0.8 * (remainingSlices - i - 1) / remainingSlices;
                            pie.startAngle = settings.pie.startAngle;
                            pie.endAngle = settings.pie.endAngle;
                        }
                    }
                    // update removed pies
                    for (pieIndex = 0; pieIndex < scene.pies.length; pieIndex++) {
                        pie = scene.pies[pieIndex];
                        if (pie.removed && pie.parentSlice) {
                            var getSliceTargetAnglesResult = scene.getSliceTargetAngles(pie.parentSlice);
                            pie.startAngle = getSliceTargetAnglesResult.a0;
                            pie.endAngle = getSliceTargetAnglesResult.a1;
                        }
                    }
                    return pieChanges;
                };
                PieLayout.prototype.computeDesiredRadiusFromLabels = function (pie, g) {
                    var config = this.scene.settings.slice.style.label;
                    var labelLayout = new LabelLayout(g, 1, 0, 100, 0, 100, config, this.scene.settings.labels);
                    var padding = config.padding * 2;
                    var labelHeight = labelLayout.lineHeight + padding;
                    var leftLongestWord = 0;
                    var rightLongestWord = 0;
                    var leftLabelArea = 0;
                    var rightLabelArea = 0;
                    var fsum = 0;
                    var startAngle = pie.startAngle;
                    var endAngle = pie.endAngle;
                    var da = endAngle - startAngle;
                    var astart = pie.startAngle;
                    var sliceAngle1 = astart;
                    for (var sliceIndex = 0; sliceIndex < pie.slices.length; sliceIndex++) {
                        var slice = pie.slices[sliceIndex];
                        var sliceAngle0 = sliceAngle1;
                        fsum = Math.min(1, fsum + slice.fraction);
                        sliceAngle1 = astart + fsum * da;
                        var a0 = Math.max(sliceAngle0, startAngle);
                        var a1 = Math.min(sliceAngle1, endAngle);
                        // slice not visible
                        if (a0 >= endAngle || a1 <= startAngle) {
                            continue;
                        }
                        if (slice.label.text) {
                            var longestWord = "";
                            for (var wIndex = 0, wSource = slice.label.text.split(" "); wIndex < wSource.length; wIndex++) {
                                var wrd = wSource[wIndex];
                                if (wrd.length > longestWord.length) {
                                    longestWord = wrd;
                                }
                            }
                            var l = Internal.Base.Graphics.getTextWidth(g, slice.label.textStyle, longestWord) + padding;
                            var w = Internal.Base.Graphics.getTextWidth(g, slice.label.textStyle, slice.label.text) + padding;
                            var a = labelHeight * w * 1.2;
                            var rightSide = ((a0 + a1) / 2 + Math.PI / 2) % (2 * Math.PI) <= Math.PI;
                            if (rightSide) {
                                rightLabelArea += a;
                                rightLongestWord = Math.max(rightLongestWord, l);
                            }
                            else {
                                leftLabelArea += a;
                                leftLongestWord = Math.max(leftLongestWord, l);
                            }
                        }
                    }
                    Internal.Base.Graphics.clearShadow(g);
                    // compute radius from area
                    var effectiveHeight = Math.min(this.scene.width, this.scene.height);
                    var availableArea = this.scene.width * effectiveHeight;
                    var chartArea = Math.max(1, availableArea - 2 * Math.max(leftLabelArea, rightLabelArea) * 1.2);
                    var radiusByArea = Math.sqrt(chartArea / Math.PI);
                    // compute radius from longest word
                    var lw = Math.max(leftLongestWord, rightLongestWord);
                    var radiusByLongestWord = this.scene.width / 2 - lw * 1.1;
                    return Math.min(radiusByArea, radiusByLongestWord);
                };
                PieLayout.prototype.placeLabels = function (pie, g) {
                    if (!this.chart.assetsLoaded)
                        return;
                    var iconConfig = this.scene.settings.icons;
                    var config = this.scene.settings.labels;
                    var sliceConfig = this.scene.settings.slice;
                    var labelsEnabled = config.enabled;
                    var iconMinSize = iconConfig.sizeExtent[0];
                    var iconMaxSize = iconConfig.sizeExtent[1];
                    var iconPlacement = iconConfig.placement;
                    var iconAutohide = iconConfig.autohideWhenTooSmall;
                    if (this.scene.settings.advanced.iconMinSize) {
                        iconMinSize = this.scene.settings.advanced.iconMinSize;
                    }
                    var margin = sliceConfig.margin;
                    var x = pie.x;
                    var y = pie.y;
                    var add = this.scene.currentInnerRadius;
                    var mul = this.scene.currentRadius - add;
                    var pr0 = pie.currentInnerRadius * mul + add;
                    var pr1 = pie.currentRadius * mul + add;
                    var fsum = 0;
                    var startAngle = pie.currentStartAngle;
                    var endAngle = pie.currentEndAngle;
                    var da = endAngle - startAngle;
                    var astart = pie.currentStartAngle;
                    var left = this.scene.x0 - x;
                    var right = left + this.scene.width;
                    var top = this.scene.y0 - y;
                    var bottom = top + this.scene.height;
                    var insideLabelLayout = new LabelLayout(g, pr1, left, right, top, bottom, sliceConfig.style.insideLabel, this.scene.settings.labels);
                    var outsideLabelLayout = new LabelLayout(g, pr1, left, right, top, bottom, sliceConfig.style.label, this.scene.settings.labels);
                    var leftOutsideLabels = [];
                    var rightOutsideLabels = [];
                    var sliceAngle1 = astart;
                    for (var sliceIndex = 0; sliceIndex < pie.allSlices.length; sliceIndex++) {
                        var slice = pie.allSlices[sliceIndex];
                        var sliceAngle0 = sliceAngle1;
                        fsum = Math.min(1, fsum + slice.currentFraction);
                        sliceAngle1 = astart + fsum * da;
                        var a0 = Math.max(sliceAngle0, startAngle);
                        var a1 = Math.min(sliceAngle1, endAngle);
                        var r0 = pr0 + slice.currentCutoutDistance;
                        var r1 = pr1 + slice.currentCutoutDistance;
                        var angleMiddle = (a0 + a1) / 2; // the middle of slice
                        if (!slice.removed && !pie.background) {
                            if (slice.insideLabel.text && labelsEnabled) {
                                var text_1 = slice.insideLabel.text;
                                var label = void 0;
                                if (!slice.currentInsideLabel) {
                                    label = slice.currentInsideLabel = new Internal.Base.Label(slice.insideLabel, true);
                                }
                                else {
                                    label = slice.currentInsideLabel;
                                }
                                if (slice.currentInsideLabel.text !== text_1) {
                                    label.text = text_1;
                                }
                                var insideLablelProp = insideLabelLayout.fitLabelInSlice(g, label, r0, r1, a0, a1);
                                label.shouldBeVisible = label.visible = config.insideLabel === "always" || insideLablelProp >= config.insideLabelVisibilityFraction;
                            }
                            else {
                                slice.currentInsideLabel = null;
                            }
                            var text = (slice.label.text && labelsEnabled) ? slice.label.text : "";
                            if (config.insideLabel === "append"
                                && slice.insideLabel.text
                                && labelsEnabled
                                && !slice.currentInsideLabel.userPlaced
                                && !slice.currentInsideLabel.shouldBeVisible) {
                                if (text) {
                                    x = Math.cos(angleMiddle);
                                    if (x > 0) {
                                        text = slice.insideLabel.text + ", " + text;
                                    }
                                    else {
                                        text = text + ", " + slice.insideLabel.text;
                                    }
                                }
                                else {
                                    text = slice.insideLabel.text;
                                }
                            }
                            if (text) {
                                var label = null;
                                if (!slice.currentLabel) {
                                    label = slice.currentLabel = new Internal.Base.Label(slice.label, true);
                                }
                                else {
                                    label = slice.currentLabel;
                                }
                                if (slice.currentLabel.text !== text) {
                                    label.text = text;
                                }
                                if (!label.userPlaced) {
                                    outsideLabelLayout.placeOutsideLabelInitial(label, angleMiddle);
                                }
                                if (label.x > 0) {
                                    label.style.align = "left";
                                    rightOutsideLabels.push(label);
                                }
                                else {
                                    label.style.align = "right";
                                    leftOutsideLabels.push(label);
                                }
                            }
                            else {
                                slice.currentLabel = null;
                            }
                        }
                        else {
                            slice.currentLabel = null;
                            slice.currentInsideLabel = null;
                        }
                        // place icons
                        var icon = null;
                        if (slice.icon && (!pie.background || slice.id === pie.activeSliceId)) {
                            var fitBoxInSliceResult = insideLabelLayout.fitBoxInSlice(1, 1, r0, r1, a0, a1);
                            x = fitBoxInSliceResult.x;
                            y = fitBoxInSliceResult.y;
                            var iconSize = fitBoxInSliceResult.prop;
                            iconSize -= margin;
                            if (!iconAutohide || iconSize * 2 >= iconMinSize) {
                                iconSize = Math.max(Math.min(iconSize, iconMaxSize / 2), iconMinSize / 2);
                                icon = new PieChart.Icon();
                                icon.hwidth = iconSize;
                                icon.hheight = iconSize;
                                icon.inside = true;
                                if (slice.iconOffset) {
                                    icon.x = 0;
                                    icon.y = 0;
                                    this.applyOffset(icon, slice.iconOffset, r0, r1, a0, a1);
                                }
                                else if (iconPlacement === "center") {
                                    icon.x = 0;
                                    icon.y = 0;
                                    this.applyOffset(icon, [0, 0, 0, 0], r0, r1, a0, a1);
                                }
                                else {
                                    icon.x = x;
                                    icon.y = y;
                                }
                            }
                            else {
                            }
                        }
                        slice.currentIcon = icon;
                    }
                    outsideLabelLayout.computeOutsideLabelLocations(g, leftOutsideLabels, rightOutsideLabels);
                };
                PieLayout.prototype.applyOffset = function (item, offset, r0, r1, a0, a1) {
                    var dx = 0;
                    var dy = 0;
                    if (offset.length >= 2) {
                        dx = offset[0];
                        dy = offset[1];
                    }
                    var oc = 0;
                    var oa = 0;
                    if (offset.length >= 4) {
                        oc = offset[2];
                        oa = offset[3];
                    }
                    var offsetCenter = r0 + (r1 - r0) * (oc + 1) / 2;
                    var offsetAngle = a0 + (a1 - a0) * (oa + 1) / 2;
                    dx += Math.cos(offsetAngle) * offsetCenter;
                    dy += Math.sin(offsetAngle) * offsetCenter;
                    item.x += dx;
                    item.y += dy;
                };
                return PieLayout;
            }());
            PieChart.PieLayout = PieLayout;
            var LabelLayout = (function (_super) {
                __extends(LabelLayout, _super);
                function LabelLayout(g, r1, left, right, top, bottom, labelStyle, config) {
                    _super.call(this);
                    this.config = config;
                    this.bottom = bottom;
                    this.top = top;
                    this.right = right;
                    this.left = left;
                    this.margin = labelStyle.margin || 0;
                    this.rr = r1 + config.connectorLength;
                    this.lineHeight = Internal.Base.Graphics.getTextHeight(g, labelStyle.textStyle.font);
                    this.interLabelSpacing = Math.max(config.interLabelSpacing * this.lineHeight, this.margin);
                }
                LabelLayout.prototype.placeOutsideLabelInitial = function (label, angle) {
                    var x = this.rr * Math.cos(angle);
                    var y = this.rr * Math.sin(angle);
                    var shortenProp = 1;
                    if (y < this.top) {
                        shortenProp = Math.min(shortenProp, this.top / y);
                    }
                    if (y > this.bottom) {
                        shortenProp = Math.min(shortenProp, this.bottom / y);
                    }
                    if (x < this.left) {
                        shortenProp = Math.min(shortenProp, this.left / x);
                    }
                    if (x > this.right) {
                        shortenProp = Math.min(shortenProp, this.right / x);
                    }
                    label.x = x * shortenProp;
                    label.y = y * shortenProp;
                };
                LabelLayout.prototype.computeOutsideLabelLocations = function (g, leftLabels, rightLabels) {
                    var bottom = this.bottom - this.margin;
                    var top = this.top + this.margin;
                    var labelSpacing = this.interLabelSpacing;
                    leftLabels.sort(function (a, b) { return (b.y - a.y); });
                    rightLabels.sort(function (a, b) { return (a.y - b.y); });
                    // save x for later
                    for (var labelIndex = 0; labelIndex < leftLabels.length; labelIndex++) {
                        var label = leftLabels[labelIndex];
                        label.originX = label.x;
                    }
                    for (var labelIndex = 0; labelIndex < rightLabels.length; labelIndex++) {
                        var label = rightLabels[labelIndex];
                        label.originX = label.x;
                    }
                    var alignVariants = (this.config.placement === "wrap") ? ([false]) : ([true, false]);
                    for (var alignedIndex = 0; alignedIndex < alignVariants.length; alignedIndex++) {
                        var aligned = alignVariants[alignedIndex];
                        // first try aligned and then unaligned
                        var worstProp = 100;
                        var hasMultiline = false;
                        for (var labelsIndex = 0; labelsIndex < 2; labelsIndex++) {
                            var labels = labelsIndex === 0 ? leftLabels : rightLabels;
                            // fit labels in available space, one by one
                            for (var labelIndex = 0; labelIndex < labels.length; labelIndex++) {
                                var label = labels[labelIndex];
                                label.prop = this.fitLabelOutside(g, label, aligned);
                            }
                            // adjust label locations to eliminate overlaps
                            var maxHeight = bottom - top;
                            var visibleLabels = [];
                            var height = 0;
                            for (var labelIndex = 0; labelIndex < labels.length; labelIndex++) {
                                var label = labels[labelIndex];
                                if (label.visible) {
                                    var h = label.hheight * 2 + labelSpacing;
                                    if (height + h < maxHeight) {
                                        visibleLabels.push(label);
                                        height += h;
                                    }
                                    else {
                                        label.visible = label.userPlaced;
                                        // need to hide labels = not good placement
                                        worstProp = 0.5;
                                    }
                                }
                            }
                            // do sweep
                            var labelBottom = bottom;
                            var labelTop = top;
                            if (labels === leftLabels) {
                                labelTop += height;
                            }
                            else {
                                labelBottom -= height;
                            }
                            for (var labelIndex = 0; labelIndex < visibleLabels.length; labelIndex++) {
                                var label = visibleLabels[labelIndex];
                                if (labels === leftLabels) {
                                    // pop height from top
                                    labelTop -= label.hheight * 2 + labelSpacing;
                                }
                                else {
                                    labelBottom += label.hheight * 2 + labelSpacing;
                                }
                                if (!label.userPlaced && (label.y + label.hheight > labelBottom || label.y - label.hheight < labelTop)) {
                                    // move Y to respect top and bottom
                                    label.y = Math.min(Math.max(label.y, labelTop + label.hheight), labelBottom - label.hheight);
                                    // update location after y changed
                                    var prop = this.fitLabelOutside(g, label, aligned);
                                    worstProp = Math.min(prop, worstProp);
                                    hasMultiline = hasMultiline || (label.rows && label.rows.subLines[label.rows.subLines.length - 1].row > 0);
                                }
                                else {
                                    worstProp = Math.min(worstProp, label.prop);
                                }
                                if (labels === leftLabels) {
                                    labelBottom = label.y - label.hheight - labelSpacing;
                                }
                                else {
                                    labelTop = label.y + label.hheight + labelSpacing;
                                }
                            }
                        }
                        // break after aligned if all is fine
                        if (worstProp >= 1 || !hasMultiline) {
                            break;
                        }
                    }
                };
                LabelLayout.prototype.fitLabelOutside = function (g, label, aligned) {
                    var _this = this;
                    if (aligned === void 0) { aligned = false; }
                    if (aligned == null)
                        aligned = false; // ported from CoffeeScript;
                    var locationFunc = function (hheight) {
                        if (label.userPlaced) {
                            return _this.getOutsideMaxWidth(label.x, label.y, hheight, false);
                        }
                        else {
                            return _this.placeOutsideMaxWidth(label.originX, label.y, hheight, aligned);
                        }
                    };
                    return this.fitLabelInRect(g, label, locationFunc);
                };
                LabelLayout.prototype.fitLabelInSlice = function (g, label, r0, r1, a0, a1) {
                    var _this = this;
                    // figure out alignment
                    var a = Math.cos(a0);
                    var b = Math.cos(a1);
                    var left = Math.min(a, b);
                    var right = Math.max(a, b);
                    var noSpaceAlign;
                    if ((left < 0 && right < 0) || -left > right * 2) {
                        noSpaceAlign = "right";
                    }
                    else if ((left > 0 && right > 0) || -left * 2 < right) {
                        noSpaceAlign = "left";
                    }
                    else {
                        noSpaceAlign = "center";
                    }
                    var x;
                    var y;
                    // compute center X and Y
                    if (label.userPlaced) {
                        x = label.x;
                        y = label.y;
                    }
                    else {
                        var rprop = void 0;
                        // simple best guess for now
                        if (r0 * 2 >= r1) {
                            rprop = 0.5;
                        }
                        else {
                            rprop = 0.5 + (r1 - r0 * 2) / r1 / 4;
                        }
                        var rm = r0 + (r1 - r0) * rprop;
                        var am = (a0 + a1) / 2;
                        var cosa = Math.cos(am);
                        var sina = Math.sin(am);
                        x = rm * cosa;
                        y = rm * sina;
                    }
                    var top = y - this.rayIntersectsSlice(x, y, 0, -1, r0, r1, a0, a1);
                    var bottom = y + this.rayIntersectsSlice(x, y, 0, 1, r0, r1, a0, a1);
                    var sliceLocationFunc = function (xx, yy) {
                        // test if height fits in slice
                        if (!(r1 > 0) || yy <= top || yy >= bottom) {
                            return [1e-5, 1e-5];
                        }
                        // compute max width
                        var le = _this.rayIntersectsSlice(xx, yy, -1, 0, r0, r1, a0, a1);
                        var ri = _this.rayIntersectsSlice(xx, yy, 1, 0, r0, r1, a0, a1);
                        return [le, ri];
                    };
                    return this.fitLabelInLines(g, label, x, y, "center", noSpaceAlign, sliceLocationFunc);
                };
                LabelLayout.prototype.placeOutsideMaxWidth = function (x, y, hheight, aligned) {
                    var radius = this.rr;
                    // fit top/bottom inside bounds
                    var ltop = y - hheight / 2;
                    var lbottom = ltop + hheight;
                    if (ltop < this.top) {
                        var diff = this.top - ltop;
                        ltop += diff;
                        lbottom += diff;
                    }
                    if (lbottom > this.bottom) {
                        var diff = this.bottom - lbottom;
                        ltop += diff;
                        lbottom += diff;
                    }
                    // find , right
                    var lleft = this.left;
                    var lright = this.right;
                    var distanceFromCenter;
                    if (aligned) {
                        distanceFromCenter = radius;
                    }
                    else {
                        if (ltop > radius || lbottom < -radius) {
                            distanceFromCenter = 0;
                        }
                        else if (ltop > 0) {
                            distanceFromCenter = Math.sqrt(radius * radius - ltop * ltop);
                        }
                        else if (lbottom < 0) {
                            distanceFromCenter = Math.sqrt(radius * radius - lbottom * lbottom);
                        }
                        else {
                            distanceFromCenter = radius;
                        }
                    }
                    if (x > 0) {
                        lleft = Math.max(distanceFromCenter, x);
                    }
                    else {
                        lright = Math.min(x, -distanceFromCenter);
                    }
                    return {
                        x: (lleft + lright) / 2,
                        y: (ltop + lbottom) / 2,
                        dx: 1,
                        dy: 0,
                        width: lright - lleft
                    };
                };
                LabelLayout.prototype.getOutsideMaxWidth = function (x, y, hheight, aligned) {
                    // fit top/bottom inside bounds
                    var ltop = y - hheight / 2;
                    var lbottom = ltop + hheight;
                    // find , right
                    var lleft = this.left;
                    var lright = this.right;
                    var radius = this.rr;
                    var distanceFromCenter;
                    if (aligned) {
                        distanceFromCenter = radius;
                    }
                    else {
                        if (ltop > radius || lbottom < -radius) {
                            distanceFromCenter = 0;
                        }
                        else if (ltop > 0) {
                            distanceFromCenter = Math.sqrt(radius * radius - ltop * ltop);
                        }
                        else if (lbottom < 0) {
                            distanceFromCenter = Math.sqrt(radius * radius - lbottom * lbottom);
                        }
                        else {
                            distanceFromCenter = radius;
                        }
                    }
                    if (x > 0) {
                        lleft = distanceFromCenter;
                    }
                    else {
                        lright = -distanceFromCenter;
                    }
                    // find closest distance to obstacle
                    var dist = Math.min(Math.abs(x - lleft), Math.abs(x - lright));
                    return {
                        x: x,
                        y: y,
                        dx: 1,
                        dy: 0,
                        width: dist * 2
                    };
                };
                LabelLayout.prototype.fitBoxInSlice = function (hwidth, hheight, r0, r1, a0, a1) {
                    // simple best guess for now
                    var rprop = 0.5 + (r1 - r0) / r1 / 4;
                    var rm = r0 + (r1 - r0) * rprop;
                    var am = (a0 + a1) / 2;
                    var cosa = Math.cos(am);
                    var sina = Math.sin(am);
                    var x = rm * cosa;
                    var y = rm * sina;
                    // compute max label size
                    var dx = hwidth;
                    var dy = hheight;
                    var d0 = this.rayIntersectsSlice(x, y, dx, dy, r0, r1, a0, a1);
                    var d1 = this.rayIntersectsSlice(x, y, -dx, dy, r0, r1, a0, a1);
                    var d2 = this.rayIntersectsSlice(x, y, -dx, -dy, r0, r1, a0, a1);
                    var d3 = this.rayIntersectsSlice(x, y, dx, -dy, r0, r1, a0, a1);
                    var prop = Math.min(d0, d1, d2, d3);
                    return { x: x, y: y, prop: prop };
                };
                /** computes point where ray (x0,y0, dx,dy) intersects slice (0,0,r0,r1,a0,a1)
                x0,y0 is assumed to be inside the slice
                returns distance along dx,dy to travel to get to intersection */
                LabelLayout.prototype.rayIntersectsSlice = function (x0, y0, dx, dy, r0, r1, a0, a1) {
                    // test top and bottom circles
                    var d = Internal.Base.Geometry.rayIntersectsCircle(x0, y0, dx, dy, r0);
                    d = Math.min(d, Internal.Base.Geometry.rayIntersectsCircle(x0, y0, dx, dy, r1));
                    // left line
                    var cosa = Math.cos(a0);
                    var sina = Math.sin(a0);
                    d = Math.min(d, Internal.Base.Geometry.rayIntersectsSegment(x0, y0, dx, dy, r0 * cosa, r0 * sina, r1 * cosa, r1 * sina));
                    // right line
                    cosa = Math.cos(a1);
                    sina = Math.sin(a1);
                    d = Math.min(d, Internal.Base.Geometry.rayIntersectsSegment(x0, y0, dx, dy, r0 * cosa, r0 * sina, r1 * cosa, r1 * sina));
                    return d;
                };
                return LabelLayout;
            }(Internal.Base.LabelLayoutBase));
            PieChart.LabelLayout = LabelLayout;
        })(PieChart = Internal.PieChart || (Internal.PieChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var PieChart;
        (function (PieChart) {
            var Renderers;
            (function (Renderers) {
                var CommonBase = (function () {
                    function CommonBase(renderer) {
                        this.renderer = renderer;
                        this.settings = this.renderer.settings;
                    }
                    CommonBase.prototype.paintPie = function (context, x, y, r0, r1, a0, a1, pie) {
                        if (pie.fillColor) {
                            context.beginPath();
                            context.arc(x, y, r1, a0, a1, false);
                            context.arc(x, y, r0, a1, a0, true);
                            context.closePath();
                            Internal.Base.Graphics.fill(context, pie);
                        }
                    };
                    CommonBase.prototype.paintExpandableHilights = function (context, piex, piey, slices) {
                        // each slice has .renderParams field with [innerRadius, outerRadius,outLeft, outerRight,  innerLeft, innerRight]
                        var distance = this.settings.slice.expandableMarkStyle.distance;
                        var style = this.settings.slice.expandableMarkStyle;
                        if (style.lineWidth <= 0)
                            return;
                        for (var sliceIndex = 0; sliceIndex < slices.length; sliceIndex++) {
                            var slice = slices[sliceIndex];
                            if (!slice.expandable) {
                                continue;
                            }
                            var params = slice._renderParams;
                            var x = piex + slice.x;
                            var y = piey + slice.y;
                            var r0 = params[0];
                            var r1 = params[1];
                            var r = Math.max((r0 + r1) / 2, r1 - distance);
                            var oa0 = params[2];
                            var oa1 = params[3];
                            context.beginPath();
                            context.arc(x, y, r, oa0, oa1);
                            Internal.Base.Graphics.paint(context, style);
                        }
                    };
                    CommonBase.prototype.strokeSlice = function (context, x, y, slice) {
                        /* each slice has .renderParams field with:
                        0 -> innerRadius (r0)
                        1 -> outerRadius (r1)
                        2 -> outerLeft - angle in radians
                        3 -> outerRight - angle in radians
                        4 -> innerLeft - angle in radians
                        5 -> innerRight - angle in radians */
                        var params = slice._renderParams;
                        x = x + slice.x;
                        y = y + slice.y;
                        var r0 = params[0];
                        var r1 = params[1];
                        var oa0 = params[2];
                        var oa1 = params[3];
                        var ia0 = params[4];
                        var ia1 = params[5];
                        var perimeter = r1 * Math.abs(oa1 - oa0);
                        var width = r1 - r0;
                        var offset = Math.min(0.1 * Math.min(perimeter, width), 3);
                        if (r0 + r1 === -2) {
                            // dumb code to work around safari JS engine bugs
                            r0 = 0;
                            r1 = 0;
                        }
                        context.beginPath();
                        // outside arc
                        if (slice.lineDecoration === "zigzag") {
                            this.strokeZigZag(context, x, y, r1, offset, oa0, oa1);
                        }
                        else {
                            // normal slice
                            context.arc(x, y, r1, oa0, oa1, false);
                        }
                        // inside arc
                        if (ia0 === ia1) {
                            context.lineTo(x + Math.cos(ia1) * r0, y + Math.sin(ia0) * r0);
                        }
                        else {
                            context.arc(x, y, r0, ia1, ia0, true);
                        }
                        context.closePath();
                    };
                    CommonBase.prototype.strokeZigZag = function (context, x, y, r, offset, a0, a1) {
                        // start with 2 pixels per zig
                        var da = 5 / r;
                        var a = a0;
                        context.moveTo(x + r * Math.cos(a0), y + r * Math.sin(a0));
                        while (a + da < a1) {
                            a += da;
                            // da *= 1.2
                            context.lineTo(x + (r + offset) * Math.cos(a), y + (r + offset) * Math.sin(a));
                            offset = -offset;
                        }
                        context.lineTo(x + r * Math.cos(a1), y + r * Math.sin(a1));
                    };
                    CommonBase.prototype.strokeAndPaint = function (g, x, y, slice) {
                        var gr = Internal.Base.Graphics.beginStrokeAndFill(g, slice);
                        this.strokeSlice(gr, x, y, slice);
                        Internal.Base.Graphics.endStrokeAndFill(g, gr, slice);
                    };
                    return CommonBase;
                }());
                Renderers.CommonBase = CommonBase;
            })(Renderers = PieChart.Renderers || (PieChart.Renderers = {}));
        })(PieChart = Internal.PieChart || (Internal.PieChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Base.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var PieChart;
        (function (PieChart) {
            var Renderers;
            (function (Renderers) {
                var Flat = (function (_super) {
                    __extends(Flat, _super);
                    function Flat() {
                        _super.apply(this, arguments);
                    }
                    Flat.prototype.paintSlices = function (g, x, y, slices) {
                        // each slice has .renderParams field with [innerRadius, outerRadius,outLeft, outerRight,  innerLeft, innerRight]
                        for (var sliceIndex = 0; sliceIndex < slices.length; sliceIndex++) {
                            var slice = slices[sliceIndex];
                            this.strokeAndPaint(g, x, y, slice);
                        }
                    };
                    return Flat;
                }(Renderers.CommonBase));
                Renderers.Flat = Flat;
            })(Renderers = PieChart.Renderers || (PieChart.Renderers = {}));
        })(PieChart = Internal.PieChart || (Internal.PieChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Base.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var PieChart;
        (function (PieChart) {
            var Renderers;
            (function (Renderers) {
                var Can = (function (_super) {
                    __extends(Can, _super);
                    function Can() {
                        _super.apply(this, arguments);
                    }
                    Can.prototype.paintPie = function (context, x, y, r0, r1, a0, a1, pie) {
                        _super.prototype.paintPie.call(this, context, x, y, r0, r1, a0, a1, pie);
                        // paint shadows
                        var depth = this.settings.pie.depth;
                        if (depth > 0 && pie.allSlices.length > 0) {
                            context.fillStyle = "rgba(0,0,0,0.05)";
                            for (var offsetIndex = 0; offsetIndex < [5, 10, 18].length; offsetIndex++) {
                                var offset = [5, 10, 18][offsetIndex];
                                context.beginPath();
                                context.arc(x, y + offset + depth, r1, a0, a1, false);
                                context.arc(x, y + offset + depth, r0, a1, a0, true);
                                context.closePath();
                                context.fill();
                            }
                        }
                    };
                    Can.prototype.paintSlices = function (g, x, y, slices) {
                        // each slice has .renderParams field with [innerRadius, outerRadius,outLeft, outerRight,  innerLeft, innerRight]
                        var depth = this.settings.pie.depth;
                        var density = 2 * this.settings.advanced.renderQuality;
                        var stepOffset = 1 / density;
                        var numSteps = depth * density;
                        // paint lower shadow
                        g.shadowOffsetX = 0;
                        g.shadowOffsetY = 0;
                        g.shadowBlur = depth * 1.5;
                        g.shadowColor = "black";
                        g.fillStyle = "black";
                        for (var sliceIndex = 0; sliceIndex < slices.length; sliceIndex++) {
                            var slice = slices[sliceIndex];
                            this.strokeSlice(g, x, y + depth, slice);
                            g.fill();
                        }
                        g.shadowColor = null;
                        g.shadowBlur = 0;
                        // paint outlines
                        g.lineWidth = 1;
                        for (var i = 0; i <= numSteps; i++) {
                            for (var sliceIndex = 0; sliceIndex < slices.length; sliceIndex++) {
                                var slice = slices[sliceIndex];
                                if (slice.fillColor instanceof CanvasGradient) {
                                    Internal.Base.Helpers.error("slice.fillColor cannot be gradient if `can` renderer is used");
                                    continue;
                                }
                                this.strokeSlice(g, x, y + depth - i * stepOffset, slice);
                                if (i >= numSteps - 1) {
                                    // last lines are lighter
                                    g.strokeStyle = Internal.Base.Colors.derive(slice.fillColor, 1.35, 1);
                                }
                                else {
                                    g.strokeStyle = Internal.Base.Colors.derive(slice.fillColor, 0.5 + i / numSteps * 0.2, 1);
                                }
                                g.stroke();
                            }
                        }
                        /* paint inner edge shadow
                        only on the inner side and only the part that points upwards
                        the idea is to simulate ambient occlusion on the edge */
                        var PI = Math.PI;
                        g.shadowBlur = depth;
                        g.shadowColor = "rgba(0,0,0,0.1)";
                        g.fillStyle = "black";
                        for (var sliceIndex = 0; sliceIndex < slices.length; sliceIndex++) {
                            var slice = slices[sliceIndex];
                            var params = slice._renderParams;
                            var leftAngle = params[4];
                            var rightAngle = params[5];
                            if (leftAngle === rightAngle) {
                                continue;
                            }
                            while (leftAngle > PI) {
                                leftAngle -= PI * 2;
                                rightAngle -= PI * 2;
                            }
                            if (leftAngle < 0) {
                                if (rightAngle > 0) {
                                    rightAngle = Math.min(rightAngle, PI);
                                    if (this.strokeInnerShadowSlice(g, x, y, slice, 0, rightAngle)) {
                                        g.fill();
                                    }
                                }
                            }
                            else if (rightAngle < PI) {
                                if (this.strokeInnerShadowSlice(g, x, y, slice, leftAngle, rightAngle)) {
                                    g.fill();
                                }
                            }
                            else {
                                if (leftAngle < PI) {
                                    if (this.strokeInnerShadowSlice(g, x, y, slice, leftAngle, PI)) {
                                        g.fill();
                                    }
                                }
                                if (rightAngle > 2 * PI) {
                                    if (this.strokeInnerShadowSlice(g, x, y, slice, PI * 2, rightAngle)) {
                                        g.fill();
                                    }
                                }
                            }
                        }
                        // stroke original slice
                        for (var sliceIndex = 0; sliceIndex < slices.length; sliceIndex++) {
                            var slice = slices[sliceIndex];
                            this.strokeAndPaint(g, x, y, slice);
                        }
                    };
                    Can.prototype.strokeInnerShadowSlice = function (context, x, y, slice, leftAngle, rightAngle) {
                        var params = slice._renderParams;
                        var r0 = params[0] + 1;
                        var r1 = Math.min(params[1] - 1, r0 + 10);
                        if (r0 >= params[1] || r1 <= params[0]) {
                            return false;
                        }
                        leftAngle += 1 / r0;
                        rightAngle -= 1 / r0;
                        if (leftAngle >= rightAngle) {
                            return;
                        }
                        context.beginPath();
                        context.arc(x, y, r1, leftAngle, rightAngle, false);
                        context.arc(x, y, r0, rightAngle, leftAngle, true);
                        context.closePath();
                        return true;
                    };
                    return Can;
                }(Renderers.CommonBase));
                Renderers.Can = Can;
            })(Renderers = PieChart.Renderers || (PieChart.Renderers = {}));
        })(PieChart = Internal.PieChart || (Internal.PieChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Base.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var PieChart;
        (function (PieChart) {
            var Renderers;
            (function (Renderers) {
                var Smoothy = (function (_super) {
                    __extends(Smoothy, _super);
                    function Smoothy() {
                        _super.apply(this, arguments);
                    }
                    Smoothy.prototype.paintSlices = function (g, x, y, slices) {
                        // each slice has .renderParams field with [innerRadius, outerRadius,outLeft, outerRight,  innerLeft, innerRight]
                        this.g = g;
                        for (var sliceIndex = 0; sliceIndex < slices.length; sliceIndex++) {
                            var slice = slices[sliceIndex];
                            this.strokeAndPaint(g, x, y, slice);
                            this.elegantGradient(x, y, slice);
                        }
                    };
                    Smoothy.prototype.getRadialGradient = function (x, y, sr0, x1, y1, sr1, angle) {
                        var c1 = Math.abs(Math.sin(angle));
                        var gradient = this.g.createRadialGradient(x, y, sr0, x1, y1, sr1);
                        this.addColorStops(gradient, c1, angle);
                        return gradient;
                    };
                    Smoothy.prototype.getLinearGradient = function (g, x, y, sr0, x1, y1, sr1, angle) {
                        // store in cache maybe?
                        var dr = sr1 - sr0;
                        var sina = Math.sin(angle);
                        var cosa = Math.cos(angle);
                        var rx0 = x + cosa * sr0;
                        var ry0 = y + sina * sr0;
                        var rx1 = rx0 + cosa * dr;
                        var ry1 = ry0 + sina * dr;
                        var c1 = Math.abs(sina);
                        var gradient = this.g.createLinearGradient(rx0, ry0, rx1, ry1);
                        this.addColorStops(gradient, c1, angle);
                        return gradient;
                    };
                    Smoothy.prototype.addColorStops = function (g, c1, angle) {
                        var black = "0,0,0";
                        var white = "255,255,255";
                        var col1 = white;
                        var col2 = black;
                        if (angle <= 0 || angle > Math.PI) {
                            col1 = black;
                            col2 = white;
                        }
                        var coef1 = 0.4 * c1;
                        var coef2 = 0.2 * c1;
                        var coef3 = 0.1 * c1;
                        var coef4 = 0.3 * c1;
                        var coef5 = 0.5 * c1;
                        g.addColorStop(0, "rgba(" + col1 + "," + coef1.toFixed(3) + ")");
                        g.addColorStop(0.1, "rgba(" + col1 + "," + coef2.toFixed(3) + ")");
                        g.addColorStop(0.1, "rgba(" + col1 + "," + coef3.toFixed(3) + ")");
                        g.addColorStop(0.4, "rgba(" + black + "," + 0.1 + ")");
                        g.addColorStop(0.9, "rgba(" + col2 + "," + coef3.toFixed(3) + ")");
                        g.addColorStop(0.95, "rgba(" + col2 + "," + coef4.toFixed(3) + ")");
                        g.addColorStop(1, "rgba(" + col2 + "," + coef5.toFixed(3) + ")");
                    };
                    Smoothy.prototype.elegantGradient = function (xx, yy, slice) {
                        var sr0 = slice._renderParams[0];
                        var sr1 = slice._renderParams[1];
                        var a1 = slice._renderParams[2];
                        var a2 = slice._renderParams[3];
                        var quality = this.settings.advanced.renderQuality;
                        // quality between 1 and 0
                        var inc = Math.PI / Math.max(1, 180 * quality);
                        var as1 = a1;
                        while (as1 < a2) {
                            var as2 = Math.min(as1 + inc, a2);
                            this.g.beginPath();
                            this.g.arc(xx, yy, sr1, as1, as2);
                            this.g.arc(xx, yy, sr0, as2, as1, true);
                            this.g.closePath();
                            Internal.Base.Graphics.paint(this.g, {
                                fillColor: this.getRadialGradient(xx, yy, sr0, xx, yy, sr1, as1)
                            });
                            as1 = as2;
                        }
                    };
                    return Smoothy;
                }(Renderers.CommonBase));
                Renderers.Smoothy = Smoothy;
            })(Renderers = PieChart.Renderers || (PieChart.Renderers = {}));
        })(PieChart = Internal.PieChart || (Internal.PieChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Base.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var PieChart;
        (function (PieChart) {
            var Renderers;
            (function (Renderers) {
                var Bevel = (function (_super) {
                    __extends(Bevel, _super);
                    function Bevel() {
                        _super.apply(this, arguments);
                    }
                    // public gradients: Dictionary<CanvasGradient> = {};
                    Bevel.prototype.paintSlices = function (g, x, y, slices) {
                        // each slice has .renderParams field with [innerRadius, outerRadius,outLeft, outerRight,  innerLeft, innerRight]
                        this.g = g;
                        for (var sliceIndex = 0; sliceIndex < slices.length; sliceIndex++) {
                            var slice = slices[sliceIndex];
                            this.strokeAndPaint(g, x, y, slice);
                            // stroke bevel
                            this.smartGradient(x, y, slice);
                        }
                    };
                    Bevel.prototype.getSmartGradient = function (x, y, sr0, sr1, side, position) {
                        // let n = "g" + side + position + sr0 + sr1;
                        // TODO: investigate if the caching of CanvasGradient objects can be used.
                        // if (this.gradients[n] && false) {
                        //     return this.gradients[n];
                        // }
                        var x1 = 0;
                        var x2 = 0;
                        var y1 = 0;
                        var y2 = 0;
                        var c1;
                        var c2;
                        if (side === "inside") {
                            if (position === "top") {
                                y1 = sr1 - sr0;
                                y2 = y;
                                c1 = "rgba(0,0,0,0.3)";
                                c2 = "rgba(0,0,0,0)";
                            }
                            else {
                                y1 = y;
                                y2 = y + sr0;
                                c1 = "rgba(255,255,255,0)";
                                c2 = "rgba(255,255,255,0.3)";
                            }
                        }
                        else {
                            if (position === "top") {
                                y2 = y;
                                c1 = "rgba(255,255,255,0.3)";
                                c2 = "rgba(255,255,255,0)";
                            }
                            else {
                                y1 = y;
                                y2 = y + sr1;
                                c1 = "rgba(0,0,0,0)";
                                c2 = "rgba(0,0,0,0.3)";
                            }
                        }
                        try {
                            var gradient = this.g.createLinearGradient(x1, y1, x2, y2);
                            gradient.addColorStop(0, c1);
                            gradient.addColorStop(1, c2);
                            // this.gradients[n] = gradient;
                            return gradient;
                        }
                        catch (e) {
                            throw "Could not create linear gradient: " + e;
                        }
                    };
                    Bevel.prototype.smartOuterShineTop = function (x, y, sr0, sr1, a1, a2, a3, a4) {
                        if (a1 > 0 && a2 < Math.PI) {
                            return;
                        }
                        if (a2 > 0 && a1 < 0) {
                            a2 = 0;
                            a4 = 0;
                        }
                        if (a1 > 0 && a1 < Math.PI) {
                            a1 = Math.PI;
                            a3 = Math.PI;
                        }
                        var s = {
                            _renderParams: [
                                sr1 - 0.1 * (sr1 - sr0),
                                sr1,
                                a1,
                                a2,
                                a3,
                                a4,
                                null, null
                            ],
                            x: 0,
                            y: 0,
                            fillColor: this.getSmartGradient(x, y, sr0, sr1, "outside", "top")
                        };
                        this.strokeAndPaint(this.g, x, y, s);
                    };
                    Bevel.prototype.smartOuterShineBottom = function (x, y, sr0, sr1, a1, a2, a3, a4) {
                        if (a2 < 0 || a1 > Math.PI) {
                            return;
                        }
                        if (a1 < 0) {
                            a1 = 0;
                            a3 = 0;
                        }
                        if (a2 > Math.PI) {
                            a2 = Math.PI;
                            a4 = Math.PI;
                        }
                        var s = {
                            _renderParams: [
                                sr1 - 0.1 * (sr1 - sr0),
                                sr1,
                                a1,
                                a2,
                                a3,
                                a4,
                                null, null
                            ],
                            x: 0,
                            y: 0,
                            fillColor: this.getSmartGradient(x, y, sr0, sr1, "outside", "bottom")
                        };
                        this.strokeAndPaint(this.g, x, y, s);
                    };
                    Bevel.prototype.smartInnerShineTop = function (x, y, sr0, sr1, a1, a2, a3, a4) {
                        if (a1 > 0 && a2 < Math.PI) {
                            return;
                        }
                        if (a2 > 0 && a1 < 0) {
                            a2 = 0;
                            a4 = 0;
                        }
                        if (a1 > 0 && a1 < Math.PI) {
                            a1 = Math.PI;
                            a3 = Math.PI;
                        }
                        var s = {
                            _renderParams: [
                                sr0,
                                sr0 + 0.1 * (sr1 - sr0),
                                a1,
                                a2,
                                a3,
                                a4,
                                null, null
                            ],
                            x: 0,
                            y: 0,
                            fillColor: this.getSmartGradient(x, y, sr0, sr1, "inside", "top")
                        };
                        this.strokeAndPaint(this.g, x, y, s);
                    };
                    Bevel.prototype.smartInnerShineBottom = function (x, y, sr0, sr1, a1, a2, a3, a4) {
                        if (a2 < 0 || a1 > Math.PI) {
                            return;
                        }
                        if (a1 < 0) {
                            a1 = 0;
                            a3 = 0;
                        }
                        if (a2 > Math.PI) {
                            a2 = Math.PI;
                            a4 = Math.PI;
                        }
                        var s = {
                            _renderParams: [
                                sr0,
                                sr0 + 0.1 * (sr1 - sr0),
                                a1,
                                a2,
                                a3,
                                a4,
                                null, null
                            ],
                            x: 0,
                            y: 0,
                            fillColor: this.getSmartGradient(x, y, sr0, sr1, "inside", "bottom")
                        };
                        this.strokeAndPaint(this.g, x, y, s);
                    };
                    Bevel.prototype.smartGradient = function (x, y, slice) {
                        // each slice has .renderParams field with [innerRadius, outerRadius,outLeft, outerRight,  innerLeft, innerRight]
                        x = x + slice.x;
                        y = y + slice.y;
                        var sr0 = slice._renderParams[0];
                        var sr1 = slice._renderParams[1];
                        var a1 = slice._renderParams[2];
                        var a2 = slice._renderParams[3];
                        var a3 = slice._renderParams[4];
                        var a4 = slice._renderParams[5];
                        // draw smart outer ring
                        this.smartOuterShineTop(x, y, sr0, sr1, a1, a2, a3, a4);
                        this.smartOuterShineBottom(x, y, sr0, sr1, a1, a2, a3, a4);
                        this.smartInnerShineTop(x, y, sr0, sr1, a1, a2, a3, a4);
                        this.smartInnerShineBottom(x, y, sr0, sr1, a1, a2, a3, a4);
                    };
                    return Bevel;
                }(Renderers.CommonBase));
                Renderers.Bevel = Bevel;
            })(Renderers = PieChart.Renderers || (PieChart.Renderers = {}));
        })(PieChart = Internal.PieChart || (Internal.PieChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/core/ChartEvents.ts" />
/// <reference path="../base/Geometry.ts" />
/// <reference path="../base/Graphics.ts" />
/// <reference path="renderer/Flat.ts" />
/// <reference path="renderer/Can.ts" />
/// <reference path="renderer/Smoothy.ts" />
/// <reference path="renderer/Bevel.ts" />
/// <reference path="Scene.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var PieChart;
        (function (PieChart) {
            var PieRenderer = (function () {
                function PieRenderer(chart) {
                    this.renderer = null;
                    this.chart = chart;
                    this.settings = chart.settings;
                    this.scene = chart.scene;
                }
                PieRenderer.prototype.onSceneChange = function (event) {
                    if (event.changes.settings) {
                        this.buildSeries();
                    }
                };
                PieRenderer.prototype.buildSeries = function () {
                    var theme = this.settings.pie.theme;
                    var c = theme.charAt(0).toUpperCase() + theme.slice(1);
                    try {
                        this.renderer = new PieChart.Renderers[c](this);
                    }
                    catch (e) {
                        throw "Renderer " + theme + " is not available: " + e;
                    }
                };
                PieRenderer.prototype.paintScene = function (event) {
                    var g = event.context;
                    var labelRenderer = event.labelRenderer;
                    var innerPies = event.isExport ? this.settings.pie.showInnerPiesExport : this.settings.pie.showInnerPies;
                    var hasBackgroundPie = false;
                    for (var pieindex = 0; pieindex < this.scene.pies.length; pieindex++) {
                        var pie = this.scene.pies[pieindex];
                        if (innerPies || !pie.background) {
                            this.paintPie(g, labelRenderer, pie);
                        }
                        hasBackgroundPie = hasBackgroundPie || pie.background;
                    }
                    if (!event.isExport && (this.scene.hoverBack || (this.scene.settings.advanced.backAlwaysVisible && hasBackgroundPie)))
                        this.paintBackArrow(event);
                };
                PieRenderer.prototype.paintBackArrow = function (event) {
                    var img = this.scene.assetsLoader.getAssetImage(this.scene.settings.advanced.backImage);
                    if (!img)
                        return;
                    var topPie = this.scene.pies[this.scene.pies.length - 1];
                    var invsq2 = 0.707106781186547;
                    var x = topPie.x;
                    var y = topPie.y;
                    // adjust y for hepth
                    var depth = this.settings.pie.depth;
                    y += (this.scene.pies.length - 1) * depth;
                    var ihw = img.width / 2;
                    var ihh = img.height / 2;
                    var phs = topPie.innerRadius * invsq2;
                    var widthProportion = Math.min(ihw, Math.max(phs, ihw / 2)) / ihw;
                    var heightProportion = Math.min(ihh, Math.max(phs, ihh / 2)) / ihh;
                    var zoom = Math.min(widthProportion, heightProportion);
                    var g = event.context;
                    // Background color
                    if (this.settings.advanced.backImageBackground) {
                        var spacing = this.settings.slice.margin;
                        var add = this.scene.currentInnerRadius;
                        var mul = this.scene.currentRadius - add;
                        var r0 = Math.max(this.scene.pies[0].currentInnerRadius * mul + add, spacing / 2);
                        g.beginPath();
                        g.arc(x, y, r0, 0, 2 * Math.PI);
                        g.closePath();
                        g.fillStyle = this.settings.advanced.backImageBackground;
                        g.fill();
                    }
                    g.globalAlpha = 0.5;
                    Internal.Base.Graphics.drawImageHighQuality(g, img, x - ihw * zoom, y - ihh * zoom, ihw * 2 * zoom, ihh * 2 * zoom);
                    g.globalAlpha = 1;
                };
                PieRenderer.prototype.paintPie = function (g, labelRenderer, pie) {
                    var spacing = this.settings.slice.margin;
                    // No spacing when single slice
                    if (pie.allSlices.length < 2) {
                        spacing = 0;
                    }
                    var innerR = this.scene.currentInnerRadius;
                    var sliceCenterAxis = this.scene.currentRadius - innerR;
                    var r0 = Math.max(pie.currentInnerRadius * sliceCenterAxis + innerR, spacing / 2);
                    var r1 = pie.currentRadius * sliceCenterAxis + innerR;
                    var startAngle = pie.currentStartAngle;
                    var endAngle = pie.currentEndAngle;
                    var angleDiff = endAngle - startAngle;
                    var angle1 = startAngle;
                    if (!(r1 > 0 && angleDiff > 0)) {
                        return;
                    }
                    var pxToAngleR0 = (r0 > 0) ? (1 / r0) : 0;
                    var pxToAngleR1 = 1 / r1;
                    var spacingAngleR0 = spacing / 2 * pxToAngleR0;
                    var spacingAngleR1 = spacing / 2 * pxToAngleR1;
                    var slicesToPaint = [];
                    for (var sliceIndex = 0; sliceIndex < pie.allSlices.length; sliceIndex++) {
                        var slice = pie.allSlices[sliceIndex];
                        var sliceAngle = slice.currentFraction * angleDiff;
                        if (slice.currentFraction <= 0) {
                            continue;
                        }
                        var angle = angle1;
                        angle1 += sliceAngle;
                        var sr0 = r0 + slice.currentCutoutDistance;
                        var sr1 = r1 + slice.currentCutoutDistance;
                        var outerAngleLeft = void 0;
                        var outerAngleRight = void 0;
                        if (sliceAngle <= spacingAngleR1 * 4) {
                            // just a single line - draw at least half the margin
                            var m = (angle + angle1) / 2;
                            var aR1 = sliceAngle / 4;
                            outerAngleLeft = m - aR1;
                            outerAngleRight = m + aR1;
                        }
                        else {
                            outerAngleLeft = angle + spacingAngleR1;
                            outerAngleRight = angle1 - spacingAngleR1;
                        }
                        var innerAngleLeft = angle + spacingAngleR0;
                        var innerAngleRight = angle1 - spacingAngleR0;
                        if (innerAngleLeft > innerAngleRight) {
                            innerAngleLeft = innerAngleRight = (innerAngleLeft + innerAngleRight) / 2;
                        }
                        if (outerAngleRight < startAngle || outerAngleLeft > endAngle) {
                            continue;
                        }
                        outerAngleLeft = Math.max(outerAngleLeft, startAngle);
                        outerAngleRight = Math.min(outerAngleRight, endAngle);
                        innerAngleLeft = Math.max(innerAngleLeft, startAngle);
                        innerAngleRight = Math.min(innerAngleRight, endAngle);
                        if (innerAngleLeft > innerAngleRight) {
                            innerAngleLeft = innerAngleRight = (innerAngleLeft + innerAngleRight) / 2;
                        }
                        slice._renderParams = [
                            sr0,
                            sr1,
                            outerAngleLeft,
                            outerAngleRight,
                            innerAngleLeft,
                            innerAngleRight,
                            slice.fillColor,
                            slice.lineColor
                        ];
                        // store current for paint.
                        slice.fillColor = slice.currentFillColor;
                        slice.lineColor = slice.currentLineColor;
                        slicesToPaint.push(slice);
                    }
                    var pieX = pie.x;
                    var pieY = pie.y;
                    this.renderer.paintPie(g, pieX, pieY, r0, r1, pie.currentStartAngle, pie.currentEndAngle, pie);
                    this.renderer.paintSlices(g, pieX, pieY, slicesToPaint);
                    if (pie === this.scene.peek()) {
                        this.renderer.paintExpandableHilights(g, pieX, pieY, slicesToPaint);
                    }
                    // restore fill color, line color
                    for (var slice2Index = 0; slice2Index < slicesToPaint.length; slice2Index++) {
                        var slice2 = slicesToPaint[slice2Index];
                        slice2.fillColor = slice2._renderParams[6];
                        slice2.lineColor = slice2._renderParams[7];
                    }
                    if (!pie.removed) {
                        // paint icons
                        Internal.Base.Graphics.clearShadow(g);
                        for (var sliceIndex = 0; sliceIndex < pie.allSlices.length; sliceIndex++) {
                            var slice = pie.allSlices[sliceIndex];
                            if (slice.currentIcon) {
                                var img = this.scene.assetsLoader.getAssetImage(slice.icon);
                                if (img) {
                                    var icon = slice.currentIcon;
                                    var xx = pieX + icon.x;
                                    var yy = pieY + icon.y;
                                    var w = Math.min(img.width / 2, icon.hwidth);
                                    var h = Math.min(img.height / 2, icon.hheight);
                                    Internal.Base.Graphics.drawImageHighQuality(g, img, xx - w, yy - h, w * 2, h * 2);
                                }
                            }
                        }
                        // paint labels
                        angle1 = startAngle;
                        for (var sliceIndex = 0; sliceIndex < pie.allSlices.length; sliceIndex++) {
                            var slice = pie.allSlices[sliceIndex];
                            var sliceAngle = slice.currentFraction * angleDiff;
                            var angle = angle1;
                            angle1 = angle + sliceAngle;
                            // clip to pie bounds
                            var a0 = Math.max(angle, startAngle);
                            var a1 = Math.min(angle1, endAngle);
                            var am = (a0 + a1) / 2;
                            var isActive = slice === this.scene.hoverSlice;
                            var rl = r1 + slice.currentCutoutDistance;
                            if (slice.currentInsideLabel && slice.currentInsideLabel.visible) {
                                this.paintLabel(g, labelRenderer, pieX, pieY, rl, am, slice.currentInsideLabel, isActive);
                            }
                            if (slice.currentLabel && slice.currentLabel.visible) {
                                this.paintLabel(g, labelRenderer, pieX, pieY, rl, am, slice.currentLabel, isActive);
                            }
                        }
                    }
                };
                PieRenderer.prototype.paintLabel = function (g, labelRenderer, x, y, r1, angleM, label, active) {
                    var top = this.scene.y0 + 3;
                    var bottom = top + this.scene.height - 6;
                    var labelConfig = this.settings.labels;
                    var lx = label.x;
                    var ly = label.y;
                    var hw = label.hwidth;
                    var r2 = r1 + labelConfig.connectorLength;
                    // compute connecting point to label from the outer edge of slice
                    // based on label position against the center of pie
                    var x2;
                    var y2;
                    if (lx < 0) {
                        x2 = lx + hw;
                        y2 = ly;
                    }
                    else if (lx >= 0) {
                        x2 = lx - hw;
                        y2 = ly;
                    }
                    // paint connector
                    if (labelConfig.connectors && x2 * x2 + y2 * y2 > r1 * r1) {
                        var sina = Math.sin(angleM);
                        var cosa = Math.cos(angleM);
                        g.beginPath();
                        var x0 = x + r1 * cosa;
                        var y0 = y + r1 * sina;
                        g.moveTo(x0, y0);
                        var x1 = x + r2 * cosa;
                        var y1 = y + r2 * sina;
                        y1 = Math.min(Math.max(y1, top), bottom);
                        x2 += x;
                        y2 += y;
                        y2 = Math.min(Math.max(y2, top), bottom);
                        var r15 = (r1 + r2) / 2;
                        var t = Internal.Base.Geometry.rayIntersectsCircle(x2 - x, y2 - y, x0 - x2, y0 - y2, r1);
                        var a = Internal.Base.Geometry.lineTouchingCircle(x2 - x, y2 - y, x1 - x, y1 - y, r2);
                        if (t < 0.9 && a) {
                            // test line overlaps pie circle - route around the circle
                            var xc = a.x;
                            var yc = a.y;
                            var touchAngle = Math.atan2(yc, xc);
                            while (touchAngle - angleM > Math.PI) {
                                touchAngle -= Math.PI * 2;
                            }
                            while (touchAngle - angleM < -Math.PI) {
                                touchAngle += Math.PI * 2;
                            }
                            var da = touchAngle - angleM;
                            xc += x;
                            yc += y;
                            // route like this x0,y0-(curve via x1,y1)->x1a,y1a-(arc)->xc,yc-(line)->x2,y2
                            x1 = x + r15 * cosa;
                            y1 = y + r15 * sina;
                            y1 = Math.min(Math.max(y1, top), bottom);
                            var x1a = x + r15 * Math.cos(angleM + da * 0.2);
                            var y1a = y + r15 * Math.sin(angleM + da * 0.2);
                            y1a = Math.min(Math.max(y1a, top), bottom);
                            g.quadraticCurveTo(x1, y1, x1a, y1a);
                            var x2p = x + r2 * Math.cos(touchAngle);
                            var y2p = y + r2 * Math.sin(touchAngle);
                            y2p = Math.min(Math.max(y2p, top), bottom);
                            // draw arc from (x1a, y1a) to (x2,y2) with radius r15
                            Internal.Base.Graphics.arcBetweenTwoPoints(g, x, y, r15, x1a, y1a, x2p, y2p);
                            g.lineTo(x2, y2);
                        }
                        else {
                            // route simply x0,y0-(curve via x1,y1)->x2,y2
                            g.quadraticCurveTo(x1, y1, x2, y2);
                        }
                        // paint wider line if slice is active
                        var conStyle = this.settings.slice.connectorStyle;
                        var width = conStyle.lineWidth;
                        if (active) {
                            conStyle.lineWidth += 2;
                        }
                        Internal.Base.Graphics.stroke(g, conStyle);
                        conStyle.lineWidth = width;
                    }
                    labelRenderer.paint(g, x + label.x, y + label.y, 1, label);
                    Internal.Base.Graphics.clearShadow(g);
                };
                return PieRenderer;
            }());
            PieChart.PieRenderer = PieRenderer;
        })(PieChart = Internal.PieChart || (Internal.PieChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Scene.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var PieChart;
        (function (PieChart) {
            var PieBuilder = (function () {
                function PieBuilder(chart) {
                    this.chart = chart;
                    this.scene = chart.scene;
                }
                PieBuilder.prototype.updatePie = function (pie, animate) {
                    var data = this.getPieData(pie);
                    this.rectifyScrollOffsets(pie, data);
                    var getForwardCountResult = this.getForwardCount(pie.id, data, pie.offset);
                    var numberOfSlices = getForwardCountResult.numberOfSlices;
                    var ready = getForwardCountResult.isReady;
                    pie.data = data;
                    pie.loading = !ready;
                    if (ready) {
                        var buildSlicesResult = this.buildSlices(pie, pie.offset, numberOfSlices);
                        var newSlices = buildSlicesResult.slices;
                        var others = buildSlicesResult.othersSlice;
                        var previous = buildSlicesResult.previousSlice;
                        this.applyNewSlices(pie, newSlices, others, previous, animate);
                    }
                    return ready;
                };
                PieBuilder.prototype.scrollForward = function (pie, newOffset) {
                    var data = this.getPieData(pie);
                    pie.data = data;
                    var ready = true;
                    var numberOfSlices;
                    if (newOffset === null || newOffset === void 0) {
                        // scrolling forwards by 1 page, figure out the new offset
                        var getForwardCountResult = this.getForwardCount(pie.id, data, pie.offset);
                        numberOfSlices = getForwardCountResult.numberOfSlices;
                        ready = getForwardCountResult.isReady;
                        newOffset = pie.offset + numberOfSlices;
                    }
                    if (ready) {
                        var getForwardCountResult = this.getForwardCount(pie.id, data, newOffset);
                        numberOfSlices = getForwardCountResult.numberOfSlices;
                        ready = getForwardCountResult.isReady;
                    }
                    if (!ready) {
                        pie.loading = true;
                        return false;
                    }
                    else {
                        var buildSlicesResult = this.buildSlices(pie, newOffset, numberOfSlices);
                        var newSlices = buildSlicesResult.slices;
                        var newOthers = buildSlicesResult.othersSlice;
                        var newPrevious = buildSlicesResult.previousSlice;
                        if (pie.othersSlice) {
                            var newSlicesStartPos = Math.min(newSlices.length, Math.max(0, (pie.offset + pie.count) - newOffset));
                            this.fitSlicesInOrigin(pie.othersSlice, newSlices.slice(newSlicesStartPos), newOthers);
                            if (!newOthers) {
                                // make a mock previous to force previous to snap to zero instantly
                                newOthers = pie.othersSlice;
                                newOthers.fraction = 0;
                                newOthers.currentFraction = 0;
                                newOthers.removed = true;
                            }
                        }
                        pie.offset = newOffset;
                        this.applyNewSlices(pie, newSlices, newOthers, newPrevious);
                        pie.loading = false;
                        return true;
                    }
                };
                PieBuilder.prototype.scrollBackward = function (pie, newOffset) {
                    var data = this.getPieData(pie);
                    pie.data = data;
                    var ready = true;
                    var numberOfSlices = 0;
                    // Check if the data has been truncated and we're currently displaying slices beyond the end. If so, adjust the "previous" slice
                    // content count to include all of the available data.
                    if (data && data.done && pie.offset > data.offset + data.values.length) {
                        pie.offset = data.offset + data.values.length;
                    }
                    if (newOffset == null) {
                        // scrolling backward by 1 page, figure out the new offset
                        var getBackOffsetResult = this.getBackOffset(pie.id, data, pie.offset);
                        newOffset = getBackOffsetResult.newOffset;
                        ready = getBackOffsetResult.isReady;
                        if (ready) {
                            // while cycle is needed in cases when the Others slice is composed entirely of zero values.
                            // in that case the getBackOffset() method does not work correctly and this corrects that.
                            do {
                                newOffset += numberOfSlices;
                                var getForwardCountResult = this.getForwardCount(pie.id, data, newOffset);
                                numberOfSlices = getForwardCountResult.numberOfSlices;
                                ready = getForwardCountResult.isReady;
                            } while (ready && newOffset + numberOfSlices < pie.offset);
                        }
                    }
                    else {
                        var getForwardCountResult = this.getForwardCount(pie.id, data, newOffset);
                        numberOfSlices = getForwardCountResult.numberOfSlices;
                        ready = getForwardCountResult.isReady;
                    }
                    if (!ready) {
                        pie.loading = true;
                        return false;
                    }
                    else {
                        var buildSlicesResult = this.buildSlices(pie, newOffset, numberOfSlices);
                        var newSlices = buildSlicesResult.slices;
                        var newOthers = buildSlicesResult.othersSlice;
                        var newPrevious = buildSlicesResult.previousSlice;
                        if (pie.previousSlice) {
                            var newSlicesEndPos = Math.min(newSlices.length, Math.max(0, pie.offset - newOffset));
                            this.fitSlicesInOrigin(pie.previousSlice, newSlices.slice(0, newSlicesEndPos), newPrevious);
                            if (!newPrevious) {
                                // make a mock previous to force previous to snap to zero instantly
                                newPrevious = pie.previousSlice;
                                newPrevious.fraction = 0;
                                newPrevious.currentFraction = 0;
                                newPrevious.removed = true;
                            }
                        }
                        pie.offset = newOffset;
                        this.applyNewSlices(pie, newSlices, newOthers, newPrevious);
                        pie.loading = false;
                        return true;
                    }
                };
                PieBuilder.prototype.fitSlicesInOrigin = function (origin, slices, extraSlice) {
                    // distribute slices + extraSlice to start from the same fraction as origin
                    var originFraction = Math.max(1e-6, origin.currentFraction);
                    var targetFraction = 0;
                    for (var sliceIndex = 0; sliceIndex < slices.length; sliceIndex++) {
                        var slice = slices[sliceIndex];
                        targetFraction += slice.fraction;
                    }
                    if (extraSlice) {
                        targetFraction += extraSlice.fraction;
                    }
                    var compression = originFraction / targetFraction;
                    for (var sliceIndex = 0; sliceIndex < slices.length; sliceIndex++) {
                        var slice = slices[sliceIndex];
                        slice.currentFraction = slice.fraction * compression;
                        slice.currentFillColor = origin.currentFillColor;
                        slice.currentLineColor = origin.currentLineColor;
                    }
                    if (extraSlice) {
                        extraSlice.currentFraction = extraSlice.fraction * compression;
                        extraSlice.currentFillColor = origin.currentFillColor;
                        extraSlice.currentLineColor = origin.currentLineColor;
                    }
                };
                /**
                 * The pie has 2 properties - scrollOffset and offset. Offset determines how many slices are hidden in the
                 * "previous" slice, scrollOffset is a fraction, describing how far the pie has been scrolled (used in rotational scrolling)
                 * Calling rectifyScrollOffsets will look at the scrollOffset, and determine, how many slices can be hidden within
                 * the "previous" slice, or may need to be taken out from that slice, and update the "offset" accordingly
                 * @param pie - the pie that needs to be updated
                 * @param data - pie data
                 */
                PieBuilder.prototype.rectifyScrollOffsets = function (pie, data) {
                    if (data == null) {
                        pie.scrollOffset = 0;
                        return;
                    }
                    var offset = pie.offset;
                    var sliceData;
                    if (pie.scrollOffset < 0) {
                        // user is trying to scroll forward, via scroll gesture
                        // the 1st slices are merged/converted to the "previous" slice
                        if (offset === 0) {
                            // the pie doesn't have a previous slice yet, so the 1st slice is converted to "previous"
                            pie.scrollOffset -= this.scene.settings.interaction.others.navigationFraction;
                        }
                        while (pie.scrollOffset < 0 && offset - data.offset < data.values.length) {
                            sliceData = data.values[offset - data.offset];
                            pie.scrollOffset += sliceData.fraction / pie.visibleFraction;
                            offset++;
                        }
                        // Limit the furthest end of scroll offset
                        var maxVisible = this.scene.settings.interaction.others.maxSlicesVisible + 1;
                        if (offset + maxVisible > data.values.length) {
                            pie.scrollOffset = 0;
                            offset = Math.max(data.values.length - maxVisible, 0);
                        }
                    }
                    else if (pie.scrollOffset > 0) {
                        // Scrolling backwards, checking, whether slices need to be added back to the beginning of the piechart
                        // compensation for the navigation fraction size, when scrolling back
                        var addedValue = 0;
                        if (offset === 1) {
                            addedValue = this.scene.settings.interaction.others.navigationFraction;
                        }
                        while (offset > 0 && pie.scrollOffset + addedValue > data.values[offset - data.offset - 1].fraction / pie.visibleFraction) {
                            sliceData = data.values[offset - data.offset - 1];
                            pie.scrollOffset -= sliceData.fraction / pie.visibleFraction;
                            offset--;
                        }
                        if (offset === 0) {
                            // limit scrolling
                            pie.scrollOffset = 0;
                        }
                    }
                    pie.offset = offset;
                };
                /**
                 * Counts the amount of pie slices that are to be displayed via the current scroll position/page.
                 * Requests additional data if required
                 */
                PieBuilder.prototype.getForwardCount = function (
                    /** ID of the pie */ id, 
                    /** Data cache of the pie */ data, 
                    /** Index of the first slice after the "previous" slice. */ othersOffset) {
                    // Check that we have data for at least the first visible slice. Request it if necessary.
                    if (!data || (data.offset > othersOffset) || (data.offset + data.values.length <= othersOffset)) {
                        if (!data || !data.done || data.offset > othersOffset) {
                            // First slice not yet loaded. Request it and return.
                            this.scene.mainData.requestPieData(id, othersOffset);
                            return { numberOfSlices: 0, isReady: false };
                        }
                        else {
                            // We're currently outside the available data range, and no more slices can be requested.
                            return { numberOfSlices: 0, isReady: true };
                        }
                    }
                    // Cache some values in local variables.
                    var dataStart = data.offset;
                    var dataEnd = dataStart + data.values.length;
                    var othersSettings = this.scene.settings.interaction.others;
                    var minSlice = othersSettings.minSliceFraction;
                    var maxOthers = othersSettings.maxOthersFraction;
                    var maxSlices = othersSettings.maxSlicesVisible;
                    // Check if "others" slice 
                    if (!othersSettings.enabled || dataEnd - othersOffset <= othersSettings.minSlices) {
                        // Cannot create the "Others" slice. Display all available data. If more data is available, request it.
                        if (!data.done)
                            this.scene.mainData.requestMorePieData(id);
                        return { numberOfSlices: Math.max(dataEnd - othersOffset, 0), isReady: data.done };
                    }
                    var othersSum = data.afterFraction;
                    for (var i = othersOffset; i <= dataEnd - 1; i++) {
                        othersSum += data.values[i - dataStart].fraction;
                    }
                    var count = 0;
                    var slicesSum = 0;
                    var full = data.done;
                    while (count + othersOffset < dataEnd) {
                        count++;
                        var val = data.values[othersOffset + count - dataStart - 1].fraction;
                        slicesSum += val;
                        othersSum -= val;
                        var othersRealFraction = othersSum / (othersSum + slicesSum);
                        var othersVisibleFraction = Math.min(othersRealFraction, maxOthers);
                        var sliceFraction = val / slicesSum * (1 - othersVisibleFraction);
                        if (count > maxSlices || sliceFraction < minSlice) {
                            // do not leave a single slice
                            if (data.done && count + othersOffset !== dataEnd) {
                                count--;
                            }
                            full = true;
                            break;
                        }
                    }
                    if (!full) {
                        this.scene.mainData.requestMorePieData(id);
                    }
                    return {
                        numberOfSlices: count,
                        isReady: full
                    };
                };
                /** Figure out the new offset when clicking the "previous" slice. */
                PieBuilder.prototype.getBackOffset = function (
                    /** ID of the pie */ id, 
                    /** Data cache of the pie */ data, 
                    /** Index of the first slice after the "previous" slice. */ othersOffset) {
                    // Crazy case possible if data has had an error and then has been readjusted to the start.
                    if (othersOffset === 0) {
                        return { newOffset: 0, isReady: true };
                    }
                    // Check if we have the data for the first invisible slice inside the "previous" slice (counting starting at the visible slices).
                    // If we don't have it, request it and return.
                    if (!data || (data.offset >= othersOffset) || (!data.done && data.offset + data.values.length < othersOffset)) {
                        this.scene.mainData.requestPieData(id, Math.max(0, othersOffset - this.scene.mainData.dataSettings.itemsToLoad));
                        return { newOffset: 0, isReady: false };
                    }
                    // If we're at the very start of the pie, then we canot rewind anymore. Return.
                    if (othersOffset === 0) {
                        return { newOffset: 0, isReady: true };
                    }
                    // Start computation. Cache some values in local variables.
                    var dataStart = data.offset;
                    var dataEnd = dataStart + data.values.length;
                    var minSlice = this.scene.settings.interaction.others.minSliceFraction;
                    var maxOthers = this.scene.settings.interaction.others.maxOthersFraction;
                    var maxSlices = this.scene.settings.interaction.others.maxSlicesVisible;
                    // Compute fraction of total pie for all values beyond the "previous" slice.
                    // That is, this is the fraction of the whole pie that the "others" slice will take up afterwards.
                    var othersFrac = data.afterFraction;
                    for (var i = othersOffset; i < dataEnd; i++) {
                        othersFrac += data.values[i - dataStart].fraction;
                    }
                    // Iterate backwards through the slices currently in the "previous" slice. Add together until enough slices have been gathered.
                    var pos = othersOffset;
                    var smallestFrac = data.values[othersOffset - dataStart - 1].fraction; // Fraction of the first slice inside the "previous" slice.
                    var slicesFrac = 0;
                    var full = data.offset === 0;
                    while (pos > data.offset) {
                        pos--;
                        slicesFrac += data.values[pos - dataStart].fraction;
                        var count = othersOffset - pos;
                        var otherSliceFrac = Math.min(othersFrac / (othersFrac + slicesFrac), maxOthers);
                        var smallestSliceFraction = smallestFrac / slicesFrac * (1 - otherSliceFrac);
                        if (pos === 0 || count > maxSlices || smallestSliceFraction < minSlice) {
                            // do not leave a single slice
                            if (pos !== 0) {
                                pos++;
                            }
                            full = true;
                            break;
                        }
                    }
                    if (!full) {
                        this.scene.mainData.requestLessPieData(id);
                    }
                    return { newOffset: pos, isReady: full };
                };
                /**
                 * (re-)constructs the visible pie slices, given the page offset
                 * @param pie
                 * @param offset
                 * @param count
                 * @returns {Object}
                 */
                PieBuilder.prototype.buildSlices = function (pie, offset, count) {
                    var config = this.scene.settings;
                    var data = pie.data;
                    if (!data) {
                        throw new Error("Internal error");
                    }
                    var slicesFraction = 0;
                    var slices = [];
                    for (var i = offset; i < offset + count; i++) {
                        var s = new PieChart.Slice(pie, i);
                        s.data = data.values[i - data.offset];
                        s.id = s.data.__id;
                        slicesFraction += s.data.fraction;
                        slices.push(s);
                    }
                    // build "others" slice
                    var othersSettings = config.interaction.others;
                    var othersFraction = data.afterFraction;
                    var othersVal = data.afterSum;
                    for (var i = offset + count; i < data.offset + data.values.length; i++) {
                        var v = data.values[i - data.offset];
                        othersVal += v.value;
                        othersFraction += v.fraction;
                    }
                    var othersSlice;
                    if (othersFraction > 0 && (offset > 0 || data.values.length > othersSettings.minSlices)) {
                        othersSlice = new PieChart.Slice(pie, Infinity);
                        othersSlice.data = {
                            value: othersVal,
                            fraction: othersFraction,
                            name: config.localization.othersLabel
                        };
                    }
                    else {
                        othersSlice = null;
                    }
                    // build previous slice
                    var previousSlice = null;
                    var previousFraction = 0;
                    if (offset > 0) {
                        var prevValue = data.beforeSum;
                        for (var i = data.offset; i <= Math.min(offset, data.offset + data.values.length) - 1; i++) {
                            prevValue += Math.abs(data.values[i - data.offset].value);
                        }
                        previousSlice = new PieChart.Slice(pie, -1);
                        previousFraction = othersSettings.navigationFraction;
                        previousFraction += pie.scrollOffset;
                        previousSlice.data = {
                            value: prevValue,
                            name: config.localization.previousLabel
                        };
                        previousSlice.fraction = previousFraction;
                    }
                    /* Calculate slice fractions. Compute others fraction adjusted to total sum */
                    pie.visibleFraction = (slicesFraction + othersFraction) * (1 + (previousFraction / (1 - previousFraction)));
                    if (othersSlice) {
                        othersFraction = Math.max(othersSettings.navigationFraction, othersFraction);
                        othersFraction = Math.min(othersSettings.maxOthersFraction, othersFraction);
                        othersSlice.fraction = othersFraction;
                    }
                    // compress slices in available space
                    var fractionCompress = (1 - previousFraction - othersFraction) / slicesFraction;
                    slicesFraction = 1 - previousFraction - othersFraction;
                    for (var sliceIndex = 0; sliceIndex < slices.length; sliceIndex++) {
                        var slice = slices[sliceIndex];
                        slice.fraction = slice.data.fraction * fractionCompress;
                    }
                    // adjust slice fractions with minFraction
                    var minFraction = config.slice.minFraction;
                    if (minFraction > 0) {
                        var prevMinSlices = 0;
                        while (true) {
                            var slicesInMin = 0;
                            var fractionInMin = 0;
                            for (var sliceIndex = 0; sliceIndex < slices.length; sliceIndex++) {
                                var slice = slices[sliceIndex];
                                if (slice.fraction <= minFraction) {
                                    slicesInMin += 1;
                                    fractionInMin += slice.fraction;
                                }
                            }
                            if (slicesInMin === slices.length) {
                                var ff = slicesFraction / slices.length;
                                for (var sliceIndex = 0; sliceIndex < slices.length; sliceIndex++) {
                                    var slice = slices[sliceIndex];
                                    slice.fraction = ff;
                                }
                                break;
                            }
                            else {
                                fractionCompress = (slicesFraction - (slicesInMin * minFraction)) / (slicesFraction - fractionInMin);
                                for (var sliceIndex = 0; sliceIndex < slices.length; sliceIndex++) {
                                    var slice = slices[sliceIndex];
                                    if (slice.fraction <= minFraction) {
                                        slice.fraction = minFraction;
                                    }
                                    else {
                                        slice.fraction = slice.fraction * fractionCompress;
                                    }
                                }
                                if (slicesInMin === prevMinSlices) {
                                    break;
                                }
                                prevMinSlices = slicesInMin;
                            }
                        }
                    }
                    return {
                        slices: slices,
                        othersSlice: othersSlice,
                        previousSlice: previousSlice
                    };
                };
                /**
                 * Updates the pie with the given slices
                 * @param pie
                 * @param newSlices
                 * @param others
                 * @param previous
                 * @param [animate=true] - whether the pie should be updated via animation
                 */
                PieBuilder.prototype.applyNewSlices = function (pie, newSlices, others, previous, animate) {
                    if (animate === void 0) { animate = true; }
                    var oldSlices = pie.allSlices;
                    var wasEmpty = oldSlices.length === 0;
                    var slices = [];
                    var allSlices = [];
                    var i1 = 0;
                    var i2 = 0;
                    var oldLen = oldSlices.length;
                    var newLen = newSlices.length + (others ? 1 : 0) + (previous ? 1 : 0);
                    if (previous) {
                        if (!pie.previousSlice) {
                            if (!wasEmpty) {
                                previous.currentFraction = 0;
                            }
                            pie.previousSlice = previous;
                        }
                        else {
                            pie.previousSlice.removed = previous.removed;
                            pie.previousSlice.data = previous.data;
                            pie.previousSlice.fraction = previous.fraction;
                            pie.previousSlice.value = previous.value;
                            if (!animate) {
                                this.jumpSliceToAnimationEnd(pie.previousSlice);
                            }
                        }
                        allSlices.push(pie.previousSlice);
                    }
                    else if (pie.previousSlice) {
                        pie.previousSlice.removed = true;
                        pie.previousSlice.fraction = 0;
                        allSlices.push(pie.previousSlice);
                    }
                    while (i1 < oldSlices.length || i2 < newSlices.length) {
                        var s1 = oldSlices[i1];
                        var s2 = newSlices[i2];
                        if (s1 && (s1.index === Infinity || s1.index === -1)) {
                            // ignore old "previous" and "others"
                            i1++;
                        }
                        else if (s1 && s2 && (s1.originalId || s1.id) === s2.id) {
                            /* slice kept */
                            s1.removed = false;
                            s1.fraction = s2.fraction;
                            s1.data = s2.data;
                            if (s2.currentFraction && animate) {
                                s1.currentFraction = s2.currentFraction;
                                s1._animatorF = null;
                            }
                            if (!animate) {
                                this.jumpSliceToAnimationEnd(s1);
                            }
                            slices.push(s1);
                            allSlices.push(s1);
                            i1++;
                            i2++;
                        }
                        else if (!s2 || (s1 && (s1.index < s2.index || oldLen > newLen))) {
                            // slice removed
                            s1.removed = true;
                            s1.fraction = 0;
                            // this is to avoid duplicate slice IDs.
                            // the original ID is used in cases when the same value is being added back while
                            // the removal animation is still in progress.
                            if (!s1.originalId)
                                s1.originalId = s1.id;
                            s1.id = Internal.Base.Helpers.getIdentifierStr();
                            if (animate) {
                                allSlices.push(s1);
                            }
                            i1++;
                        }
                        else {
                            // new slice
                            if (!s2.currentFraction && !wasEmpty) {
                                s2.currentFraction = 0;
                            }
                            if (!animate) {
                                this.jumpSliceToAnimationEnd(s2);
                            }
                            slices.push(s2);
                            allSlices.push(s2);
                            i2++;
                        }
                    }
                    if (others) {
                        if (!pie.othersSlice) {
                            if (!wasEmpty) {
                                others.currentFraction = 0;
                            }
                            pie.othersSlice = others;
                        }
                        else {
                            pie.othersSlice.removed = others.removed;
                            pie.othersSlice.data = others.data;
                            pie.othersSlice.fraction = others.fraction;
                            pie.othersSlice.value = others.value;
                            if (!animate) {
                                this.jumpSliceToAnimationEnd(pie.othersSlice);
                            }
                        }
                        allSlices.push(pie.othersSlice);
                    }
                    else if (pie.othersSlice) {
                        allSlices.push(pie.othersSlice);
                        pie.othersSlice.removed = true;
                        pie.othersSlice.fraction = 0;
                    }
                    if (!animate && pie.othersSlice) {
                        this.jumpSliceToAnimationEnd(pie.othersSlice);
                    }
                    pie.total = pie.data ? pie.data.total : 0;
                    pie.count = newSlices.length;
                    pie.slices = slices;
                    pie.allSlices = allSlices;
                    // copy values to slice
                    for (var sliceIndex = 0; sliceIndex < allSlices.length; sliceIndex++) {
                        var slice = allSlices[sliceIndex];
                        slice.value = slice.data.value;
                        if (!animate) {
                            this.jumpSliceToAnimationEnd(slice);
                        }
                    }
                    // link to parent and child pies
                    this.scene.updateOnPieChanged(pie);
                };
                /**
                 * Ends the running animation in a slice, and jumps to the end of the animation
                 * @param slice
                 */
                PieBuilder.prototype.jumpSliceToAnimationEnd = function (slice) {
                    if (slice._animatorF) {
                        slice._animatorF.jump(slice.fraction);
                    }
                    else {
                        slice._animatorF = new Internal.Base.Animator(slice.fraction, slice.fraction, this.scene.settings.interaction.animation.scrollDuration, "<>", 0);
                    }
                    slice.currentFraction = slice.fraction;
                };
                PieBuilder.prototype.getPieData = function (pie) {
                    var data = this.scene.mainData.getPieData(pie.id);
                    if (!data) {
                        return null;
                    }
                    // compute fractions
                    var sum = data.total;
                    if (sum > 0) {
                        for (var vIndex = 0; vIndex < data.values.length; vIndex++) {
                            var v = data.values[vIndex];
                            v.fraction = Math.max(1e-9, v.value / sum);
                        }
                    }
                    else {
                        sum = data.values.length;
                        for (var vIndex = 0; vIndex < data.values.length; vIndex++) {
                            var v = data.values[vIndex];
                            v.fraction = 1 / sum;
                        }
                    }
                    if (data.afterSum > 0) {
                        data.afterFraction = data.afterSum / sum;
                    }
                    else {
                        data.afterFraction = 0;
                    }
                    if (data.beforeSum > 0) {
                        data.beforeFraction = data.beforeSum / sum;
                    }
                    else {
                        data.beforeFraction = 0;
                    }
                    return data;
                };
                return PieBuilder;
            }());
            PieChart.PieBuilder = PieBuilder;
        })(PieChart = Internal.PieChart || (Internal.PieChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Animations.ts" />
/// <reference path="Layout.ts" />
/// <reference path="Renderer.ts" />
/// <reference path="Builder.ts" />
/// <reference path="../base/core/ChartShell.ts" />
/// <reference path="../base/Geometry.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var PieChart;
        (function (PieChart) {
            var PieView = (function (_super) {
                __extends(PieView, _super);
                function PieView(chart) {
                    _super.call(this);
                    this.animationOrder = 500;
                    this.paintOrder = 30;
                    this.updateOrder = 700;
                    this.chart = chart;
                    this.scene = chart.scene;
                    this.renderer = new PieChart.PieRenderer(chart);
                    this.animator = new PieChart.Animations(chart);
                    this.layout = new PieChart.PieLayout(chart, this);
                    this.builder = new PieChart.PieBuilder(chart);
                }
                /** builds pie contents, returns true if more data is needed */
                PieView.prototype.updatePie = function (pie, animate) {
                    if (animate === void 0) { animate = true; }
                    return this.builder.updatePie(pie, animate);
                };
                /** scrools forward to the specified offset or one page and updates pie contents, returns true if more data is needed */
                PieView.prototype.scrollForward = function (pie, offset) {
                    return this.builder.scrollForward(pie, offset);
                };
                /** scrools backward to the specified offset or one page and updates pie contents, returns true if more data is needed */
                PieView.prototype.scrollBackward = function (pie, offset) {
                    return this.builder.scrollBackward(pie, offset);
                };
                PieView.prototype.onSceneChange = function (event) {
                    this.renderer.onSceneChange(event);
                };
                PieView.prototype.doAnimations = function (event) {
                    var pieChanges = false;
                    if (event.changes.settings || event.changes.pie || event.changes.bounds || event.changes.assets) {
                        var pie = this.scene.peek();
                        if (pie && this.chart.assetsLoaded) {
                            pieChanges = this.layout.placeStack(pie, event.context);
                        }
                    }
                    var changedPies = this.animator.doAnimations(event);
                    for (var pieIndex = 0; pieIndex < changedPies.length; pieIndex++) {
                        var pie = changedPies[pieIndex];
                        this.layout.placeLabels(pie, event.context);
                    }
                    if (pieChanges || changedPies) {
                        event.changes.position = true;
                    }
                };
                PieView.prototype.paintScene = function (event) {
                    this.renderer.paintScene(event);
                };
                /**
                 * Converts the pointer movement to the polar coordinate system of the given pie
                 * @param pie - the pie, relative to which the
                 * @param event
                 * @returns {{dfraction: number, doffset: number}} - dfraction is expressed as a fraction of 360 deg
                 */
                PieView.prototype.getMovement = function (pie, event) {
                    // return movement along [fraction, distance]
                    var x0 = event.x - event.dx - pie.x;
                    var y0 = event.y - event.dy - pie.y;
                    var x1 = event.x - pie.x;
                    var y1 = event.y - pie.y;
                    var a0 = Internal.Base.Geometry.normalizeAngle(Math.atan2(y0, x0));
                    var a1 = Internal.Base.Geometry.normalizeAngle(Math.atan2(y1, x1));
                    var df = Internal.Base.Geometry.subtractAngle(a1, a0) / (pie.currentEndAngle - pie.currentStartAngle);
                    var d0 = Math.sqrt(x0 * x0 + y0 * y0);
                    var d1 = Math.sqrt(x1 * x1 + y1 * y1);
                    var dd = d1 - d0;
                    return { dfraction: df, doffset: dd };
                };
                PieView.prototype.findPieAt = function (px, py, tolerance) {
                    var add = this.scene.currentInnerRadius;
                    var mul = this.scene.currentRadius - add;
                    for (var i = this.scene.pies.length - 1; i >= 0; i--) {
                        var pie = this.scene.pies[i];
                        var x = pie.x;
                        var y = pie.y;
                        var r0 = pie.currentInnerRadius * mul + add;
                        var r1 = pie.currentRadius * mul + add;
                        var xx = Math.max(0, r0 - tolerance);
                        xx = r1 + tolerance;
                        var r1sq = xx * xx;
                        var dx = px - x;
                        var dy = py - y;
                        var distSq = dx * dx + dy * dy;
                        if (pie.background || this.scene.pies.length === 1) {
                            if (distSq <= r1sq) {
                                return pie;
                            }
                        }
                    }
                    return null;
                };
                PieView.prototype.findSliceAt = function (px, py, tolerance, coverCenter) {
                    var add = this.scene.currentInnerRadius;
                    var mul = this.scene.currentRadius - add;
                    for (var i = this.scene.pies.length - 1; i >= 0; i--) {
                        var pie = this.scene.pies[i];
                        if (pie.background) {
                            continue;
                        }
                        var x = pie.x;
                        var y = pie.y;
                        var r0 = coverCenter ? 0 : pie.currentInnerRadius * mul + add;
                        var r1 = pie.currentRadius * mul + add;
                        var xx = Math.max(0, r0 - tolerance);
                        xx = r1 + tolerance;
                        var dx = px - x;
                        var dy = py - y;
                        var distSq = dx * dx + dy * dy;
                        var dist = Math.sqrt(distSq);
                        dx /= dist;
                        dy /= dist;
                        var a1 = pie.currentStartAngle;
                        var ad = pie.currentEndAngle - a1;
                        var cosa1 = Math.cos(a1);
                        var sina1 = Math.sin(a1);
                        for (var sliceIndex = 0; sliceIndex < pie.allSlices.length; sliceIndex++) {
                            var slice = pie.allSlices[sliceIndex];
                            var cosa0 = cosa1;
                            var sina0 = sina1;
                            a1 += ad * slice.currentFraction;
                            cosa1 = Math.cos(a1);
                            sina1 = Math.sin(a1);
                            if (dist >= r0 + slice.currentCutoutDistance && dist <= r1 + slice.currentCutoutDistance) {
                                var dp1 = sina0 * dx - cosa0 * dy;
                                var dp2 = sina1 * dx - cosa1 * dy;
                                if (dp1 < 0 && dp2 > 0) {
                                    return slice;
                                }
                                if (Math.abs(ad * slice.currentFraction) > Math.PI) {
                                    // obtuse angle
                                    if ((dp1 < 0 && dp2 < 0) || (dp1 > 0 && dp2 > 0)) {
                                        return slice;
                                    }
                                }
                            }
                        }
                    }
                    return null;
                };
                PieView.prototype.findLabelAt = function (px, py, tolerance) {
                    for (var i = this.scene.pies.length - 1; i >= 0; i--) {
                        var pie = this.scene.pies[i];
                        var x = px - pie.x;
                        var y = py - pie.y;
                        for (var sliceIndex = 0; sliceIndex < pie.allSlices.length; sliceIndex++) {
                            var slice = pie.allSlices[sliceIndex];
                            if (slice.currentLabel) {
                                var l = slice.currentLabel;
                                if (l.visible && l.x - l.hwidth <= x && l.x + l.hwidth >= x && l.y - l.hheight <= y && l.y + l.hheight >= y) {
                                    return { slice: slice, label: l };
                                }
                            }
                            if (slice.currentInsideLabel) {
                                var l = slice.currentInsideLabel;
                                if (l.visible && l.x - l.hwidth <= x && l.x + l.hwidth >= x && l.y - l.hheight <= y && l.y + l.hheight >= y) {
                                    return { slice: slice, label: l };
                                }
                            }
                        }
                    }
                    return { slice: null, label: null };
                };
                return PieView;
            }(Internal.Base.ChartElement));
            PieChart.PieView = PieView;
        })(PieChart = Internal.PieChart || (Internal.PieChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Impl.ts" />
/// <reference path="../base/Resizer.ts" />
/// <reference path="../base/MessagesOverlay.ts" />
/// <reference path="../base/Title.ts" />
/// <reference path="../base/Legend.ts" />
/// <reference path="../base/Credits.ts" />
/// <reference path="Scene.ts" />
/// <reference path="Selection.ts" />
/// <reference path="Styles.ts" />
/// <reference path="DomLayer.ts" />
/// <reference path="Settings.ts" />
/// <reference path="Scrolling.ts" />
/// <reference path="Navigator.ts" />
/// <reference path="InfoPopup.ts" />
/// <reference path="Legend.ts" />
/// <reference path="Data.ts" />
/// <reference path="PieView.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var PieChart;
        (function (PieChart) {
            var Impl = (function (_super) {
                __extends(Impl, _super);
                function Impl(settings, api) {
                    _super.call(this, new PieChart.Settings(settings), new PieChart.Scene(), api);
                    this.scene.loading = false;
                    this.selection = this.events.addElement(new PieChart.Selection(this));
                    this.scene.view = new PieChart.PieView(this);
                    this.popup = this.events.addElement(new PieChart.InfoPopup(this));
                    this.legend = this.events.addElement(new PieChart.Legend(this));
                    this.events.addElement(new PieChart.Styles(this));
                    this.navigator = this.events.addElement(new PieChart.Navigator(this));
                    this.events.addElement(this.scene.view);
                    // prepare components
                    this.finalInitialize();
                    this.navigator.setPie(this.settings.navigation.initialDrilldown, this.settings.navigation.initialOffset, "init");
                }
                Impl.prototype.createDataObj = function (dataSettings) {
                    return new PieChart.Data(this, dataSettings, false);
                };
                Impl.prototype.getData = function (id) {
                    return _super.prototype.getData.call(this, id);
                };
                Impl.prototype.createDomLayer = function () {
                    return new PieChart.DomLayer(this);
                };
                Impl.prototype.onSettingsChanged = function (changes) {
                    if (changes.navigation && (changes.navigation.initialDrilldown || changes.navigation.initialOffset)) {
                        this.navigator.setPie(this.settings.navigation.initialDrilldown, this.settings.navigation.initialOffset);
                    }
                    if (changes.labels || changes.icons || changes.pie || changes.slice || changes.interaction) {
                        this.events.notifySceneChanges({ pie: true });
                    }
                };
                Impl.prototype.save = function () {
                    var selectionIds = this.saveSelection();
                    return JSON.stringify({
                        pie: this.navigator.getPie(),
                        offset: this.navigator.getPieOffset(),
                        selection: selectionIds
                    });
                };
                Impl.prototype.zoomOut = function (animate, origin) {
                    if (animate === void 0) { animate = true; }
                    if (origin === void 0) { origin = "api"; }
                    this.navigator.goBack(origin);
                };
                Impl.prototype.zoomOutPossible = function () {
                    var scene = this.scene;
                    return scene.length() > 1 || scene.peek().offset > 0;
                };
                Impl.prototype.restore = function (stateStr, animate) {
                    if (!stateStr) {
                        return;
                    }
                    var pie = JSON.parse(stateStr);
                    this.setPie(pie.pie, pie.offset, animate);
                    this.setSelection(pie.selection);
                };
                Impl.prototype.updateFilters = function () {
                    // overrides base functionality
                    this.updateFilter(true);
                };
                Impl.prototype.updateFilter = function (deep) {
                    if (deep === void 0) { deep = false; }
                    this.log("Update filter");
                    var dataChanges = {};
                    for (var k in this.settings._computedDataMap)
                        dataChanges[k] = true;
                    this.events.notifySceneChanges({ data: dataChanges, dataDeep: deep });
                };
                Impl.prototype.setSelection = function (selection, origin) {
                    if (origin === void 0) { origin = "api"; }
                    this.log("Set selection");
                    var realSelection = [];
                    var selectionIds = [];
                    for (var nIndex = 0; nIndex < selection.length; nIndex++) {
                        var n = selection[nIndex];
                        if (n instanceof PieChart.Slice) {
                            realSelection.push(n);
                        }
                        else if (Internal.Base.Helpers.isString(n)) {
                            selectionIds.push(n);
                        }
                        else {
                            this.error("SetSelection: Selection contents must be Piechart_Slice object or string, got " + n);
                        }
                    }
                    this.selection.setSelection(realSelection, selectionIds, false, origin);
                };
                Impl.prototype.saveSelection = function () {
                    var selectionIds = this.scene.selectionIds.splice(0);
                    for (var sIndex = 0; sIndex < this.scene.selection.length; sIndex++) {
                        var s = this.scene.selection[sIndex];
                        selectionIds.push(s.id);
                    }
                    return selectionIds;
                };
                Impl.prototype.exportVisibleData = function () {
                    var p = this.scene.peek();
                    if (!p)
                        return [];
                    return PieChart.Data.exportValues(p.data);
                };
                Impl.prototype.setPie = function (root, offset, animate, origin) {
                    if (animate === void 0) { animate = true; }
                    if (origin === void 0) { origin = "api"; }
                    this.log("Set pie");
                    this.navigator.setPie(root, offset, origin);
                };
                Impl.prototype.setPieOffset = function (offset, animate, origin) {
                    if (animate === void 0) { animate = true; }
                    if (origin === void 0) { origin = "api"; }
                    this.log("Set pie offset");
                    this.navigator.setPie(this.getPie(), offset, origin);
                };
                Impl.prototype.getPie = function () {
                    return this.navigator.getPie();
                };
                Impl.prototype.getActiveSlices = function () {
                    var r = [];
                    for (var pieIndex = 0; pieIndex < this.scene.stack.length; pieIndex++) {
                        var pie = this.scene.stack[pieIndex];
                        if (pie.parentSlice) {
                            r.push(pie.parentSlice);
                        }
                    }
                    return r;
                };
                Impl.prototype.getActivePies = function () {
                    return this.scene.stack;
                };
                Impl.prototype.expandSlice = function (slice, origin) {
                    if (origin === void 0) { origin = "api"; }
                    return this.navigator.expandSlice(slice, origin);
                };
                Impl.prototype.getSliceDimensions = function (sliceId, showPartial) {
                    // figure out the slice object
                    if (!Array.isArray(sliceId)) {
                        this.error("getSliceDimensions: slice Id must be an array");
                        return null;
                    }
                    if (sliceId.length < 2) {
                        return null;
                    }
                    if (!showPartial && this.scene.stack.length + 1 < sliceId.length) {
                        return null;
                    }
                    var pos = 0;
                    var pie;
                    for (var pieIndex = 0; pieIndex < this.scene.stack.length; pieIndex++) {
                        pie = this.scene.stack[pieIndex];
                        if (pie.id !== sliceId[pos]) {
                            return null;
                        }
                        pos += 1;
                        if (pos === sliceId.length - 1) {
                            break;
                        }
                    }
                    var sid = sliceId[pos];
                    for (var sliceIndex = 0; sliceIndex < pie.slices.length; sliceIndex++) {
                        var slice = pie.slices[sliceIndex];
                        if (slice.id === sid) {
                            var rp = slice._renderParams;
                            if (!rp) {
                                return null;
                            }
                            return {
                                centerX: pie.x,
                                centerY: pie.y,
                                r0: rp[0],
                                r1: rp[1],
                                a0: rp[2],
                                a1: rp[3]
                            };
                        }
                    }
                    return null;
                };
                /** events */
                Impl.prototype.saveNavigation = function () {
                    var pie = this.scene.peek();
                    if (!(pie && !pie.loading)) {
                        return null;
                    }
                    return {
                        pie: this.navigator.getPie(),
                        offset: this.navigator.getPieOffset()
                    };
                };
                Impl.prototype.restoreNavigation = function (state, animate, origin) {
                    this.navigator.setPie(state.pie, state.offset, origin);
                };
                Impl.prototype.doChartUpdateNotify = function (origin) {
                    _super.prototype.doChartUpdateNotify.call(this, origin);
                    // legacy events.
                    var args = this.createEventArguments(null, origin);
                    this.dispatchEventParams("pieChange", args, null);
                    this.dispatchEventParams("pieReadyStateChanged", args, null);
                };
                Impl.prototype.createEventArguments = function (event, origin) {
                    var scene = this.scene;
                    var pie = scene.peek();
                    return {
                        chart: this.api,
                        origin: origin,
                        pie: pie,
                        offset: pie ? pie.offset : null,
                        count: pie ? pie.count : null,
                        // use a copy of the selection so that the caller can freely modify it
                        selection: scene.selection.slice(),
                        slice: scene.hoverSlice,
                        hoverSlice: scene.hoverSlice,
                        hoverPie: scene.hoverPie,
                        label: scene.hoverLabel,
                        hoverLabel: scene.hoverLabel,
                    };
                };
                Impl.prototype.defaultClick = function (event, args) {
                    var s = args.clickSlice;
                    var p = args.clickPie;
                    var isDrilldown = this.settings.interaction.mode === "drilldown";
                    if (isDrilldown || (s && (s === s.pie.othersSlice || s === s.pie.previousSlice))) {
                        if (s) {
                            if (s.url) {
                                Internal.Base.Helpers.openUrl(s.url, s.urlTarget);
                                event.preventDefault();
                            }
                            else {
                                if (this.navigator.expandSlice(s, "user")) {
                                    event.preventDefault();
                                }
                            }
                        }
                        else if (p && args.clickOrigin === "back") {
                            this.setSelection([], "user");
                            this.navigator.goCenter("user");
                            event.preventDefault();
                        }
                    }
                };
                return Impl;
            }(Internal.Base.Impl));
            PieChart.Impl = Impl;
        })(PieChart = Internal.PieChart || (Internal.PieChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="ZoomCharts.d.ts" />
/// <reference path="piechart/Settings.ts" />
/// <reference path="piechart/Impl.ts" />
/// <reference path="base/Api.ts" />
/// <reference path="base/SettingsHelper.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    /** @api-class */
    var PieChart = (function (_super) {
        __extends(PieChart, _super);
        function PieChart(settings) {
            var _this = this;
            _super.call(this);
            this.typeName = "PieChart";
            if (PieChart.chartFactoryMethod) {
                this._impl = PieChart.chartFactoryMethod(function (stngs) { return new ZoomCharts.Internal.PieChart.Impl(stngs, _this); }, settings);
            }
            else {
                this._impl = new ZoomCharts.Internal.PieChart.Impl(settings, this);
            }
        }
        PieChart.prototype.updateSettings = function (changes) {
            _super.prototype.updateSettings.call(this, changes);
            return this;
        };
        PieChart.prototype.replaceSettings = function (changes) {
            _super.prototype.replaceSettings.call(this, changes);
            return this;
        };
        PieChart.prototype.updateFilter = function () {
            this._impl.updateFilter();
            return this;
        };
        PieChart.prototype.addData = function (data, sourceId) {
            if (sourceId == null)
                sourceId = "default";
            this._impl.addData(data, sourceId);
        };
        PieChart.prototype.replaceData = function (data, sourceId) {
            if (sourceId == null)
                sourceId = "default";
            this._impl.replaceData(data, sourceId);
        };
        /** Retrieves or updates the selected slices on the chart.
        @param selected - The slices or their IDs that should be selected. Any currently selected slices that are not present will be unselected.
        @returns An array of currently selected slices after the changes have been applied. */
        PieChart.prototype.selection = function (selected) {
            if (selected) {
                if (!Array.isArray(selected)) {
                    this._impl.error("PieChart.selection() - the argument must be an array of PieChart.Slice objects or strings.");
                }
                else {
                    var ids = selected.slice();
                    for (var i = 0; i < ids.length; i++) {
                        var n = ids[i];
                        if (n instanceof ZoomCharts.Internal.PieChart.Slice) {
                            // the user of the public API might be passing in slice objects that are long gone from the chart. To avoid issues in
                            // such cases, use the ID values and not the slice instances themselves.
                            ids[i] = n.id;
                        }
                        else if (!ZoomCharts.Internal.Base.Helpers.isString(n)) {
                            this._impl.error("PieChart.selection() - the argument must be an array of PieChart.Slice objects or strings.");
                        }
                    }
                    this._impl.setSelection(ids);
                }
            }
            // return a copy of the selection so that the user code can freely modify it.
            return this._impl.scene.selection.slice();
        };
        PieChart.prototype.getPie = function () {
            return this._impl.getPie();
        };
        PieChart.prototype.getPieOffset = function () {
            return this._impl.navigator.getPieOffset();
        };
        PieChart.prototype.setPie = function (pieId, offset) {
            if (offset === void 0) { offset = 0; }
            if (offset == null)
                offset = 0; // ported from CoffeeScript;
            this._impl.setPie(pieId, offset);
            return this;
        };
        PieChart.prototype.setPieOffset = function (offset) {
            this._impl.setPieOffset(offset);
            return this;
        };
        PieChart.prototype.getActiveSlices = function () {
            return this._impl.getActiveSlices();
        };
        PieChart.prototype.getActivePies = function () {
            return this._impl.getActivePies();
        };
        PieChart.prototype.getActivePie = function () {
            var p = this._impl.getActivePies();
            return p[p.length - 1];
        };
        PieChart.prototype.expandSlice = function (slice) {
            return this._impl.expandSlice(slice, "api");
        };
        PieChart.prototype.getSliceDimensions = function (sliceId, showPartial) {
            if (showPartial === void 0) { showPartial = false; }
            if (showPartial == null)
                showPartial = false; // ported from CoffeeScript;
            /* returns dimensions object on screen
            centerX, centerY, x0, y0, a0, a1 */
            return this._impl.getSliceDimensions(sliceId, showPartial);
        };
        PieChart.prototype.on = function (name, listener) {
            _super.prototype.on.call(this, name, listener);
        };
        PieChart.themes = {
            "dark": ZoomCharts.Internal.PieChart.Settings.DarkTheme,
            "flat": ZoomCharts.Internal.PieChart.Settings.FlatTheme,
            "bevel": ZoomCharts.Internal.PieChart.Settings.BevelTheme,
            "gradient": ZoomCharts.Internal.PieChart.Settings.GradientTheme,
            "raised": ZoomCharts.Internal.PieChart.Settings.CanTheme
        };
        /**
         * An internal method that is used by the test runner engine to automatically pass the generated settings when a new chart instance is created.
         * @ignore
         */
        PieChart.chartFactoryMethod = null;
        return PieChart;
    }(ZoomCharts.Internal.Base.Api));
    ZoomCharts.PieChart = PieChart;
    ZoomCharts.Internal.Base.Helpers.exportSymbol("PieChart", ZoomCharts.PieChart);
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../base/Bar/Combobox.ts" />
/// <reference path="../TimeStep.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var TimeChart;
        (function (TimeChart) {
            var Bar;
            (function (Bar) {
                var DisplayPeriodDropdown = (function (_super) {
                    __extends(DisplayPeriodDropdown, _super);
                    function DisplayPeriodDropdown(chart, options) {
                        options.cssClass = options.cssClass || "DVSL-bar-btn-month";
                        options.title = options.title || chart.settings.localization.toolbar.periodDropdownTitle;
                        _super.call(this, chart, options);
                        this._getItemsCache = null;
                        this.custom = {
                            displayAnchor: null,
                            disabled: false,
                            displayPeriod: null,
                            displayPeriodStr: null,
                            displayUnit: null,
                            displayUnitStr: null,
                            selected: false,
                            name: chart.settings.localization.toolbar.customPeriod
                        };
                        this.updateSelectedItem();
                    }
                    DisplayPeriodDropdown.prototype.onSelectionChange = function (item) {
                        this.chart.setDisplayPeriod(item.displayPeriodStr, item.displayAnchor, item.displayUnit == null ? null : item.displayUnit.toString(), true, "user");
                    };
                    DisplayPeriodDropdown.prototype.onSceneChange = function (changes) {
                        if (changes.settings)
                            this._getItemsCache = null;
                        if ((changes.settingsChanges && (changes.settingsChanges.area || changes.settingsChanges.toolbar)) || changes.time /*|| changes.toolbar*/) {
                            this.updateSelectedItem();
                        }
                    };
                    DisplayPeriodDropdown.prototype.updateSelectedItem = function () {
                        var last = this._lastSelectedItem;
                        if (last && last !== this.custom
                            && this.chart.isThisDisplayPeriod(last.displayPeriodStr, last.displayAnchor, last.displayUnitStr)) {
                            this.setSelectedItem(last);
                            return;
                        }
                        var items = this.getItems();
                        for (var itemIndex = 0; itemIndex < items.length; itemIndex++) {
                            var item = items[itemIndex];
                            if (item !== last && this.chart.isThisDisplayPeriod(item.displayPeriodStr, item.displayAnchor, item.displayUnitStr)) {
                                this.setSelectedItem(item);
                                return;
                            }
                        }
                        this.setSelectedItem(this.custom);
                    };
                    DisplayPeriodDropdown.prototype.setSelectedItem = function (item) {
                        if (this._lastSelectedItem) {
                            this._lastSelectedItem.selected = false;
                        }
                        item.selected = true;
                        _super.prototype.setSelectedItem.call(this, item);
                        this._lastSelectedItem = item;
                    };
                    DisplayPeriodDropdown.prototype.getItems = function () {
                        if (this._getItemsCache) {
                            return this._getItemsCache;
                        }
                        var r = [];
                        var minUnit = this.chart.settings._minUnit;
                        var selected = this.custom;
                        for (var pIndex = 0; pIndex < this.chart.settings.toolbar.periods.length; pIndex++) {
                            var s = this.chart.settings.toolbar.periods[pIndex];
                            var p = s.parse();
                            var period = p.displayPeriod;
                            var unit = p.displayUnit;
                            if ((unit && unit.isSmaller(minUnit)) || (period && period.isSmallerOrEqual(minUnit))) {
                                continue;
                            }
                            r.push(p);
                            if (this.chart.isThisDisplayPeriod(s.displayPeriod, p.displayAnchor, s.displayUnit))
                                selected = p;
                        }
                        this._lastSelectedItem = selected;
                        selected.selected = true;
                        this._getItemsCache = r;
                        return r;
                    };
                    return DisplayPeriodDropdown;
                }(Internal.Base.Bar.Combobox));
                Bar.DisplayPeriodDropdown = DisplayPeriodDropdown;
                Internal.Base.Bar.ToolbarItemNames["displayPeriod"] = function (chart, options) { return new TimeChart.Bar.DisplayPeriodDropdown(chart, options); };
            })(Bar = TimeChart.Bar || (TimeChart.Bar = {}));
        })(TimeChart = Internal.TimeChart || (Internal.TimeChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../base/Bar/Combobox.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var TimeChart;
        (function (TimeChart) {
            var Bar;
            (function (Bar) {
                var DisplayUnitDropdown = (function (_super) {
                    __extends(DisplayUnitDropdown, _super);
                    function DisplayUnitDropdown(chart, options) {
                        if (!options)
                            options = {};
                        options.cssClass = options.cssClass || "DVSL-bar-btn-bars";
                        options.title = options.title || chart.settings.localization.toolbar.unitDropdownTitle;
                        _super.call(this, chart, options);
                        this.updateSelectedItem();
                    }
                    DisplayUnitDropdown.prototype.onSelectionChange = function (item) {
                        this.chart.setDisplayUnit(item.value, true, "user");
                    };
                    DisplayUnitDropdown.prototype.onSceneChange = function (changes) {
                        if (changes.settings)
                            this._getItemsCache = null;
                        if ((changes.settingsChanges && (changes.settingsChanges.area || changes.settingsChanges.toolbar)) || changes.time /*|| changes.toolbar*/) {
                            this.updateSelectedItem();
                        }
                    };
                    DisplayUnitDropdown.prototype.updateSelectedItem = function () {
                        var unit = this.chart.displayUnit;
                        if (!unit) {
                            return;
                        }
                        var items = this.getItems();
                        // find appropriate item in list to get it's proper name
                        for (var itemIndex = 0; itemIndex < items.length; itemIndex++) {
                            var item = items[itemIndex];
                            if (item.value.isEqual(unit)) {
                                this.setSelectedItem(item);
                                return;
                            }
                        }
                        // default
                        this.setSelectedItem({ name: unit.name, value: unit, disabled: false, selected: true });
                    };
                    DisplayUnitDropdown.prototype.getItems = function () {
                        if (this._getItemsCache)
                            return this._getItemsCache;
                        var scene = this.chart.scene;
                        var items = [];
                        var minSelectableTime = ((scene.timeEnd - scene.timeStart) / scene.width) * this.chart.settings.timeAxis.minUnitWidth;
                        var wasDisabled = false;
                        for (var unitIndex = 0; unitIndex < this.chart.settings._displayUnitsParsed.length; unitIndex++) {
                            var unit = this.chart.settings._displayUnitsParsed[unitIndex];
                            if (unit.approxTime() < minSelectableTime) {
                                if (!wasDisabled) {
                                    items.push({
                                        name: this.chart.settings.localization.toolbar.unavailableUnitTitle,
                                        value: unit,
                                        disabled: true,
                                        selected: false
                                    });
                                    wasDisabled = true;
                                }
                            }
                            else {
                                items.push({
                                    name: unit.name,
                                    value: unit,
                                    disabled: false,
                                    selected: unit.isEqual(scene.displayUnit)
                                });
                            }
                        }
                        return items;
                    };
                    return DisplayUnitDropdown;
                }(Internal.Base.Bar.Combobox));
                Bar.DisplayUnitDropdown = DisplayUnitDropdown;
                Internal.Base.Bar.ToolbarItemNames["displayUnit"] =
                    function (chart, options) { return new TimeChart.Bar.DisplayUnitDropdown(chart, options); };
            })(Bar = TimeChart.Bar || (TimeChart.Bar = {}));
        })(TimeChart = Internal.TimeChart || (Internal.TimeChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../../base/Settings.ts" />
/// <reference path="../../base/Bar/Toolbar.ts" />
/// <reference path="../../base/Bar/BackButton.ts" />
/// <reference path="../../base/Bar/ZoomOutButton.ts" />
/// <reference path="../../linearchart/Bar/LinLogButton.ts" />
/// <reference path="../../linearchart/Bar/Toolbar.ts" />
/// <reference path="DisplayPeriodDropdown.ts" />
/// <reference path="DisplayUnitDropdown.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var TimeChart;
        (function (TimeChart) {
            var SettingsAreaDisplayPeriod = (function () {
                function SettingsAreaDisplayPeriod(nameOrDisplayPeriod, displayAnchor, displayPeriod, displayUnit) {
                    /** Named time interval. */
                    this.name = null;
                    /** Reference time for passed data. For example, if the `displayPeriod` is set to `1 d`, this could contain the timestamp of the start of that day. */
                    this.displayAnchor = null;
                    /** Display period, either "auto" or a time unit such as `1 d`. */
                    this.displayPeriod = null;
                    /** Units in which to show data. */
                    this.displayUnit = null;
                    if (displayAnchor === void 0) {
                        this.displayPeriod = nameOrDisplayPeriod;
                    }
                    else {
                        this.name = nameOrDisplayPeriod;
                        this.displayAnchor = displayAnchor;
                        this.displayPeriod = displayPeriod;
                        this.displayUnit = displayUnit;
                    }
                }
                /** @ignore */
                SettingsAreaDisplayPeriod.prototype.parse = function () {
                    var dp = this.displayPeriod;
                    var du = this.displayUnit;
                    return {
                        name: this.name,
                        displayAnchor: this.displayAnchor,
                        displayPeriod: dp === "max" ? null : TimeChart.TimeStep.parse(dp),
                        displayPeriodStr: dp,
                        displayUnit: du === "auto" ? null : TimeChart.TimeStep.parse(du),
                        displayUnitStr: du,
                        selected: false,
                        disabled: false
                    };
                };
                return SettingsAreaDisplayPeriod;
            }());
            TimeChart.SettingsAreaDisplayPeriod = SettingsAreaDisplayPeriod;
            var SettingsToolbar = (function (_super) {
                __extends(SettingsToolbar, _super);
                function SettingsToolbar() {
                    _super.apply(this, arguments);
                    this.enabled = true;
                    /** Whether to show the Zoom-out button in the toolbar. */
                    this.zoomOut = true;
                    /** Whether to show the Lin/Log button in the toolbar. */
                    this.logScale = true;
                    /** Whether to show the display unit dropdown. */
                    this.displayUnit = true;
                    /** Whether to show display period dropdown. */
                    this.displayPeriod = true;
                    /** Create custom zoomout function to specify target unit for each display unit once `Zoom-out` toolbar item clicked. Also possible to specify
                        new from and to timestamps to manage zoomout range in perspective to current range. If only unit specified, internal logic
                        will be applied that is 30 times wider time range than compared to range before `Zoom-out` toolbar item clicked. If only from and to timestamps
                        specified than unit will be used as a next unit to current display item that's available of display units. If according to min, max unit width
                        is not possible to show specified range, the middle of both timestamps will be the center of zoomout range and some portion of both sides may be
                        cut down.
                        @returns Target unit referenced for current display unit and from, to timestamps. In case of null returned, the next higher display unit will be chosen.
                        @version 1.12.0 */
                    this.zoomOutFunction = null;
                    /** Time periods */
                    this.periods = [
                        new SettingsAreaDisplayPeriod("Last second", "now", "1 s", "25 ms"),
                        new SettingsAreaDisplayPeriod("Last minute", "now", "1 m", "1 s"),
                        new SettingsAreaDisplayPeriod("Last hour", "now", "1 h", "1 m"),
                        new SettingsAreaDisplayPeriod("Last day", "now", "1 d", "1 h"),
                        new SettingsAreaDisplayPeriod("Last week", "now", "1 w", "6 h"),
                        new SettingsAreaDisplayPeriod("Last month", "now", "1 M", "1 d"),
                        new SettingsAreaDisplayPeriod("Last year", "now", "1 y", "1 M"),
                        new SettingsAreaDisplayPeriod("All data", "newestData", "max", "auto"),
                    ];
                    this.items = [
                        new Internal.Base.SettingsToolbarItem("back", "left"),
                        new Internal.Base.SettingsToolbarItem("zoomOut", "left"),
                        new Internal.Base.SettingsToolbarItem("logScale", "right"),
                        new Internal.Base.SettingsToolbarItem("displayPeriod", "right"),
                        new Internal.Base.SettingsToolbarItem("displayUnit", "right"),
                        new Internal.Base.SettingsToolbarItem("export", "right"),
                    ];
                }
                return SettingsToolbar;
            }(Internal.Base.SettingsToolbar));
            TimeChart.SettingsToolbar = SettingsToolbar;
        })(TimeChart = Internal.TimeChart || (Internal.TimeChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="TimeStep.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var TimeChart;
        (function (TimeChart) {
            var TimeSetup = (function () {
                function TimeSetup(chart) {
                    this.settings = chart.settings;
                    this.chart = chart;
                    this.scene = chart.scene;
                }
                TimeSetup.prototype.toBiggerDisplayUnit = function (unit) {
                    var best = null;
                    for (var pIndex = 0; pIndex < this.settings._displayPeriodsParsed.length; pIndex++) {
                        var p = this.settings._displayPeriodsParsed[pIndex];
                        // TODO: parse funky display periods too
                        if (p.approxTime() > unit.approxTime() && (best === null || p.approxTime() < best.approxTime())) {
                            best = p;
                        }
                    }
                    return best;
                };
                /**
                * Calculate range for specified unit regarding to anchor restrictions.
                * @return time range for specified unit
                */
                TimeSetup.prototype.getMinRangeForUnit = function (from, to, unit, anchor) {
                    var unitTime = unit.approxTime();
                    var minw = this.scene.settings.timeAxis.minUnitWidth;
                    var maxw = this.scene.settings.timeAxis.maxUnitWidth;
                    var exceed = this.verifyUnitWidth(from, to, unit);
                    if (exceed.min || exceed.max) {
                        Internal.Base.Helpers.warn("Could not show all data as requested by `navigation.initialDisplayPeriod`. "
                            + "Please adjust either `navigation.initialDisplayPeriod` or `timeAxis.minUnitWidth` and `timeAxis.maxUnitWidth`.");
                        var portion = void 0;
                        if (exceed.min) {
                            portion = (this.scene.width / minw) * unitTime;
                        }
                        else if (exceed.max) {
                            portion = (this.scene.width / maxw) * unitTime;
                        }
                        if (anchor === "oldestData") {
                            to = from + portion;
                        }
                        else {
                            from = to - portion;
                        }
                    }
                    return {
                        from: from,
                        to: to
                    };
                };
                TimeSetup.prototype.verifyUnitWidth = function (from, to, unit) {
                    var unitTime = unit.approxTime();
                    var minw = this.scene.settings.timeAxis.minUnitWidth;
                    var maxw = this.scene.settings.timeAxis.maxUnitWidth;
                    var s = (to - from) / this.scene.width;
                    // true, when exceed limits
                    return {
                        min: !(minw * s < unitTime),
                        max: !(maxw * s > unitTime)
                    };
                };
                TimeSetup.prototype.adjustTimeRangeToUnits = function (scene, from, to, unit) {
                    var center = to - (to - from) / 2;
                    var unitTime = unit.approxTime();
                    var unitRange = this.getUnitRange(scene, [unit]);
                    var rangeDiff = to - from;
                    var bars;
                    if (rangeDiff < unitRange.minTime) {
                        bars = Math.ceil((unitRange.minTime) / unitTime);
                    }
                    else {
                        bars = Math.min((to - from) / unitTime, Math.floor((unitRange.maxTime) / unitTime));
                    }
                    var barsToTime = bars * unitTime;
                    from = center - (barsToTime / 2) + 1;
                    to = center + (barsToTime / 2) - 1;
                    return { from: from, to: to };
                };
                /** Verify situation where min/max unit width violation occures */
                TimeSetup.prototype.preventUnitWidthViolation = function (to, from) {
                    var scene = this.scene;
                    var width = scene.width;
                    var scale = (to - from) / width;
                    var msPerMinUnit = scale * scene.settings.timeAxis.minUnitWidth;
                    return msPerMinUnit > scene.displayUnit.approxTime();
                };
                TimeSetup.prototype.getBiggerDisplayPeriod = function (from, to) {
                    var dt = Math.abs(to - from);
                    var bestD = 0;
                    var best = null;
                    for (var pIndex = 0; pIndex < this.settings._displayPeriodsParsed.length; pIndex++) {
                        var p = this.settings._displayPeriodsParsed[pIndex];
                        var unitdt = p.approxTime();
                        var proportion = dt / unitdt;
                        if (proportion < 0.9 && proportion > bestD) {
                            bestD = proportion;
                            best = p;
                        }
                    }
                    return best;
                };
                /**
                * @returns {TimeStep} one unit up to specified
                */
                TimeSetup.prototype.getBiggerDisplayUnit = function (unit) {
                    var parsedUnits = this.settings._displayUnitsParsed;
                    var curtime = unit.approxTime();
                    for (var i = 0; i < parsedUnits.length; i++) {
                        var e = parsedUnits[i];
                        if (e.approxTime() > curtime) {
                            return e;
                        }
                    }
                    return unit;
                };
                /** Gets the largest configured display unit that is smaller than the given unit.
                Returns `null` if the current is the smallest unit. */
                TimeSetup.prototype.getSmallerDisplayUnit = function (unit) {
                    var parsedUnits = this.settings._displayUnitsParsed;
                    var curtime = unit.approxTime();
                    for (var i = parsedUnits.length - 1; i >= 0; i--) {
                        var e = parsedUnits[i];
                        if (e.approxTime() < curtime) {
                            return e;
                        }
                    }
                    return null;
                };
                TimeSetup.prototype.getClosestDisplayPeriod = function (dt, unitHint, allowMultiples) {
                    var below = null;
                    var belowT = 0;
                    var above = null;
                    var aboveT = Infinity;
                    for (var pIndex = 0; pIndex < this.settings._displayPeriodsParsed.length; pIndex++) {
                        var p = this.settings._displayPeriodsParsed[pIndex];
                        var pt = p.approxTime();
                        if (pt <= dt && (below === null || belowT < pt)) {
                            below = p;
                            belowT = pt;
                        }
                        if (pt >= dt && (above === null || aboveT > pt)) {
                            above = p;
                            aboveT = pt;
                        }
                    }
                    if (allowMultiples) {
                        if (unitHint && unitHint.approxTime() < dt * 0.8) {
                            return unitHint;
                        }
                        if ((above !== null && aboveT < dt * 1.2) || below === null) {
                            return above;
                        }
                        else {
                            return below;
                        }
                    }
                    else {
                        if (below !== null && (belowT > dt * 0.8 || aboveT > dt * 1.2)) {
                            return below;
                        }
                        else {
                            return above;
                        }
                    }
                };
                TimeSetup.prototype.isAllowedDisplayUnit = function (unit) {
                    for (var uIndex = 0; uIndex < this.settings._displayUnitsParsed.length; uIndex++) {
                        var u = this.settings._displayUnitsParsed[uIndex];
                        if (u.isEqual(unit)) {
                            return true;
                        }
                    }
                    return false;
                };
                TimeSetup.prototype.adjustTimeAfterScale = function (from, to, dragFrom, dragTo) {
                    var scene = this.scene;
                    var scale = (to - from) / scene.width;
                    var minUnitWidth = scene.settings.timeAxis.minUnitWidth;
                    var unitTime = scene.displayUnit.approxTime();
                    if (!(minUnitWidth * scale <= unitTime)) {
                        // in respect to min, max unit width equal time portion of both sides will be cut down
                        var midTime = dragFrom + ((dragTo - dragFrom) / 2);
                        var minBars = (scene.width / minUnitWidth) | 0;
                        from = midTime - ((minBars / 2) * unitTime);
                        to = midTime + ((minBars / 2) * unitTime);
                    }
                    return { from: from, to: to };
                };
                TimeSetup.prototype.computeDisplayUnit = function (oldFrom, oldTo, oldUnit, from, to, scene, state) {
                    var result = {
                        from: from,
                        to: to,
                        unit: null
                    };
                    if (from == null || to == null) {
                        Internal.Base.Helpers.error("`computeDisplayUnit` called with invalid arguments.");
                    }
                    // keep the same unit on scroll
                    if (state && !state.scale && state.scroll) {
                        result.unit = oldUnit || this.scene.displayUnit;
                        return result;
                    }
                    // test if old unit is still good
                    if (oldFrom !== null && oldTo !== null && oldUnit) {
                        if (Math.abs((oldTo - oldFrom) - (to - from)) < 0.001) {
                            result.unit = oldUnit;
                            return result;
                        }
                    }
                    // start from scratch - possible time range changes
                    var du = this.scene.displayUnit;
                    var settings = this.scene.settings;
                    var width = Math.max(scene.width, 10);
                    var timeAxis = settings.timeAxis;
                    // this tries to avoid the initial view showing only a single column. it is not ideal since the checks
                    // later done after dragging do not use the same assumption. but at least the initial view is nicer.
                    var maxUnitWidth = Math.max(timeAxis.minUnitWidth, Math.min(width / 3, timeAxis.maxUnitWidth));
                    var msPerMinUnit = (to - from) / width * timeAxis.minUnitWidth;
                    var msPerMaxUnit = (to - from) / width * maxUnitWidth;
                    var bestUnit = null;
                    var bestUnitTime = 0;
                    var parsedUnits = settings._displayUnitsParsed;
                    var minAproxTime = settings._minUnit.approxTime();
                    var policyForcesMinWidth = timeAxis.unitSizePolicy === "min";
                    if (state && state.scale) {
                        var maxApproxTime = Infinity;
                        if (oldUnit && state.scale !== 2 /* Any */) {
                            if (state.scale === -1 /* ExpandRange */) {
                                minAproxTime = oldUnit.approxTime();
                            }
                            else {
                                maxApproxTime = oldUnit.approxTime();
                            }
                        }
                        for (var i = 0; i < parsedUnits.length; i++) {
                            var step = parsedUnits[i];
                            var msPerUnit = step.approxTime();
                            if (msPerUnit < minAproxTime || msPerUnit > maxApproxTime) {
                                continue;
                            }
                            var isBetter = void 0;
                            if (bestUnit === null) {
                                isBetter = true;
                            }
                            else if (policyForcesMinWidth) {
                                isBetter = (msPerUnit >= msPerMinUnit && msPerUnit < bestUnitTime) || (bestUnitTime < msPerMinUnit && msPerUnit > bestUnitTime);
                            }
                            else {
                                // max or auto
                                isBetter = (msPerUnit <= msPerMaxUnit && msPerUnit > bestUnitTime) || (bestUnitTime > msPerMaxUnit && msPerUnit < bestUnitTime);
                            }
                            if (isBetter) {
                                bestUnit = step;
                                bestUnitTime = msPerUnit;
                            }
                        }
                        if (!bestUnit) {
                            // event the largest available unit results in a width
                            if (du.approxTime() !== parsedUnits[parsedUnits.length - 1].approxTime()) {
                                Internal.Base.Helpers.warn("`computeDisplayUnit` could not lookup the new unit - " +
                                    "no units available matching the `minUnitWidth` and `maxUnitWidth` for the current range.", null, true);
                                this.scene.disableScaleLimiter = true;
                            }
                            bestUnit = this.scene.displayUnit;
                        }
                    }
                    else {
                        var testFrom = from;
                        var testTo = to;
                        var anchor = settings.navigation.initialDisplayAnchor;
                        var limits = this.chart.getDisplayLimits();
                        var changel = to === limits.to && (anchor === "now" || anchor === "newestData");
                        var changer = from === limits.from && (anchor === "oldestData");
                        if (du && du.unit === settings._minUnit.unit && du.count === 1) {
                            bestUnit = du;
                        }
                        var x = 50;
                        // cutting time out of range once possible to get parsed units that accepts min/max unit width restrictions
                        while (--x > 0) {
                            var hasSmaller = false;
                            for (var i = 0; i < parsedUnits.length; i++) {
                                var step = parsedUnits[i];
                                var msPerUnit = step.approxTime();
                                if (msPerUnit < minAproxTime) {
                                    continue;
                                }
                                if (msPerUnit < msPerMinUnit) {
                                    hasSmaller = true;
                                }
                                else if (msPerUnit <= msPerMaxUnit) {
                                    var isBetter = void 0;
                                    if (bestUnit == null) {
                                        isBetter = true;
                                    }
                                    else if (policyForcesMinWidth) {
                                        isBetter = msPerUnit < bestUnitTime;
                                    }
                                    else {
                                        // max or auto
                                        isBetter = msPerUnit > bestUnitTime;
                                    }
                                    if (isBetter) {
                                        bestUnit = step;
                                        bestUnitTime = msPerUnit;
                                    }
                                }
                                else {
                                    break;
                                }
                            }
                            if (!bestUnit && !hasSmaller) {
                                // if there are no smaller units available there is no sense in reducing the time range
                                // in this case the smallest unit is taken and the time range adjusted so that the max
                                // unit width is used.
                                var center = (testFrom + testTo) / 2;
                                var showTime = (width / maxUnitWidth) * minAproxTime / 2;
                                bestUnit = settings._minUnit;
                                testFrom = center - showTime;
                                testTo = center + showTime;
                            }
                            if (!bestUnit) {
                                var testRange = testTo - testFrom;
                                var cutQuarter = (testRange - testRange / 4) >= minAproxTime;
                                var portion = cutQuarter ? testRange / 4 : testRange - minAproxTime;
                                if (changel) {
                                    testFrom += portion;
                                }
                                else if (changer) {
                                    testTo -= portion;
                                }
                                else {
                                    // keep the center
                                    testFrom += portion / 2;
                                    testTo -= portion / 2;
                                }
                                msPerMinUnit = (testTo - testFrom) / width * timeAxis.minUnitWidth;
                                msPerMaxUnit = (testTo - testFrom) / width * maxUnitWidth;
                            }
                            else {
                                var tsc = this.scene.timeStepSettings;
                                return {
                                    from: bestUnit.roundTimeDown(testFrom, tsc),
                                    to: bestUnit.roundTimeUp(testTo, tsc),
                                    unit: bestUnit
                                };
                            }
                        }
                        if (x === 0) {
                            Internal.Base.Helpers.warn("`computeDisplayUnit` could not lookup the new unit. It is possible that the chart did not load the data properly.");
                        }
                    }
                    if (!bestUnit) {
                        Internal.Base.Helpers.error("", oldFrom, oldTo, oldUnit, from, to, width);
                        throw new Error("Could not calculate displayUnit");
                    }
                    result.unit = bestUnit;
                    return result;
                };
                /** Compute the period.
                Snapping to bars will be done later. */
                TimeSetup.prototype.tryComputeDisplayPeriod = function (periodStr, anchorStr, unitStr, dataFrom, dataTo, scene, curTime) {
                    var unit = (unitStr === "auto") ? null : (TimeChart.TimeStep.parse(unitStr));
                    var from = null;
                    var to = null;
                    if (periodStr && periodStr.indexOf(">") > -1) {
                        // special case - fixed period
                        var periodStrings = periodStr.split(">", 2);
                        from = parseInt(periodStrings[0], 10);
                        to = parseInt(periodStrings[1], 10);
                        // since the period string is always coming from settings or api calls, the timestamps will be UTC
                        var difs = TimeChart.TimeStep.timeUnitDiffs;
                        var hasTimePart = unit ? difs[unit.unit] < difs["d"] : true;
                        from = this.scene.timestampToInternal(from, hasTimePart);
                        to = this.scene.timestampToInternal(to, hasTimePart);
                    }
                    else {
                        // parse display period
                        if (periodStr === "max" && dataFrom !== null && dataTo !== null) {
                            from = dataFrom;
                            to = (anchorStr === "now") ? curTime : dataTo;
                        }
                        else if (periodStr !== "max") {
                            var period = TimeChart.TimeStep.parse(periodStr);
                            // get anchor time
                            var anchor = void 0;
                            if (anchorStr === "now") {
                                anchor = curTime;
                            }
                            else if (anchorStr === "newestData" && dataTo !== null) {
                                anchor = dataTo;
                            }
                            else {
                                anchor = Internal.Base.Helpers.tryParseFloat(anchorStr, null);
                            }
                            if (period && anchor !== null) {
                                from = period.sub(anchor);
                                to = anchor;
                            }
                        }
                    }
                    if (from === null || to === null) {
                        return {
                            from: null,
                            to: null,
                            unit: null
                        };
                    }
                    // Try to fit in screen
                    var computeTimeScaleRangeResult = this.getUnitRange(scene);
                    var minTimeScale = computeTimeScaleRangeResult.minTime;
                    var maxTimeScale = computeTimeScaleRangeResult.maxTime;
                    var minUnit = computeTimeScaleRangeResult.minUnit;
                    var maxUnit = computeTimeScaleRangeResult.maxUnit;
                    if (to - from > maxTimeScale) {
                        unit = maxUnit;
                        from = to - maxTimeScale;
                    }
                    if (to - from < minTimeScale) {
                        unit = minUnit;
                        from = to - minTimeScale;
                    }
                    return {
                        from: from,
                        to: to,
                        unit: unit
                    };
                };
                /** Resolves from/to values that are strings */
                TimeSetup.prototype.resolveFromTo = function (from, to, unit) {
                    var fromNo;
                    var toNo;
                    var tsc = this.scene.timeStepSettings;
                    var dataLimits = null;
                    if (Internal.Base.Helpers.isNumber(from)) {
                        fromNo = from;
                    }
                    else if (from === "oldestData") {
                        if (dataLimits === null)
                            dataLimits = this.chart.getDisplayLimits(unit);
                        fromNo = dataLimits.from;
                    }
                    else {
                        if (from != null) {
                            Internal.Base.Helpers.error("Invalid `from` value '" + from + "'. Valid values are numbers and 'oldestData'.");
                        }
                        fromNo = null;
                    }
                    if (Internal.Base.Helpers.isNumber(to)) {
                        toNo = to;
                    }
                    else if (to === "newestData") {
                        if (dataLimits === null)
                            dataLimits = this.chart.getDisplayLimits(unit);
                        toNo = dataLimits.to;
                    }
                    else if (to === "now") {
                        toNo = this.scene.getCurTime();
                    }
                    else {
                        if (to != null) {
                            Internal.Base.Helpers.error("Invalid `to` value '" + to + "'. Valid values are numbers and 'oldestData'.");
                        }
                        toNo = null;
                    }
                    return { limitFrom: unit.roundTimeDown(fromNo, tsc), limitTo: unit.roundTimeUp(toNo, tsc) };
                };
                TimeSetup.prototype.getUnitRange = function (scene, unitSteps) {
                    if (unitSteps === void 0) { unitSteps = this.settings._displayUnitsParsed; }
                    var maxUnit = unitSteps[unitSteps.length - 1];
                    var maxStepDiff = maxUnit.approxTime();
                    var minUnit = unitSteps[0];
                    var minStepDiff = minUnit.approxTime();
                    var width = Math.max(10, scene.width);
                    var maxTime = width / this.settings.timeAxis.minUnitWidth * maxStepDiff;
                    var minTime = width / this.settings.timeAxis.maxUnitWidth * minStepDiff;
                    return {
                        minTime: minTime,
                        maxTime: maxTime,
                        minUnit: minUnit,
                        maxUnit: maxUnit
                    };
                };
                TimeSetup.prototype.getLimits = function (unit, isFinal) {
                    // apply data limits
                    var settings = this.settings.interaction.scrolling;
                    var limitMode = settings.limitMode;
                    var applyLimit = (!isFinal) ? (limitMode === "block") : (limitMode !== null);
                    if (!applyLimit || !unit) {
                        return { limitFrom: null, limitTo: null };
                    }
                    return this.resolveFromTo(settings.limitFrom, settings.limitTo, unit);
                };
                TimeSetup.prototype.preventOverscale = function (scene, units, origin, from, to, unit, isFinal) {
                    var data = this.getLimits(unit, isFinal);
                    var dataFrom = data.limitFrom;
                    var dataTo = data.limitTo;
                    var allUnitsRange = this.getUnitRange(scene, units);
                    var unitsMin = allUnitsRange.minTime;
                    var unitsMax = allUnitsRange.maxTime;
                    if (dataFrom !== null && dataTo !== null && to - from > dataTo - dataFrom) {
                        var center = (dataFrom + dataTo) / 2;
                        var offset = (dataTo - dataFrom) / 2;
                        offset = Math.max(offset, unitsMin / 2);
                        return this.adjustTimeRangeToUnits(scene, center - offset, center + offset, unit);
                    }
                    else {
                        unitsMax *= 0.99;
                        unitsMin *= 1.01;
                        var passedRange = to - from;
                        passedRange = Math.min(passedRange, unitsMax);
                        passedRange = Math.max(passedRange, unitsMin);
                        var downscale = (passedRange === unitsMin) ? passedRange / (to - from) : 1;
                        if (origin === null) {
                            origin = (from + to) / 2;
                        }
                        if (from === to && from > 0) {
                            Internal.Base.Helpers.error("From = To, trouble", from, to);
                        }
                        return {
                            from: origin + (from - origin) * downscale,
                            to: origin + (to - origin) * downscale
                        };
                    }
                };
                TimeSetup.prototype.preventOverscroll = function (unit, from, to, isFinal) {
                    var dataLimits = this.getLimits(unit, isFinal);
                    var limitFrom = dataLimits.limitFrom;
                    var limitTo = dataLimits.limitTo;
                    var settings = this.settings.interaction.scrolling;
                    var diff = to - from;
                    if (limitFrom !== null && limitTo !== null) {
                        diff = Math.min(diff, limitTo - limitFrom);
                    }
                    diff *= settings.overscrollProportion;
                    if (limitFrom !== null) {
                        limitFrom -= diff;
                    }
                    if (limitTo !== null) {
                        limitTo += diff;
                    }
                    if (limitFrom !== null && limitTo !== null && limitTo - limitFrom < to - from) {
                        // limits smaller than from->to
                        if (limitFrom < from) {
                            diff = from - limitFrom;
                        }
                        else if (limitTo > to) {
                            diff = to - limitTo;
                        }
                        from -= diff;
                        to -= diff;
                    }
                    else {
                        // limits bigger than from->to
                        if (limitTo !== null && limitTo < to) {
                            diff = to - limitTo;
                            from -= diff;
                            to -= diff;
                        }
                        else if (limitFrom !== null && limitFrom > from) {
                            diff = limitFrom - from;
                            from = limitFrom;
                            to += diff;
                        }
                    }
                    return { from: from, to: to };
                };
                TimeSetup.prototype.scroll = function (from, to, displayUnit, direction, count, unit) {
                    var step;
                    if (unit === "displayUnit") {
                        step = displayUnit.clone();
                    }
                    else if (unit === "page") {
                        step = this.getTimeRangeStep(from, to);
                    }
                    else if (TimeChart.TimeStep.isGoodUnit(unit)) {
                        step = TimeChart.TimeStep.parse(unit);
                    }
                    else {
                        Internal.Base.Helpers.error("Incorrect scroll unit: " + unit);
                        return;
                    }
                    step.count *= count;
                    if (direction === "<") {
                        return {
                            from: step.sub(from),
                            to: step.sub(to)
                        };
                    }
                    else {
                        return {
                            from: step.add(from),
                            to: step.add(to)
                        };
                    }
                };
                /** Computes time step of one page. */
                TimeSetup.prototype.getTimeRangeStep = function (from, to) {
                    from = Math.round(from);
                    to = Math.round(to);
                    var biggestStep = null;
                    var tsc = this.scene.timeStepSettings;
                    for (var unitIndex = 0; unitIndex < TimeChart.TimeStep.knownUnits.length; unitIndex++) {
                        var unit = TimeChart.TimeStep.knownUnits[unitIndex];
                        var step = new TimeChart.TimeStep(unit, 1);
                        var ff = step.roundTimeRound(from, tsc);
                        var tt = step.roundTimeRound(to, tsc);
                        if (from === ff && to === tt && (biggestStep === null || biggestStep.approxTime() < step.approxTime())) {
                            biggestStep = step;
                        }
                    }
                    biggestStep.count = Math.max(1, biggestStep.numberOfUnits(from, to));
                    return biggestStep;
                };
                return TimeSetup;
            }());
            TimeChart.TimeSetup = TimeSetup;
        })(TimeChart = Internal.TimeChart || (Internal.TimeChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="TimeSetup.ts" />
/// <reference path="../base/Helpers.ts" />
/// <reference path="../base/Data.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var TimeChart;
        (function (TimeChart) {
            var isSupportedDataArray;
            if (typeof Float64Array !== typeof void 0) {
                isSupportedDataArray = function (array) {
                    return Array.isArray(array)
                        || array instanceof Int32Array
                        || array instanceof Uint32Array
                        || array instanceof Float32Array
                        || array instanceof Float64Array
                        || array instanceof Int16Array
                        || array instanceof Uint16Array;
                };
            }
            else {
                isSupportedDataArray = function (array) { return Array.isArray(array); };
            }
            var SettingsData = (function (_super) {
                __extends(SettingsData, _super);
                function SettingsData() {
                    _super.apply(this, arguments);
                    /** Time steps at what data can be fetched.
                    @version 1.15.0 - multiples of units can now also be specified (for example, `5 m`).*/
                    this.units = ["ms", "s", "m", "h", "d", "M", "y"];
                    /** URL that is used to load data. Additional query string parameters are added to the given url:
                    `from`, `to`, `unit` and `timeZone`. See the documentation of `dataFunction` for the description of these
                    parameters.
                    @type url */
                    this.url = null;
                    /** Allows specifying specific URL for each time unit. This can be useful if the data is pregenerated in
                    static files, for example, to specify different data file where time aggregated by months or years -
                    `urlByUnit: { 'y': '/data/yearData.json', 'm': '/data/monthData.json' }`.
                    If this is specified, it overrides `url` property. */
                    this.urlByUnit = null;
                    /** Maximum number of data points to request in one go. Multiple requests will be issued if more data is needed.
                    
                    Note that the server can opt to return less data in the response as well - more requests will be issued in this
                    case as well.
                    @type integer */
                    this.requestMaxUnits = 10000;
                    /** How much data to load in advance. For example, if `prefetchRatio=1`, the chart will automatically load data
                    so that the user can scroll a whole width of the chart to both sides without waiting for the data.
                    @type float */
                    this.prefetchRatio = 1;
                    /** Whether to request only when scrolling/scaling has stopped.
                    @version 1.15.0 - the setting also has effect during animations and not only during user interaction */
                    this.minimizeRequests = false;
                    /** Maximum number of data entries to store per data unit.
                    @version 1.14.0 - default changed to 500000; the value will be automatically increased if the chart requires more entries at once to display the data.
                    @type integer*/
                    this.cacheSize = 500000;
                    /** Specifies whether the numeric timestamps used with this data source are in seconds instead of milliseconds.
                    
                    This applies to the `from` and `to` request parameters and all timestamps within the data response. */
                    this.timestampInSeconds = false;
                    /** The format string (or strings) that is used to parse timestamps that are given as strings. Note that
                    for optimal performance a single format string should be used (or even better, the numeric timestamps
                    should be used instead).
            
                    When `stringTimestampFormat` is not specified the parser supports ISO 8601 formats (for details see
                    [moment documentation](http://momentjs.com/docs/#/parsing/string/)).
            
                    See [moment documentation](http://momentjs.com/docs/#/parsing/string-format/) for details on the format
                    strings.
                    @version 1.12.0*/
                    this.stringTimestampFormat = null;
                    /** Data time zone offset in minutes.
                    @deprecated
                    @version 1.12.0 - the property has been deprecated in favor of `timeZone` in the data response.
                    @units minutes */
                    this.timeZoneOffset = null;
                    /** A delegate that will be Load more chart data. */
                    this.dataFunction = null;
                    /** This property allows the data to be specified inline with the settings. Note that even if this is specified
                    the chart might want to invoke `url` or `dataFunction` if the user selects a time range outside of what has
                    been preloaded. */
                    this.preloaded = null;
                    /** If set to `true`, the validation of the loaded data is not performed and warnings will not be displayed.
                    Note that errors are not suppressed.
                    
                    This setting should only be used when it is determined that the potential issues described by these warnings
                    does not prevent the chart from working correctly. It should also be noted that a future version of the library
                    might change the behavior of the situations the warnings are intended to prevent.
                    @experimental */
                    this.suppressWarnings = false;
                    /** Specifies if the cached values from a smaller unit may be used when retrieving the data for a larger unit.
            
                    This should be set to `false` when the data source uses a custom aggregation specific to each individual unit.
            
                    Note that currently the smaller units are only used when they overlap the required range completely. For partial
                    overlap the values are only used as a placeholder while the larger unit is requested from the data source.
                    @version 1.15.0*/
                    this.useSmallerUnitCache = true;
                    /** Specifies if the chart detected that the data source returns too little values for the time range to cover for the fact that
                    by default the chart rounds `from` and `to` to whole units.
                    @ignore */
                    this._skipRequestRangeRounding = false;
                }
                return SettingsData;
            }(Internal.Base.SettingsData));
            TimeChart.SettingsData = SettingsData;
            var Data = (function () {
                function Data(chart, dataSettings) {
                    this.chart = null;
                    this.scene = null;
                    this.settings = null;
                    /** set to true of server delivers no data */
                    this.noData = false;
                    /** hard limit of data range - server was asked for data outside this range and did not return it. */
                    this.dataLimitFrom = null;
                    this.dataLimitTo = null;
                    this.dataLimitFromUnit = null;
                    this.dataLimitToUnit = null;
                    /** range where a non-zero data is present */
                    this.dataFrom = null;
                    this.dataTo = null;
                    this.error = null;
                    this.cache = {};
                    /** map from unit to RequestData */
                    this.requests = {};
                    /** List of data objects that are pending validation and addition until moment.js becomes available. */
                    this._pendingAddData = [];
                    this.dataSettings = dataSettings;
                    this.scene = chart.scene;
                    this.settings = chart.settings;
                    this.chart = chart;
                    this.dataId = "data" + dataSettings.id;
                    this._prepareUsableUnits();
                    this.updateDataLimit(null, null, null, null, new TimeChart.TimeStep("ms", 1));
                }
                Data.binSearch = function (data, timestamp) {
                    // Returns index of first item that is >= timestamp.
                    var i0 = 0;
                    if (!data) {
                        throw "no data";
                    }
                    var i1 = data.length - 1;
                    while (i0 < i1) {
                        var ii = ((i1 + i0) / 2) | 0;
                        if (data[ii][0] < timestamp) {
                            i0 = ii + 1;
                        }
                        else if (data[ii][0] > timestamp) {
                            i1 = ii;
                        }
                        else {
                            // equals
                            while (ii > 0 && data[ii - 1][0] === timestamp) {
                                ii -= 1;
                            }
                            return ii;
                        }
                    }
                    if (i0 < data.length && data[i0][0] < timestamp) {
                        return i0 + 1;
                    }
                    else {
                        return i0;
                    }
                };
                /** finds first x>start where data[x][index] is not null */
                Data.linSearchUp = function (data, start, dataIndex, dataFunction) {
                    if (dataFunction) {
                        for (var i = start + 1; i <= data.length - 1; i++) {
                            if (dataFunction(data[i]) !== null) {
                                return i;
                            }
                        }
                    }
                    else {
                        for (var i = start + 1; i <= data.length - 1; i++) {
                            if (data[i][dataIndex] !== null) {
                                return i;
                            }
                        }
                    }
                    return -1;
                };
                /** finds first x<start where data[x][index] is not null */
                Data.linSearchDown = function (data, start, dataIndex, dataFunction) {
                    if (dataFunction) {
                        for (var i = start - 1; i >= 0; i--) {
                            if (dataFunction(data[i]) !== null) {
                                return i;
                            }
                        }
                    }
                    else {
                        for (var i = start - 1; i >= 0; i--) {
                            if (data[i][dataIndex] !== null) {
                                return i;
                            }
                        }
                    }
                    return -1;
                };
                Data.findSubrange = function (data, from, to) {
                    var i0 = Data.binSearch(data, from);
                    var i1 = Data.binSearch(data, to);
                    return { i0: i0, i1: i1 };
                };
                /** Called by Impl.ts when the moment.js has been loaded. */
                Data.prototype.notifyAssetsLoaded = function () {
                    if (!TimeChart.moment || !TimeChart.moment.tz) {
                        return;
                    }
                    var data = this._pendingAddData;
                    for (var i = 0; i < data.length; i++) {
                        var x = data[i];
                        this.addDataInt(x.request, x.parsedData, x.append);
                    }
                    this._pendingAddData = [];
                };
                Data.prototype.applyPreloadedData = function () {
                    if (this.dataSettings.preloaded) {
                        this.addData(this.dataSettings.preloaded);
                    }
                };
                Data.prototype.remove = function () {
                    this.scene.setMessage(this.dataId, null);
                    for (var u in this.requests) {
                        var r = this.requests[u];
                        if (r) {
                            r.callback = null;
                        }
                    }
                };
                Data.prototype._prepareUsableUnits = function () {
                    var units = this.dataSettings.units;
                    if (units.length === 0) {
                        throw new Error("The `data.units` array must contain at least one value.");
                    }
                    var res = this._units = new Array(units.length);
                    for (var i = 0; i < units.length; i++) {
                        var u = units[i];
                        var ts = TimeChart.TimeStep.parse(u, u, true);
                        if (ts) {
                            res[i] = { size: ts.approxTime(), unit: ts, key: ts.toString() };
                        }
                    }
                    res.sort(function (a, b) { return b.size - a.size; });
                };
                Data.prototype._findUsableUnit = function (unit) {
                    var res = this._units;
                    var cache = this.cache;
                    for (var i = 0; i < res.length; i++) {
                        var u = res[i];
                        if (cache[u.key] !== null && unit.isMultipleOf(u.unit)) {
                            return u.unit;
                        }
                    }
                    this.chart.error("Cannot load data - no suitable data unit configured for the requested `" + unit + "`.");
                };
                Data.prototype.determineDataLimits = function (unit, needFrom, needTo, callback) {
                    var _this = this;
                    // load with the biggest unit
                    if (!unit) {
                        unit = this._units[0].unit;
                    }
                    else {
                        unit = this._findUsableUnit(unit);
                        if (!unit) {
                            // the console error is shown by _findUsableUnit
                            return;
                        }
                    }
                    var from = null;
                    var to = null;
                    var t = unit.approxTime();
                    if (this.dataLimitFromUnit && this.dataLimitFromUnit.approxTime() <= t) {
                        from = this.dataLimitFrom;
                    }
                    if (this.dataLimitToUnit && this.dataLimitToUnit.approxTime() <= t) {
                        to = this.dataLimitTo;
                    }
                    // check if we already have the data
                    if ((!needFrom || from != null) && (!needTo || to != null)) {
                        callback(this.dataLimitFrom, this.dataLimitTo, unit);
                        return;
                    }
                    // nope - fire up some requests to get needed data
                    this.scene.setMessage(this.dataId, this.settings.localization.determiningDataBounds, 999);
                    // figure out "from"  - just load more data until limit is hit
                    var fromData = function (f0, callbackFrom, callbackTo, callbackUnit) {
                        if (!callbackUnit) {
                            // request failed
                            _this.scene.setMessage(_this.dataId, null);
                            return;
                        }
                        if (!(_this.dataLimitFrom !== null || !needFrom)) {
                            if (f0 !== callbackFrom) {
                                _this.scheduleDataLoading(callbackUnit, null, callbackFrom, false, function (a, b, c) { return fromData(callbackFrom, a, b, c); });
                                return;
                            }
                            else {
                                _this.dataLimitFrom = callbackFrom;
                            }
                        }
                        _this.scene.setMessage(_this.dataId, null);
                        callback(_this.dataLimitFrom, _this.dataLimitTo, callbackUnit);
                    };
                    /* data handling functions first
                    figure out "to" - just load more data until limit is hit */
                    var toData = function (f0, t0, callbackFrom, callbackTo, callbackUnit) {
                        if (!callbackUnit) {
                            // request failed
                            _this.scene.setMessage(_this.dataId, null);
                            return;
                        }
                        if (!(_this.dataLimitTo !== null || !needTo)) {
                            if (t0 !== callbackTo) {
                                _this.scheduleDataLoading(callbackUnit, callbackTo, null, false, function (a, b, c) { return toData(f0, callbackTo, a, b, c); });
                                return;
                            }
                            else {
                                _this.dataLimitTo = callbackTo;
                            }
                        }
                        // we don't have the real previous from, give different value to fromData to make it load next portion
                        fromData(f0 + 1, f0, callbackTo, callbackUnit);
                    };
                    /* start the real loading
                    TODO: not not ask for full period if we have some initial limits for bigger units */
                    this.scheduleDataLoading(unit, null, null, false, function (a, b, c) { return toData(a, b, a, b, c); });
                };
                Data.prototype.getDataForRange = function (from, to, step, callback) {
                    var config = this.dataSettings;
                    var cachedData = null;
                    var loadingNeeded = true;
                    var loadFrom = from;
                    var loadTo = to;
                    if (this.dataLimitFrom !== null) {
                        loadFrom = Math.max(this.dataLimitFrom, loadFrom);
                    }
                    if (this.dataLimitTo !== null) {
                        loadTo = Math.min(this.dataLimitTo, loadTo);
                    }
                    for (var i = 0; i < this._units.length; i++) {
                        var u = this._units[i];
                        var c = this.cache[u.key];
                        if (c && step.isMultipleOf(u.unit) && c.from < to && c.to > from) {
                            if (config.useSmallerUnitCache || c.unit.approxTime() === step.approxTime()) {
                                cachedData = c;
                                // some data exists, but does not fully cover from,to
                                loadingNeeded = loadFrom < c.from || loadTo > c.to;
                            }
                            break;
                        }
                    }
                    // figure out what parts need to be loaded
                    var loadingStarted = false;
                    if (loadingNeeded) {
                        loadingNeeded = !!config.dataFunction || !!config.url || !!config.urlByUnit; // any of them is defined
                        if (loadingNeeded && (!config.minimizeRequests || !this.chart.scrolling.isActive())) {
                            // note that initially this.cache[loadUnit] will be `undefined` if there hasn't been any request with that unit
                            // however it will be `null` if for some reason it was marked as non-existant on the server.
                            // this is automatically checked by _findUsableStep.
                            var loadUnit = this._findUsableUnit(step);
                            var increasingDirection = false;
                            if (cachedData && loadUnit.approxTime() === cachedData.unit.approxTime()) {
                                // incremental loading is not used if we load a bigger unit than was found in the cache.
                                if (loadFrom >= cachedData.from) {
                                    increasingDirection = true;
                                    loadFrom = Math.max(loadFrom, cachedData.to);
                                }
                                if (loadTo <= cachedData.to || loadFrom < cachedData.from) {
                                    loadTo = Math.min(loadTo, cachedData.from);
                                }
                            }
                            var requiredCount = loadUnit.numberOfUnits(from, to);
                            var limit = config.cacheSize;
                            if (requiredCount > limit) {
                                Internal.Base.Helpers.warn("The chart requires " + requiredCount + " values (using data unit `" + loadUnit
                                    + "`) to display the current time range. `data.cacheSize` limit (currently " + limit
                                    + ") will be automatically increased to allow this.");
                                config.cacheSize = (requiredCount * 1.2) | 0;
                            }
                            loadingStarted = this.scheduleDataLoading(loadUnit, loadFrom, loadTo, increasingDirection, callback);
                        }
                    }
                    if (cachedData) {
                        var findSubrangeResult = Data.findSubrange(cachedData.values, from, to);
                        var startIndex = findSubrangeResult.i0;
                        var endIndex = findSubrangeResult.i1;
                        return {
                            unit: step.unit,
                            count: step.count,
                            from: cachedData.from,
                            to: cachedData.to,
                            values: cachedData.values,
                            startIndex: startIndex,
                            endIndex: endIndex,
                            loading: loadingStarted
                        };
                    }
                    else if (loadingStarted) {
                        // data is now loading, return empty set for now
                        return {
                            unit: step.unit,
                            count: step.count,
                            from: loadFrom,
                            to: loadTo,
                            values: [],
                            startIndex: 0,
                            endIndex: 0,
                            loading: true
                        };
                    }
                    else {
                        Internal.Base.Helpers.warn("The datasource `" + config.id + "` cannot return data for unit " + step, null, true);
                        // data source has no data for this unit
                        return {
                            unit: null,
                            count: null,
                            from: null,
                            to: null,
                            values: [],
                            startIndex: 0,
                            endIndex: 0,
                            loading: false
                        };
                    }
                };
                /** fires data update request for data from current data limitTo up to newTo */
                Data.prototype.updateData = function (dataUnit, newTo, callback) {
                    var u = this._findUsableUnit(dataUnit);
                    var us = u.toString();
                    if (!this.cache[us] || this.requests[us]) {
                        return;
                    }
                    var c = this.scene.timeStepSettings;
                    var requestTo = u.roundTimeUp(newTo, c);
                    var requestFrom = u.roundTimeDown(this.cache[us].lastTimestamp, c);
                    if (requestFrom <= requestTo) {
                        this.scheduleDataLoading(dataUnit, requestFrom, requestTo, false, callback);
                    }
                };
                Data.prototype.scheduleDataLoading = function (unit, from0, to0, isIncreasing, callback) {
                    var _this = this;
                    if (!unit) {
                        throw "No unit";
                    }
                    if (from0 > to0)
                        return false;
                    // callback - (from, to, unit)
                    this.chart.log("Scheduling data loading " + unit + "," + from0 + "," + to0);
                    var time = Internal.Base.Helpers.performanceNow();
                    // check if existing request is in progress
                    var unitStr = unit.toString();
                    var r = this.requests[unitStr];
                    if (r) {
                        if (r.time + this.dataSettings.requestTimeout < time) {
                            // cancel previous request
                            r.callback = null;
                            delete this.requests[unitStr];
                        }
                        else {
                            this.chart.log("Already loading for selected period");
                            return true;
                        }
                    }
                    var from = from0;
                    var to = to0;
                    var tsc = this.scene.timeStepSettings;
                    if (!this.dataSettings._skipRequestRangeRounding) {
                        // round to full units -
                        if (from !== null) {
                            from = unit.roundTimeDown(from, tsc);
                        }
                        if (to !== null) {
                            to = unit.roundTimeUp(to, tsc);
                        }
                    }
                    // limit max time units
                    if (from !== null && to !== null) {
                        var timeUnitsAsked = (to - from) / unit.approxTime();
                        if (timeUnitsAsked > this.dataSettings.requestMaxUnits) {
                            if (isIncreasing) {
                                to = unit.add(from, this.dataSettings.requestMaxUnits);
                            }
                            else {
                                from = unit.sub(to, this.dataSettings.requestMaxUnits);
                            }
                        }
                    }
                    var df = this.getDataFunction();
                    if (!df) {
                        this.chart.log("No data function. Cannot load data?");
                        return false;
                    }
                    var hasTimePart = TimeChart.TimeStep.timeUnitDiffs[unit.unit] < TimeChart.TimeStep.timeUnitDiffs["d"];
                    var tz = hasTimePart ? null : this.settings.timeAxis.timeZone;
                    this.requests[unitStr] = r = new RequestData(unit, from, to, callback, time, tz);
                    var succ = function (data) { return _this.dataReceivedRaw(r, data); };
                    var fl = function () { return _this.dataFailed(r); };
                    from = this.convertTimestampFromInternal(from, hasTimePart);
                    to = this.convertTimestampFromInternal(to, hasTimePart);
                    if (from === to && to !== null)
                        to++;
                    var response = df(from, to, unit.toShortString(), succ, fl, tz);
                    this.chart.log("Data requested " + unit + ", " + from + ", " + to);
                    // Not in spec, but check if user retured the response right away.
                    if (Internal.Base.Helpers.isObjectOrArray(response) || Internal.Base.Helpers.isString(response)) {
                        if (!this.dataSettings.suppressWarnings)
                            Internal.Base.Helpers.warn("Data object should not be returned directly from the `dataFunction` delegate - instead call the `success` callback.");
                        this.dataReceivedRaw(r, response);
                    }
                    return true;
                };
                Data.prototype.dataReceivedRaw = function (request, rawData) {
                    if (this.chart.removed)
                        return;
                    this.scene.setMessage(this.dataId, null);
                    delete this.requests[request.unitStr];
                    this.chart.log("Data arrived");
                    var data = Internal.Base.Helpers.parseData(rawData, this.dataSettings.format);
                    if (Internal.Base.Helpers.isObjectOrArray(rawData))
                        data = this.cloneDataObject(data);
                    // append = false means that the data will be merged only if the ranges overlap or are next to one another.
                    this.addDataInt(request, data, false);
                };
                Data.prototype.cloneDataObject = function (data) {
                    data = Internal.Base.Helpers.clone(data);
                    var v = data.values;
                    if (!data.error && v) {
                        if (!Array.isArray(v)) {
                            data.error = "The `values` in the TimeChart data object must be an array or arrays.";
                        }
                        else {
                            data.values = v = v.slice();
                            for (var i = 0; i < v.length; i++) {
                                var x = v[i];
                                if (!isSupportedDataArray(x)) {
                                    data.error = "The `values` in the TimeChart data object must be an array of arrays. The value at index " + i + " is not an array.";
                                    break;
                                }
                                else {
                                    v[i] = Array.prototype.slice.call(x);
                                }
                            }
                        }
                    }
                    return data;
                };
                Data.prototype.addData = function (parsedData) {
                    parsedData = this.cloneDataObject(parsedData);
                    this.addDataInt(null, parsedData, true);
                };
                Data.prototype.addDataInt = function (request, sourceData, append) {
                    if (append === void 0) { append = false; }
                    // failed to parse response, error was logged, stop this data loading
                    if (sourceData === null) {
                        return;
                    }
                    if (!TimeChart.moment || !TimeChart.moment.tz) {
                        // moment is not yet loaded. suppress the data loading until it becomes available.
                        this._pendingAddData.push({ request: request, parsedData: sourceData, append: append });
                        return;
                    }
                    var parsedData = this.cleanupData(sourceData);
                    if (parsedData.error) {
                        // handle no unit errors
                        if (parsedData.error === "no-unit" && request) {
                            this.cache[request.unitStr] = null;
                        }
                        // error in data
                        this.chart.error(parsedData.error);
                        return;
                    }
                    var newData;
                    if (request) {
                        newData = this.analyzeData(parsedData, request);
                    }
                    else {
                        newData = this.analyzeDataNoRequest(parsedData, append);
                    }
                    if (request && !request.unit.isMultipleOf(newData.unit)) {
                        this.chart.error("Incorrect data - requested unit `"
                            + request.unit + "`, got `" + newData.unit
                            + "`. The requested unit must be a multiple of returned unit.");
                        // mark that there is not data at this unit
                        this.cache[request.unitStr] = null;
                        if (request.callback) {
                            request.callback(null, null, null);
                        }
                    }
                    else {
                        var respUnitStr = newData.unitStr;
                        if (request && (respUnitStr !== request.unitStr)) {
                            // mark that there is not data at this unit
                            this.cache[request.unitStr] = null;
                            var missingUnit = true;
                            var units = this._units;
                            for (var i = 0; i < units.length; i++) {
                                if (units[i].unit.isEqual(newData.unit)) {
                                    missingUnit = false;
                                    break;
                                }
                            }
                            if (missingUnit) {
                                Internal.Base.Helpers.warn("The data source returned unit `" + respUnitStr + "` which was not declared in `data.units`.");
                                this.dataSettings.units.push(respUnitStr);
                                this._prepareUsableUnits();
                            }
                        }
                        if (newData.unit && newData.from != null && newData.to != null) {
                            // store the data at correct unit
                            var data = this.cache[newData.unitStr];
                            if (data) {
                                this.cache[newData.unitStr].merge(newData, this.dataSettings.cacheSize, this.chart, append);
                            }
                            else {
                                this.cache[newData.unitStr] = newData;
                            }
                        }
                        if (request && request.callback) {
                            request.callback(newData.from, newData.to, newData.unit);
                        }
                    }
                    this.chart.events.notifySceneChanges({ data: (_a = {}, _a[this.dataSettings.id] = true, _a) });
                    var _a;
                };
                Data.prototype.dataFailed = function (request) {
                    if (!this.cache[request.unitStr]) {
                        this.cache[request.unitStr] = null;
                    }
                    this.scene.setMessage(this.dataId, this.settings.localization.dataRequestFailed, 1000);
                    this.chart.error("Failed data loading request");
                    if (request.callback) {
                        request.callback(null, null, null);
                    }
                };
                Data.prototype.updateDataLimit = function (dataFrom, dataTo, limitFrom, limitTo, unit) {
                    this.chart.invalidateDataLimits();
                    // update limits to include all returned data
                    if ((dataFrom !== void 0 && dataFrom !== null)) {
                        if (this.dataFrom === null || this.dataFrom > dataFrom) {
                            this.dataFrom = dataFrom;
                        }
                    }
                    if (dataTo !== void 0 && dataTo !== null) {
                        if (this.dataTo === null || this.dataTo < dataTo) {
                            this.dataTo = dataTo;
                        }
                    }
                    // update limits
                    if (limitFrom != null) {
                        this.dataLimitFrom = limitFrom;
                        this.dataLimitFromUnit = unit;
                        this.dataFrom = this.dataFrom == null ? limitFrom : Math.max(this.dataFrom, limitFrom);
                    }
                    if (limitTo != null) {
                        this.dataLimitTo = limitTo;
                        this.dataLimitToUnit = unit;
                        this.dataTo = this.dataTo == null ? limitTo : Math.min(this.dataTo, limitTo);
                    }
                };
                Data.prototype.cleanupData = function (data) {
                    /* cleans up data and sets error if errors found
                    data already contains error (from server?) */
                    if (data.error) {
                        return data;
                    }
                    if (data.timeZone === "local") {
                        Internal.Base.Helpers.error("The data source has to specify a timezone that is not `local` so that it works independent of the browser settings.");
                        data.timeZone = TimeChart.moment.tz.guess();
                    }
                    // hard failures - will no accept the data
                    data.error = "bad-response";
                    var enableWarnings = !this.dataSettings.suppressWarnings;
                    var msg = "";
                    // support deprecated data.data
                    if (data.data && !data.values) {
                        if (enableWarnings)
                            Internal.Base.Helpers.warn("Use of property `data` in the TimeChart data object (returned from the URL, dataFunction or preloaded property)"
                                + " is deprecated. Please use `values` instead.", null, true);
                        data.values = data.data;
                    }
                    if (data.unit == null)
                        msg += "\nRequired field 'unit' not set in data";
                    if (data.values == null)
                        msg += "\nRequired field 'values' not set in data";
                    var parsedUnit = TimeChart.TimeStep.parse(data.unit, void 0, false);
                    if (null === parsedUnit)
                        msg += "\nData error: unrecognized data unit: " + data.unit;
                    if (msg.length) {
                        data.error = msg.substr(1);
                        return data;
                    }
                    data.error = null;
                    var timeZone = data.timeZone || "UTC";
                    var hasTimePart = TimeChart.TimeStep.timeUnitDiffs[parsedUnit.unit] < TimeChart.TimeStep.timeUnitDiffs["d"];
                    // this is restored at the end of this method.
                    var originalDefaultZone = TimeChart.moment.defaultZone;
                    var originalLocale = TimeChart.moment.locale();
                    TimeChart.moment.locale(this.scene.momentLocale);
                    TimeChart.moment.tz.setDefault(timeZone);
                    data.from = this.convertTimestampToInternal(data.from, hasTimePart);
                    data.to = this.convertTimestampToInternal(data.to, hasTimePart);
                    data.dataLimitFrom = this.convertTimestampToInternal(data.dataLimitFrom, hasTimePart);
                    data.dataLimitTo = this.convertTimestampToInternal(data.dataLimitTo, hasTimePart);
                    var dataFrom;
                    var dataTo;
                    var prevTimestamp = -1e30;
                    var needsSort = false;
                    /* soft failures, accept data but print error*/
                    if (data.from != null && data.to != null && data.from >= data.to) {
                        this.chart.error("Data logic error. from >= to: " + data.from + ", " + data.to + ". The values will be ignored.");
                        data.from = null;
                        data.to = null;
                    }
                    if (data.dataLimitFrom != null && data.dataLimitTo != null && data.dataLimitFrom >= data.dataLimitTo) {
                        this.chart.error("Data logic error. dataLimitFrom >= dataLimitTo: " + data.dataLimitFrom + ", " + data.dataLimitTo + ". The values will be ignored.");
                        data.dataLimitFrom = null;
                        data.dataLimitTo = null;
                    }
                    var dataLimitFrom = data.dataLimitFrom;
                    var dataLimitTo = data.dataLimitTo;
                    if (dataLimitFrom == null)
                        dataLimitFrom = -Infinity;
                    if (dataLimitTo == null)
                        dataLimitTo = Infinity;
                    var fast = 0;
                    if (timeZone === "UTC" && this.settings.timeAxis.timeZone === "UTC") {
                        fast = this.dataSettings.timestampInSeconds ? 1000 : 1;
                    }
                    if (data.values.length > 0) {
                        // cleanup data values
                        var goodValues = [];
                        for (var vIndex = 0; vIndex < data.values.length; vIndex++) {
                            var v = data.values[vIndex];
                            if (!Array.isArray(v)) {
                                this.chart.error("Data error: the value at index " + vIndex + " is not an array.");
                                continue;
                            }
                            var vlen = v.length;
                            for (var i = 1; i < vlen; i++) {
                                var a = v[i];
                                if (a !== null) {
                                    if (typeof a !== "number" && isNaN(v[i] = parseFloat(a))) {
                                        this.chart.error("Data error: the value is not a number: values[" + vIndex + "][" + i + "] = " + a);
                                        v[i] = null;
                                    }
                                }
                            }
                            var tstamp = vlen ? v[0] : null;
                            if (tstamp != null) {
                                v[0] = tstamp = (fast && typeof tstamp === "number")
                                    ? tstamp * fast
                                    : this.convertTimestampToInternal(tstamp, hasTimePart);
                                if (tstamp === null)
                                    continue;
                                if (tstamp < dataLimitFrom || tstamp > dataLimitTo) {
                                    this.chart.error("Data error: value timestamp outside data limits. values[" + vIndex + "][0] = " + v[0]
                                        + ". Limits: " + dataLimitFrom + "..." + dataLimitTo);
                                }
                                if (enableWarnings && prevTimestamp === tstamp) {
                                    Internal.Base.Helpers.warn("There are multiple values given for the same timestamp " + v[0] + " which might produce invalid results.");
                                }
                                if (prevTimestamp > tstamp && !needsSort) {
                                    if (enableWarnings)
                                        Internal.Base.Helpers.warn("Data values are not sorted on timestamp in ascending order (timestamp " + v[0] + ")."
                                            + " TimeChart will sort the data automatically but to achieve better performance the data source should be sorted.");
                                    needsSort = true;
                                }
                                prevTimestamp = v[0];
                                goodValues.push(v);
                            }
                        }
                        data.values = goodValues;
                        if (needsSort)
                            goodValues.sort(function (a, b) { return a[0] - b[0]; });
                        dataFrom = goodValues[0][0];
                        dataTo = goodValues[goodValues.length - 1][0];
                    }
                    if (data.from != null && dataFrom < data.from) {
                        Internal.Base.Helpers.warn("Data logic error. Data time " + dataFrom + " outside [from, to) range: " + data.from + ", " + data.to);
                        data.from = dataFrom;
                    }
                    if (data.to != null && dataTo >= data.to) {
                        Internal.Base.Helpers.warn("Data logic error. Data time " + dataTo + " outside [from, to) range: " + data.from + ", " + data.to);
                        data.to = dataTo + 1;
                    }
                    // it is very important that this assignment is always called.
                    TimeChart.moment.defaultZone = originalDefaultZone;
                    TimeChart.moment.locale(originalLocale);
                    return data;
                };
                Data.prototype.analyzeDataNoRequest = function (data, addingData) {
                    var config = this.dataSettings;
                    var from = data.from;
                    var to = data.to;
                    var step = TimeChart.TimeStep.parse(data.unit);
                    var dataFrom = null;
                    var dataTo = null;
                    if (from == null || to == null) {
                        // take from and to from data no limits defined
                        if (data.values.length > 0) {
                            var tsc = this.scene.timeStepSettings;
                            dataFrom = data.values[0][0];
                            dataTo = data.values[data.values.length - 1][0];
                            dataFrom = step.roundTimeDown(dataFrom, tsc);
                            dataTo = step.roundTimeUp(dataTo + 1, tsc);
                            if (from == null) {
                                from = dataFrom;
                            }
                            if (to == null) {
                                to = dataTo;
                            }
                        }
                    }
                    // if there is no data function defined, assume that this is the only data and limits can be retrieved from it
                    if (config.dataFunction == null && config.url == null
                        && (data.dataLimitFrom == null && data.dataLimitTo == null)
                        && !Internal.Base.Helpers.hasProperties(config.urlByUnit)) {
                        Internal.Base.Helpers.warn("Using preloaded data without specifying `dataLimitFrom` and `dataLimitTo` is not recommended"
                            + " - these values will be implied from the data and might result in invalid behavior.", null, 1e30);
                        if (data.dataLimitFrom == null) {
                            data.dataLimitFrom = Math.min((addingData ? this.dataLimitFrom : 0) || 1e30, data.from || dataFrom);
                        }
                        if (data.dataLimitTo == null) {
                            data.dataLimitTo = Math.max((addingData ? this.dataLimitTo : 0) || -1e30, data.to || dataTo);
                        }
                    }
                    // process data limits
                    this.updateDataLimit(dataFrom, dataTo, data.dataLimitFrom, data.dataLimitTo, step);
                    var r = new TimeData(step, from, to, data.values);
                    if (data.error != null)
                        r.error = data.error;
                    return r;
                };
                Data.prototype.analyzeData = function (data, request) {
                    // use data limit if no form/to returned
                    if (request.from === null && data.from == null && data.dataLimitFrom != null) {
                        data.from = data.dataLimitFrom;
                        Internal.Base.Helpers.warn("`from` is not set in the data response - using `dataLimitFrom` instead. This may produce unexpected results.");
                    }
                    if (request.to === null && data.to == null && data.dataLimitTo != null) {
                        data.to = data.dataLimitTo;
                        Internal.Base.Helpers.warn("`to` is not set in the data response - using `dataLimitTo` instead. This may produce unexpected results.");
                    }
                    var from = data.from;
                    var to = data.to;
                    var dataFrom = null;
                    var dataTo = null;
                    if (from != null && to != null && from >= to) {
                        this.chart.error("Data logic error. from >= to: " + from + ", " + to);
                    }
                    var step = TimeChart.TimeStep.parse(data.unit);
                    var tsc = this.scene.timeStepSettings;
                    if (data.values.length > 0) {
                        dataFrom = data.values[0][0];
                        dataTo = data.values[data.values.length - 1][0];
                        // Round dataFrom, dataTo to next full unit
                        dataFrom = step.roundTimeDown(dataFrom, tsc);
                        dataTo = step.roundTimeUp(dataTo + 1, tsc);
                        // take from and to from data if all else fails
                        if (from == null) {
                            if (request.from !== null) {
                                from = Math.min(request.from, dataFrom);
                            }
                            else {
                                from = dataFrom;
                            }
                        }
                        if (to == null) {
                            if (request.to !== null) {
                                to = Math.max(request.to, dataTo);
                            }
                            else {
                                to = dataTo;
                            }
                        }
                        if (request.from && dataTo <= request.unit.add(request.from)) {
                            this.dataSettings._skipRequestRangeRounding = true;
                        }
                    }
                    else {
                        if (from == null)
                            from = request.from;
                        if (to == null)
                            to = request.to;
                        if (data.from != null && data.to != null) {
                            dataFrom = data.from;
                            dataTo = data.to;
                        }
                        else {
                            // No data, no limits, no nothing. Mark as empty - for dataLimit calculation
                            dataFrom = request.from;
                            dataTo = request.to;
                            // nothing at all
                            if (request.from === null
                                && request.to === null
                                && from == null
                                && to == null
                                && data.dataLimitFrom == null
                                && data.dataLimitTo == null) {
                                this.noData = true;
                            }
                        }
                    }
                    // process data limits
                    this.updateDataLimit(dataFrom, dataTo, data.dataLimitFrom, data.dataLimitTo, step);
                    // compute data limits from from/to fields
                    if (request.from !== null && data.to != null) {
                        var rdt = step.roundTimeDown(data.to, tsc);
                        if (rdt <= request.from) {
                            this.updateDataLimit(null, null, null, data.to, step);
                        }
                    }
                    if (request.to !== null && data.from != null) {
                        var rdf = step.roundTimeUp(data.from, tsc);
                        if (rdf >= request.to) {
                            this.updateDataLimit(null, null, data.from, null, step);
                        }
                    }
                    // if there is no other limits, guess data limits from the data itself. We cannot trust requests that are inside known data limit. 
                    // Only use requests that cross existing data limit.
                    if (data.from == null && data.dataLimitFrom == null) {
                        if ((this.dataLimitFrom !== null && (request.from === null || (request.from <= this.dataLimitFrom && dataFrom > this.dataLimitFrom)))
                            || (this.dataLimitFrom === null && (request.from === void 0 || request.from === null))) {
                            this.updateDataLimit(null, null, dataFrom, null, step);
                            from = dataFrom;
                        }
                    }
                    if (data.to == null && data.dataLimitTo == null) {
                        if ((this.dataLimitTo !== null && (request.to === null || (request.to >= this.dataLimitTo && dataTo < this.dataLimitTo)))
                            || (this.dataLimitTo === null && (request.to === void 0 || request.to === null))) {
                            this.updateDataLimit(null, null, null, dataTo, step);
                            to = dataTo;
                        }
                    }
                    var r = new TimeData(step, from, to, data.values);
                    if (data.error) {
                        r.error = data.error;
                    }
                    return r;
                };
                Data.prototype.getDataFunction = function () {
                    var _this = this;
                    var config = this.dataSettings;
                    if (config.dataFunction)
                        return config.dataFunction;
                    var hasUrlByUnit = Internal.Base.Helpers.hasProperties(config.urlByUnit);
                    if (config.url || hasUrlByUnit)
                        return function (from, to, unit, success, fail, timeZone) {
                            var url;
                            if (hasUrlByUnit) {
                                url = config.urlByUnit[unit];
                                if (!url) {
                                    return ("{\"error\":\"no-unit\", \"errormessage\":\"no data url for this time unit: " + unit + "\"}");
                                }
                            }
                            else {
                                url = config.url;
                            }
                            var params = [];
                            if (from !== null) {
                                params.push(["from", from.toString(10)]);
                            }
                            if (to !== null) {
                                params.push(["to", to.toString(10)]);
                            }
                            params.push(["unit", unit]);
                            if (timeZone !== null)
                                params.push(["timeZone", timeZone]);
                            Internal.Base.Data.doRequest(url, _this.dataSettings, params, success, fail);
                        };
                    return null;
                };
                Data.prototype.hasPendingRequests = function () {
                    return Internal.Base.Helpers.hasProperties(this.requests);
                };
                /**
                 * Parses and converts the given timestamp from the data source representation into the time axis timezone.
                 * Unlike `Scene.timestampToInternal` this also handles string timestamps and data timezone.
                 *
                 * @param external - the data timestamp that has to be parsed
                 * @param hasTimePart - specifies if the timestamp represents a date unit (d, w, M or y) for which the timezone adjustment is not performed.
                 */
                Data.prototype.convertTimestampToInternal = function (external, hasTimePart) {
                    if (external == null)
                        return null;
                    var s = this.dataSettings;
                    var ta = this.settings.timeAxis;
                    var isnumber = Internal.Base.Helpers.isNumber(external);
                    if (isnumber && s.timestampInSeconds) {
                        external = external * 1000;
                    }
                    // note that timeZone is not specified in this call but rather in the caller using `moment.tz.setDefault`.
                    // the same applies to the locale that could be used by stringTimestampFormat
                    var x = TimeChart.moment(external, isnumber ? null : s.stringTimestampFormat);
                    if (!x.isValid()) {
                        var tryparse = parseFloat(external);
                        if (!isnumber && !isNaN(tryparse)) {
                            Internal.Base.Helpers.warn("Numeric timestamp value `" + external + "` was passed as string. This has been deprecated starting from version 1.12.");
                            return this.convertTimestampToInternal(tryparse, hasTimePart);
                        }
                        Internal.Base.Helpers.error("Could not parse timestamp value `" + external + "`. The value will be ignored.");
                        return null;
                    }
                    if (hasTimePart)
                        x = x.tz(ta.timeZone);
                    // utcOffset is only available from 2.9.0, this increases the backwards compatibility
                    var offset = x.utcOffset ? x.utcOffset() : x.zone();
                    external = +x + offset * 60000;
                    // apply the deprecated offsets.
                    return external + (ta.timeZoneOffset - s.timeZoneOffset) * 60000;
                };
                /**
                 * Converts the given timestamp from the internal representation (that is in the time-axis timezone)
                 * to UTC.
                 * @param internal - the internal timestamp
                 * @param hasTimePart - specifies if the timestamp represents a date unit (d, w, M or y) for which the timezone adjustment is not performed.
                 */
                Data.prototype.convertTimestampFromInternal = function (internal, hasTimePart) {
                    if (internal == null)
                        return null;
                    var s = this.dataSettings;
                    // handle the timeAxis timezone
                    internal = this.scene.timestampFromInternal(internal, hasTimePart);
                    // apply the deprecated offset
                    internal += s.timeZoneOffset * 60000;
                    if (s.timestampInSeconds) {
                        internal /= 1000;
                    }
                    return internal;
                };
                return Data;
            }());
            TimeChart.Data = Data;
            var TimeData = (function () {
                function TimeData(unit, from, to, values) {
                    /** actual values list of [time, value] */
                    this.values = null;
                    this.error = null;
                    this.values = values;
                    this.to = to;
                    this.from = from;
                    this.unit = unit;
                    this.unitStr = unit.toString();
                    this.updateLastTimestamp();
                }
                TimeData.prototype.updateLastTimestamp = function () {
                    if (this.values.length > 0) {
                        this.lastTimestamp = this.values[this.values.length - 1][0];
                    }
                    else {
                        this.lastTimestamp = 0;
                    }
                };
                TimeData.prototype.merge = function (newData, maxCount, events, append) {
                    if (newData.unit.approxTime() !== this.unit.approxTime()) {
                        throw new Error("merge unit mismatch");
                    }
                    if (!append && (this.from > newData.to || this.to < newData.from)) {
                        // no overlap = no merge
                        this.values = newData.values;
                        this.from = newData.from;
                        this.to = newData.to;
                        return;
                    }
                    if (newData.values.length > 0 && newData.from > newData.values[0][0]) {
                        events.error("Data merge - oldest data before from");
                    }
                    if (newData.values.length > 0 && newData.to < newData.values[newData.values.length - 1][0]) {
                        events.error("Data merge - newest data after to");
                    }
                    var addBefore = 0;
                    while (addBefore < this.values.length && this.values[addBefore][0] < newData.from) {
                        addBefore += 1;
                    }
                    var addAfter = this.values.length;
                    while (addAfter > 0 && this.values[addAfter - 1][0] >= newData.to) {
                        addAfter -= 1;
                    }
                    var v = newData.values;
                    this.from = Math.min(this.from, newData.from);
                    this.to = Math.max(this.to, newData.to);
                    if (addBefore > 0) {
                        // trim data if too many
                        var from = Math.max(0, v.length + addBefore - maxCount);
                        v = this.values.slice(from, (addBefore - 1) + 1).concat(v);
                        if (from > 0) {
                            this.from = this.values[from - 1][0] + 1;
                        }
                    }
                    if (addAfter < this.values.length) {
                        // trim data if too many
                        var toAdd = this.values.length - addAfter;
                        toAdd = Math.min(toAdd, maxCount - v.length);
                        v = v.concat(this.values.slice(addAfter, (addAfter + toAdd) + 1));
                        if (toAdd < this.values.length - addAfter) {
                            this.to = this.values[addAfter + toAdd][0];
                        }
                    }
                    this.values = v;
                    this.updateLastTimestamp();
                };
                return TimeData;
            }());
            TimeChart.TimeData = TimeData;
            var RequestData = (function () {
                function RequestData(unit, from, to, callback, time, timeZone) {
                    this.time = time;
                    this.callback = callback;
                    this.to = to;
                    this.from = from;
                    this.unit = unit;
                    this.unitStr = unit.toString();
                    this.timeZone = timeZone;
                }
                return RequestData;
            }());
        })(TimeChart = Internal.TimeChart || (Internal.TimeChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/core/ChartEvents.ts" />
/// <reference path="../base/Graphics.ts" />
/// <reference path="../linearchart/Scrolling.ts" />
/// <reference path="../base/Helpers.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var TimeChart;
        (function (TimeChart) {
            var SettingsInteractionScrolling = (function (_super) {
                __extends(SettingsInteractionScrolling, _super);
                function SettingsInteractionScrolling() {
                    _super.apply(this, arguments);
                    /** Defines the chart behavior when the chart is scrolled passed the data limits. The actual limits are stored in `limitFrom` and `limitTo`.
                    @type enum
                    @value snapBack - allow scrolling past the limit but scroll back.
                    @value block - do not allow to scroll past the limit
                    @value null - no limit scroll */
                    this.limitMode = "snapBack";
                    /** Limits scrolling in the left side. This should be either the timestamp value in milliseconds or the string constant 'oldestData'.
                    Specify `null` to disable the limit. */
                    this.limitFrom = "oldestData";
                    /** Limits scrolling in the right side. This should be either the timestamp value in milliseconds or the string constant 'newestData'.
                    Specify `null` to disable the limit. */
                    this.limitTo = "newestData";
                    /** Allows the user to scroll past the limit to a certain degree. This coefficient is multiplied to the overscroll area - so if `overscrollProportion`
                    is set to 0.1 and the user scrolls 10 units past the limit, the chart will scroll back 9 units.
                    @type float
                    @min 0
                    @max 1 */
                    this.overscrollProportion = 0;
                }
                return SettingsInteractionScrolling;
            }(Internal.LinearChart.SettingsInteractionScrolling));
            TimeChart.SettingsInteractionScrolling = SettingsInteractionScrolling;
            var Scrolling = (function (_super) {
                __extends(Scrolling, _super);
                function Scrolling(chart) {
                    _super.call(this, chart);
                    this.animationOrder = 600;
                    this.paintOrder = 10;
                    this.updateOrder = 1400;
                    this.animationUnit = null;
                    this.targetUnit = null;
                    this.dragStartBar0 = null;
                    this.dragStartBar1 = null;
                    this.dragStartUnit = null;
                    this.timeSetup = new TimeChart.TimeSetup(chart);
                }
                Scrolling.prototype.onSceneChange = function (event) {
                    _super.prototype.onSceneChange.call(this, event);
                    var scene = this.scene;
                    var unit = this.scene.displayUnit;
                    if ((this.scalingActive ||
                        !scene.timeScale ||
                        scene.lastUnit !== unit) && unit) {
                        if (!this.timeSetup.preventUnitWidthViolation(this.chart.timeEnd, this.chart.timeStart)) {
                            scene.timeScale = (scene.timeEnd - scene.timeStart) / scene.width;
                        }
                    }
                    if (scene.lastUnit !== unit) {
                        scene.lastUnit = unit;
                    }
                };
                /**
                * On pointer drag check time in pixel and never allow current display unit to be smaller than that. If so, returns the same range.
                * @return scaled range.
                */
                Scrolling.prototype.scaleViewRange = function (event, from, to) {
                    var r = _super.prototype.scaleViewRange.call(this, event, from, to);
                    var scene = this.scene;
                    var config = scene.settings.timeAxis;
                    var s = (r.to - r.from) / scene.width * config.minUnitWidth / 1.5;
                    if (scene.disableScaleLimiter || s <= scene.displayUnit.approxTime()) {
                        return r;
                    }
                    return { from: from, to: to };
                };
                Scrolling.prototype.setTimeRangeSnap = function (from, to, origin, desiredUnit, animate, notifyOrigin, scroll, scale) {
                    var snapResult = this.snap(from, to, origin, desiredUnit, scroll, scale);
                    from = snapResult.from;
                    to = snapResult.to;
                    var unit = snapResult.unit;
                    var period = snapResult.period;
                    var anchor = snapResult.anchor;
                    this.setTimeRange(from, to, unit, animate, notifyOrigin, anchor, period);
                };
                Scrolling.prototype.computeDisplayPeriod = function (period, anchor, unitStr, dataFrom, dataTo) {
                    var tryComputeDisplayPeriodResult = this.timeSetup.tryComputeDisplayPeriod(period, anchor, unitStr, dataFrom, dataTo, this.scene, this.scene.getCurTime());
                    var from = tryComputeDisplayPeriodResult.from;
                    var to = tryComputeDisplayPeriodResult.to;
                    var unit = tryComputeDisplayPeriodResult.unit;
                    if (from === null || to === null) {
                        return {
                            from: null,
                            to: null,
                            unit: null
                        };
                    }
                    // apply common adjustments
                    return this.computeTimeRangeExtend(from, to, unit);
                };
                Scrolling.prototype.computeTimeRangeExtend = function (from, to, unit) {
                    var scene = this.scene;
                    // For scaling - snaps both ends to full/partial block
                    if (!unit) {
                        // initial display period based on anchor and min/max unit width policy
                        var result = this.timeSetup.computeDisplayUnit(scene.timeStart, scene.timeEnd, scene.displayUnit, from, to, scene);
                        from = result.from;
                        to = result.to;
                        unit = result.unit;
                    }
                    // snap to full bars
                    var tsc = scene.timeStepSettings;
                    from = unit.roundTimeDown(from, tsc);
                    to = unit.roundTimeUp(to, tsc);
                    // fixup for zero range
                    if (to === from) {
                        to = unit.add(to, 1);
                    }
                    // prevent overscroll once more - to compensate for unit change
                    var overscrollRange = this._preventOverscroll(from, to, unit, true);
                    from = overscrollRange.from;
                    to = overscrollRange.to;
                    return {
                        from: from,
                        to: to,
                        unit: unit
                    };
                };
                Scrolling.prototype.computeDisplayUnit = function (from, to, animate) {
                    var oldStart = (this.dragStartFrom !== null) ? this.dragStartFrom : this.scene.timeStart;
                    var oldEnd = (this.dragStartTo !== null) ? this.dragStartTo : this.scene.timeEnd;
                    var oldUnit = this.dragStartUnit ? this.dragStartUnit : this.scene.displayUnit;
                    var scroll = this.chart.scrolling;
                    var state = {
                        scroll: scroll.scrollingActive,
                        scale: scroll.scalingActive,
                        animate: animate
                    };
                    return this.timeSetup.computeDisplayUnit(oldStart, oldEnd, oldUnit, from, to, this.scene, state);
                };
                /** Just sets the specified time range (with optional animation). */
                Scrolling.prototype.setTimeRange = function (from, to, unit, animate, notifyOrigin, anchor, period) {
                    if (anchor === void 0) { anchor = null; }
                    if (period === void 0) { period = null; }
                    from = Math.round(from);
                    to = Math.round(to);
                    if (from > to) {
                        return;
                    }
                    if (!unit) {
                        var r = this.computeDisplayUnit(from, to);
                        from = r.from;
                        to = r.to;
                        unit = r.unit;
                    }
                    if (notifyOrigin === "init") {
                        // allow initial period to get time range restrictions
                        var r = this.timeSetup.getMinRangeForUnit(from, to, unit, anchor);
                        from = r.from;
                        to = r.to;
                    }
                    if (from !== this.getFrom() || to !== this.getTo() || !unit.isEqual(this.scene.displayUnit)) {
                        if (animate)
                            this.abort();
                        this.scene.anchor = anchor;
                        this.scene.period = period;
                        this.targetUnit = unit;
                        this.animationUnit = (!unit || (this.scene.displayUnit && unit.toString() !== this.scene.displayUnit.toString())) ? null : unit;
                        this.goToPosition(from, to, animate, Internal.Base.Helpers.performanceNow(), true);
                        this.events.notifySceneChanges({ time: true });
                        if (notifyOrigin) {
                            this.chart.notifyTimeChanged(from, to, unit, notifyOrigin);
                        }
                    }
                };
                Scrolling.prototype.zoomOut = function (displayUnit, from, to, animate, notifyOrigin) {
                    if (!this.scene.displayUnit)
                        return;
                    var zoom = this.computeZoomOut(from, to);
                    this.scene.displayUnit = zoom.unit;
                    this.setTimeRangeSnap(zoom.from, zoom.to, zoom.center, zoom.unit, animate, notifyOrigin, false, true);
                };
                Scrolling.prototype.zoomIn = function (unit, center, from, to, animate, notifyOrigin) {
                    if (!this.scene.displayUnit)
                        return;
                    if (center === null) {
                        center = (from + to) / 2;
                    }
                    var zoomInResult = this.onZoomIn(from, to, center, 0.5);
                    this.setTimeRangeSnap(zoomInResult.from, zoomInResult.to, zoomInResult.center, unit, animate, notifyOrigin, false, true);
                };
                Scrolling.prototype.handleZoomWheel = function (from, to, origin, time, scale) {
                    var snap1 = this.onSnapWhileDragging(from, to, origin, this.scrollingActive, scale);
                    from = snap1.from;
                    to = snap1.to;
                    var unit = snap1.unit;
                    // onSnapAfterDragging uses scene.displayUnit
                    this.scene.displayUnit = unit;
                    if (this.pointer1 === null) {
                        var snap2 = this.onSnapAfterDragging(from, to, origin, this.scrollingActive, scale);
                        from = snap2.from;
                        to = snap2.to;
                        unit = snap2.unit;
                        this.scene.displayUnit = unit;
                    }
                    this.goToPosition(from, to, true, time, true);
                };
                /* --------------
                Inner methods
                -------------- */
                Scrolling.prototype.xyInArea = function (x, y) {
                    return this.scene.xyInChart(x, y);
                };
                Scrolling.prototype.xyToPosition = function (x, y) {
                    return this.scene.xToTime(x);
                };
                /** called to compute target positions, returns [from, to] */
                Scrolling.prototype.onZoomOut = function (from, to, origin, scale) {
                    if (scale === void 0) { scale = null; }
                    if (scale) {
                        return _super.prototype.onZoomOut.call(this, from, to, origin, scale);
                    }
                    else {
                        return this.computeZoomOut(from, to);
                    }
                };
                /** called to compute target positions, returns [from, to] */
                Scrolling.prototype.onZoomIn = function (from, to, center, scale) {
                    if (scale === void 0) { scale = null; }
                    if (scale) {
                        return _super.prototype.onZoomIn.call(this, from, to, center, scale);
                    }
                    else if (this.dragStartBar0) {
                        from = this.dragStartBar0;
                        to = this.dragStartBar1;
                        if (to - from > this.scene.timeEnd - this.scene.timeStart) {
                            // zoomed in beyond initial scope, get new one, ignore selection, it will be too big.
                            var getClickBarResult = this.scene.getClickBar(center);
                            from = getClickBarResult.time0;
                            to = getClickBarResult.time1;
                        }
                    }
                    return {
                        from: from,
                        to: to,
                        center: (from + to) / 2
                    };
                };
                /** computes positions after scroll */
                Scrolling.prototype.onScroll = function (from, to, direction) {
                    // scroll 1 page left/right
                    return this.timeSetup.scroll(from, to, this.scene.displayUnit, direction, 1, "page");
                };
                /** called when home button is pressed */
                Scrolling.prototype.onGoHome = function (from, to) {
                    var dataTo = this.chart.getDisplayLimits().to;
                    if (dataTo === null) {
                        return {
                            from: from,
                            to: to,
                            origin: null
                        };
                    }
                    this.scene.anchor = "newestData";
                    var dt = to - from;
                    return {
                        from: dataTo - dt,
                        to: dataTo,
                        origin: dataTo
                    };
                };
                /** called when dragging starts, no return value */
                Scrolling.prototype.onStartDragging = function (oldFrom, oldTo, pos) {
                    this.scene.anchor = null;
                    this.animationUnit = null;
                    this.dragStartUnit = this.scene.displayUnit;
                    var getClickBarResult = this.scene.getClickBar(pos);
                    this.dragStartBar0 = getClickBarResult.time0;
                    this.dragStartBar1 = getClickBarResult.time1;
                };
                /** called to determine position snap while dragging, returns snapped [from, to] */
                Scrolling.prototype.onSnapWhileDragging = function (from, to, origin, isScrolling, isScaling) {
                    var overscaleRange = this._preventOverscale(from, to, null, origin, false);
                    from = overscaleRange.from;
                    to = overscaleRange.to;
                    var unit = this.computeDisplayUnit(from, to).unit;
                    var overscrollRange = this._preventOverscroll(from, to, unit, false);
                    from = overscrollRange.from;
                    to = overscrollRange.to;
                    this.events.notifySceneChanges({ time: true });
                    return { from: from, to: to, unit: unit };
                };
                /** called to determine position snap after release, returns snapped [from, to]
                also perform any notifications here */
                Scrolling.prototype.onSnapAfterDragging = function (from, to, origin, isScrolling, isScaling) {
                    // check units before snap because of scale
                    if (isScaling) {
                        var range = this.timeSetup.adjustTimeAfterScale(from, to, this.dragStartBar0, this.dragStartBar1);
                        from = range.from;
                        to = range.to;
                    }
                    // isScaling = false here because once the user has selected the display unit he wants, it should not change once the pointer is released
                    var snap = this.snap(from, to, origin, null, isScrolling, false);
                    var unit = snap.unit;
                    var period = snap.period;
                    var anchor = snap.anchor;
                    this.targetUnit = unit;
                    this.animationUnit = this.scene.displayUnit;
                    this.scene.period = period;
                    this.scene.anchor = anchor;
                    this.dragStartBar0 = null;
                    this.dragStartBar1 = null;
                    this.dragStartFrom = null;
                    this.dragStartTo = null;
                    this.dragStartUnit = null;
                    this.events.notifySceneChanges({ time: true });
                    this.chart.notifyTimeChanged(from, to, unit, "user");
                    return { from: snap.from, to: snap.to, unit: unit };
                };
                /** called when scroll positions have changed, ie - animating */
                Scrolling.prototype.onPositionChanged = function (from, to, animate) {
                    // avoid setting the timeRange if from/to are invalid. This case is from data.html test (no data + no limits) that render blank chart.
                    if (isNaN(from) && isNaN(to))
                        return;
                    var unit;
                    if (this.animationUnit) {
                        unit = this.animationUnit;
                    }
                    else {
                        unit = this.computeDisplayUnit(from, to).unit;
                    }
                    this.scene.setTimeRange(from, to, unit);
                    this.chart.timeStart = from;
                    this.chart.timeEnd = to;
                    this.chart.displayUnit = unit;
                    this.events.notifySceneChanges({ position: true, time: true });
                };
                /** called when scroll animation is done */
                Scrolling.prototype.onAnimationDone = function (from, to) {
                    if (this.targetUnit) {
                        var unit = this.targetUnit ? this.targetUnit : (this.computeDisplayUnit(from, to).unit);
                        this.chart.displayUnit = unit;
                        this.scene.setTimeRange(from, to, unit);
                    }
                    this.targetUnit = null;
                    this.animationUnit = null;
                    this.chart.notifyAnimationDone();
                };
                Scrolling.prototype.onPointerDrag = function (event) {
                    if (this.scene.displayUnit) {
                        // prevent calling the calculations if the scene has not been initialized.
                        // otherwise if the user starts dragging while the chart is still loading,
                        // various errors might be thrown.
                        _super.prototype.onPointerDrag.call(this, event);
                    }
                };
                /** Compute zoomout state based on zoomout function or use the current display range to create 15x wider time range. */
                Scrolling.prototype.computeZoomOut = function (from, to) {
                    var zoomFunc = this.scene.settings.toolbar.zoomOutFunction;
                    var unit = this.scene.displayUnit;
                    var targetUnit = null;
                    var intendedRange; // diff in ms
                    var zoTarget = null;
                    var range = (to - from);
                    var center = to - range / 2;
                    // trying to get target unit
                    if (zoomFunc) {
                        zoTarget = zoomFunc(unit.unit, unit.count, from, to);
                    }
                    if (zoTarget != null && zoTarget.unit) {
                        targetUnit = new TimeChart.TimeStep(zoTarget.unit, zoTarget.count || 1);
                    }
                    if (!targetUnit) {
                        targetUnit = this.timeSetup.getBiggerDisplayUnit(unit);
                    }
                    // we know the target unit, lets get data limits or limits based on unit width restrictions
                    var unitTime = targetUnit.approxTime();
                    var unitLimits = this.timeSetup.getUnitRange(this.scene, [targetUnit]);
                    // figure out if intended range have strictly defined from, to by custom function
                    var strictLimits = zoTarget != null && (zoTarget.from != null || zoTarget.to != null);
                    if (!strictLimits) {
                        var scaleUp = Math.min(30 * range / unitTime, Math.floor(unitLimits.maxTime / unitTime));
                        intendedRange = unitTime * scaleUp;
                    }
                    else {
                        intendedRange = Math.min(unitLimits.maxTime, zoTarget.to - zoTarget.from);
                        // check if user defined from/to and resulting target unit hold the test of unit width restriction
                        var exceed = this.timeSetup.verifyUnitWidth(zoTarget.from, zoTarget.to, targetUnit);
                        if (exceed.min || exceed.max) {
                            var r = this.timeSetup.adjustTimeRangeToUnits(this.chart.scene, zoTarget.from, zoTarget.to, targetUnit);
                            from = r.from;
                            to = r.to;
                        }
                    }
                    // take limits into account when changing small
                    if (!zoTarget || (zoTarget && !zoTarget.from)) {
                        from = center - intendedRange / 2;
                        to = center + intendedRange / 2;
                    }
                    return {
                        from: from,
                        to: to,
                        center: center,
                        unit: targetUnit
                    };
                };
                /** Takes the time range and applies snapping rules from settings. */
                Scrolling.prototype.snap = function (from, to, origin, desiredUnit, scroll, scale) {
                    // update scale if needed
                    if ((scale || scroll) && this.scene.settings.interaction.scrolling.limitMode) {
                        var overscaleRange = this._preventOverscale(from, to, desiredUnit, origin, true);
                        from = overscaleRange.from;
                        to = overscaleRange.to;
                    }
                    // now the scale is clear, compute display unit
                    var unit;
                    var rangeSetup;
                    if (desiredUnit) {
                        unit = desiredUnit;
                    }
                    else if (!scale || (!scale && scroll)) {
                        // preserve current unit if no scaling
                        unit = this.scene.displayUnit;
                    }
                    else {
                        // compute unit
                        rangeSetup = this.computeDisplayUnit(from, to);
                        unit = rangeSetup.unit;
                        from = rangeSetup.from;
                        to = rangeSetup.to;
                    }
                    // now prevent overscroll
                    if (scroll || scale) {
                        var diff = to - from;
                        // first use basic overscroll to emulate what happens when scrolling
                        var overscrollRange = this._preventOverscroll(from, to, unit, false);
                        from = overscrollRange.from;
                        to = overscrollRange.to;
                        overscrollRange = this._preventOverscroll(from, to, unit, true);
                        from = overscrollRange.from;
                        to = overscrollRange.to;
                        scale = scale || (to - from !== diff);
                    }
                    if (!desiredUnit && scale) {
                        // now we have a unit, start over again
                        rangeSetup = this.computeDisplayUnit(from, to);
                        from = rangeSetup.from;
                        to = rangeSetup.to;
                        return this.snap(from, to, origin, unit, scroll, scale);
                    }
                    var period = scale ? null : this.scene.period;
                    var anchor = this.scene.anchor;
                    // apply snap to period
                    var snapMode = this.scene.settings.interaction.snapMode;
                    if (snapMode) {
                        var isYears = this.scene.majorTimeUnit && this.scene.majorTimeUnit.unit === "y";
                        var snapUnit = void 0;
                        if (snapMode === "displayUnit") {
                            snapUnit = unit;
                        }
                        else if ((snapMode === "multiperiod" || snapMode === "period")) {
                            var range = to - from;
                            var getDisplayLimitsResult = this.chart.getDisplayLimits();
                            var dataFrom = getDisplayLimitsResult.from;
                            var dataTo = getDisplayLimitsResult.to;
                            if (dataFrom !== null) {
                                range = Math.min(range, dataTo - dataFrom);
                            }
                            var sp = this.timeSetup.getClosestDisplayPeriod(range, this.scene.majorTimeUnit, snapMode === "multiperiod" || isYears);
                            snapUnit = sp;
                            period = sp.toString();
                        }
                        var tsc = this.scene.timeStepSettings;
                        if (snapMode === "period" && !isYears) {
                            from = snapUnit.roundTimeDown(origin, tsc);
                            to = snapUnit.add(from, 1);
                        }
                        else {
                            if (scale) {
                                // just round
                                from = snapUnit.roundTimeRound(from, tsc);
                                to = snapUnit.roundTimeRound(to, tsc);
                            }
                            else {
                                // round by preserving number of units
                                var numberOfUnits = Math.max(snapUnit.numberOfUnits(from, to), 1);
                                var fd = Math.abs(snapUnit.roundTimeRound(from, tsc) - from);
                                var td = Math.abs(snapUnit.roundTimeRound(to, tsc) - to);
                                if (fd < td) {
                                    from = snapUnit.roundTimeRound(from, tsc);
                                    to = snapUnit.add(from, numberOfUnits);
                                }
                                else {
                                    to = snapUnit.roundTimeRound(to, tsc);
                                    from = snapUnit.sub(to, numberOfUnits);
                                }
                            }
                        }
                    }
                    else {
                        // no snapping, round to 1 ms
                        from = Math.round(from);
                        to = Math.round(to);
                    }
                    return {
                        from: from,
                        to: to,
                        unit: unit,
                        period: period,
                        anchor: anchor
                    };
                };
                Scrolling.prototype._preventOverscroll = function (from, to, unit, isFinal) {
                    return this.timeSetup.preventOverscroll(unit, from, to, isFinal);
                };
                Scrolling.prototype._preventOverscale = function (from, to, unit, center, isFinal) {
                    // setup checking units if any
                    var units;
                    if (unit) {
                        units = [unit];
                    }
                    else {
                        unit = this.scene.displayUnit;
                        units = this.scene.settings._displayUnitsParsed;
                    }
                    return this.timeSetup.preventOverscale(this.scene, units, center, from, to, unit, isFinal);
                };
                return Scrolling;
            }(Internal.LinearChart.Scrolling));
            TimeChart.Scrolling = Scrolling;
        })(TimeChart = Internal.TimeChart || (Internal.TimeChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/core/ChartEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var TimeChart;
        (function (TimeChart) {
            var SettingsInteractionSelection = (function () {
                function SettingsInteractionSelection() {
                    /** Enable/disable selection */
                    this.enabled = true;
                    /** Distance in pixels to both sides of the selection left/right edges that can be used to drag the selection area to expand/collapse it.
                    @type float
                    @units pixels */
                    this.tolerance = 6;
                    /** Specifies if the selection area can be moved by dragging it. By default the whole chart is moved instead.
                    @version 1.14.0 */
                    this.moveByDragging = false;
                    /** Specifies the speed by which the selection is resized by dragging it up and down. Requires `moveByDragging` to be enabled.
            
                    Note - set to `0` to disable the resize gesture.
                    @version 1.14.0 */
                    this.resizeSensitivity = 2;
                    /** Specifies how much the pointer must move vertically for the resize to start. Requires `moveByDragging` to be enabled.
                    @version 1.14.0 */
                    this.resizeTolerance = 20;
                }
                return SettingsInteractionSelection;
            }());
            TimeChart.SettingsInteractionSelection = SettingsInteractionSelection;
            var SettingsAreaStyleSelection = (function () {
                function SettingsAreaStyleSelection() {
                    this.lineColor = "rgba(0,0,0,0.5)";
                    this.lineWidth = 2;
                    this.fillColor = "rgba(30,160,220,0.15)";
                    /** Specifies if the selection is drawn behind or above the series themselves.
                    @version 1.13.2*/
                    this.behindSeries = false;
                }
                return SettingsAreaStyleSelection;
            }());
            TimeChart.SettingsAreaStyleSelection = SettingsAreaStyleSelection;
            var Selection = (function (_super) {
                __extends(Selection, _super);
                function Selection(chart) {
                    _super.call(this);
                    this.selectStart = null;
                    this.selectingPointer = null;
                    this.isSelecting = false;
                    /** Specifies if the edge of the selection is being hovered (when the resize cursor is being shown).
                    This is used to avoid drilldown when the edge is clicked. */
                    this.isHoveringEdge = false;
                    this.lastX = 0;
                    this.lastY = 0;
                    this.roundAround = false;
                    this.selectionRemoved = false;
                    this.animationOrder = 500;
                    this.updateOrder = 1300;
                    /** Specifies if the selection is being moved (dragged). */
                    this.isMoving = false;
                    /** Contains the X coordinate of the mouse cursor when the move was initiated */
                    this.moveStartX = 0;
                    /** Contains the Y coordinate of the mouse cursor when the move was initiated. */
                    this.moveStartY = 0;
                    /** Contains the start time of the selection when the move started. */
                    this.moveSelectionStart = null;
                    /** Contains the end time of the selection when the move started. */
                    this.moveSelectionEnd = null;
                    this.chart = chart;
                    this.scene = chart.scene;
                    var settings = chart.settings;
                    this.settings = settings.interaction.selection;
                    this.styleSettings = settings.area.style.selection;
                    this.labelStyle = settings.area.style.selectionLabel;
                    this.paintOrder = this.styleSettings.behindSeries ? 3 : 15;
                }
                Selection.prototype.onSceneChange = function (event) {
                    // emulate selection drag when time axis change
                    if ((event.changes.time || event.changes.bounds) && this.selectStart !== null) {
                        this.dragPointer(null, this.lastX, this.lastY, event.changes);
                    }
                    if (event.changes.settings) {
                        var newPaintOrder = this.styleSettings.behindSeries ? 3 : 15;
                        if (this.paintOrder !== newPaintOrder) {
                            this.paintOrder = newPaintOrder;
                            this.chart.events.refreshElementOrder();
                        }
                    }
                };
                Selection.prototype.getLineCoordinates = function () {
                    var scene = this.scene;
                    var config = this.styleSettings;
                    var xStart = Math.round(scene.timeToX(scene.selectionStart));
                    var xEnd = Math.round(scene.timeToX(scene.selectionEnd));
                    var lineWidth = config.lineWidth;
                    var x0 = Math.round(scene.x0);
                    var x1 = Math.round(x0 + scene.width);
                    // if the selection line is just outside the visible area, draw it inside.
                    if (xStart - lineWidth < x0 && xStart > x0 - lineWidth * 4)
                        xStart = x0 + lineWidth;
                    if (xEnd + lineWidth > x1 && xEnd < x1 + lineWidth * 4)
                        xEnd = xEnd - lineWidth;
                    return { start: xStart, end: xEnd };
                };
                Selection.prototype.paintScene = function (event) {
                    var scene = this.scene;
                    var config = this.styleSettings;
                    if (scene.selectionStart == null || scene.selectionEnd == null || !this.chart.assetsLoaded) {
                        return;
                    }
                    var x0 = Math.round(scene.x0);
                    var x2 = Math.round(x0 + scene.width);
                    var y0 = Math.round(scene.y0);
                    var y2 = Math.round(y0 + scene.height + scene.bottomAxisSize);
                    var res = this.getLineCoordinates();
                    var xL = res.start;
                    var xR = res.end;
                    var h = scene.height + scene.bottomAxisSize;
                    var leftText = TimeChart.moment(scene.selectionStart)
                        .locale(this.scene.momentLocale)
                        .utc()
                        .format(scene.minorTimeFormat);
                    var rightText = TimeChart.moment(Math.max(scene.selectionStart, scene.selectionEnd - 1))
                        .locale(this.scene.momentLocale)
                        .utc()
                        .format(scene.minorTimeFormat);
                    var g = event.context;
                    Internal.Base.Graphics.pushClip(event, x0, y0, this.scene.width, h);
                    Internal.Base.Graphics.rectStyle(g, config);
                    var pxL = xL + (config.lineWidth % 2) / 2;
                    var pxR = xR + (config.lineWidth % 2) / 2;
                    g.fillRect(pxL + config.lineWidth / 2, y0, xR - xL - config.lineWidth, h);
                    g.beginPath();
                    g.moveTo(pxL, y0);
                    g.lineTo(pxL, y2);
                    g.moveTo(pxR, y0);
                    g.lineTo(pxR, y2);
                    Internal.Base.Graphics.stroke(g, config);
                    // Labels
                    var labelRenderer = event.labelRenderer;
                    var textStyle = this.labelStyle;
                    var textWidthLeft = Internal.Base.Graphics.getTextWidth(g, textStyle, leftText);
                    var textWidthRight = Internal.Base.Graphics.getTextWidth(g, textStyle, rightText);
                    var ll = new Internal.Base.Label({ text: leftText, textStyle: textStyle }, true);
                    var rl = new Internal.Base.Label({ text: rightText, textStyle: textStyle }, true);
                    var ySpace = 10;
                    var xSpace = 5;
                    // label is always drawn on the visible section
                    if (xL < x0) {
                        xL = x0;
                    }
                    if (xR > x2) {
                        xR = x2;
                    }
                    if (textWidthLeft + textWidthRight + 20 < xR - xL) {
                        xL = xL + xSpace;
                        xR = xR - textWidthRight - xSpace;
                    }
                    else {
                        xL = xL - textWidthLeft - xSpace;
                        xR = xR + xSpace;
                    }
                    // adjust label position to not overlap toolbars and stuff.
                    var innerArea = this.chart.shell.getChartInnerArea();
                    var yL = innerArea.findTopPosition(xL, xL + textWidthLeft);
                    var yR = innerArea.findTopPosition(xR, xR + textWidthRight);
                    labelRenderer.paint(g, xL + textWidthLeft / 2, yL + ySpace, 1, ll);
                    labelRenderer.paint(g, xR + textWidthRight / 2, yR + ySpace, 1, rl);
                    Internal.Base.Graphics.popClip(event);
                };
                Selection.prototype.onPointerMove = function (event) {
                    var scene = this.scene;
                    var config = this.settings;
                    if (!config.enabled) {
                        return;
                    }
                    if (scene.xyInBottom(event.x, event.y)) {
                        // do not consume - allow others to do other sutff too.
                        event.cursor = "text";
                    }
                    var isHoveringEdge = false;
                    if (scene.selectionStart != null && scene.selectionEnd != null && scene.xyInChartOrBottom(event.x, event.y) && scene.timeStart < scene.timeEnd) {
                        var res = this.getLineCoordinates();
                        if (Math.abs(res.start - event.x) <= config.tolerance) {
                            event.cursor = "e-resize";
                            event.consumed = true;
                            isHoveringEdge = true;
                        }
                        else if (Math.abs(res.end - event.x) <= config.tolerance) {
                            event.cursor = "w-resize";
                            event.consumed = true;
                            isHoveringEdge = true;
                        }
                        else if (config.moveByDragging && res.start < event.x && res.end > event.x) {
                            event.cursor = "move";
                            event.consumed = true;
                        }
                    }
                    this.isHoveringEdge = isHoveringEdge;
                };
                Selection.prototype.onPointerDown = function (event) {
                    var scene = this.scene;
                    var config = this.settings;
                    if ((!scene.xyInChartOrBottom(event.x, event.y)) || this.selectingPointer !== null || (!config.enabled)) {
                        return;
                    }
                    this.selectionRemoved = false;
                    this.lastX = event.x;
                    var x0 = null;
                    var x1 = null;
                    if (scene.selectionStart !== null || scene.selectionEnd !== null) {
                        var coords = this.getLineCoordinates();
                        var s0X = Math.abs(coords.start - event.x);
                        var s1X = Math.abs(coords.end - event.x);
                        var capture = false;
                        // resize existing selection
                        if (s0X < config.tolerance && s0X <= s1X) {
                            this.selectStart = scene.selectionEnd;
                            capture = true;
                        }
                        else if (s1X < config.tolerance && s1X <= s0X) {
                            this.selectStart = scene.selectionStart;
                            capture = true;
                        }
                        else if (config.moveByDragging && coords.start < event.x && coords.end > event.x) {
                            this.isMoving = true;
                            this.moveStartX = event.x;
                            this.moveStartY = event.y;
                            this.moveSelectionStart = scene.selectionStart;
                            this.moveSelectionEnd = scene.selectionEnd;
                            this.selectStart = scene.xToTime(event.x);
                            capture = true;
                        }
                        if (capture) {
                            this.selectingPointer = event.identifier;
                            event.consumed = true;
                            this.roundAround = true;
                            this.isSelecting = true;
                            return;
                        }
                    }
                    // default - start new selection
                    if (scene.xyInBottom(event.x, event.y)) {
                        this.selectingPointer = event.identifier;
                        this.selectStart = scene.xToTime(event.x);
                        event.capture = true;
                        this.roundAround = true;
                        this.isSelecting = true;
                        if (event.x >= x0 && event.x <= x1) {
                        }
                        else {
                            // outside
                            if (scene.selectionStart !== null) {
                                this.selectionRemoved = true;
                                scene.selectionStart = null;
                                scene.selectionEnd = null;
                                event.changes.selection = true;
                            }
                        }
                    }
                };
                Selection.prototype.onPointerDrag = function (event) {
                    if (!this.scene.displayUnit
                        || this.selectingPointer !== event.identifier) {
                        return;
                    }
                    this.dragPointer(event, event.x, event.y, event.changes);
                    event.consumed = true;
                };
                Selection.prototype.dragPointer = function (event, x, y, changes) {
                    var scene = this.scene;
                    var t0;
                    var t1;
                    if (this.isMoving) {
                        var diff = scene.dxToDtime(x - this.moveStartX);
                        t0 = this.moveSelectionStart + diff;
                        t1 = this.moveSelectionEnd + diff;
                        var delta = y - this.moveStartY;
                        var tolerance = this.settings.resizeTolerance;
                        if (Math.abs(delta) > tolerance) {
                            delta = delta < 0 ? delta + tolerance : delta - tolerance;
                            var selectionSize = (this.moveSelectionEnd - this.moveSelectionStart);
                            var ydiff = Math.min(selectionSize, scene.dxToDtime(delta * this.settings.resizeSensitivity));
                            var coef = selectionSize === 0 ? 0.5 : (this.selectStart - this.moveSelectionStart) / selectionSize;
                            t0 += ydiff * coef;
                            t1 -= ydiff * (1 - coef);
                        }
                    }
                    else {
                        var selectStart = this.selectStart;
                        var time = this.scene.xToTime(x);
                        var filling = Math.abs(selectStart - time);
                        var startSnapped = scene.snapTimeRound(selectStart);
                        var diff = startSnapped - selectStart;
                        var sign = Internal.Base.Helpers.sign(diff);
                        startSnapped = selectStart + Math.min(diff * sign, filling * 0.9) * sign;
                        if (startSnapped < time) {
                            // start is leftmost
                            t0 = startSnapped;
                            t1 = time;
                        }
                        else {
                            // start is rightmost
                            t0 = time;
                            t1 = startSnapped;
                        }
                    }
                    this.lastX = x;
                    this.lastY = y;
                    scene.selectionStart = t0;
                    scene.selectionEnd = t1;
                    changes.selection = true;
                    if (scene.settings.events.selectionChangeDuringInteraction) {
                        this.chart.notifySelectionChanged(this.chart.createEventArguments(event, "user"));
                    }
                };
                Selection.prototype.onPointerUp = function (event) {
                    if (this.selectingPointer !== event.identifier) {
                        return;
                    }
                    if (this.isSelecting) {
                        var snapSelectionResult = this.snapSelection();
                        var st = snapSelectionResult.st;
                        var en = snapSelectionResult.en;
                        if (st === en) {
                            st = null;
                            en = null;
                        }
                        var scene = this.scene;
                        scene.selectionStart = st;
                        scene.selectionEnd = en;
                        // workaround for when the info popup is displayed at some previous position just after
                        // resizing the selection.
                        if (st != null) {
                            scene.hoverFrom = st;
                            scene.hoverTo = en;
                        }
                        this.chart.notifySelectionChanged(this.chart.createEventArguments(event, "user"));
                        event.changes.selection = true;
                    }
                    if (this.isSelecting || this.selectionRemoved) {
                        event.consumed = true;
                    }
                    this.isSelecting = false;
                    this.isMoving = false;
                    this.selectStart = null;
                    this.selectingPointer = null;
                };
                /** TODO: some better bahavior */
                Selection.prototype.onPointerCancel = function (event) {
                    this.onPointerUp(event);
                };
                Selection.prototype.snapSelection = function () {
                    var scene = this.scene;
                    var st;
                    var en;
                    if (scene.selectionStart != null) {
                        if (this.roundAround) {
                            st = scene.snapTimeRound(scene.selectionStart);
                            en = scene.snapTimeRound(scene.selectionEnd);
                        }
                        else {
                            st = scene.snapTimeDown(scene.selectionStart);
                            en = scene.snapTimeUp(scene.selectionEnd);
                        }
                    }
                    else {
                        st = null;
                        en = null;
                    }
                    return { st: st, en: en };
                };
                return Selection;
            }(Internal.Base.ChartElement));
            TimeChart.Selection = Selection;
        })(TimeChart = Internal.TimeChart || (Internal.TimeChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../linearchart/Scene.ts" />
/// <reference path="../base/Helpers.ts" />
/// <reference path="TimeSetup.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var TimeChart;
        (function (TimeChart) {
            var Scene = (function (_super) {
                __extends(Scene, _super);
                function Scene() {
                    _super.apply(this, arguments);
                    /** time value at the left side of the chart */
                    this.timeStart = 0;
                    /** time value at the right side of the chart */
                    this.timeEnd = 0;
                    this.anchor = null;
                    this.period = null;
                    /** time unit for 1 display unit */
                    this.displayUnit = null;
                    /** map from data id to TimeData object */
                    this.data = {};
                    this.markers = [];
                    /** main data object - used for various range limit calculations.
            
                    Note that this should not be used for any new code as instead all active
                    data objects should be reviewed. */
                    this.mainData = null;
                    this.selectionStart = null;
                    this.selectionEnd = null;
                    this.minorTimeFormat = null;
                    this.minorTimeUnit = null;
                    this.majorTimeUnit = null;
                    this.majorTimeFormat = null;
                    this.hoverFrom = null;
                    this.hoverTo = null;
                    this.timeScale = 0; // for bound changes
                    this.lastUnit = null; // for bounds changes
                    /** Specifies if the scale limiter (stopping the scale once the minUnitWidth is significantly exceeded) is disabled. */
                    this.disableScaleLimiter = false;
                    /** The name of the moment locale that has to be used for all formatting within the chart. */
                    this.momentLocale = "zc" + (Scene._momentLocaleCounter++).toFixed(0);
                }
                Scene.prototype.setTimeRange = function (minTime, maxTime, unit) {
                    if (!unit) {
                        Internal.Base.Helpers.error("Scene.setTimeRange: no display unit");
                    }
                    this.timeStart = minTime;
                    this.timeEnd = maxTime;
                    this.displayUnit = unit;
                };
                Scene.prototype.pixelsPerTime = function () {
                    return this.width / (this.timeEnd - this.timeStart);
                };
                /**
                 * Gets the number milliseconds that are represented by a single pixel on the chart.
                 */
                Scene.prototype.getScale = function () {
                    return (this.timeEnd - this.timeStart) / this.width;
                };
                Scene.prototype.timeToX = function (time) {
                    return this.x0 + this.width * (time - this.timeStart) / (this.timeEnd - this.timeStart);
                };
                Scene.prototype.timeToXCoefs = function () {
                    return {
                        tadd: this.x0 - this.timeStart * this.width / (this.timeEnd - this.timeStart),
                        tmul: this.width / (this.timeEnd - this.timeStart)
                    };
                };
                Scene.prototype.xToTime = function (x) {
                    return this.timeStart + (this.timeEnd - this.timeStart) * (x - this.x0) / this.width;
                };
                Scene.prototype.xToFraction = function (x) {
                    return (x - this.x0) / this.width;
                };
                Scene.prototype.dTimeToDx = function (time) {
                    return this.width * time / (this.timeEnd - this.timeStart);
                };
                Scene.prototype.dxToDtime = function (dx) {
                    return dx / this.width * (this.timeEnd - this.timeStart);
                };
                Scene.prototype.snapTimeDown = function (time) {
                    return this.displayUnit.roundTimeDown(time, this.timeStepSettings);
                };
                Scene.prototype.snapTimeUp = function (time) {
                    return this.displayUnit.roundTimeUp(time, this.timeStepSettings);
                };
                Scene.prototype.snapTimeRound = function (time) {
                    return this.displayUnit.roundTimeRound(time, this.timeStepSettings);
                };
                Scene.prototype.getClickBar = function (time) {
                    var du = this.displayUnit;
                    if (!du)
                        return { time0: null, time1: null };
                    return {
                        time0: du.roundTimeDown(time, this.timeStepSettings),
                        time1: du.roundTimeUp(time + 1, this.timeStepSettings)
                    };
                };
                Scene.prototype.getCurTime = function () {
                    var s = this.settings.currentTime;
                    var curUTCTime;
                    if (s.time != null) {
                        curUTCTime = s.time;
                    }
                    else {
                        curUTCTime = new Date().getTime();
                    }
                    return this.timestampToInternal(curUTCTime, true);
                };
                /**
                 * Converts the given timestamp from UTC into the time axis timezone.
                 * @param utc - the data timestamp that has to be parsed
                 * @param hasTimePart - specifies if the timestamp represents a date unit (d, w, M or y) for which the timezone adjustment is not performed.
                 */
                Scene.prototype.timestampToInternal = function (utc, hasTimePart) {
                    if (utc == null)
                        return null;
                    utc = +utc;
                    var ta = this.settings.timeAxis;
                    if (hasTimePart) {
                        if (!TimeChart.moment || !TimeChart.moment.tz)
                            return null;
                        var x = TimeChart.moment.utc(utc).tz(ta.timeZone);
                        // utcOffset is only available from 2.9.0, this increases the backwards compatibility
                        var offset = x.utcOffset ? x.utcOffset() : x.zone();
                        utc = +x + offset * 60000;
                    }
                    // apply the deprecated offsets.
                    return utc + ta.timeZoneOffset * 60000;
                };
                /**
                 * Converts the given timestamp from the internal representation (that is in the time-axis timezone) to UTC.
                 * This method works with millisecond timestamps only.
                 * @param internal - the internal timestamp
                 * @param hasTimePart - specifies if the timestamp represents a date unit (d, w, M or y) for which the timezone adjustment is not performed.
                 */
                Scene.prototype.timestampFromInternal = function (internal, hasTimePart) {
                    if (internal == null)
                        return null;
                    var ta = this.settings.timeAxis;
                    if (hasTimePart) {
                        if (!TimeChart.moment || !TimeChart.moment.tz)
                            return null;
                        var x = TimeChart.moment.utc(internal).tz(ta.timeZone);
                        // utcOffset is only available from 2.9.0, this increases the backwards compatibility
                        var offset = x.utcOffset ? x.utcOffset() : x.zone();
                        internal = +x - offset * 60000;
                    }
                    // apply the deprecated offsets
                    internal = internal - ta.timeZoneOffset * 60000;
                    return internal;
                };
                Scene._momentLocaleCounter = 0;
                return Scene;
            }(Internal.LinearChart.Scene));
            TimeChart.Scene = Scene;
        })(TimeChart = Internal.TimeChart || (Internal.TimeChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="Scene.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var TimeChart;
        (function (TimeChart) {
            var TimeSlicer = (function () {
                function TimeSlicer(scene, step, arrays, from, to, uniform, extraSteps) {
                    if (arrays === void 0) { arrays = []; }
                    if (from === void 0) { from = null; }
                    if (to === void 0) { to = null; }
                    if (uniform === void 0) { uniform = true; }
                    if (extraSteps === void 0) { extraSteps = 2; }
                    this.scene = null;
                    this.step = null;
                    /** if true, the slices are uniform, if false the slices start from 1 in each new period (eg 1.st day in month) */
                    this.uniform = false;
                    this.currentFrom = 0;
                    this.currentTo = 0;
                    /** moment instance for times[0] - internal use */
                    this.fromBar = null;
                    /** moment instance for times[times.length - 1] - internal use */
                    this.toBar = null;
                    this.fromIndex = 0;
                    this.toIndex = 0;
                    /** times and xes is buffer of visible range
                    [fromIdex .. toIndex] is the visible part of that buffer */
                    this.times = [];
                    this.xes = [];
                    this.oldMul = 0;
                    this.oldAdd = 0;
                    this.values = [];
                    this.counts = [];
                    /** list of arrays to update when slicing */
                    this.arrays = [];
                    /** list of non mine arrays to update when slicing */
                    this.extraArrays = [];
                    this.bufExpandSize = 100;
                    this.extraSteps = 2;
                    this.uniformTolerance = 0;
                    /** extra steps time */
                    this.approxExtraTime = 0;
                    this.extraSteps = extraSteps;
                    this.uniform = uniform;
                    this.step = step;
                    this.scene = scene;
                    from = from || this.scene.timeStart;
                    to = to || this.scene.timeEnd;
                    // duplicates "arrays"
                    this.extraArrays = arrays.slice(0);
                    this.arrays = arrays.slice(0);
                    this.arrays.push("xes");
                    this.arrays.push("times");
                    this.uniformTolerance = Math.min(1, this.step.count - 2);
                    this.approxExtraTime = this.extraSteps * step.approxTime();
                    this.init(from - this.approxExtraTime, to + this.approxExtraTime);
                }
                TimeSlicer.prototype.getArray = function (name) {
                    switch (name) {
                        case "xes":
                            return this.xes;
                        case "times":
                            return this.times;
                        case "values":
                            return this.values;
                        case "counts":
                            return this.counts;
                        default:
                            Internal.Base.Helpers.error("TimeSlicer: Invalid get array: '" + name + "'");
                            return null;
                    }
                };
                TimeSlicer.prototype.setArray = function (name, arr) {
                    switch (name) {
                        case "xes":
                            this.xes = arr;
                            return;
                        case "times":
                            this.times = arr;
                            return;
                        case "values":
                            this.values = arr;
                            return;
                        case "counts":
                            this.counts = arr;
                            return;
                        default:
                            Internal.Base.Helpers.error("TimeSlicer: Invalid set array: '" + name + "'");
                            return;
                    }
                };
                TimeSlicer.prototype._getOrigin = function (from) {
                    var tsc = this.scene.timeStepSettings;
                    if (this.step.count === 1 || this.uniform) {
                        return this.step.roundTimeDown(from, tsc);
                    }
                    // find a nice multiple from the stat of bigger unit
                    var t0 = this.step.getBigger().roundTimeDown(from, tsc);
                    var unitsToAdd = this.step.numberOfUnits(t0, from);
                    return this.step.add(t0, unitsToAdd);
                };
                TimeSlicer.prototype._add = function (m) {
                    // special case for days in month, everything else is uniform
                    if (this.uniform || this.step.count === 1 || this.step.unit !== "d") {
                        return m.add(this.step.count, this.step.unit);
                    }
                    else {
                        // special case for days
                        var dim = m.daysInMonth();
                        var date = m.date();
                        if (date + this.step.count * 2 > dim + 1 + this.uniformTolerance) {
                            // skip to 1st of next month
                            return m.add(dim - date + 1, "d");
                        }
                        else {
                            // usual stuff
                            return m.add(this.step.count, this.step.unit);
                        }
                    }
                };
                TimeSlicer.prototype._sub = function (m) {
                    if (this.uniform || this.step.count === 1 || this.step.unit !== "d") {
                        return m.subtract(this.step.count, this.step.unit);
                    }
                    else {
                        var date = m.date();
                        if (date <= this.step.count) {
                            // compute from beggining of month
                            m.subtract(1, "M");
                            var dim = m.daysInMonth() - 1;
                            var targetDay = dim + 1 - this.step.count + this.uniformTolerance;
                            return m.date(1 + targetDay - ((targetDay % this.step.count) | 0));
                        }
                        else {
                            // usual stuff
                            return m.subtract(this.step.count, this.step.unit);
                        }
                    }
                };
                TimeSlicer.prototype.init = function (from, to) {
                    var _this = this;
                    for (var aIndex = 0; aIndex < this.arrays.length; aIndex++) {
                        var a = this.arrays[aIndex];
                        this.setArray(a, []);
                    }
                    if (from >= to) {
                        this.fromIndex = 0;
                        this.toIndex = 0;
                        this.fromBar = null;
                        this.toBar = null;
                        return;
                    }
                    // setup fromBar
                    this.fromBar = TimeChart.moment(this._getOrigin(from)).utc();
                    this.fromIndex = 0;
                    var t = TimeChart.moment(this.fromBar).utc();
                    // generate slices
                    this.times.push(t.valueOf());
                    while ((t.valueOf() < to)) {
                        this._add(t);
                        this.times.push(t.valueOf());
                    }
                    this.toIndex = this.times.length;
                    this.toBar = t;
                    this.currentFrom = from;
                    this.currentTo = to;
                    this.xes = this.times.map(function (tx) { return _this.scene.timeToX(tx); });
                    for (var arrIndex = 0; arrIndex < this.extraArrays.length; arrIndex++) {
                        var arr = this.extraArrays[arrIndex];
                        var x = [];
                        x.length = this.times.length;
                        this.setArray(arr, x);
                    }
                };
                TimeSlicer.prototype.makeMiniSlice = function (time) {
                    /* makes a slice containing specified time
                    returns time and x for start and end of the slice */
                    var timeToXCoefsResult = this.scene.timeToXCoefs();
                    var tadd = timeToXCoefsResult.tadd;
                    var tmul = timeToXCoefsResult.tmul;
                    var m = TimeChart.moment(this._getOrigin(time)).utc();
                    var t0 = m.valueOf();
                    var x0 = tadd + t0 * tmul;
                    this._add(m);
                    var t1 = m.valueOf();
                    var x1 = tadd + t1 * tmul;
                    return {
                        t0: t0,
                        x0: x0,
                        t1: t1,
                        x1: x1
                    };
                };
                TimeSlicer.prototype.update = function (from, to) {
                    if (from === void 0) { from = this.scene.timeStart; }
                    if (to === void 0) { to = this.scene.timeEnd; }
                    if (to == null)
                        to = this.scene.timeEnd; // ported from CoffeeScript;
                    if (from == null)
                        from = this.scene.timeStart; // ported from CoffeeScript;
                    /* Returns [offset, newBefore, newAfter].
                    Data needs to be shifted by offset.
                    Values [fromIndex..newBefore) and [newAfter..toIndex) are
                    new and need updating.
        
                    patch extra steps */
                    from -= this.approxExtraTime;
                    to += this.approxExtraTime;
                    // no change
                    if (from === this.currentFrom && to === this.currentTo) {
                        this.updateXes(this.fromIndex, this.toIndex);
                        return {
                            offset: 0,
                            newBefore: this.fromIndex,
                            newAfter: this.toIndex
                        };
                    }
                    // full rebuild
                    if (this.fromBar === null || from > this.toBar.valueOf() || to < this.fromBar.valueOf()) {
                        this.init(from, to);
                        return {
                            offset: 0,
                            newBefore: this.toIndex,
                            newAfter: this.toIndex
                        };
                    }
                    // incremental update
                    var offset = 0;
                    var newBefore = this.fromIndex;
                    var newAfter = this.toIndex;
                    var timeToXCoefsResult = this.scene.timeToXCoefs();
                    var tadd = timeToXCoefsResult.tadd;
                    var tmul = timeToXCoefsResult.tmul;
                    // add new slices
                    var dfrom = this.fromBar.valueOf() - from;
                    if (dfrom > 0) {
                        var count = ((dfrom / this.step.approxTime()) | 0) + 2;
                        // add extra space before
                        if (this.fromIndex < count) {
                            var a = [];
                            a.length = count + this.bufExpandSize;
                            for (var arrIndex = 0; arrIndex < this.arrays.length; arrIndex++) {
                                var arr = this.arrays[arrIndex];
                                this.setArray(arr, a.concat(this.getArray(arr)));
                            }
                            offset += a.length;
                            newBefore += a.length;
                            newAfter += a.length;
                            this.fromIndex += a.length;
                            this.toIndex += a.length;
                        }
                        // add new values before
                        var t = this.fromBar.valueOf();
                        while (t > from) {
                            this._sub(this.fromBar);
                            this.fromIndex -= 1;
                            t = this.fromBar.valueOf();
                            this.times[this.fromIndex] = t;
                            this.xes[this.fromIndex] = tadd + t * tmul;
                        }
                    }
                    var dto = to - this.toBar.valueOf();
                    if (dto > 0) {
                        var count = ((dto / this.step.approxTime()) | 0) + 2;
                        // add extra space after
                        if (this.times.length < this.toIndex + count) {
                            var l = this.toIndex + count + this.bufExpandSize;
                            for (var arrIndex = 0; arrIndex < this.arrays.length; arrIndex++) {
                                var arr = this.arrays[arrIndex];
                                this.getArray(arr).length = l;
                            }
                        }
                        // add new values after
                        var t = this.toBar.valueOf();
                        while (t < to) {
                            this._add(this.toBar);
                            t = this.toBar.valueOf();
                            this.times[this.toIndex] = t;
                            this.xes[this.toIndex] = tadd + t * tmul;
                            this.toIndex += 1;
                        }
                    }
                    // shrink from/to
                    this._add(this.fromBar);
                    while (this.fromBar.valueOf() < from) {
                        this.fromIndex += 1;
                        this._add(this.fromBar);
                    }
                    this._sub(this.fromBar);
                    this._sub(this.toBar);
                    while (this.toBar.valueOf() >= to) {
                        this.toIndex -= 1;
                        this._sub(this.toBar);
                    }
                    this._add(this.toBar);
                    // trim slices outside of from/to
                    var ds = this.toIndex - this.fromIndex + this.bufExpandSize;
                    if (this.fromIndex > ds) {
                        var remove = this.fromIndex - this.bufExpandSize;
                        for (var arrIndex = 0; arrIndex < this.arrays.length; arrIndex++) {
                            var arr = this.arrays[arrIndex];
                            this.getArray(arr).splice(0, remove);
                        }
                        offset -= remove;
                        newBefore -= remove;
                        newAfter -= remove;
                        this.fromIndex -= remove;
                        this.toIndex -= remove;
                    }
                    if (this.toIndex < this.times.length - ds) {
                        for (var arrIndex = 0; arrIndex < this.arrays.length; arrIndex++) {
                            var arr = this.arrays[arrIndex];
                            this.getArray(arr).length = this.toIndex + this.bufExpandSize;
                        }
                    }
                    this.updateXes(newBefore, newAfter);
                    this.currentFrom = from;
                    this.currentTo = to;
                    return {
                        offset: offset,
                        newBefore: newBefore,
                        newAfter: newAfter
                    };
                };
                TimeSlicer.prototype.updateXes = function (newBefore, newAfter) {
                    var timeToXCoefsResult = this.scene.timeToXCoefs();
                    var tadd = timeToXCoefsResult.tadd;
                    var tmul = timeToXCoefsResult.tmul;
                    if (this.oldAdd !== tadd || this.oldMul !== tmul) {
                        this.oldAdd = tadd;
                        this.oldMul = tmul;
                        for (var i = newBefore; i <= newAfter - 1; i++) {
                            this.xes[i] = tadd + this.times[i] * tmul;
                        }
                    }
                };
                return TimeSlicer;
            }());
            TimeChart.TimeSlicer = TimeSlicer;
        })(TimeChart = Internal.TimeChart || (Internal.TimeChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Graphics.ts" />
/// <reference path="TimeStep.ts" />
/// <reference path="../base/core/ChartEvents.ts" />
/// <reference path="TimeSetup.ts" />
/// <reference path="TimeSlicer.ts" />
/// <reference path="../base/Label.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var TimeChart;
        (function (TimeChart) {
            var SettingsTimeAxis = (function () {
                function SettingsTimeAxis() {
                    /** Shows/hides time axis. */
                    this.enabled = true;
                    /** Whether to show vertical grid. */
                    this.vgrid = true;
                    /** Minimum width of a single time axis display unit, in px. If the width is smaller than this, the cgart will switch to bigger time units
                    (e.g. from minutes to hours).
            
                    Note that this value applies to the whole cluster and not a single series. That is, if you have two columns for each timestamp side by side, each of them
                    will only have half of this limit available in the worst case.
            
                    @see Documentation: [`maxUnitWidth`](#doc_maxUnitWidth)
                    @type float */
                    this.minUnitWidth = 1;
                    /** Maximum width of a single time axis display unit, in px. If the width is bigger than this, the chart will use a smaller time unit
                    (e.g. switch from minutes to seconds).
            
                    Note that this value applies to the whole cluster and not a single series. That is, if you have two columns for each timestamp side by side, both of them
                    have to fit within this limit.
            
                    @see Documentation: [`minUnitWidth`](#doc_minUnitWidth)
                    @type float */
                    this.maxUnitWidth = 200;
                    /** Whether to highlight weekends in day view. The highlight only appears if the display unit is hours, days or weeks.
            
                    @see Documentation: [`localization.holidayWeekdays`](https://zoomcharts.com/developers/en/time-chart/api-reference/settings/localization/holidayWeekdays.html)
                    @see Documentation: [`timeAxis.style.dateHolidays`](https://zoomcharts.com/developers/en/time-chart/api-reference/settings/timeAxis/style/dateHolidays.html) */
                    this.showHolidays = true;
                    /** Whether to show smallest bars on time axis. It matches with display unit dropdown entry used in time chart toolbar. */
                    this.miniTimeRuler = true;
                    /* tslint:disable:max-line-length */
                    /** Specifies when the chart switches the display unit during up/down scroll and other situations when the most appropriate display unit has to be selected.
                    @type enum
                    @value auto - same as 'max'.
                    @value min - uses smallest unit that has size >= minUnitWidth; when zooming in, the display unit is switched as soon as the next display can display the time range using the minimum unit width.
                    @value max - uses largest unit that has size <= maxUnitWidth; when zooming in, the display unit is switched when the current display unit exceeds the maximum unit width. */
                    /* tslint:enable:max-line-length */
                    this.unitSizePolicy = "auto";
                    /** Time axis time zone offset in minutes.
                    @deprecated
                    @version 1.12.0 - the property has been deprecated in favor of `timeZone`
                    @units minutes */
                    this.timeZoneOffset = null;
                    /** Time zone identifier, for example, `UTC` or `America/Los_Angeles`. See
                    [time zone support](time-chart/introductory-topics/time-zone-support.html) for details.
            
                    @see Documentation: [`data.timeZone`](time-chart/api-reference/settings/data.html#timeZone)
                    @version 1.12.0*/
                    this.timeZone = "UTC";
                    /** Time axis style */
                    this.style = {
                        /** Whether to display minor time labels as balloons instead of ruler style. */
                        showMinorTimeBalloons: false,
                        /** Whether to show balloons around major time labels. */
                        showMajorTimeBalloons: true,
                        /** Style for minor time labels balloons. */
                        minorTimeBalloonStyle: { fillColor: "#FFF" },
                        /** Style for major time labels balloons. */
                        majorTimeBalloonStyle: { fillColor: null },
                        /** Style for minor time labels. */
                        minorTimeLabel: { fillColor: "#000000", font: "12px Arial" },
                        /** Style for major time labels. */
                        majorTimeLabel: { fillColor: "#FFF", font: "11px Arial" },
                        /** Tint for lighter blocks of altering shades for time axis. Every second major unit will have this overlay painted on them. */
                        dateLighten: {
                            fillColor: "rgba(255,255,255,0.2)"
                        },
                        /** Style used to highlight weekends.
            
                        Note that this is drawn on top of the series so semi-transparent fill styles should be used.
            
                        @version 1.13.0 - added line and shadow styles, previously only `fillColor` was supported.
                        @see Documentation: [`timeAxis.showHolidays`](https://zoomcharts.com/developers/en/time-chart/api-reference/settings/timeAxis/showHolidays.html) */
                        dateHolidays: {
                            fillColor: "rgba(230,230,230,0.2)"
                        },
                        /** Minor time ruler style. */
                        minorTimeRuler: {
                            lineColor: "rgba(0,0,0,0.2)"
                        },
                        /** Chart vertical grid settings */
                        vgrid: {
                            lineColor: "rgba(0,0,0,0.1)"
                        }
                    };
                }
                return SettingsTimeAxis;
            }());
            TimeChart.SettingsTimeAxis = SettingsTimeAxis;
            var TimeAxis = (function (_super) {
                __extends(TimeAxis, _super);
                function TimeAxis(chart) {
                    var _this = this;
                    _super.call(this);
                    // is used to decide when to recompute label formats
                    this.curSceneScale = 0;
                    // is copied to scene for usage in other renders
                    this.minorFormat = null;
                    this.majorFormat = null;
                    this.minorTimeUnit = null;
                    this.majorTimeUnit = null;
                    this.minorLabelHeight = null;
                    this.majorLabelHeight = null;
                    this.minorLabelWidths = null;
                    this.minorLabelBallonWidths = null;
                    this.majorLabelWidths = null;
                    this.fullLabelWidths = null;
                    this.multiYearWidth = 0;
                    this.majorSlices = null;
                    this.minorSlices = null;
                    this.animationOrder = 610;
                    this.paintOrder = 30;
                    this.updateOrder = 1000;
                    this.multiples = {
                        ms: [1, 10, 100],
                        s: [1, 2, 5, 15, 30],
                        m: [1, 2, 5, 15, 30],
                        h: [1, 3, 6, 12, 24],
                        d: [1, 2, 5, 10],
                        w: [1, 5, 10, 20],
                        M: [1, 3, 6],
                        y: [1, 10, 100, 1000]
                    };
                    this.chart = chart;
                    this.scene = this.chart.scene;
                    this.tt = new TimeChart.TimeSetup(chart);
                    this.options = this.scene.settings.timeAxis;
                    this.panel = new Internal.Base.ChartPanel();
                    this.panel.side = "bottom";
                    // after legend
                    this.panel.packingOrder = 100;
                    this.panel.computeSize = function (aw, ah, g, lr) { return _this.computeSize(aw, ah, g, lr); };
                }
                TimeAxis.prototype.computeSize = function (availableWidth, availableHeight, g, labelRenderer) {
                    if (!this.options.enabled) {
                        this.scene.bottomAxisSize = 0;
                        return {
                            width: availableWidth,
                            height: 0
                        };
                    }
                    /* compute text sizes
                    8888.12.30 23.55.55 */
                    var widestTime = TimeChart.moment(218342562955000).utc();
                    var localization = this.scene.settings.localization.timeAxisDates;
                    // minor labels
                    var textStyle = this.options.style.minorTimeLabel;
                    this.minorLabelHeight = Internal.Base.Graphics.getTextHeight(g, this.options.style.minorTimeLabel.font) * 0.8;
                    this.minorLabelWidths = {};
                    this.minorLabelBallonWidths = {};
                    var unitIndex;
                    for (unitIndex = 0; unitIndex < TimeChart.TimeStep.knownUnits.length; unitIndex++) {
                        var unit = TimeChart.TimeStep.knownUnits[unitIndex];
                        var w = Internal.Base.Graphics.getTextWidth(g, textStyle, widestTime.format(localization.minorLabelTimeFormats[unit]));
                        this.minorLabelWidths[unit] = w;
                        this.minorLabelBallonWidths[unit] = w + this.minorLabelHeight;
                    }
                    // major labels
                    textStyle = this.options.style.majorTimeLabel;
                    this.majorLabelHeight = Internal.Base.Graphics.getTextHeight(g, this.options.style.majorTimeLabel.font) * 0.8;
                    this.majorLabelWidths = {};
                    this.fullLabelWidths = {};
                    for (unitIndex = 0; unitIndex < TimeChart.TimeStep.knownUnits.length; unitIndex++) {
                        var unit = TimeChart.TimeStep.knownUnits[unitIndex];
                        this.majorLabelWidths[unit] = this.majorLabelHeight
                            + Internal.Base.Graphics.getTextWidth(g, textStyle, widestTime.format(localization.majorLabelTimeFormats[unit]));
                        this.fullLabelWidths[unit] = this.majorLabelHeight
                            + Internal.Base.Graphics.getTextWidth(g, textStyle, widestTime.format(localization.majorLabelFullTimeFormats[unit]));
                    }
                    this.multiYearWidth = Internal.Base.Graphics.getTextWidth(g, textStyle, "8888 - 8888") + this.majorLabelHeight;
                    // constant to preserve 44px height on default settings.
                    var height = Math.round(Math.min((this.minorLabelHeight + this.majorLabelHeight) * 2.3913043, availableHeight));
                    this.scene.bottomAxisSize = height;
                    return {
                        width: availableWidth,
                        height: height
                    };
                };
                TimeAxis.prototype.onSceneChange = function (event) {
                    var sc = event.changes.settingsChanges;
                    if (sc && sc.timeAxis) {
                        event.changes.bounds = true;
                    }
                };
                TimeAxis.prototype.getPanels = function () {
                    return [this.panel];
                };
                /** Called whenever time scale cahanges */
                TimeAxis.prototype.getMajorLabelWidth = function (step, minorStep) {
                    if (step.unit === "y" && step.count > 1) {
                        return this.multiYearWidth;
                    }
                    else if (minorStep) {
                        return this.majorLabelWidths[step.unit];
                    }
                    else if (this.fullLabelWidths !== null) {
                        return this.fullLabelWidths[step.unit] || null;
                    }
                    else {
                        return null;
                    }
                };
                TimeAxis.prototype.computeLabels = function (displayUnit) {
                    /* find major labels
                    go up in units until a suitable is found */
                    var s = new TimeChart.TimeSetup(this.chart);
                    var chartDt = this.scene.timeEnd - this.scene.timeStart;
                    var nextUnit = s.toBiggerDisplayUnit(displayUnit);
                    var majorUnit;
                    var minorUnit;
                    if (nextUnit) {
                        var baseUnit = new TimeChart.TimeStep("s", 1);
                        majorUnit = (nextUnit.isSmaller(baseUnit)) ? baseUnit : nextUnit;
                        minorUnit = this.computeMinorUnit(majorUnit);
                        nextUnit = s.toBiggerDisplayUnit(majorUnit);
                        // find smallest major unit that fits
                        while (nextUnit
                            && (nextUnit.approxTime() <= chartDt * 0.5 || majorUnit.approxTime() < this.scene.dxToDtime(this.getMajorLabelWidth(majorUnit, minorUnit != null)))) {
                            majorUnit = nextUnit;
                            minorUnit = this.computeMinorUnit(majorUnit);
                            nextUnit = s.toBiggerDisplayUnit(nextUnit);
                        }
                    }
                    // major unit bigger than 1 year, find a multiple of years
                    if (!nextUnit) {
                        majorUnit = (displayUnit.unit === "y") ? displayUnit : (new TimeChart.TimeStep("y", 1));
                        for (var mIndex = 0; mIndex < this.multiples["y"].length; mIndex++) {
                            var m = this.multiples["y"][mIndex];
                            majorUnit = new TimeChart.TimeStep("y", m);
                            minorUnit = this.computeMinorUnit(majorUnit);
                            if (majorUnit.approxTime() > this.scene.dxToDtime(this.getMajorLabelWidth(majorUnit, minorUnit != null))) {
                                break;
                            }
                        }
                    }
                    return {
                        minorUnit: minorUnit,
                        majorUnit: majorUnit
                    };
                };
                TimeAxis.prototype.computeMinorUnit = function (majorUnit) {
                    var unit = this.scene.displayUnit.clone();
                    var unit2 = new TimeChart.TimeStep(TimeChart.TimeStep.toSmallerUnit[majorUnit.unit], 1);
                    if (unit2.unit && unit2.isBigger(unit)) {
                        unit = unit2;
                    }
                    var unitDt = unit.approxTime();
                    var minorUnit = null;
                    if (this.minorLabelWidths === null)
                        return null;
                    // add extra space
                    var unitSpacing = this.scene.dxToDtime(this.minorLabelWidths[unit.unit]) * 1.5;
                    for (var mIndex = 0; mIndex < this.multiples[unit.unit].length; mIndex++) {
                        var m = this.multiples[unit.unit][mIndex];
                        if (m < unit.count) {
                            m = unit.count;
                        }
                        unit.count = m;
                        unitDt = unit.approxTime();
                        if (unitSpacing <= unitDt) {
                            minorUnit = unit;
                            break;
                        }
                    }
                    if (minorUnit && minorUnit.isEqual(majorUnit)) {
                        minorUnit = null;
                    }
                    return minorUnit;
                };
                TimeAxis.prototype.doAnimations = function (event) {
                    // Always compute units also when not enabled - need to set scene.minorTimeUnit and scene.majorTimeUnit
                    if (!(this.scene.displayUnit && (this.scene.timeStart < this.scene.timeEnd))) {
                        return;
                    }
                    // recompute text formats on demand
                    var sceneScale = this.scene.getScale();
                    if (!(Math.abs(1 - this.curSceneScale / sceneScale) < 0.001)) {
                        this.curSceneScale = sceneScale;
                        var computeLabelsResult = this.computeLabels(this.scene.displayUnit);
                        var minorStep = computeLabelsResult.minorUnit;
                        var majorStep = computeLabelsResult.majorUnit;
                        if (minorStep) {
                            this.minorFormat = this.scene.settings.localization.timeAxisDates.minorLabelTimeFormats[minorStep.unit];
                            this.majorFormat = this.scene.settings.localization.timeAxisDates.majorLabelTimeFormats[majorStep.unit];
                        }
                        else {
                            this.minorFormat = null;
                            this.majorFormat = this.scene.settings.localization.timeAxisDates.majorLabelFullTimeFormats[majorStep.unit];
                        }
                        this.minorTimeUnit = minorStep;
                        this.majorTimeUnit = majorStep;
                        if (this.majorSlices === null || majorStep.approxTime() !== this.majorSlices.step.approxTime()) {
                            this.majorSlices = new TimeChart.TimeSlicer(this.scene, majorStep);
                        }
                        if (minorStep && (this.minorSlices === null || minorStep.approxTime() !== this.minorSlices.step.approxTime())) {
                            this.minorSlices = new TimeChart.TimeSlicer(this.scene, minorStep, [], null, null, false);
                        }
                        else if (minorStep === null) {
                            this.minorSlices = null;
                        }
                    }
                    this.majorSlices.update();
                    if (this.minorSlices) {
                        this.minorSlices.update();
                    }
                    // save time formats for use in other parts
                    if (this.minorTimeUnit) {
                        this.scene.minorTimeFormat = this.minorFormat;
                        this.scene.minorTimeUnit = this.minorTimeUnit;
                    }
                    else if (this.scene.displayUnit) {
                        this.scene.minorTimeUnit = this.scene.displayUnit;
                        this.scene.minorTimeFormat = this.scene.settings.localization.timeAxisDates.minorLabelTimeFormats[this.scene.displayUnit.unit];
                    }
                    this.scene.majorTimeFormat = this.majorFormat;
                    this.scene.majorTimeUnit = this.majorTimeUnit;
                };
                TimeAxis.prototype.paintScene = function (event) {
                    if (!(this.scene.displayUnit && this.options.enabled && (this.scene.timeStart < this.scene.timeEnd))) {
                        return;
                    }
                    var styleConfig = this.scene.settings.timeAxis.style;
                    var g = event.context;
                    var labelRenderer = event.labelRenderer;
                    var x0 = this.scene.x0;
                    var x1 = x0 + this.scene.width;
                    var y0 = this.panel.top + 1;
                    var y1 = this.panel.bottom;
                    var height = y1 - y0;
                    var y00 = this.scene.y0;
                    var height0 = this.scene.height;
                    var yMajor = y1 - this.majorLabelHeight * 1.8;
                    Internal.Base.Graphics.pushClip(event, x0, y00, this.scene.width, height + height0);
                    /* paint major labels
                    paint shades */
                    var xes = this.majorSlices.xes;
                    var times = this.majorSlices.times;
                    var fromIndex = this.majorSlices.fromIndex;
                    var toIndex = this.majorSlices.toIndex;
                    var alternateOverlay = styleConfig.dateLighten;
                    if (alternateOverlay && alternateOverlay.fillColor) {
                        var num = this.majorSlices.step.numberOfUnits(0, times[fromIndex]);
                        g.beginPath();
                        for (var i = fromIndex + (num | 0) % 2; i <= toIndex - 2; i += 2) {
                            var xa = (Math.max(xes[i], x0) | 0) + 1;
                            var xb = Math.min(xes[i + 1], x1) | 0;
                            g.rect(xa, y0 - 1, xb - xa, height);
                        }
                        Internal.Base.Graphics.fill(g, alternateOverlay);
                    }
                    // paint holiday shades
                    if (this.options.showHolidays && this.minorSlices
                        && (this.minorSlices.step.unit === "w" || this.minorSlices.step.unit === "d" || this.minorSlices.step.unit === "h")) {
                        // get transform directly from scene
                        var timeToXCoefsResult = this.scene.timeToXCoefs();
                        var tradd = timeToXCoefsResult.tadd;
                        var trmul = timeToXCoefsResult.tmul;
                        var dayInc = 60 * 60 * 24 * 1000;
                        var t = this.scene.timeStart;
                        t = Math.round(t - (t % dayInc));
                        var dayNo = TimeChart.moment(t).utc().isoWeekday();
                        var holidayWeekdays = this.scene.settings.localization.holidayWeekdays;
                        var fillStyle = styleConfig.dateHolidays;
                        var fillContext = Internal.Base.Graphics.beginStrokeAndFill(g, fillStyle);
                        var xa = t * trmul + tradd;
                        while (xa <= x1) {
                            var xb = xa + trmul * dayInc;
                            if (holidayWeekdays.indexOf(dayNo) > -1) {
                                fillContext.rect(xa, y00, xb - xa, Math.min(5, height) + height0);
                            }
                            dayNo = ((dayNo) % 7 + 1);
                            xa = xb;
                        }
                        Internal.Base.Graphics.endStrokeAndFill(g, fillContext, fillStyle);
                    }
                    // paint vgrid
                    if (this.options.vgrid) {
                        var gr = Internal.Base.Graphics.beginStrokeAndFill(g, this.options.style.vgrid);
                        for (var i = fromIndex + 1; i <= toIndex - 2; i++) {
                            // 0.5 to force 1 pixel line
                            var x = (xes[i] | 0) + 0.5;
                            if (x >= x1) {
                                break;
                            }
                            gr.moveTo(x, y00);
                            gr.lineTo(x, y1);
                        }
                        Internal.Base.Graphics.endStrokeAndFill(g, gr, this.options.style.vgrid);
                    }
                    var isMultiYear = this.majorSlices.step.unit === "y" && this.majorSlices.step.count > 1;
                    var textWidth = this.getMajorLabelWidth(this.majorSlices.step, this.minorFormat != null);
                    var momentLocale = this.scene.momentLocale;
                    if (!this.minorSlices || (this.majorSlices.step.unit !== this.minorSlices.step.unit)) {
                        // paint major labels - baloons
                        if (styleConfig.showMajorTimeBalloons) {
                            g.beginPath();
                            for (var i = fromIndex; i <= toIndex - 2; i++) {
                                var tx0 = xes[i];
                                var tx1 = xes[i + 1];
                                if (tx0 >= x1 || tx1 <= x0) {
                                    continue;
                                }
                                var textX = (tx0 + tx1) / 2;
                                if (tx0 < x0) {
                                    tx0 = x0;
                                    textX = Math.min((tx0 + tx1) / 2, tx1 - textWidth);
                                }
                                if (tx1 > x1) {
                                    tx1 = x1;
                                    textX = Math.max((tx0 + tx1) / 2, tx0 + textWidth);
                                }
                                Internal.Base.Graphics.strokeBalloon2(g, textX, yMajor + 1, textWidth, this.majorLabelHeight);
                            }
                            Internal.Base.Graphics.paint(g, styleConfig.majorTimeBalloonStyle);
                        }
                        // paint major labels - text
                        for (var i = fromIndex; i <= toIndex - 2; i++) {
                            var tx0 = xes[i];
                            var tx1 = xes[i + 1];
                            if (tx0 >= x1 || tx1 <= x0) {
                                continue;
                            }
                            var t = times[i];
                            var text = void 0;
                            if (isMultiYear) {
                                var t1 = times[i + 1] - 1;
                                text = TimeChart.moment.utc(t).locale(momentLocale).format(this.majorFormat) + " - " + TimeChart.moment(t1).locale(momentLocale).utc().format(this.majorFormat);
                            }
                            else {
                                text = TimeChart.moment.utc(t).locale(momentLocale).format(this.majorFormat);
                            }
                            var textX = (tx0 + tx1) / 2;
                            if (tx0 < x0) {
                                tx0 = x0;
                                textX = Math.min((tx0 + tx1) / 2, tx1 - textWidth);
                            }
                            if (tx1 > x1) {
                                tx1 = x1;
                                textX = Math.max((tx0 + tx1) / 2, tx0 + textWidth);
                            }
                            var value = new Internal.Base.Label({ text: text, textStyle: styleConfig.majorTimeLabel }, true);
                            labelRenderer.paint(g, textX, yMajor, 1, value);
                        }
                    }
                    // paint minor labels
                    var settings = this.scene.settings.timeAxis;
                    var minRuler = settings.style.minorTimeRuler;
                    if (this.minorSlices) {
                        times = this.minorSlices.times;
                        xes = this.minorSlices.xes;
                        fromIndex = this.minorSlices.fromIndex;
                        toIndex = this.minorSlices.toIndex;
                        textWidth = this.minorLabelWidths[this.minorSlices.step.unit];
                        var lytext = y0 + (this.minorLabelHeight * 0.4) | 0;
                        var ly0 = y0 - 1;
                        var ly1 = lytext + (this.minorLabelHeight * 1.6) | 0;
                        // bubbles for minor labels
                        if (styleConfig.showMinorTimeBalloons) {
                            g.beginPath();
                            for (var i = fromIndex; i <= toIndex - 1; i++) {
                                var x = xes[i];
                                Internal.Base.Graphics.strokeBalloon(g, x, y0 - 5, textWidth, this.minorLabelHeight);
                            }
                            Internal.Base.Graphics.paint(g, styleConfig.minorTimeBalloonStyle);
                        }
                        else {
                            /* text lines
                            do not paint on major lines */
                            var fiMajor = this.majorSlices.fromIndex;
                            var xMajor = this.majorSlices.xes;
                            g.beginPath();
                            var iMajor = fiMajor;
                            for (var i = fromIndex; i <= toIndex - 1; i++) {
                                var x = xes[i];
                                while (x > xMajor[iMajor]) {
                                    iMajor += 1;
                                }
                                if (xMajor[iMajor] === x) {
                                    continue;
                                }
                                if (x >= x1) {
                                    break;
                                }
                                x = (x | 0) - 0.5;
                                g.moveTo(x, ly0);
                                g.lineTo(x, ly1);
                            }
                            Internal.Base.Graphics.stroke(g, minRuler);
                        }
                        // text
                        var align = styleConfig.showMinorTimeBalloons ? "center" : "left";
                        var xinc = styleConfig.showMinorTimeBalloons ? 0 : 3;
                        for (var i = fromIndex; i <= toIndex - 1; i++) {
                            var x = xes[i];
                            var t = times[i];
                            var text = TimeChart.moment(t).locale(momentLocale).utc().format(this.minorFormat);
                            // aspectRatio:1e9 is to ensure backwards compatibility to before the label style refactor
                            // when the default aspectRatio was 3 and a slightly different result was returned from
                            // LabelRenderer.measureText().
                            var value = new Internal.Base.Label({ text: text, aspectRatio: 1e9, align: align, textStyle: styleConfig.minorTimeLabel });
                            labelRenderer.measure(g, value);
                            var lxtext = x + xinc + value.hwidth;
                            labelRenderer.paint(g, lxtext, lytext + value.hheight, 1, value);
                        }
                    }
                    var barSlices = this.chart.dataWarehouse.getDisplayUnitsSlicer();
                    if (settings.miniTimeRuler && minRuler && barSlices && barSlices.xes[barSlices.fromIndex + 1] - barSlices.xes[barSlices.fromIndex] > 4) {
                        // paint mini ticks
                        var ty0 = y0 - 1;
                        var ty1 = y0 + 3;
                        xes = barSlices.xes;
                        var maI0 = this.majorSlices.fromIndex;
                        var miI0 = this.minorSlices ? this.minorSlices.fromIndex : maI0;
                        var maX = this.majorSlices.xes;
                        var miX = this.minorSlices ? this.minorSlices.xes : maX;
                        g.beginPath();
                        var maI = maI0;
                        var miI = miI0;
                        var counter = 0;
                        for (var i = barSlices.fromIndex; i <= barSlices.toIndex - 2; i++) {
                            var x = xes[i];
                            while (x > maX[maI]) {
                                maI += 1;
                            }
                            if (maX[maI] === x) {
                                continue;
                            }
                            while (x > miX[miI]) {
                                miI += 1;
                            }
                            if (miX[miI] === x) {
                                continue;
                            }
                            if (x >= x1) {
                                break;
                            }
                            x = (x | 0) - 0.5;
                            g.moveTo(x, ty0);
                            g.lineTo(x, ty1);
                            counter++;
                        }
                        if (counter) {
                            Internal.Base.Graphics.stroke(g, minRuler);
                        }
                        if (this.scene.settings.advanced.themeCSSClass.indexOf("gradient") !== -1) {
                            var tone = Internal.Base.Colors.colorTone(minRuler.lineColor, 2, 2);
                            counter = 0;
                            g.beginPath();
                            maI = maI0;
                            miI = miI0;
                            for (var i = barSlices.fromIndex; i <= barSlices.toIndex - 2; i++) {
                                var x = xes[i];
                                while (x > maX[maI]) {
                                    maI += 1;
                                }
                                if (maX[maI] === x) {
                                    continue;
                                }
                                while (x > miX[miI]) {
                                    miI += 1;
                                }
                                if (miX[miI] === x) {
                                    continue;
                                }
                                if (x >= x1) {
                                    break;
                                }
                                x = (x | 0) + 0.5;
                                g.moveTo(x, ty0);
                                g.lineTo(x, ty1);
                                counter++;
                            }
                            if (counter) {
                                Internal.Base.Graphics.stroke(g, { lineColor: tone.color });
                            }
                        }
                    }
                    Internal.Base.Graphics.popClip(event);
                };
                return TimeAxis;
            }(Internal.Base.ChartElement));
            TimeChart.TimeAxis = TimeAxis;
        })(TimeChart = Internal.TimeChart || (Internal.TimeChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/core/ChartEvents.ts" />
/// <reference path="TimeStep.ts" />
/// <reference path="../base/Settings.ts" />
/// <reference path="Markers.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var TimeChart;
        (function (TimeChart) {
            var SettingsCurrentTime = (function (_super) {
                __extends(SettingsCurrentTime, _super);
                function SettingsCurrentTime() {
                    _super.apply(this, arguments);
                    this.showTime = true;
                    this.align = "left";
                    this.side = "bottom";
                    this.label = {
                        margin: 4,
                        padding: 3,
                        textStyle: {
                            font: "12px Arial",
                            fillColor: "red"
                        }
                    };
                    this.style = {
                        lineColor: "red"
                    };
                }
                return SettingsCurrentTime;
            }(TimeChart.SettingsMarker));
            TimeChart.SettingsCurrentTime = SettingsCurrentTime;
            var TimeUpdater = (function (_super) {
                __extends(TimeUpdater, _super);
                function TimeUpdater(chart) {
                    _super.call(this);
                    this.animationOrder = 100;
                    this.paintOrder = 35;
                    this.updateOrder = 900;
                    this.marker = null;
                    this.timeTimerUnit = null;
                    this.timeTimer = null;
                    this.timeTimerTarget = -Infinity;
                    this.timeTickerEnabled = false;
                    /** Specifies that every time the visible time is changed, the timer update has to be refreshed. */
                    this.timeTimerCheckAlways = false;
                    this._lastAnchor = null;
                    this.chart = chart;
                    this.settings = this.chart.settings;
                    this.scene = this.chart.scene;
                    this.events = this.chart.events;
                    this.createMarker();
                    this.updateTimers();
                }
                TimeUpdater.prototype.updateTimers = function () {
                    var _this = this;
                    var config = this.settings.advanced;
                    this.timeTickerEnabled = config.timeUpdateInterval && (this.settings.currentTime.enabled || this.scene.anchor === "now");
                    if (this.timeTickerEnabled) {
                        this.updateCurTime();
                    }
                    else if (this.timeTimer) {
                        clearTimeout(this.timeTimer);
                        this.timeTimer = null;
                    }
                    if (config.dataUpdateInterval) {
                        this.dataTimer = setInterval(function () { return _this.dataTick(); }, config.dataUpdateInterval);
                    }
                    else if (this.dataTimer) {
                        clearInterval(this.dataTimer);
                        this.dataTimer = null;
                    }
                };
                TimeUpdater.prototype.createMarker = function () {
                    var config = this.settings.currentTime;
                    var marker = this.marker;
                    var markerArr = this.scene.markers;
                    if (marker) {
                        markerArr.splice(markerArr.indexOf(marker), 1);
                        this.marker = null;
                    }
                    if (config.enabled) {
                        marker = this.marker = new TimeChart.Marker(this.scene, config, null);
                        marker.isMilestone = false;
                        markerArr.push(marker);
                    }
                };
                TimeUpdater.prototype.onSceneChange = function (event) {
                    var timersUpdated = false;
                    var sc = event.changes.settingsChanges;
                    if (sc) {
                        if (sc.advanced || sc.currentTime) {
                            this.updateTimers();
                            timersUpdated = true;
                        }
                        if (sc.currentTime)
                            this.createMarker();
                    }
                    if (this._lastAnchor !== this.scene.anchor) {
                        if (!timersUpdated) {
                            this.updateTimers();
                        }
                        this._lastAnchor = this.scene.anchor;
                    }
                    if (this.timeTickerEnabled && (event.changes.timeMarker ||
                        (event.changes.time && (this.timeTimerCheckAlways || !this.timeTimer || this.scene.getScale() < this.timeTimerUnit)))) {
                        this.updateCurTime();
                        this.updateVisiblePeriod();
                    }
                };
                TimeUpdater.prototype.timerTick = function () {
                    this.timeTimer = null;
                    if (this.chart.removed) {
                        return;
                    }
                    this.updateCurTime();
                    // advance visible period
                    this.updateVisiblePeriod();
                };
                TimeUpdater.prototype.dataTick = function () {
                    var _this = this;
                    this.dataTimer = null;
                    if (this.chart.removed) {
                        return;
                    }
                    if (this.scene.displayUnit) {
                        var curTime = this.scene.getCurTime();
                        var callback = function () {
                            _this.updateVisiblePeriod();
                        };
                        for (var id in this.chart.data) {
                            var data = this.chart.data[id];
                            data.updateData(this.scene.displayUnit, curTime, callback);
                        }
                    }
                };
                TimeUpdater.prototype.doAnimations = function (event) {
                    if (event.changes.data) {
                        this.updateVisiblePeriod();
                    }
                };
                TimeUpdater.prototype.updateCurTime = function (event) {
                    var _this = this;
                    var scene = this.scene;
                    this.timeTimerUnit = scene.getScale();
                    // update time marker
                    var markerTime = scene.getCurTime();
                    if (this.marker) {
                        this.marker.time = markerTime;
                    }
                    var x = scene.timeToX(markerTime);
                    // the scene is not yet fully initialized
                    if (isNaN(x))
                        return;
                    var isVisible = x + 200 > scene.x0 && x - 200 < scene.x0 + scene.width;
                    var interval = this.settings.advanced.timeUpdateInterval;
                    /** how large the gap must be for the previous timer to be cleared */
                    var allowedOverflow = 0;
                    if (!isVisible) {
                        // if the marker is not visible and to the right, this method will be called when the user moves the selection
                        if (x > 0)
                            return;
                        // if the marker is to the left, create a timer that will show it as it becomes visible.
                        interval = Math.max(interval, scene.dxToDtime(-x - 200) / 2);
                        // used in case when the user drags the marker back into view from being hidden on the left
                        this.timeTimerCheckAlways = true;
                    }
                    else {
                        this.timeTimerCheckAlways = false;
                        if (event === void 0) {
                            // the method is called from the timer - ask for the frame to be redrawn.
                            this.events.notifySceneChanges({ requestPaint: true });
                        }
                        // if the data unit for example, days, there is no need to call the update every second
                        // but even if the line does not move, if the displayunit is less than hour the label might show minutes and seconds and thus must be updated
                        // div2 is there because setInterval is not guaranteed to be precise
                        if (scene.displayUnit.approxTime() >= 3600000) {
                            allowedOverflow = (scene.xToTime((x + 1) | 0) - markerTime) / 2;
                            interval = Math.max(interval, allowedOverflow);
                            // to avoid calling clearTimeout/setTimeout when the scale is slowly increased (by dragging downwards).
                            allowedOverflow /= 4;
                        }
                    }
                    var curTime = +new Date();
                    if (this.timeTimer) {
                        var curInterval = this.timeTimerTarget - curTime;
                        // if the current setTimeout will invoke before the target time, let it and avoid calling extra `clearTimeout`/`setTimeout`.
                        if (curInterval < interval + allowedOverflow) {
                            return;
                        }
                        // the current setTimeout will be too late, create a new one.
                        window.clearTimeout(this.timeTimer);
                    }
                    // if the marker would move more than one pixel during the interval, do not set timeout, instead request animation frame for fluent animation
                    if (isVisible && scene.dTimeToDx(interval) > 1) {
                        this.events.notifySceneChanges({ timeMarker: true });
                    }
                    else {
                        this.timeTimerTarget = curTime + interval;
                        this.timeTimer = setTimeout(function () { return _this.timerTick(); }, interval);
                    }
                };
                TimeUpdater.prototype.updateVisiblePeriod = function () {
                    var scene = this.scene;
                    var unit = scene.displayUnit;
                    if (!unit || !this.settings.navigation.followAnchor) {
                        return;
                    }
                    var targetTimeEnd = null;
                    if (scene.anchor === "now") {
                        var curTime = scene.getCurTime();
                        targetTimeEnd = curTime;
                    }
                    else if (scene.anchor === "newestData") {
                        var latestDataTime = this.chart.getDataLimits().to;
                        targetTimeEnd = latestDataTime;
                    }
                    if (targetTimeEnd !== null) {
                        var scrolling = this.chart.scrolling;
                        var timeEnd = scrolling.getTo();
                        if (timeEnd < targetTimeEnd) {
                            var timeStart = scrolling.getFrom();
                            var dt = unit.roundTimeUp(targetTimeEnd, scene.timeStepSettings) - timeEnd;
                            this.chart.scrolling.setTimeRangeSnap(timeStart + dt, timeEnd + dt, timeEnd + dt, scene.displayUnit, true, "timer", true, false);
                        }
                    }
                };
                return TimeUpdater;
            }(Internal.Base.ChartElement));
            TimeChart.TimeUpdater = TimeUpdater;
        })(TimeChart = Internal.TimeChart || (Internal.TimeChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../linearchart/Settings.ts" />
/// <reference path="../base/Helpers.ts" />
/// <reference path="TimeStep.ts" />
/// <reference path="Bar/Toolbar.ts" />
/// <reference path="Data.ts" />
/// <reference path="Scrolling.ts" />
/// <reference path="Selection.ts" />
/// <reference path="TimeAxis.ts" />
/// <reference path="TimeUpdater.ts" />
/// <reference path="Markers.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var TimeChart;
        (function (TimeChart) {
            var Settings = (function (_super) {
                __extends(Settings, _super);
                function Settings(settings) {
                    // initialize common settings
                    _super.call(this, Internal.Base.SettingsMapping.TimeChartSettings);
                    //#endregion
                    //#region Calculated properties
                    this._minUnit = null;
                    /**min display period in MS*/
                    this._displayUnitsParsed = [];
                    this._displayPeriodsParsed = [];
                    this._computedDataMap = {};
                    //#endregion
                    /** Theme to apply. You can either use this to share configuration objects between multiple charts or use one of the predefined
                    themes.
                    @see Documentation: [Pre-defined themes](time-chart/api-reference/api.html#doc_themes)
                    */
                    this.theme = Settings.FlatTheme;
                    /** Settings to specify initial view once the page loaded.
            
                    Note that API methods such as [`setDisplayPeriod`][1] or [`displayUnit`][2] should be used to set these values
                    after the chart has been loaded.
                    [1]: time-chart/api-reference/api.html#setDisplayPeriod
                    [2]: time-chart/api-reference/api.html#displayUnit*/
                    this.navigation = {
                        /** Specifies anchor position for initial time period. Use it together with `initialDisplayPeriod` from which beginning is calculated.
            
                         Use [`setDisplayPeriod()`][1] to change the value after the chart has been loaded.
                         [1]: time-chart/api-reference/api.html#setDisplayPeriod
            
                         Valid values:
                         - `now` - set end of the period to current time
                         - `newestData` - set end of the period to newest data
                         - `oldestData` - set beginning of the period to oldest data
                         - time stamp - set period end time in UTC milliseconds */
                        initialDisplayAnchor: "newestData",
                        /** Time period to show initially. Use in combination with intitialDisplayAnchor.
            
                        Possible values:
                        - `max` - shows all data
                        - `timestamp > timestamp` - shows the time range specified by two UTC timestamps, in milliseconds.
                        - custom time period like `10 seconds`, `5 m`.
            
                         Use [`setDisplayPeriod()`][1] to change the value after the chart has been loaded.
                         [1]: time-chart/api-reference/api.html#setDisplayPeriod
                        */
                        initialDisplayPeriod: "max",
                        /** Data display unit to use for initial view.
            
                        Possible values:
                        - `auto` - determine automatically based on time range
                        - custom time unit like `1 m`, `3 weeks`.
            
                         Use [`displayUnit()`][1] to change the value after the chart has been loaded.
                         [1]: time-chart/api-reference/api.html#displayUnit
                        */
                        initialDisplayUnit: "auto",
                        /** Whether to allow the chart view to follow display anchor. Use it for real-time updates. */
                        followAnchor: false
                    };
                    this.area = new SettingsArea();
                    this.chartTypes = {
                        /** Series type to render values as vertical bars. */
                        columns: { type: "columns" },
                        /** Series type to connect value points by lines. */
                        line: { type: "line" },
                        /** Series type to show an opening and closing value on top of a total variance. */
                        candlestick: { type: "candlestick" }
                    };
                    /** Moving time line that represents the current time, mainly to analyze real-time data changes. To achieve it,
                     use server time of page load and adjust time zone offset. */
                    this.currentTime = new TimeChart.SettingsCurrentTime();
                    /** Time line markers that represents event on time.
                    @version 1.9.0 */
                    this.milestones = [];
                    /** X-axis line representing time at the bottom of chart.
            
                    Time line made of two different time graduations. Next image shows time line graduation by days and 3 hours.
                    ![time axis](time-chart/images/settings-timeAxis.png)
            
                    As you change the zoom level time axis graduation changes accordingly.*/
                    this.timeAxis = new TimeChart.SettingsTimeAxis();
                    this.data = [];
                    // provides extra control options for user to interact with data
                    this.toolbar = new TimeChart.SettingsToolbar();
                    this.localization = new SettingsLocalization();
                    this.interaction = new SettingsInteraction();
                    this.advanced = new SettingsAdvanced();
                    this.events = new SettingsEvents();
                    this.advanced.assets.push({ url: "assets://moment.js", required: function () { return !window.moment; } });
                    this.advanced.assets.push({ url: "assets://moment-tz.js", required: function () { return (!window.moment || !window.moment.tz); } });
                    this.apply(settings);
                    this._initializing = false;
                }
                /** Handles the deprecated timeZoneOffset parameter and detects if moment-tz.js should be loaded. */
                Settings.prototype.timeZoneCompatibility = function () {
                    var timeAxis = this.timeAxis;
                    if (timeAxis.timeZoneOffset === "local") {
                        timeAxis.timeZoneOffset = -new Date().getTimezoneOffset();
                    }
                    var data = this.data;
                    for (var i = 0; i < data.length; i++) {
                        var d = data[i];
                        if (d.timeZoneOffset != null) {
                            Internal.Base.Helpers.error("Setting `data.timeZoneOffset` has been deprecated. Please use `timeZone` in the data response instead.");
                            if (d.timeZoneOffset === "local") {
                                d.timeZoneOffset = -new Date().getTimezoneOffset();
                            }
                        }
                    }
                };
                Settings.prototype.apply = function (settings) {
                    this.applyCompatibility(settings, [
                        { from: "toolbars", to: "toolbar" },
                        { from: "toolbar.periodSelection", to: "toolbar.displayPeriod" },
                        { from: "toolbar.zoomOutButton", to: "toolbar.zoomOut" },
                        { from: "toolbar.backButton", to: "toolbar.back" },
                        { from: "interaction.scrolling.noData", to: "interaction.scrolling.limitMode" },
                        { from: "interaction.scrolling.noDataSnapBackProportion", to: "interaction.scrolling.overscrollProportion", transform: function (v) { return 1 - v; } },
                        { from: "area.initialDisplayPeriod", to: "navigation.initialDisplayPeriod" },
                        { from: "area.initialDisplayAnchor", to: "navigation.initialDisplayAnchor" },
                        { from: "area.initialDisplayUnit", to: "navigation.initialDisplayUnit" },
                        { from: "area.followAnchor", to: "navigation.followAnchor" },
                        { from: "timeAxis.timeZoneOffset", alternative: "timeAxis.timeZone" },
                        { from: "timeAxis.style.vgrid", to: "timeAxis.style.vgrid.lineColor", filter: function (v) { return (typeof v === "string"); } },
                        { from: "currentTime.overrideCurTime", to: "currentTime.time" },
                        { from: "advanced.maxUnitsToDisplay", alternative: "timeAxis.minUnitWidth" },
                    ]);
                    // merge data
                    var changes = _super.prototype.apply.call(this, settings, SettingsSeries);
                    this.timeZoneCompatibility();
                    // TODO: detect that these three operations are required based on `changes`. Also they could be merged together for better performance.
                    this._calcMinUnit();
                    this._displayUnitsParsed = this._parseUnits(this.area.displayUnits);
                    this._displayPeriodsParsed = this._parsePeriods(this.area.displayPeriods);
                    return changes;
                };
                Settings.prototype._parseUnits = function (unitList) {
                    var r = [];
                    for (var sIndex = 0; sIndex < unitList.length; sIndex++) {
                        var s = unitList[sIndex];
                        var t = TimeChart.TimeStep.parse(s.unit, s.name);
                        if (this._minUnit.isSmallerOrEqual(t)) {
                            r.push(t);
                        }
                    }
                    return r.sort(function (a, b) { return a.approxTime() - b.approxTime(); });
                };
                Settings.prototype._parsePeriods = function (unitList) {
                    var r = [];
                    for (var sIndex = 0; sIndex < unitList.length; sIndex++) {
                        var p = TimeChart.TimeStep.parse(unitList[sIndex].unit);
                        if (p && this._minUnit.isSmallerOrEqual(p)) {
                            r.push(p);
                        }
                    }
                    return r.sort(function (a, b) { return a.approxTime() - b.approxTime(); });
                };
                Settings.prototype._calcMinUnit = function () {
                    // compute max from display and data units
                    var minUnit = new TimeChart.TimeStep("y", 1e6);
                    for (var sIndex = 0; sIndex < this.area.displayUnits.length; sIndex++) {
                        var s = this.area.displayUnits[sIndex];
                        var ss = TimeChart.TimeStep.parse(s.unit, s.name);
                        if (ss.isSmaller(minUnit)) {
                            minUnit = ss;
                        }
                    }
                    var minUnit2 = new TimeChart.TimeStep("y", 1e6);
                    for (var sIndex = 0; sIndex < this._computedSeries.length; sIndex++) {
                        var cs = this._computedSeries[sIndex];
                        var data = this._computedDataMap[cs.data.source];
                        if (!data) {
                            throw new Error("Data source for series not found!");
                        }
                        for (var unitIndex = 0; unitIndex < data.units.length; unitIndex++) {
                            var unit = data.units[unitIndex];
                            var step = TimeChart.TimeStep.parse(unit);
                            if (step.isSmaller(minUnit2)) {
                                minUnit2 = step;
                            }
                        }
                    }
                    if (minUnit2.isBigger(minUnit)) {
                        minUnit = minUnit2;
                    }
                    this._minUnit = minUnit;
                };
                //#region Themes
                Settings.StaticChart = {
                    interaction: {
                        zooming: { enabled: false, click: false },
                        selection: { enabled: false },
                        scrolling: { enabled: false },
                        resizing: { enabled: false }
                    },
                    toolbar: {
                        items: ["export"]
                    }
                };
                Settings.DarkTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-flat DVSL-dark",
                        style: {
                            loadingArcStyle: {
                                lineColor: "#EEE"
                            },
                            messageTextStyle: {
                                fillColor: "#EEE"
                            }
                        }
                    },
                    area: {
                        style: {
                            fillColor: "rgba(28,26,28,1)",
                            noData: {
                                fillColor: "#DDD",
                                image: "builtin://linearchart-no-data-light"
                            },
                            selection: {
                                "lineColor": "#838283"
                            },
                            selectionLabel: {
                                "fillColor": "#BFBBB9"
                            },
                            zoomHighlight: {
                                "fillColor": "rgba(142,142,142,0.15)"
                            },
                            zoomHighlightInactive: {
                                "fillColor": "rgba(142,142,142,0.15)"
                            }
                        }
                    },
                    title: {
                        margin: 15,
                        style: {
                            fillColor: "#A8A7A8"
                        }
                    },
                    chartTypes: {
                        columns: {
                            style: {
                                gradient: 1,
                                depth: 0
                            }
                        }
                    },
                    valueAxisDefault: {
                        style: {
                            valueLabel: { textStyle: { fillColor: "#A8A7A8" } },
                            title: { textStyle: { fillColor: "#A8A7A8" } }
                        }
                    },
                    timeAxis: {
                        style: {
                            majorTimeLabel: { fillColor: "#A8A7A8", shadowColor: null },
                            minorTimeLabel: { fillColor: "#A8A7A8", shadowColor: null },
                            minorTimeRuler: { lineColor: "#838283" },
                            dateLighten: { fillColor: "rgba(142,142,142,0.15)" },
                            dateHolidays: { fillColor: "rgba(139,139,139,0.11)" }
                        }
                    },
                    info: {
                        style: { highlight: { fillColor: "rgba(142,142,142,0.15)" } }
                    },
                    currentTime: {
                        style: {
                            lineColor: "#D12E2B"
                        }
                    },
                    legend: {
                        text: {
                            fillColor: "#A8A7A8"
                        },
                        advanced: {
                            disabledSeries: {
                                textColor: "rgba(168,167,168,0.5)",
                                lineColor: "rgba(117,117,117,0.8)"
                            }
                        }
                    }
                };
                Settings.FlatTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-flat",
                    },
                    area: {
                        style: {
                            noData: {
                                fillColor: "#DDD",
                                image: "builtin://linearchart-no-data-light"
                            }
                        }
                    },
                    chartTypes: {
                        columns: {
                            style: { gradient: 1, depth: 0 }
                        }
                    },
                    timeAxis: {
                        style: {
                            showMajorTimeBalloons: false,
                            showMinorTimeBalloons: false,
                            majorTimeLabel: {
                                fillColor: "#000",
                                shadowColor: null
                            },
                            minorTimeLabel: {
                                fillColor: "#000",
                                shadowColor: null
                            },
                            dateLighten: {
                                fillColor: "rgba(0,0,0,0.05)"
                            }
                        }
                    }
                };
                Settings.RoundTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-round",
                    },
                    valueAxisDefault: {
                        style: {
                            valueLabel: {
                                textStyle: {
                                    fillColor: "#000000",
                                    font: "11px Arial",
                                    shadowOffsetX: 0,
                                    shadowOffsetY: 1,
                                    shadowBlur: 0,
                                    shadowColor: "rgba(255,255,255,0.5)"
                                }
                            }
                        }
                    },
                    timeAxis: {
                        style: {
                            showMinorTimeBalloons: false,
                            showMajorTimeBalloons: true,
                            minorTimeBalloonStyle: {
                                fillColor: "#FFF",
                                shadowOffsetX: 0,
                                shadowOffsetY: 2,
                                shadowBlur: 2,
                                shadowColor: "#888"
                            },
                            majorTimeBalloonStyle: {
                                fillColor: "#AAA",
                                shadowOffsetX: 0,
                                shadowOffsetY: -1,
                                shadowBlur: 0,
                                shadowColor: "rgba(0,0,0,0.3)"
                            },
                            minorTimeLabel: {
                                fillColor: "#000000",
                                font: "12px Arial",
                                shadowOffsetX: 0,
                                shadowOffsetY: 1,
                                shadowBlur: 0,
                                shadowColor: "rgba(255,255,255,0.5)"
                            },
                            majorTimeLabel: {
                                fillColor: "#FFF",
                                font: "11px Arial",
                                shadowOffsetX: 0,
                                shadowOffsetY: 1,
                                shadowBlur: 1,
                                shadowColor: "#7c7c7c"
                            },
                            minorTimeRuler: {
                                lineColor: "rgba(0,0,0,0.2)"
                            },
                            dateLighten: {
                                fillColor: "rgba(0,0,0,0.05)"
                            }
                        }
                    },
                    chartTypes: {
                        columns: {
                            style: { gradient: 0.8, depth: 3 }
                        }
                    },
                    area: {
                        style: {
                            noData: {
                                image: "builtin://linearchart-no-data-dark"
                            }
                        }
                    }
                };
                Settings.GradientTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-gradient",
                    },
                    valueAxisDefault: {
                        style: {
                            valueLabel: {
                                textStyle: {
                                    fillColor: "#000000",
                                    font: "11px Arial",
                                    shadowOffsetX: 0,
                                    shadowOffsetY: 1,
                                    shadowBlur: 0,
                                    shadowColor: "rgba(255,255,255,0.5)"
                                }
                            }
                        }
                    },
                    timeAxis: {
                        style: {
                            showMinorTimeBalloons: false,
                            showMajorTimeBalloons: true,
                            minorTimeBalloonStyle: {
                                fillColor: "#FFF",
                                shadowOffsetX: 0,
                                shadowOffsetY: 2,
                                shadowBlur: 2,
                                shadowColor: "#888"
                            },
                            majorTimeBalloonStyle: {
                                fillColor: "AAA",
                                shadowOffsetX: 0,
                                shadowOffsetY: -1,
                                shadowBlur: 0,
                                shadowColor: "rgba(0,0,0,0.3)"
                            },
                            minorTimeLabel: {
                                fillColor: "#000000",
                                font: "12px Arial",
                                shadowOffsetX: 0,
                                shadowOffsetY: 1,
                                shadowBlur: 0,
                                shadowColor: "rgba(255,255,255,0.5)"
                            },
                            majorTimeLabel: {
                                fillColor: "#FFF",
                                font: "11px Arial",
                                shadowOffsetX: 0,
                                shadowOffsetY: 1,
                                shadowBlur: 1,
                                shadowColor: "#7c7c7c"
                            },
                            minorTimeRuler: {
                                lineColor: "rgba(0,0,0,0.2)"
                            },
                            dateLighten: {
                                fillColor: "rgba(255,255,255,0.2)"
                            }
                        }
                    },
                    chartTypes: {
                        columns: {
                            style: {
                                gradient: 0.8,
                                depth: 3,
                            }
                        }
                    },
                    area: {
                        style: {
                            noData: {
                                image: "builtin://linearchart-no-data-dark"
                            }
                        }
                    }
                };
                return Settings;
            }(Internal.LinearChart.Settings));
            TimeChart.Settings = Settings;
            var SettingsSeries = (function (_super) {
                __extends(SettingsSeries, _super);
                function SettingsSeries() {
                    _super.apply(this, arguments);
                    this.data = new SettingsSeriesData();
                }
                /** Used dynamically by SettingsHelper to determine the correct mapping based on the type. */
                SettingsSeries.getMapping = function (target, source) {
                    if (target && source.type && target.type !== source.type)
                        throw new Error("It is not possible to change the value of `type` property for an existing layer.");
                    switch (target ? target.type : source.type) {
                        case "columns":
                        case void 0:
                            return Internal.Base.SettingsMapping.TimeChartSettingsSeriesColumns;
                        case "candlestick":
                            return Internal.Base.SettingsMapping.TimeChartSettingsSeriesCandleStick;
                        case "line":
                            return Internal.Base.SettingsMapping.TimeChartSettingsSeriesLines;
                        default:
                            throw new Error("The value '" + source.type + "' is not valid for the `type` property of a series. Valid values are: columns, candlestick, line.");
                    }
                };
                SettingsSeries.createInstance = function (source, type) {
                    switch (type || source.type) {
                        case "columns":
                        case void 0:
                            return new SettingsSeriesColumns();
                        case "candlestick":
                            return new SettingsSeriesCandleStick();
                        case "line":
                            return new SettingsSeriesLines();
                        default:
                            throw new Error(("The value '" + (type || source.type) + "' is not valid for the `type` property of a series.")
                                + " Valid values are: columns, candlestick, line.");
                    }
                };
                return SettingsSeries;
            }(Internal.LinearChart.SettingsSeries));
            TimeChart.SettingsSeries = SettingsSeries;
            var SettingsSeriesData = (function (_super) {
                __extends(SettingsSeriesData, _super);
                function SettingsSeriesData() {
                    _super.apply(this, arguments);
                    /** Index in value the array where the values that will be aggregated are located. An alternative is to use `valueFunction`.
                    @type integer */
                    this.index = 1;
                    /** Index in the value array where the count of aggregated values are located. This is optional but should be provided if the aggregation
                    method is `avg` (average) and URL or `dataFunction` is used to aggregate the values external to the chart because otherwise the chart will
                    aggregate values by simply counting them. So if `countIndex` is not provided and there are values:
                    `[[May 1 2014, 5], [May 2 2014, 15], [June 1 2014, 20]]` the aggregation to year 2014 will yield `(5+15+20)/3 = 13.3` when the display unit is
                    days but `((5+15)/2 + 20)/2 = 15` when the display unit is months. */
                    this.countIndex = null;
                }
                return SettingsSeriesData;
            }(Internal.LinearChart.SettingsSeriesData));
            TimeChart.SettingsSeriesData = SettingsSeriesData;
            var SettingsSeriesColumns = (function (_super) {
                __extends(SettingsSeriesColumns, _super);
                function SettingsSeriesColumns() {
                    _super.apply(this, arguments);
                    this.data = new SettingsSeriesData();
                }
                return SettingsSeriesColumns;
            }(Internal.LinearChart.SettingsSeriesColumns));
            TimeChart.SettingsSeriesColumns = SettingsSeriesColumns;
            var SettingsSeriesLines = (function (_super) {
                __extends(SettingsSeriesLines, _super);
                function SettingsSeriesLines() {
                    _super.apply(this, arguments);
                    this.data = new SettingsSeriesData();
                    this.style = new SettingsSeriesLinesStyle();
                }
                return SettingsSeriesLines;
            }(Internal.LinearChart.SettingsSeriesLines));
            TimeChart.SettingsSeriesLines = SettingsSeriesLines;
            var SettingsSeriesLinesStyle = (function (_super) {
                __extends(SettingsSeriesLinesStyle, _super);
                function SettingsSeriesLinesStyle() {
                    _super.apply(this, arguments);
                    this.markerStyleFunction = null;
                }
                return SettingsSeriesLinesStyle;
            }(Internal.LinearChart.SettingsSeriesLinesStyle));
            TimeChart.SettingsSeriesLinesStyle = SettingsSeriesLinesStyle;
            var SettingsSeriesCandleStickData = (function (_super) {
                __extends(SettingsSeriesCandleStickData, _super);
                function SettingsSeriesCandleStickData() {
                    _super.apply(this, arguments);
                    /** The index in the value arrays where the highest values in that particular time period is located. */
                    this.high = null;
                    /** The index in the value arrays where the opening values in that particular time period is located. */
                    this.open = null;
                    /** The index in the value arrays where the closing values in that particular time period is located. */
                    this.close = null;
                    /** The index in the value arrays where the lowest values in that particular time period is located. */
                    this.low = null;
                }
                return SettingsSeriesCandleStickData;
            }(SettingsSeriesData));
            TimeChart.SettingsSeriesCandleStickData = SettingsSeriesCandleStickData;
            var SettingsSeriesCandleStick = (function (_super) {
                __extends(SettingsSeriesCandleStick, _super);
                function SettingsSeriesCandleStick() {
                    _super.apply(this, arguments);
                    this.data = new SettingsSeriesCandleStickData();
                }
                return SettingsSeriesCandleStick;
            }(Internal.LinearChart.SettingsSeriesCandleStick));
            TimeChart.SettingsSeriesCandleStick = SettingsSeriesCandleStick;
            var SettingsEvents = (function (_super) {
                __extends(SettingsEvents, _super);
                function SettingsEvents() {
                    _super.call(this);
                    /** Specifies if the `onSelectionChange` event should be raised while the user drags the selection or only
                    once the pointer is released and the selection is finalized.
                    @version 1.13.2 */
                    this.selectionChangeDuringInteraction = false;
                    /** @deprecated same as onChartUpdate */
                    this.onTimeChange = null;
                    this.chartUpdateDelay = 400;
                }
                return SettingsEvents;
            }(Internal.LinearChart.SettingsEvents));
            TimeChart.SettingsEvents = SettingsEvents;
            var SettingsAdvanced = (function (_super) {
                __extends(SettingsAdvanced, _super);
                function SettingsAdvanced() {
                    _super.apply(this, arguments);
                    /** The minimum time interval in which current time marker is updated, in ms. Normally the value is calculated based on the time scale
                    so that the time only updates when the time marker would be moved and this value is only used as a baseline.
                     @type integer */
                    this.timeUpdateInterval = 900;
                    /** Determines how frequently (in ms) to poll for new data. If set to null data polling is disabled.
                    The data is automatically requested for the period since the last available timestamp until the current time.
                    Note that if there is no data available yet for the time period the chart requests, an empty data response should be
                    returned, for example `success({ from: 0, to: 1, unit: "ms", values: [] })`.
                     @type integer */
                    this.dataUpdateInterval = null;
                    /** Maximum data points to render in one view. Note that TimeChart will not allow to select such time unit that will result in more points being rendered.
                        @deprecated
                        @version 1.12.0 - property has been deprecated, use `timeAxis.minUnitWidth` instead
                    */
                    this.maxUnitsToDisplay = 20000;
                }
                return SettingsAdvanced;
            }(Internal.Base.SettingsAdvanced));
            TimeChart.SettingsAdvanced = SettingsAdvanced;
            var SettingsLocalization = (function (_super) {
                __extends(SettingsLocalization, _super);
                function SettingsLocalization() {
                    _super.apply(this, arguments);
                    /** Calendar specific localization settings. This section is used to initialize moment.js locale.
                     See moment.js documentation for detailed description: http://momentjs.com/docs/#/customization/.
            
                    @version 1.14.0 - Added `parentLocale` setting which allows using of default moment locales.
                    */
                    this.calendar = {
                        parentLocale: null
                    };
                    /** Weekdays that are considered holidays. Uses ISO numbering, with 1 being Monday and 7 being Sunday.
                     @baseType integer */
                    this.holidayWeekdays = [6, 7];
                    this.toolbar = new SettingsLocalizationToolbar();
                    /** Named time units. */
                    this.timeUnitsNames = {
                        ms: "millisecond",
                        s: "second",
                        m: "minute",
                        h: "hour",
                        d: "day",
                        w: "week",
                        M: "month",
                        y: "year"
                    };
                    /** Plural forms of time units. */
                    this.timeUnitsNamesPlural = {
                        ms: "milliseconds",
                        s: "seconds",
                        m: "minutes",
                        h: "hours",
                        d: "days",
                        w: "weeks",
                        M: "months",
                        y: "years"
                    };
                    /** Localizable strings for markers. */
                    this.markerDates = {
                        /** Time formatting strings for time marker date. */
                        timeFormats: {
                            ms: "HH:mm:ss",
                            s: "HH:mm:ss",
                            m: "HH:mm:ss",
                            h: "HH:mm",
                            d: "D, HH:mm",
                            w: "MMM D",
                            M: "MMM D",
                            y: "YYYY, MMM D"
                        }
                    };
                    /** Date and time formats used to display the selected time range in the header of the info popup.
            
                    @see moment.js - [Display / Format](http://momentjs.com/docs/#/displaying/format/) */
                    this.infoDates = {
                        /** The formats used for the major unit when displaying a time range where the major unit is the same,
                        for example, the selection contains multiple days from the same week.
            
                        If the display unit is days, the resulting header text is shown as
                        `minorTimeFormats.d(from) - minorTimeFormats.d(to) majorTimeFormats.d(from)`, e.g.
                        `Feb 24 - Feb 26 2016`. */
                        majorTimeFormats: {
                            y: null,
                            M: "YYYY",
                            w: "GGGG",
                            d: "YYYY",
                            h: "MMM D, YYYY",
                            m: "MMM D, YYYY",
                            s: "MMM D, YYYY",
                            ms: "MMM D, YYYY"
                        },
                        /** See the description of `majorTimeFormats`. */
                        minorTimeFormats: {
                            y: "YYYY",
                            M: "MMM",
                            w: "[Week] W",
                            d: "MMM D",
                            h: "HH:mm",
                            m: "HH:mm",
                            s: "HH:mm:ss",
                            ms: "ss.SSS"
                        },
                        /** The formats used when only a single time unit has been selected or when the selection spans
                        multiple major units (for example, selecting days from multiple months). */
                        fullTimeFormats: {
                            ms: "MMM D, YYYY HH:mm:ss",
                            s: "MMM D, YYYY HH:mm:ss",
                            m: "MMM D, YYYY, HH:mm",
                            h: "MMM D, YYYY HH:00",
                            d: "MMM D, YYYY",
                            w: "[Week] W, GGGG",
                            M: "MMM YYYY",
                            y: "YYYY"
                        }
                    };
                    /** Localizable strings displayed in time axis. */
                    this.timeAxisDates = {
                        /** Time formatting strings for minor time units in top line of time axis. */
                        minorLabelTimeFormats: {
                            ms: "ss.SSS",
                            s: "HH:mm:ss",
                            m: "HH:mm",
                            h: "HH:00",
                            d: "MMM D",
                            w: "MMM D",
                            M: "MMM",
                            y: "YYYY"
                        },
                        /** Time formatting strings for major time units in bottom line of time axis. */
                        majorLabelTimeFormats: {
                            ms: "MMM D, YYYY HH:mm:ss",
                            s: "MMM D, YYYY HH:mm:ss",
                            m: "MMM D, YYYY",
                            h: "MMM D, YYYY HH:00",
                            d: "MMM D, YYYY",
                            w: "[Week] W, GGGG",
                            M: "MMM YYYY",
                            y: "YYYY"
                        },
                        /** Time formatting strings for major time units in bottom line of time axis. */
                        majorLabelFullTimeFormats: {
                            ms: "MMM D, YYYY HH:mm:ss",
                            s: "MMM D, YYYY HH:mm:ss",
                            m: "MMM D, YYYY",
                            h: "MMM D, YYYY HH:00",
                            d: "MMM D, YYYY",
                            w: "[Week] W, GGGG",
                            M: "MMM YYYY",
                            y: "YYYY"
                        }
                    };
                    /** Message being displayed while loading initial data. */
                    this.determiningDataBounds = "Determining data bounds";
                    this.loadingLabel = "Loading...";
                }
                return SettingsLocalization;
            }(Internal.LinearChart.SettingsLocalization));
            TimeChart.SettingsLocalization = SettingsLocalization;
            var SettingsLocalizationToolbar = (function (_super) {
                __extends(SettingsLocalizationToolbar, _super);
                function SettingsLocalizationToolbar() {
                    _super.apply(this, arguments);
                    /** Text to show in display periods drop-down when current period does not match any of the presets. */
                    this.customPeriod = "Custom";
                    /** Display period dropdown title. */
                    this.periodDropdownTitle = "Select units in which to show the data";
                    /** Display unit dropdown title. */
                    this.unitDropdownTitle = "Select units in which to show the data";
                    /** Zoom out button text. */
                    this.zoomoutButton = "Zoom-out";
                    /** Zoom out button title. */
                    this.zoomoutTitle = "Zoom out";
                    /** Text to show if there are unavailable units in the unit dropdown. This can only happen for small units if the chart is zoomed out too much.
                    @version 1.13.0 */
                    this.unavailableUnitTitle = "zoom in for more";
                }
                return SettingsLocalizationToolbar;
            }(Internal.LinearChart.SettingsLocalizationToolbar));
            TimeChart.SettingsLocalizationToolbar = SettingsLocalizationToolbar;
            var SettingsInteraction = (function (_super) {
                __extends(SettingsInteraction, _super);
                function SettingsInteraction() {
                    _super.apply(this, arguments);
                    /** Snap mode determines how the chart locks on to data periods after dragging, scrolling and other actions.
                     @type enum
                     @value displayUnit - snap to full display unit (one column).
                     @value period - snap to full calendar period (one month, one day). Periods are defined in settings.area.displayPeriods.
                     @value multiPeriod - snap to one or several periods.
                     @value null - no snap, chart will remain at any position */
                    this.snapMode = "displayUnit";
                    /** Configurable settings to select specific time period by dragging on the time axis.
            
                    @see Documentation: [Selection style settings](time-chart/api-reference/settings/area/style/selection.html)*/
                    this.selection = new TimeChart.SettingsInteractionSelection();
                    /** Scrolling settings. */
                    this.scrolling = new TimeChart.SettingsInteractionScrolling();
                    this.zooming = new SettingsInteractionZooming();
                }
                return SettingsInteraction;
            }(Internal.LinearChart.SettingsInteraction));
            TimeChart.SettingsInteraction = SettingsInteraction;
            var SettingsInteractionZooming = (function (_super) {
                __extends(SettingsInteractionZooming, _super);
                function SettingsInteractionZooming() {
                    _super.apply(this, arguments);
                    /** If set to `false`, all zoom gestures will be disabled, irrespective of how the other properties are configured.
                    Note that the user will still be able to zoom by drill-down (clicking on values; to disable that, specify `click: false`)
                    and by using toolbar. */
                    this.enabled = true;
                    /** Whether to zoom-in when the chart area is clicked/tapped.
            
                    Note that to maintain backwards compatibility, if the zooming is completely disabled by setting `enabled: false`,
                    the click interaction will still be available and must be disabled separately.
                    @version 1.15.0 */
                    this.click = true;
                }
                return SettingsInteractionZooming;
            }(Internal.LinearChart.SettingsInteractionZooming));
            TimeChart.SettingsInteractionZooming = SettingsInteractionZooming;
            var SettingsArea = (function (_super) {
                __extends(SettingsArea, _super);
                function SettingsArea() {
                    _super.apply(this, arguments);
                    /** List of time units to use for data aggregation on the time axis.
            
                    For example: `{ area: { displayUnits: [ { unit: "5 m", "5 minutes" }, { unit: "15 m", name: "15 minutes" } ] } }` */
                    this.displayUnits = [
                        { unit: "1 ms", name: "millisecond" },
                        { unit: "1 s", name: "second" },
                        { unit: "5 s", name: "5 seconds" },
                        { unit: "1 m", name: "minute" },
                        { unit: "5 m", name: "5 minutes" },
                        { unit: "1 h", name: "hour" },
                        { unit: "6 h", name: "6 hours" },
                        { unit: "1 d", name: "day" },
                        { unit: "1 M", name: "month" },
                        { unit: "1 y", name: "year" }
                    ];
                    /** List of time periods that are used when formatting time axis.
            
                    Note that this does not impact what periods are available to choose from in the toolbar. For that
                    use [`toolbar.periods`](time-chart/api-reference/settings/toolbar/periods.html) setting. */
                    this.displayPeriods = [
                        { unit: "10 ms" },
                        { unit: "100 ms" },
                        { unit: "s" },
                        { unit: "m" },
                        { unit: "h" },
                        { unit: "d" },
                        { unit: "M" },
                        { unit: "y" },
                        { unit: "10 y" },
                        { unit: "100 y" }
                    ];
                    /** Area style settings. */
                    this.style = new SettingsAreaStyle();
                }
                return SettingsArea;
            }(Internal.LinearChart.SettingsArea));
            TimeChart.SettingsArea = SettingsArea;
            var SettingsAreaStyle = (function (_super) {
                __extends(SettingsAreaStyle, _super);
                function SettingsAreaStyle() {
                    _super.apply(this, arguments);
                    /** Default text style for all markers. */
                    this.markerText = { font: "12px Arial" };
                    /** Time period selection style. Note that the [`interaction.selection`](time-chart/api-reference/settings/interaction/selection.html) section specifies if the
                    selection can be created by the user or only through the API.*/
                    this.selection = new TimeChart.SettingsAreaStyleSelection();
                    /** Time period selection text style. */
                    this.selectionLabel = {
                        fillColor: "#000000",
                        font: "12px Arial"
                    };
                }
                return SettingsAreaStyle;
            }(Internal.LinearChart.SettingsAreaStyle));
            TimeChart.SettingsAreaStyle = SettingsAreaStyle;
        })(TimeChart = Internal.TimeChart || (Internal.TimeChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../linearchart/InfoPopup.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var TimeChart;
        (function (TimeChart) {
            var InfoPopup = (function (_super) {
                __extends(InfoPopup, _super);
                function InfoPopup(chart) {
                    _super.call(this, chart);
                    this.animationOrder = 700;
                    this.paintOrder = 25;
                    this.updateOrder = 1100;
                }
                InfoPopup.prototype.doAnimations = function (event) {
                    var scene = this.scene;
                    if (scene.selectionStart != null && this.chart.selection.isSelecting && scene.settings.info.enabled) {
                        // always show selection popup when selecting
                        var t0 = scene.selectionStart;
                        var t1 = scene.selectionEnd;
                        this.showInfoPopup(t0, t1, null, this.buildContent(t0, t1, null, null), event);
                    }
                };
                /** called when about to show popup
                Returns [t0, t1, ] or null if no info popup */
                InfoPopup.prototype.getPopupAreaMouseMoved = function (x, y) {
                    var scene = this.scene;
                    if (!(scene.displayUnit && scene.xyInChartOrBottom(x, y))) {
                        return null;
                    }
                    var t0 = scene.hoverFrom;
                    var t1 = scene.hoverTo;
                    return { t0: t0, t1: t1 };
                };
                InfoPopup.prototype.getContentsFunctionRange = function (t0, t1) {
                    var difs = TimeChart.TimeStep.timeUnitDiffs;
                    var scene = this.scene;
                    var hasTimePart = scene.displayUnit ? difs[scene.displayUnit.unit] < difs["d"] : true;
                    return [
                        scene.timestampFromInternal(t0, hasTimePart),
                        scene.timestampFromInternal(t1, hasTimePart)
                    ];
                };
                InfoPopup.prototype.buildHeader = function (t0, t1) {
                    var unit = this.scene.displayUnit;
                    if (!unit) {
                        return "";
                    }
                    var localization = this.scene.settings.localization;
                    var infoDates = localization.infoDates;
                    var count = Math.ceil(unit.numberOfUnits(t0, t1));
                    var totalCount = (count * unit.count) | 0;
                    var unitName = (totalCount % 10 === 1 && totalCount % 100 !== 11)
                        ? (localization.timeUnitsNames[unit.unit])
                        : (localization.timeUnitsNamesPlural[unit.unit]);
                    var momentLocale = this.scene.momentLocale;
                    var dateHtml;
                    if (count === 1) {
                        var t0m = TimeChart.moment(t0).locale(momentLocale).utc();
                        var date = t0m.format(infoDates.fullTimeFormats[unit.unit]);
                        dateHtml = "" + date;
                    }
                    else {
                        // make t1 one unit before for dates or ms
                        if (unit.unit === "d" || unit.unit === "M" || unit.unit === "y" || unit.unit === "ms") {
                            t1 -= 1;
                        }
                        var t0m = TimeChart.moment.utc(t0).locale(momentLocale);
                        var t1m = TimeChart.moment.utc(t1).locale(momentLocale);
                        var biggerUnit = unit.getBigger() || unit;
                        var tsc = this.scene.timeStepSettings;
                        if (unit.unit !== "y" && biggerUnit.roundTimeDown(t0, tsc) === biggerUnit.roundTimeDown(t1, tsc)) {
                            // same bigger unit, do a nice shortened time format
                            var top = t0m.format(infoDates.majorTimeFormats[unit.unit]);
                            var from = t0m.format(infoDates.minorTimeFormats[unit.unit]);
                            var to = t1m.format(infoDates.minorTimeFormats[unit.unit]);
                            dateHtml = (from + " - " + to + " " + top);
                        }
                        else {
                            // difference in bigger unit, bail for full time format
                            var from = t0m.format(infoDates.fullTimeFormats[unit.unit]);
                            var to = t1m.format(infoDates.fullTimeFormats[unit.unit]);
                            dateHtml = (from + " - " + to);
                        }
                    }
                    return "<em></em><strong>" + dateHtml + ("<small>(" + totalCount + " " + unitName + ")</small></strong>");
                };
                return InfoPopup;
            }(Internal.LinearChart.InfoPopup));
            TimeChart.InfoPopup = InfoPopup;
        })(TimeChart = Internal.TimeChart || (Internal.TimeChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/core/ChartEvents.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var TimeChart;
        (function (TimeChart) {
            var ClickNotifier = (function (_super) {
                __extends(ClickNotifier, _super);
                function ClickNotifier(chart) {
                    _super.call(this);
                    this.animationOrder = 600;
                    this.paintOrder = 20;
                    this.updateOrder = 1200;
                    this.chart = null;
                    this.scene = null;
                    this.pointer = null;
                    this.chart = chart;
                    this.scene = chart.scene;
                }
                ClickNotifier.prototype.previewPointerMove = function (event) {
                    this.pointer = null;
                    this.updateHover(event);
                };
                ClickNotifier.prototype.onPointerOut = function (event) {
                    var scene = this.scene;
                    scene.hoverFrom = null;
                    scene.hoverTo = null;
                    scene.hoverSeriesItem = null;
                    event.changes.hover = true;
                    this.chart.notifyHoverChanged(event, this.chart.createEventArguments(event, "user"));
                };
                ClickNotifier.prototype.previewPointerDown = function (event) {
                    this.pointer = event.identifier;
                    this.updateHover(event);
                };
                ClickNotifier.prototype.updateHover = function (event) {
                    // update hover data
                    var chart = this.chart;
                    var scene = chart.scene;
                    var clickRange = this.getClickRange(event.x, event.y);
                    var hoverFrom = null;
                    var hoverTo = null;
                    var hoverSeriesItem = null;
                    if (clickRange) {
                        hoverFrom = clickRange.t0;
                        hoverTo = clickRange.t1;
                        hoverSeriesItem = chart.renderer.hitTest(event.x, event.y);
                    }
                    if (chart.legend) {
                        if (hoverSeriesItem) {
                            chart.legend.notifyHoveredSeries(scene.settings._computedSeries[hoverSeriesItem.seriesIndex]);
                        }
                        else {
                            chart.legend.notifyHoveredSeries(null);
                            var series = chart.legend.getLastHoveredSeries();
                            if (series) {
                                hoverSeriesItem = {
                                    x0: null,
                                    y0: null,
                                    x1: null,
                                    y1: null,
                                    isMarker: false,
                                    seriesIndex: scene.settings._computedSeries.indexOf(series)
                                };
                            }
                        }
                    }
                    if (hoverFrom !== scene.hoverFrom
                        || hoverTo !== scene.hoverTo
                        || !hoverSeriesItem !== !scene.hoverSeriesItem
                        || (hoverSeriesItem && (hoverSeriesItem.seriesIndex !== scene.hoverSeriesItem.seriesIndex || hoverSeriesItem.x0 !== scene.hoverSeriesItem.x0))) {
                        scene.hoverFrom = hoverFrom;
                        scene.hoverTo = hoverTo;
                        scene.hoverSeriesItem = hoverSeriesItem;
                        event.changes.hover = true;
                        chart.notifyHoverChanged(event, chart.createEventArguments(event, "user"));
                    }
                };
                ClickNotifier.prototype.onClick = function (event) {
                    if (event.identifier === this.pointer) {
                        this.chart.notifyClick(event, this.chart.createEventArguments(event, "user"));
                    }
                };
                ClickNotifier.prototype.defaultClick = function (event, args) {
                    // called by Impl during the `notifyClick` that is called in the `onClick` in this file.
                    var scene = this.scene;
                    if (!scene.settings.interaction.zooming.click)
                        return;
                    var t = scene.xToTime(event.x);
                    if (scene.selectionStart !== null && (scene.selectionStart > t || scene.selectionEnd < t)) {
                        this.clearSelection(event, "user");
                    }
                    else if (scene.hoverFrom !== null && !this.chart.selection.isHoveringEdge) {
                        var oldUnit = this.scene.displayUnit;
                        var scrolling = this.chart.scrolling;
                        scrolling.setTimeRangeSnap(scene.hoverFrom, scene.hoverTo, null, null, true, "user", false, true);
                        var newUnit = scrolling.targetUnit || this.scene.displayUnit;
                        if (newUnit === oldUnit) {
                            // special case usually if the hover range covered the whole chart - in this case the old display
                            // unit was probably determined to be the best one and thus the view did not change.
                            newUnit = scrolling.timeSetup.getSmallerDisplayUnit(newUnit);
                            if (newUnit) {
                                scrolling.setTimeRangeSnap(scene.hoverFrom, scene.hoverTo, null, newUnit, true, "user", false, true);
                            }
                        }
                        // when the selection is drilled down into, it must be cleared.
                        if (scene.selectionStart !== null)
                            this.clearSelection(event, "user");
                        event.consumed = true;
                    }
                };
                ClickNotifier.prototype.onRightClick = function (event) {
                    if (this.scene.selectionStart !== null) {
                        this.clearSelection(event, "user");
                    }
                    if (this.scene.hoverFrom !== null) {
                        this.chart.notifyRightClick(event, this.chart.createEventArguments(event, "user"));
                        if (event.defaultPrevented) {
                            event.consumed = true;
                        }
                    }
                };
                ClickNotifier.prototype.onDoubleClick = function (event) {
                    if (this.scene.hoverFrom !== null) {
                        this.chart.notifyDoubleClick(event, this.chart.createEventArguments(event, "user"));
                        event.consumed = true;
                    }
                };
                ClickNotifier.prototype.clearSelection = function (event, origin) {
                    this.scene.selectionStart = null;
                    this.scene.selectionEnd = null;
                    this.chart.notifySelectionChanged(this.chart.createEventArguments(event, origin));
                    event.changes.selection = true;
                    event.consumed = true;
                };
                ClickNotifier.prototype.onTripleClick = function (event) {
                    if (this.scene.hoverFrom !== void 0 && this.scene.hoverFrom !== null) {
                        this.chart.notifyTripleClick(event, this.chart.createEventArguments(event, "user"));
                        event.consumed = true;
                    }
                };
                /** Retrieves time range corresponding to click */
                ClickNotifier.prototype.getClickRange = function (x, y) {
                    var scene = this.scene;
                    if (!scene.xyInChartOrBottom(x, y)) {
                        return null;
                    }
                    var time = this.scene.xToTime(x);
                    var t0;
                    var t1;
                    var numBars;
                    if (scene.selectionStart !== null && time >= scene.selectionStart && time < scene.selectionEnd) {
                        t0 = scene.selectionStart;
                        t1 = scene.selectionEnd;
                        // at least 2 bars - selection is not a single bar
                        numBars = Math.max(2, scene.displayUnit.numberOfUnits(t0, t1));
                    }
                    else if (scene.displayUnit) {
                        var use1Bar = true;
                        var tsSettings = scene.timeStepSettings;
                        if (scene.majorTimeUnit) {
                            var mt0 = scene.majorTimeUnit.roundTimeDown(time, tsSettings);
                            var mt1 = scene.majorTimeUnit.roundTimeUp(time + 1, tsSettings);
                            if (y > scene.y0 + scene.height && (mt0 > scene.timeStart || mt1 < scene.timeEnd)) {
                                t0 = mt0;
                                t1 = mt1;
                                // if the display unit is weeks, then selecting a single month may not be correct since a week can overlap the end of a month
                                // the same is true if the display unit is, for example, 5 days
                                t0 = scene.displayUnit.roundTimeDown(t0, tsSettings);
                                t1 = scene.displayUnit.roundTimeUp(t1, tsSettings);
                                numBars = scene.displayUnit.numberOfUnits(t0, t1);
                                use1Bar = false;
                            }
                        }
                        if (use1Bar) {
                            t0 = scene.displayUnit.roundTimeDown(time, tsSettings);
                            t1 = scene.displayUnit.roundTimeUp(time + 1, tsSettings);
                            numBars = 1;
                        }
                    }
                    else {
                        t0 = null;
                        t1 = null;
                        numBars = null;
                    }
                    return {
                        t0: t0,
                        t1: t1,
                        numBars: numBars
                    };
                };
                return ClickNotifier;
            }(Internal.Base.ChartElement));
            TimeChart.ClickNotifier = ClickNotifier;
        })(TimeChart = Internal.TimeChart || (Internal.TimeChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Helpers.ts" />
/// <reference path="TimeSlicer.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var TimeChart;
        (function (TimeChart) {
            var DataWarehouse = (function () {
                function DataWarehouse(chart) {
                    this.requests = {};
                    this.results = {};
                    this.dataSlicesCache = {};
                    this.nextRequestId = 0;
                    this.hasNewRequests = false;
                    // TODO: refactor to use a single slicer for all requests
                    this.lastSlicer = null;
                    this.chart = chart;
                    this.scene = this.chart.scene;
                }
                DataWarehouse.prototype.registerDataProcessingRequest = function (params) {
                    this.requests[this.nextRequestId] = params;
                    var chart = this.chart;
                    this.results[this.nextRequestId] = {
                        leadIn: null,
                        leadOut: null,
                        times: [],
                        xes: [],
                        values: [],
                        counts: [],
                        fromIndex: 0,
                        toIndex: 0,
                        data: [],
                        from: 0,
                        to: 0,
                        slicer: null,
                        dataExistsFrom: null,
                        dataExistsTo: null,
                        externalItems: function (from, to) {
                            var me = this;
                            var difs = TimeChart.TimeStep.timeUnitDiffs;
                            var hasTimePart = chart.displayUnit ? difs[chart.displayUnit.unit] < difs["d"] : true;
                            var res = new Array(to - from);
                            for (var i = from; i < to; i++) {
                                res[i - from] = chart.scene.timestampFromInternal(me.times[i], hasTimePart);
                            }
                            return res;
                        }
                    };
                    this.hasNewRequests = true;
                    return this.nextRequestId++;
                };
                DataWarehouse.prototype.removeDataProcessingRequest = function (id) {
                    delete this.requests[id];
                    delete this.results[id];
                };
                DataWarehouse.prototype.getDisplayUnitsSlicer = function () {
                    return this.lastSlicer;
                };
                DataWarehouse.prototype.getData = function (requestId) {
                    return this.results[requestId];
                };
                DataWarehouse.prototype.clear = function () {
                    this.requests = {};
                    this.results = {};
                };
                /** 1 called from renderer before paint */
                DataWarehouse.prototype.process = function (event) {
                    var changes = event.changes;
                    // prepare data sources
                    if (!(changes.time || changes.data || changes.displayUnit || changes.bounds || changes.settings || this.hasNewRequests)) {
                        return;
                    }
                    if (this.scene.timeStart >= this.scene.timeEnd) {
                        for (var i in this.requests) {
                            var result = this.results[i];
                            result.dataExistsFrom = null;
                            result.dataExistsTo = null;
                        }
                        return;
                    }
                    this.hasNewRequests = false;
                    this.loading = false;
                    this.hasSomeData = false;
                    var forceDataUpdate = !!changes.data || changes.time;
                    for (var i in this.requests) {
                        var request = this.requests[i];
                        var result = this.results[i];
                        var dataUpdate = this.updateData(forceDataUpdate, request, result);
                        this.updateSlices(dataUpdate, i, request, result);
                    }
                    this.scene.loading = this.loading;
                    if (this.loading) {
                        this.scene.setMessage("noData", this.scene.settings.localization.loadingLabel, 10);
                    }
                    else if (!this.hasSomeData) {
                        this.scene.setMessage("noData", this.scene.settings.localization.noDataLabel, 999);
                    }
                    else {
                        this.scene.setMessage("noData", null);
                    }
                };
                DataWarehouse.prototype.exportData = function (from, to, displayUnit, seriesArray) {
                    var slicer = new TimeChart.TimeSlicer(this.scene, displayUnit, [], from, to, true, 0);
                    var times = slicer.times;
                    var series = [];
                    for (var serIndex = 0; serIndex < seriesArray.length; serIndex++) {
                        var ser = seriesArray[serIndex];
                        var request = ser.data;
                        var source = this.chart.getData(request.source);
                        var data = source.getDataForRange(from, to, displayUnit, null);
                        var aggrValues = new Array(times.length - 1);
                        this.fillValues(data.values, slicer.times, aggrValues, slicer.counts, slicer.fromIndex, slicer.toIndex, request, displayUnit);
                        series.push(aggrValues);
                    }
                    return {
                        timestamps: slicer.times.slice(slicer.fromIndex, slicer.toIndex - 1),
                        values: series
                    };
                };
                DataWarehouse.prototype.updateData = function (dataUpdate, request, result) {
                    var _this = this;
                    // checks if new data is needed and fetches it
                    var sourceId = request.source;
                    var dataSource = this.chart.getData(sourceId);
                    var displayUnit = this.getUnitToUse(request);
                    var dt = (this.scene.timeEnd - this.scene.timeStart) * dataSource.dataSettings.prefetchRatio;
                    if (dataUpdate
                        || (!result.from && this.scene.timeStart)
                        || (!result.to && this.scene.timeEnd)
                        || result.from >= result.to
                        || this.scene.timeStart - dt < result.from
                        || this.scene.timeEnd + dt > result.to
                        || (result.dataExistsFrom !== null && result.dataExistsFrom > this.scene.timeEnd)
                        || (result.dataExistsTo !== null && result.dataExistsTo < this.scene.timeStart)) {
                        dataUpdate = true;
                        // prepare the data
                        var from = this.scene.timeStart - dt * 2;
                        var to = this.scene.timeEnd + dt * 2;
                        var data = dataSource.getDataForRange(from, to, displayUnit, function () { return _this._newDataArrived(sourceId); });
                        if (!dataSource.noData) {
                            this.hasSomeData = true;
                        }
                        if (data.from > this.scene.timeEnd || data.to < this.scene.timeStart) {
                            // data not available
                            result.data = [];
                            result.from = 0;
                            result.to = 0;
                            result.dataExistsFrom = null;
                            result.dataExistsTo = null;
                            this.loading = this.loading || data.loading;
                        }
                        else {
                            this.loading = this.loading || (data.loading && (data.from > this.scene.timeStart || data.to < this.scene.timeEnd));
                            result.data = data.values;
                            result.from = from;
                            result.to = to;
                            result.dataExistsFrom = data.from;
                            result.dataExistsTo = data.to;
                        }
                    }
                    return dataUpdate;
                };
                DataWarehouse.prototype.updateSlices = function (dataUpdate, id, request, result) {
                    // compute time slices
                    var displayUnit = this.getUnitToUse(request);
                    var dataIndex = request.index;
                    var dataFunction = request.valueFunction;
                    var data = result.data;
                    var slice = result.slicer = this.getSlice(id, request, displayUnit);
                    var updateResult = slice.update(this.scene.timeStart, this.scene.timeEnd);
                    var sliceNewBefore = updateResult.newBefore;
                    var sliceNewAfter = updateResult.newAfter;
                    var times = result.times = slice.times;
                    var counts = result.counts = slice.counts;
                    result.xes = slice.xes;
                    var values = result.values = slice.values;
                    data = result.data;
                    result.fromIndex = slice.fromIndex;
                    result.toIndex = slice.toIndex;
                    // compute aggregated values
                    if (!data) {
                        values = result.values = new Array(times.length);
                        for (var i = 0; i < values.length; i++) {
                            values[i] = null;
                        }
                        result.leadIn = null;
                        result.leadOut = null;
                    }
                    else {
                        if (data.length > 0 && !dataFunction && dataIndex >= data[0].length) {
                            this.chart.error(("No data for this DataIndex: " + dataIndex + ", only " + (data[0].length - 1) + " values present"));
                        }
                        else {
                            if (dataUpdate) {
                                this.fillValues(data, times, values, counts, slice.fromIndex, slice.toIndex, request, displayUnit);
                            }
                            else {
                                this.fillValues(data, times, values, counts, slice.fromIndex, sliceNewBefore + 1, request, displayUnit);
                                this.fillValues(data, times, values, counts, sliceNewAfter - 1, slice.toIndex, request, displayUnit);
                            }
                            this.setLeads(request, result, displayUnit);
                        }
                    }
                };
                DataWarehouse.prototype.getSlice = function (id, request, displayUnit) {
                    // TODO: use single slicer for each unit
                    var cacheIndex = id + "-" + displayUnit.toString();
                    var s;
                    if (this.dataSlicesCache.hasOwnProperty(cacheIndex)) {
                        s = this.dataSlicesCache[cacheIndex];
                    }
                    else {
                        s = this.dataSlicesCache[cacheIndex] = new TimeChart.TimeSlicer(this.scene, displayUnit, ["values", "counts"]);
                    }
                    this.lastSlicer = s;
                    return s;
                };
                DataWarehouse.prototype.getUnitToUse = function (request) {
                    /* TODO
                    if requested displayUnit is smaller than dwpr.minUnit, return
                    dwpr.minUnit
                    question, how to compare displayUnit with dwpr.minUnit. */
                    return this.scene.displayUnit;
                };
                DataWarehouse.prototype.setLeads = function (request, result, displayUnit) {
                    /* special processing for "join" no data policy
                    if first/last value in slice is null, replace it with first non-null value
                    just search in existing data, do not try to load new data
                    TODO: leads need other values too when stacked. This will need major refactor. */
                    var np = request.noDataPolicy;
                    var dataIndex = request.index;
                    var dataFunction = request.valueFunction;
                    var data = result.data;
                    var values = result.values;
                    var times = result.times;
                    var leadIn = null;
                    var leadOut = null;
                    if (np === "join" && data) {
                        // process leadIn
                        var fromIndex = result.fromIndex;
                        if (values[fromIndex] === null) {
                            var dataPos = TimeChart.Data.binSearch(data, times[fromIndex]);
                            // TODO: data might still be null after post aggregation function
                            dataPos = TimeChart.Data.linSearchDown(data, dataPos, dataIndex, dataFunction);
                            if (dataPos !== -1) {
                                var time = data[dataPos][0];
                                var makeMiniSliceResult = result.slicer.makeMiniSlice(time);
                                var t = [makeMiniSliceResult.t0, makeMiniSliceResult.t1];
                                var x = [makeMiniSliceResult.x0, makeMiniSliceResult.x1];
                                var v = [null, null];
                                var c = [null, null];
                                this.fillValues(data, t, v, c, 0, 2, request, displayUnit);
                                leadIn = {
                                    times: t,
                                    xes: x,
                                    values: v,
                                    counts: c,
                                    fromIndex: 0,
                                    toIndex: 2
                                };
                            }
                        }
                        // process leadOut
                        var toIndex = result.toIndex;
                        if (values[toIndex - 2] === null) {
                            var dataPos = TimeChart.Data.binSearch(data, times[toIndex - 1]);
                            // TODO: data might still be null after post aggregation function
                            dataPos = TimeChart.Data.linSearchUp(data, dataPos, dataIndex, dataFunction);
                            if (dataPos !== -1) {
                                var time = data[dataPos][0];
                                var makeMiniSliceResult = result.slicer.makeMiniSlice(time);
                                var t = [makeMiniSliceResult.t0, makeMiniSliceResult.t1];
                                var x = [makeMiniSliceResult.x0, makeMiniSliceResult.x1];
                                var v = [null, null];
                                var c = [null, null];
                                this.fillValues(data, t, v, c, 0, 2, request, displayUnit);
                                leadOut = {
                                    times: t,
                                    xes: x,
                                    values: v,
                                    counts: c,
                                    fromIndex: 0,
                                    toIndex: 2
                                };
                            }
                        }
                    }
                    result.leadIn = leadIn;
                    result.leadOut = leadOut;
                };
                DataWarehouse.prototype.fillValues = function (data, times, values, counts, timesI0, timesI1, request, displayUnit) {
                    var agr = request.aggregation;
                    var dataIndex = request.index | 0;
                    var countIndex = request.countIndex | 0;
                    var dataFunction = request.valueFunction;
                    var postAggregationFunction = request.aggregatedValueFunction;
                    // need at least 2 values
                    if (timesI0 + 1 >= timesI1) {
                        return;
                    }
                    // Closures is approx 2x slower, use static code
                    if (agr === "sum") {
                        this.fillValueSum(data, times, values, counts, timesI0, timesI1, dataIndex, countIndex, dataFunction);
                    }
                    else if (agr === "min") {
                        this.fillValueMin(data, times, values, counts, timesI0, timesI1, dataIndex, countIndex, dataFunction);
                    }
                    else if (agr === "max") {
                        this.fillValueMax(data, times, values, counts, timesI0, timesI1, dataIndex, countIndex, dataFunction);
                    }
                    else if (agr === "avg") {
                        this.fillValueAvg(data, times, values, counts, timesI0, timesI1, dataIndex, countIndex, dataFunction);
                    }
                    else if (agr === "count") {
                        this.fillValueCount(data, times, values, counts, timesI0, timesI1, dataIndex, countIndex, dataFunction);
                    }
                    else if (agr === "first") {
                        this.fillValueFirst(data, times, values, counts, timesI0, timesI1, dataIndex, countIndex, dataFunction);
                    }
                    else if (agr === "last") {
                        this.fillValueLast(data, times, values, counts, timesI0, timesI1, dataIndex, countIndex, dataFunction);
                    }
                    else {
                        this.chart.error("Unrecognized aggregation function: " + agr);
                    }
                    if (postAggregationFunction) {
                        for (var i = timesI0; i <= timesI1 - 2; i++) {
                            values[i] = postAggregationFunction(values[i], times[i], displayUnit ? displayUnit.toString() : null);
                        }
                    }
                };
                DataWarehouse.prototype.fillValueSum = function (data, times, values, counts, timesI0, timesI1, dataIndex, countIndex, dataFunction) {
                    var dataLen = data.length;
                    var fromIndex = TimeChart.Data.binSearch(data, times[timesI0]);
                    for (var i = timesI0; i <= timesI1 - 2; i++) {
                        var toTime = times[i + 1];
                        var acc = 0;
                        var count = 0;
                        var value = void 0;
                        while (fromIndex < dataLen && data[fromIndex][0] < toTime) {
                            if (dataFunction) {
                                value = dataFunction(data[fromIndex]);
                            }
                            else {
                                value = data[fromIndex][dataIndex];
                            }
                            if (value != null) {
                                acc += value;
                                count += countIndex === 0 ? 1 : data[fromIndex][countIndex];
                            }
                            fromIndex += 1;
                        }
                        counts[i] = count;
                        values[i] = count === 0 ? null : acc;
                    }
                };
                DataWarehouse.prototype.fillValueMin = function (data, times, values, counts, timesI0, timesI1, dataIndex, countIndex, dataFunction) {
                    var dataLen = data.length;
                    var fromIndex = TimeChart.Data.binSearch(data, times[timesI0]);
                    for (var i = timesI0; i <= timesI1 - 2; i++) {
                        var toTime = times[i + 1];
                        var acc = Infinity;
                        var count = 0;
                        var value = void 0;
                        while (fromIndex < dataLen && data[fromIndex][0] < toTime) {
                            if (dataFunction) {
                                value = dataFunction(data[fromIndex]);
                            }
                            else {
                                value = data[fromIndex][dataIndex];
                            }
                            if (value != null) {
                                acc = Math.min(acc, value);
                                count += countIndex === 0 ? 1 : data[fromIndex][countIndex];
                            }
                            fromIndex += 1;
                        }
                        counts[i] = count;
                        values[i] = count === 0 ? null : acc;
                    }
                };
                DataWarehouse.prototype.fillValueMax = function (data, times, values, counts, timesI0, timesI1, dataIndex, countIndex, dataFunction) {
                    var dataLen = data.length;
                    var fromIndex = TimeChart.Data.binSearch(data, times[timesI0]);
                    for (var i = timesI0; i <= timesI1 - 2; i++) {
                        var toTime = times[i + 1];
                        var acc = -Infinity;
                        var count = 0;
                        var value = void 0;
                        while (fromIndex < dataLen && data[fromIndex][0] < toTime) {
                            if (dataFunction) {
                                value = dataFunction(data[fromIndex]);
                            }
                            else {
                                value = data[fromIndex][dataIndex];
                            }
                            if (value != null) {
                                acc = Math.max(acc, value);
                                count += countIndex === 0 ? 1 : data[fromIndex][countIndex];
                            }
                            fromIndex += 1;
                        }
                        counts[i] = count;
                        values[i] = count === 0 ? null : acc;
                    }
                };
                DataWarehouse.prototype.fillValueCount = function (data, times, values, counts, timesI0, timesI1, dataIndex, countIndex, dataFunction) {
                    var dataLen = data.length;
                    var fromIndex = TimeChart.Data.binSearch(data, times[timesI0]);
                    for (var i = timesI0; i <= timesI1 - 2; i++) {
                        var toTime = times[i + 1];
                        var count = 0;
                        var value = void 0;
                        while (fromIndex < dataLen && data[fromIndex][0] < toTime) {
                            if (dataFunction) {
                                value = dataFunction(data[fromIndex]);
                            }
                            else {
                                value = data[fromIndex][dataIndex];
                            }
                            if (value != null) {
                                count += countIndex ? data[fromIndex][countIndex] : 1;
                            }
                            fromIndex += 1;
                        }
                        counts[i] = count;
                        values[i] = count;
                    }
                };
                DataWarehouse.prototype.fillValueAvg = function (data, times, values, counts, timesI0, timesI1, dataIndex, countIndex, dataFunction) {
                    var dataLen = data.length;
                    var fromIndex = TimeChart.Data.binSearch(data, times[timesI0]);
                    for (var i = timesI0; i <= timesI1 - 2; i++) {
                        var toTime = times[i + 1];
                        var acc = 0;
                        var count = 0;
                        var value = void 0;
                        while (fromIndex < dataLen && data[fromIndex][0] < toTime) {
                            if (dataFunction) {
                                value = dataFunction(data[fromIndex]);
                            }
                            else {
                                value = data[fromIndex][dataIndex];
                            }
                            if (value != null) {
                                acc += value;
                                count += countIndex ? data[fromIndex][countIndex] : 1;
                            }
                            fromIndex += 1;
                        }
                        counts[i] = count;
                        values[i] = count === 0 ? null : (acc / count);
                    }
                };
                DataWarehouse.prototype.fillValueFirst = function (data, times, values, counts, timesI0, timesI1, dataIndex, countIndex, dataFunction) {
                    var dataLen = data.length;
                    var fromIndex = TimeChart.Data.binSearch(data, times[timesI0]);
                    for (var i = timesI0; i <= timesI1 - 2; i++) {
                        var toTime = times[i + 1];
                        var acc = null;
                        var count = 0;
                        var value = void 0;
                        while (fromIndex < dataLen && data[fromIndex][0] < toTime) {
                            if (dataFunction) {
                                value = dataFunction(data[fromIndex]);
                            }
                            else {
                                value = data[fromIndex][dataIndex];
                            }
                            if (value != null) {
                                if (acc === null)
                                    acc = value;
                                count += countIndex ? data[fromIndex][countIndex] : 1;
                            }
                            fromIndex += 1;
                        }
                        counts[i] = count;
                        values[i] = acc;
                    }
                };
                DataWarehouse.prototype.fillValueLast = function (data, times, values, counts, timesI0, timesI1, dataIndex, countIndex, dataFunction) {
                    var dataLen = data.length;
                    var fromIndex = TimeChart.Data.binSearch(data, times[timesI0]);
                    for (var i = timesI0; i <= timesI1 - 2; i++) {
                        var toTime = times[i + 1];
                        var acc = null;
                        var count = 0;
                        var value = void 0;
                        while (fromIndex < dataLen && data[fromIndex][0] < toTime) {
                            if (dataFunction) {
                                value = dataFunction(data[fromIndex]);
                            }
                            else {
                                value = data[fromIndex][dataIndex];
                            }
                            if (value != null) {
                                acc = value;
                                count += countIndex ? data[fromIndex][countIndex] : 1;
                            }
                            fromIndex += 1;
                        }
                        counts[i] = count;
                        values[i] = acc;
                    }
                };
                DataWarehouse.prototype._newDataArrived = function (sourceId) {
                    var dataChanges = {};
                    dataChanges[sourceId] = true;
                    this.chart.events.notifySceneChanges({ data: dataChanges });
                };
                return DataWarehouse;
            }());
            TimeChart.DataWarehouse = DataWarehouse;
        })(TimeChart = Internal.TimeChart || (Internal.TimeChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/Graphics.ts" />
/// <reference path="../linearchart/Settings.ts" />
/// <reference path="../linearchart/ValueAxisSet.ts" />
/// <reference path="../linearchart/Renderer.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var TimeChart;
        (function (TimeChart) {
            var Renderer = (function (_super) {
                __extends(Renderer, _super);
                function Renderer(chart, dataWarehouse) {
                    _super.call(this);
                    this.animationOrder = 400;
                    this.paintOrder = 5;
                    this.updateOrder = 1500;
                    this.dataWarehouse = dataWarehouse;
                    this.chart = chart;
                    this.scene = this.chart.scene;
                    this.events = this.chart.events;
                    this.buildSeries();
                }
                Renderer.prototype.buildSeries = function () {
                    this.valueAxis = new Internal.LinearChart.ValueAxisSet(this.chart, this.scene.settings._computedValueAxisList);
                    this.r = new Internal.LinearChart.Renderer(this.chart, this.valueAxis);
                    this.dataWarehouse.clear();
                    this.requestIds = [];
                    for (var seriesIndex = 0; seriesIndex < this.scene.settings._computedSeries.length; seriesIndex++) {
                        var series = this.scene.settings._computedSeries[seriesIndex];
                        this.requestIds.push(this.dataWarehouse.registerDataProcessingRequest(series.data));
                    }
                };
                Renderer.prototype.onSceneChange = function (event) {
                    var changes = event.changes;
                    if (changes.linearChartSeries || changes.linearChartValueAxis) {
                        // rebuild series if change in series
                        this.buildSeries();
                    }
                    if (changes.linearChartValueAxis) {
                        changes.bounds = true;
                    }
                    if (changes.bounds || changes.settings) {
                        // makse sense
                        changes.time = true;
                    }
                    if (changes.data && Internal.Base.Helpers.hasProperties(changes.data)) {
                        // .hasProperties() check ensures that the onChartUpdate is not fired on the initial load when only the data settings are changed.
                        // instead this will be called every time new data comes in.
                        this.chart.notifyChartUpdate("data", true);
                    }
                };
                Renderer.prototype.getPanels = function () {
                    return this.valueAxis.getPanels(false);
                };
                Renderer.prototype.doAnimations = function (event) {
                    var changes = event.changes;
                    this.dataWarehouse.process(event);
                    if (this.scene.displayUnit) {
                        if (this.displayUnit !== this.scene.displayUnit) {
                            this.displayUnit = this.scene.displayUnit;
                            changes.displayUnit = true;
                        }
                        if (changes.time || changes.data || changes.displayUnit || changes.bounds) {
                            // series now process data, find min/max values
                            var data = [];
                            for (var idIndex = 0; idIndex < this.requestIds.length; idIndex++) {
                                data.push(this.dataWarehouse.getData(this.requestIds[idIndex]));
                            }
                            this.r.process(data);
                        }
                        // values axis now knows min/max values, initiates scale change animations
                        this.valueAxis.updateMinMax(event);
                        // series now convert values to actual x/y representations
                        this.r.afterProcess();
                        /* values axis recalculates locations for labels
                        if there were changes affecting value axis */
                        this.valueAxis.doAnimations(event);
                    }
                };
                Renderer.prototype.paintScene = function (event) {
                    this.valueAxis.paintUnder(event);
                    Internal.Base.Graphics.pushClip(event, this.scene.x0, this.scene.y0, this.scene.width, this.scene.height);
                    this.r.paint(event);
                    Internal.Base.Graphics.popClip(event);
                    this.valueAxis.paint(event);
                };
                Renderer.prototype.hitTest = function (x, y) {
                    if (!this.scene.xyInChart(x, y)) {
                        return null;
                    }
                    return this.r.hitTest(x, y, this.scene.settings.interaction.selection.tolerance);
                };
                Renderer.prototype.exportData = function (from, to) {
                    return this.r.exportData(from, to);
                };
                return Renderer;
            }(Internal.Base.ChartElement));
            TimeChart.Renderer = Renderer;
        })(TimeChart = Internal.TimeChart || (Internal.TimeChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="../base/core/ChartEvents.ts" />
/// <reference path="../base/Navigator.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var TimeChart;
        (function (TimeChart) {
            var Navigator = (function (_super) {
                __extends(Navigator, _super);
                function Navigator(chart) {
                    _super.call(this);
                    this.chart = chart;
                    this.scene = chart.scene;
                    this.settings = chart.settings;
                    this.reinitializePeriod = true;
                }
                Navigator.prototype.onSceneChange = function (event) {
                    var sc = event.changes.settingsChanges;
                    if (sc && sc.navigation) {
                        this.reinitializePeriod = true;
                    }
                    if (this.reinitializePeriod && this.chart.assetsLoaded) {
                        // this call will require moment.js so it is delayed until it is loaded.
                        this.setupInitialDisplayPeriod();
                    }
                };
                Navigator.prototype.onNewDataObject = function () { };
                Navigator.prototype.setupInitialDisplayPeriod = function () {
                    var _this = this;
                    if (!this.scene.width) {
                        return;
                    }
                    this.reinitializePeriod = false;
                    var ianchor = this.settings.navigation.initialDisplayAnchor;
                    var iperiod = this.settings.navigation.initialDisplayPeriod;
                    var iunit = this.settings.navigation.initialDisplayUnit;
                    this.computeDisplayPeriod(iperiod, ianchor, iunit, function (from, to, unit) {
                        _this.scene.setMessage("impl", null, 0);
                        _this.scene.loading = false;
                        /* set computed from,to,unit
                        respect stuff set by API */
                        if (_this.scene.displayUnit) {
                            unit = _this.scene.displayUnit;
                        }
                        if (!_this.scene.timeStart && !_this.scene.timeEnd) {
                            var timeSetup = _this.chart.scrolling.timeSetup;
                            var data = timeSetup.getLimits(unit, true);
                            if (data.limitFrom !== null) {
                                from = Math.round(Math.max(from, data.limitFrom));
                            }
                            if (data.limitTo !== null) {
                                to = Math.round(Math.min(to, data.limitTo));
                            }
                            _this.chart.scrolling.setTimeRange(from, to, unit, false, "init", ianchor, iperiod);
                        }
                    });
                };
                Navigator.prototype.computeDisplayPeriod = function (periodStr, anchorStr, displayUnitStr, callback) {
                    var _this = this;
                    // special case - fixed period and we already know the limits
                    var calcDisplayPeriod = this.chart.scrolling.computeDisplayPeriod(periodStr, anchorStr, displayUnitStr, this.scene.mainData.dataFrom, this.scene.mainData.dataTo);
                    var from = calcDisplayPeriod.from;
                    var to = calcDisplayPeriod.to;
                    var unit = calcDisplayPeriod.unit;
                    if (from !== null && to !== null && unit) {
                        return callback(from, to, unit);
                    }
                    // we need to load data and see what the data range is
                    if (!this.scene.mainData.dataSettings.dataFunction
                        && !this.scene.mainData.dataSettings.url
                        && !this.scene.mainData.dataSettings.urlByUnit
                        && !this.scene.mainData.dataSettings.preloaded) {
                        this.chart.error("Cannot compute data dependant display period, no data given. DisplayPeriod = " + periodStr + ", DisplayAnchor = " + anchorStr);
                        return;
                    }
                    // Load data and compute time range from it.
                    var dataLoaded = function (dataFrom, dataTo, dataUnit, oldFrom, oldTo, oldUnit) {
                        if (_this.chart.removed) {
                            return;
                        }
                        if (dataFrom === null || dataTo === null || (dataFrom === 0 && dataTo === 0 && _this.scene.mainData.noData)) {
                            // failed to load data
                            callback(oldFrom, oldTo, oldUnit);
                            return;
                        }
                        // now we have some data, try to evaluate time range.
                        calcDisplayPeriod = _this.chart.scrolling.computeDisplayPeriod(periodStr, anchorStr, displayUnitStr, dataFrom, dataTo);
                        from = calcDisplayPeriod.from;
                        to = calcDisplayPeriod.to;
                        var displayUnit = calcDisplayPeriod.unit;
                        if (from === null || to === null) {
                            _this.chart.error("Could not setup display time interval. Check your configuration.");
                            return;
                        }
                        if (displayUnit.isMultipleOf(dataUnit)) {
                            callback(from, to, displayUnit);
                        }
                        else {
                            // unit too big, ask smaller unit
                            _this.scene.mainData.determineDataLimits(displayUnit, true, true, function (a, b, c) { return dataLoaded(a, b, c, dataFrom, dataTo, displayUnit); });
                        }
                    };
                    this.scene.mainData.determineDataLimits(null, true, true, function (a, b, c) { return dataLoaded(a, b, c, 0, 0, null); });
                };
                return Navigator;
            }(Internal.Base.Navigator));
            TimeChart.Navigator = Navigator;
        })(TimeChart = Internal.TimeChart || (Internal.TimeChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="moment.d.ts" />
/// <reference path="moment-timezone.d.ts" />
/// <reference path="../linearchart/Impl.ts" />
/// <reference path="Data.ts" />
/// <reference path="Scene.ts" />
/// <reference path="Scrolling.ts" />
/// <reference path="Selection.ts" />
/// <reference path="InfoPopup.ts" />
/// <reference path="ClickNotifier.ts" />
/// <reference path="Bar/Toolbar.ts" />
/// <reference path="TimeUpdater.ts" />
/// <reference path="TimeAxis.ts" />
/// <reference path="DataWarehouse.ts" />
/// <reference path="Renderer.ts" />
/// <reference path="Navigator.ts" />
/// <reference path="Markers.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    var Internal;
    (function (Internal) {
        var TimeChart;
        (function (TimeChart) {
            TimeChart.moment = null;
            var momentTzVersionChecked = false;
            var Impl = (function (_super) {
                __extends(Impl, _super);
                function Impl(settings, api) {
                    // throws exception if stuff goes wrong
                    _super.call(this, new TimeChart.Settings(settings), new TimeChart.Scene(), api);
                    this.timeAxis = null;
                    this.timeStart = 0;
                    this.timeEnd = 0;
                    this.displayUnit = null;
                    this.selectionStart = 0;
                    this.selectionEnd = 0;
                    this._cachedDataLimits = null;
                    // prepare components
                    this.dataWarehouse = new TimeChart.DataWarehouse(this);
                    this.renderer = this.events.addElement(new TimeChart.Renderer(this, this.dataWarehouse));
                    this.scrolling = this.events.addElement(new TimeChart.Scrolling(this));
                    this.selection = this.events.addElement(new TimeChart.Selection(this));
                    this.navigator = this.events.addElement(new TimeChart.Navigator(this));
                    this.clickNotifier = this.events.addElement(new TimeChart.ClickNotifier(this));
                    this.infoPopup = this.events.addElement(new TimeChart.InfoPopup(this));
                    this.events.addElement(new TimeChart.TimeUpdater(this));
                    this.events.addElement(new TimeChart.Markers(this));
                    this.events.addElement(new Internal.LinearChart.Highlights(this));
                    this.finalInitialize();
                }
                Impl.prototype.notifyAssetsLoaded = function () {
                    // this method finished the chart initialization since it is only now that it is certain that moment.js has been loaded.
                    if (this.removed)
                        return;
                    if (!TimeChart.moment) {
                        TimeChart.moment = window.moment;
                        if (!TimeChart.moment) {
                            this.error("Unable to load moment library. Please check that the assets are configured properly.");
                            return;
                        }
                        if (!Internal.Base.Helpers.compareVersions(TimeChart.moment.version, [2, 9]))
                            this.error("ZoomCharts requires moment version 2.9.0 or newer. The loaded version is " + TimeChart.moment.version);
                    }
                    if (!momentTzVersionChecked && TimeChart.moment.tz) {
                        if (!Internal.Base.Helpers.compareVersions(TimeChart.moment.tz.version, [0, 5]))
                            this.error("ZoomCharts requires moment-timezone version 0.5.0 or newer. The loaded version is " + TimeChart.moment.tz.version);
                        momentTzVersionChecked = true;
                    }
                    this.setMomentLocale();
                    var ta = this.settings.timeAxis;
                    if (TimeChart.moment.tz && ta.timeZone === "local") {
                        ta.timeZone = TimeChart.moment.tz.guess();
                        Internal.Base.Helpers.warn("Instead of using `local` for `timeAxis.timeZone`"
                            + " it is recommended to specify the exact timezone since the local timezone detection is error prone."
                            + " The timezone was detected as `" + ta.timeZone + "`.");
                    }
                    if (!this.timeAxis) {
                        this.timeAxis = this.events.addElement(new TimeChart.TimeAxis(this));
                    }
                    var dataKeys = Object.keys(this.data);
                    for (var i = 0; i < dataKeys.length; i++) {
                        this.data[dataKeys[i]].notifyAssetsLoaded();
                    }
                    _super.prototype.notifyAssetsLoaded.call(this);
                    this.api._notifyAssetsLoaded();
                };
                Impl.prototype.createDataObj = function (dataSettings) {
                    return new TimeChart.Data(this, dataSettings);
                };
                Impl.prototype.getData = function (id) {
                    return _super.prototype.getData.call(this, id);
                };
                Impl.prototype.setMomentLocale = function () {
                    var name = this.scene.momentLocale;
                    // delete + add // avoids merging of the previous settings with the new ones.
                    var current = TimeChart.moment.locale();
                    var newSettings = this.settings.localization.calendar;
                    if (newSettings.parentLocale && !Internal.Base.Helpers.compareVersions(TimeChart.moment.version, [2, 12]))
                        this.error("Using `parentLocale` requires moment.js 2.12.0 or newer. The loaded version is " + TimeChart.moment.version);
                    TimeChart.moment.locale(name, null);
                    TimeChart.moment.locale(name, newSettings);
                    this.scene.timeStepSettings = { week: { dow: TimeChart.moment.localeData().firstDayOfWeek() } };
                    TimeChart.moment.locale(current);
                };
                Impl.prototype.remove = function () {
                    if (TimeChart.moment)
                        TimeChart.moment.locale(this.scene.momentLocale, null);
                    _super.prototype.remove.call(this);
                };
                Impl.prototype.onSettingsChanged = function (changes) {
                    // update data
                    if (changes.data) {
                        changes.toolbar = true;
                    }
                    if (changes.area && changes.area.displayUnits) {
                        var scene = this.scene;
                        var s = new TimeChart.TimeSetup(this);
                        if (scene.displayUnit && !s.isAllowedDisplayUnit(scene.displayUnit)) {
                            var newUnit = s.computeDisplayUnit(scene.timeStart, scene.timeEnd, scene.displayUnit, scene.timeStart, scene.timeEnd, scene);
                            this.scrolling.setTimeRangeSnap(scene.timeStart, scene.timeEnd, null, newUnit.unit, true, "api", true, true);
                        }
                    }
                    if (changes.localization && changes.localization.calendar) {
                        this.setMomentLocale();
                    }
                    // do repaint
                    this.events.notifySceneChanges({ time: true });
                };
                Impl.prototype.save = function () {
                    var scene = this.scene;
                    return JSON.stringify({
                        from: this.timeStart,
                        to: this.timeEnd,
                        unit: this.displayUnit.toString(),
                        selFrom: scene.selectionStart,
                        selTo: scene.selectionEnd,
                        anchor: scene.anchor,
                        period: scene.period
                    });
                };
                Impl.prototype.restore = function (stateStr, animate) {
                    if (!stateStr) {
                        return;
                    }
                    var state = JSON.parse(stateStr);
                    var unit = TimeChart.TimeStep.parse(state.unit);
                    if (!unit)
                        return;
                    this.scrolling.setTimeRange(state.from, state.to, unit, animate, "api", state.anchor, state.period);
                    this.setSelection(state.selFrom, state.selTo);
                };
                Impl.prototype.warnInvisibleChart = function (caller) {
                    if (!this.scene.width) {
                        Internal.Base.Helpers.warn("`" + caller +
                            "()` method has been called on a hidden chart. This might produce invalid results since the chart width impacts the calculations.");
                    }
                };
                Impl.prototype.setSelection = function (from, to, origin) {
                    if (origin === void 0) { origin = "api"; }
                    var scene = this.scene;
                    if (scene.selectionStart === from && scene.selectionEnd === to) {
                        return;
                    }
                    scene.selectionStart = from;
                    scene.selectionEnd = to;
                    this.events.notifySceneChanges({ selection: true });
                    this.notifySelectionChanged(this.createEventArguments(null, origin));
                };
                Impl.prototype.setTimeRange = function (from, to, animate, origin) {
                    if (origin === void 0) { origin = "api"; }
                    this.warnInvisibleChart("time");
                    this.setSelection(null, null, origin);
                    // the initialDisplayUnit is parsed at this point to handle scenarios where the
                    // time() method is called before the initial display unit is set. In that case
                    // the scrolling.setTimeRange() would have calculated its own preferred display
                    // unit and later the initialDisplayUnit would be ignored.
                    var unit = this.displayUnit;
                    if (!unit) {
                        var initial = this.settings.navigation.initialDisplayUnit;
                        if (initial && initial !== "auto") {
                            unit = TimeChart.TimeStep.parse(initial);
                        }
                    }
                    // simulate drag on the chart. this makes sure that the proper snapping is applied.
                    this.scene.displayUnit = unit;
                    if (this.scene.width) {
                        // snapping has to know the width of the chart so that it can apply min/max unit widths
                        // so avoid it for invisible chart. the warning will be shown in the browser console but
                        // this makes it more likely to produce what the dev wanted.
                        var snap = this.scrolling.onSnapWhileDragging(from, to, null, true, 2 /* Any */);
                        if (snap.unit) {
                            this.scene.displayUnit = snap.unit;
                            snap = this.scrolling.onSnapAfterDragging(snap.from, snap.to, null, true, 2 /* Any */);
                        }
                        from = snap.from;
                        to = snap.to;
                        unit = snap.unit;
                    }
                    this.scrolling.setTimeRange(from, to, unit, animate, origin);
                };
                Impl.prototype.setDisplayPeriod = function (displayPeriod, displayAnchor, displayUnit, animate, origin) {
                    var _this = this;
                    if (displayAnchor === void 0) { displayAnchor = null; }
                    if (displayUnit === void 0) { displayUnit = null; }
                    if (animate === void 0) { animate = true; }
                    if (origin === void 0) { origin = "api"; }
                    this.warnInvisibleChart("setDisplayPeriod");
                    if (displayAnchor === null) {
                        displayAnchor = this.scene.anchor;
                    }
                    this.setSelection(null, null);
                    if (typeof displayAnchor === "string") {
                        displayAnchor = displayAnchor.trim();
                    }
                    if (typeof displayPeriod === "string") {
                        displayPeriod = displayPeriod.trim();
                    }
                    return this.navigator.computeDisplayPeriod(displayPeriod, displayAnchor, displayUnit, function (form, to, unit) { return _this.scrolling.setTimeRange(form, to, unit, animate, origin, displayAnchor, displayPeriod); });
                };
                Impl.prototype.scroll = function (amount, animate) {
                    // parse amount
                    var units = amount.trim().split(" ");
                    if (units.length !== 3) {
                        this.error("Incorrect scroll format: " + amount);
                        return;
                    }
                    var direction = units[0];
                    var count = parseInt(units[1], 10);
                    var unit = units[2];
                    if ((direction !== "<" && direction !== ">") || typeof count !== "number") {
                        this.error("Scroll:Incorrect scroll format: " + amount);
                        return;
                    }
                    var s = new TimeChart.TimeSetup(this);
                    var scrollResult = s.scroll(this.timeStart, this.timeEnd, this.displayUnit, direction, count, unit);
                    var from = scrollResult.from;
                    var to = scrollResult.to;
                    this.scrolling.setTimeRange(from, to, this.displayUnit, animate, "api", null, this.scene.period);
                };
                Impl.prototype.zoomOut = function (animate, origin, unit) {
                    if (animate === void 0) { animate = true; }
                    if (origin === void 0) { origin = "api"; }
                    if (unit === void 0) { unit = null; }
                    this.setSelection(null, null);
                    this.scrolling.zoomOut(unit, this.scene.timeStart, this.scene.timeEnd, animate, origin);
                    this.scene.period = null;
                };
                Impl.prototype.zoomOutPossible = function () {
                    return !!this.scene.displayUnit;
                };
                Impl.prototype.zoomIn = function (unit, center, animate, origin) {
                    if (center === void 0) { center = null; }
                    if (animate === void 0) { animate = true; }
                    if (origin === void 0) { origin = "api"; }
                    this.setSelection(null, null);
                    this.scrolling.zoomIn(unit, center, this.scene.timeStart, this.scene.timeEnd, animate, origin);
                    this.scene.period = null;
                };
                Impl.prototype.setDisplayUnit = function (unitStr, animate, origin, verifyUnit) {
                    if (origin === void 0) { origin = "api"; }
                    if (verifyUnit === void 0) { verifyUnit = false; }
                    this.warnInvisibleChart("displayUnit");
                    var unit;
                    var from;
                    var to;
                    if (unitStr === "auto") {
                        var auto = this.scrolling.timeSetup.computeDisplayUnit(null, null, null, this.timeStart, this.timeEnd, this.scene);
                        unit = auto.unit;
                        from = auto.from;
                        to = auto.to;
                    }
                    else {
                        unit = TimeChart.TimeStep.parse(unitStr);
                        if (!unit) {
                            return;
                        }
                        if (verifyUnit) {
                            var given = unit.toString();
                            var dup = this.scene.settings._displayUnitsParsed;
                            var valid = false;
                            for (var i = 0; i < dup.length; i++) {
                                if (dup[i].toString() === given) {
                                    valid = true;
                                    break;
                                }
                            }
                            if (!valid) {
                                Internal.Base.Helpers.warn("The display unit `" + given + "` does not match a display unit configured in `area.displayUnits`.");
                            }
                        }
                        // when switching to a larger unit, make sure that the current time range will always be included
                        // in the new visible range
                        var tsc = this.scene.timeStepSettings;
                        from = unit.roundTimeDown(this.timeStart, tsc);
                        to = unit.roundTimeUp(this.timeEnd, tsc);
                    }
                    var snapResult = this.scrolling.snap(from, to, null, unit, false, true);
                    this.scrolling.setTimeRange(snapResult.from, snapResult.to, unit, animate, origin, snapResult.anchor, snapResult.period);
                };
                Impl.prototype.invalidateDataLimits = function () {
                    this._cachedDataLimits = null;
                };
                Impl.prototype.getDataLimits = function (targetUnit) {
                    if (targetUnit === void 0)
                        targetUnit = this.displayUnit;
                    var res = this._cachedDataLimits;
                    if (res && res.unit === targetUnit)
                        return res;
                    var series = this.settings._computedSeries;
                    var dataSources = Object.create(null);
                    for (var i = 0; i < series.length; i++) {
                        var s = series[i];
                        if (s.enabled) {
                            dataSources[s.data.source] = true;
                        }
                    }
                    var from = Infinity;
                    var to = -Infinity;
                    for (var source in dataSources) {
                        var data = this.data[source];
                        if (data && (data.dataLimitFrom || data.dataLimitTo)) {
                            from = Math.min(from, data.dataLimitFrom);
                            to = Math.max(to, data.dataLimitTo);
                        }
                    }
                    if (from > to) {
                        from = null;
                        to = null;
                    }
                    else if (targetUnit) {
                        from = targetUnit.roundTimeDown(from, this.scene.timeStepSettings);
                        to = targetUnit.roundTimeUp(to, this.scene.timeStepSettings);
                    }
                    return this._cachedDataLimits = { from: from, to: to, unit: targetUnit };
                };
                /** Gets the display limits rounded for the given target display unit. If `targetUnit` is not
                specified, uses `scene.displayUnit`. If `targetUnit===null`, does not round anything. */
                Impl.prototype.getDisplayLimits = function (targetUnit) {
                    var getDataLimitsResult = this.getDataLimits(targetUnit);
                    var from = getDataLimitsResult.from;
                    var to = getDataLimitsResult.to;
                    if (from === null) {
                        return getDataLimitsResult;
                    }
                    for (var markerIndex = 0; markerIndex < this.scene.markers.length; markerIndex++) {
                        var marker = this.scene.markers[markerIndex];
                        if (marker.settings.overrideLimits) {
                            from = Math.min(from, marker.time);
                            to = Math.max(to, marker.time);
                        }
                    }
                    return { from: from, to: to };
                };
                Impl.prototype.exportVisibleData = function () {
                    if (!this.displayUnit)
                        return [];
                    var series = this.settings._computedSeries;
                    var data = this.dataWarehouse.exportData(this.timeStart, this.timeEnd, this.displayUnit, series);
                    var timeFormat = this.settings.localization.infoDates.fullTimeFormats[this.displayUnit.unit];
                    var timestamps = data.timestamps;
                    var values = data.values;
                    var headers = ["timestamp", "time"];
                    for (var sIndex = 0; sIndex < series.length; sIndex++) {
                        var s = series[sIndex];
                        headers.push(s.name || s.id || "");
                    }
                    var result = [headers];
                    var momentLocale = this.scene.momentLocale;
                    for (var i = 0; i < timestamps.length; i++) {
                        var t = timestamps[i];
                        var row = [
                            t,
                            TimeChart.moment.utc(t).locale(momentLocale).format(timeFormat)
                        ];
                        for (var j = 0; j < series.length; j++) {
                            row.push(values[j][i]);
                        }
                        result.push(row);
                    }
                    return result;
                };
                /** Tests if the display period is currently displayed. */
                Impl.prototype.isThisDisplayPeriod = function (periodStr, anchorStr, unit) {
                    if (!this.displayUnit) {
                        return false;
                    }
                    var from = this.scene.mainData.dataFrom;
                    var to = this.scene.mainData.dataTo;
                    var computeDisplayPeriodResult = this.scrolling.computeDisplayPeriod(periodStr, anchorStr, unit, from, to);
                    from = computeDisplayPeriodResult.from;
                    to = computeDisplayPeriodResult.to;
                    // not used currently as during the animation the display unit might change
                    // if (!this.scene.displayUnit.isEqual(computeDisplayPeriodResult.unit)) {
                    //     return false;
                    // }
                    var chartFrom = this.scrolling.getFrom();
                    var chartTo = this.scrolling.getTo();
                    var range = chartTo - chartFrom;
                    var e1 = Math.abs(chartFrom - from) / range;
                    if (e1 > 0.1)
                        return false;
                    var e2 = Math.abs(chartTo - to) / range;
                    if (e2 > 0.1)
                        return false;
                    return true;
                };
                /** events */
                Impl.prototype.notifyTimeChanged = function (from, to, unit, origin) {
                    this.timeStart = from;
                    this.timeEnd = to;
                    this.displayUnit = unit;
                    this.notifyChartUpdate(origin);
                };
                Impl.prototype.saveNavigation = function () {
                    if (!this.displayUnit) {
                        return null;
                    }
                    return {
                        timeStart: this.timeStart,
                        timeEnd: this.timeEnd,
                        displayUnit: this.displayUnit,
                        anchor: this.scene.anchor,
                        period: this.scene.period
                    };
                };
                Impl.prototype.restoreNavigation = function (state, animate, origin) {
                    this.timeStart = state.timeStart;
                    this.timeEnd = state.timeEnd;
                    this.displayUnit = state.displayUnit;
                    this.scrolling.setTimeRange(this.timeStart, this.timeEnd, this.displayUnit, animate, origin, state.anchor, state.period);
                };
                Impl.prototype.doChartUpdateNotify = function (origin) {
                    _super.prototype.doChartUpdateNotify.call(this, origin);
                    // legacy events.
                    this.dispatchEventParams("timeChange", this.createEventArguments(null, origin), null);
                };
                Impl.prototype.createEventArguments = function (event, origin) {
                    var scene = this.scene;
                    var hover = scene.hoverSeriesItem;
                    var hoverSeries = (hover && hover.seriesIndex != null) ? scene.settings._computedSeries[hover.seriesIndex] : null;
                    var hoverMarker = hover ? hover.isMarker : false;
                    var difs = TimeChart.TimeStep.timeUnitDiffs;
                    var hasTimePart = this.displayUnit ? difs[this.displayUnit.unit] < difs["d"] : true;
                    var hoverFrom = scene.timestampFromInternal(scene.hoverFrom, hasTimePart);
                    var hoverTo = scene.timestampFromInternal(scene.hoverTo, hasTimePart);
                    return {
                        chart: this.api,
                        origin: origin,
                        timeStart: scene.timestampFromInternal(this.timeStart, hasTimePart),
                        timeEnd: scene.timestampFromInternal(this.timeEnd, hasTimePart),
                        displayUnit: this.displayUnit ? (this.displayUnit.toString()) : null,
                        selectionStart: scene.timestampFromInternal(scene.selectionStart, hasTimePart),
                        selectionEnd: scene.timestampFromInternal(scene.selectionEnd, hasTimePart),
                        hoverStart: hoverFrom,
                        hoverEnd: hoverTo,
                        hoverSeries: hoverSeries,
                        hoverMarker: hoverMarker,
                        clickStart: hoverFrom,
                        clickEnd: hoverTo,
                        clickSeries: hoverSeries,
                        clickMarker: hoverMarker
                    };
                };
                Impl.prototype.defaultClick = function (event, args) {
                    _super.prototype.defaultClick.call(this, event, args);
                    this.clickNotifier.defaultClick(event, args);
                };
                Impl.prototype.defaultRightClick = function (event) {
                    this.infoPopup.show(event);
                    event.preventDefault();
                };
                Impl.prototype.getBottomHeight = function () {
                    return this.scene.height - this.scene.bottomAxisSize;
                };
                Impl.prototype.showInfoPopup = function (timeFrom, timeTo, contents) {
                    if (timeFrom == null) {
                        this.infoPopup.hideInfoPopup(null);
                        return;
                    }
                    if (timeTo == null || timeFrom === timeTo) {
                        timeTo = timeFrom + 1;
                    }
                    else if (timeFrom > timeTo) {
                        var temp = timeFrom;
                        timeFrom = timeTo;
                        timeTo = temp;
                    }
                    var unit = this.displayUnit;
                    var tsc = this.scene.timeStepSettings;
                    timeFrom = unit.roundTimeDown(timeFrom, tsc);
                    timeTo = unit.roundTimeUp(timeTo, tsc);
                    if (timeTo < this.scene.timeStart || timeFrom > this.scene.timeEnd)
                        return;
                    this.infoPopup.manualShowInfoPopup(timeFrom, timeTo, contents);
                };
                return Impl;
            }(Internal.LinearChart.Impl));
            TimeChart.Impl = Impl;
        })(TimeChart = Internal.TimeChart || (Internal.TimeChart = {}));
    })(Internal = ZoomCharts.Internal || (ZoomCharts.Internal = {}));
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="ZoomCharts.d.ts" />
/// <reference path="timechart/Settings.ts" />
/// <reference path="timechart/Impl.ts" />
/// <reference path="base/Api.ts" />
var ZoomCharts;
(function (ZoomCharts) {
    /** @api-class */
    var TimeChart = (function (_super) {
        __extends(TimeChart, _super);
        function TimeChart(settings) {
            var _this = this;
            _super.call(this);
            /** Stores callbacks that will be executed when moment.tz becomes available. */
            this._cachedApiCalls = [];
            this.typeName = "TimeChart";
            if (TimeChart.chartFactoryMethod) {
                this._impl = TimeChart.chartFactoryMethod(function (stngs) { return new ZoomCharts.Internal.TimeChart.Impl(stngs, _this); }, settings);
            }
            else {
                this._impl = new ZoomCharts.Internal.TimeChart.Impl(settings, this);
            }
        }
        TimeChart.prototype._notifyAssetsLoaded = function () {
            var cac = this._cachedApiCalls;
            if (cac === null)
                return;
            this._cachedApiCalls = null;
            for (var i = 0; i < cac.length; i++) {
                cac[i]();
            }
        };
        TimeChart.prototype.updateSettings = function (changes) {
            _super.prototype.updateSettings.call(this, changes);
            return this;
        };
        TimeChart.prototype.replaceSettings = function (changes) {
            _super.prototype.replaceSettings.call(this, changes);
            return this;
        };
        TimeChart.prototype.on = function (name, listener) {
            _super.prototype.on.call(this, name, listener);
        };
        /* tslint:enable:max-line-length */
        /** Gets or sets the displayed time range in JavaScript timestamp (milliseconds). Note that both
        `from` and `to` must be specified for the time range to be updated.
        
        All timestamps are specified in UTC.
        
        Note that this method will return `[null, null]` if `moment-timezone` library is still being downloaded.
        @version 1.12.0 - parameters now take UTC timestamps and not the chart internal timestamp.
        @version 1.13.2 - the new time range will be modified accoring to the limits in chart configuration and display unit might be changed based on the range.
        @version 1.15.0 - parameters can now be passed as `Date` or `moment` instances.
        */
        TimeChart.prototype.time = function (from, to, animate) {
            var _this = this;
            if (animate === void 0) { animate = true; }
            var impl = this._impl;
            var scene = impl.scene;
            var difs = ZoomCharts.Internal.TimeChart.TimeStep.timeUnitDiffs;
            var hasTimePart = impl.displayUnit ? difs[impl.displayUnit.unit] < difs["d"] : true;
            // note that '!=' is used to compare both against undefined and null
            if (from != null && to != null) {
                if (this._cachedApiCalls) {
                    this._cachedApiCalls.push(function () {
                        _this.time(from, to, animate);
                    });
                    return [null, null];
                }
                // +from / +to is used to handle Date and moment objects - both will return the UTC timestamp for valueOf().
                impl.setTimeRange(scene.timestampToInternal(+from, hasTimePart), scene.timestampToInternal(+to, hasTimePart), animate);
            }
            return [
                scene.timestampFromInternal(impl.timeStart, hasTimePart),
                scene.timestampFromInternal(impl.timeEnd, hasTimePart)
            ];
        };
        /** When the chart is animating, gets the target time range (otherwise returns the current time range).

        This method is useful when there are related data objects (such as data tables or other charts) that have
        to be filtered based on the visible time range in the chart. By using `onChartUpdate` event and this
        method it is possible to start updating the page as soon as the animation change but do it for the values
        the chart is animating towards.

        If the data has not yet been loaded, this method returns `[null, null]`.

        @returns Array with two members - the first is the UTC timestamp of the start, the second the UTC timestamp of the end of the time range.
        @see Documentation - [`targetDisplayUnit()`](#targetDisplayUnit)
        @version 1.14.0
        */
        TimeChart.prototype.targetTime = function () {
            var impl = this._impl;
            var scene = impl.scene;
            var scrolling = impl.scrolling;
            var difs = ZoomCharts.Internal.TimeChart.TimeStep.timeUnitDiffs;
            var unit = scrolling.targetUnit || impl.displayUnit;
            if (!unit)
                return [null, null];
            var hasTimePart = impl.displayUnit ? difs[impl.displayUnit.unit] < difs["d"] : true;
            return [
                scene.timestampFromInternal(scrolling.getFrom(), hasTimePart),
                scene.timestampFromInternal(scrolling.getTo(), hasTimePart)
            ];
        };
        /** When the chart is animating, gets the target display unit (otherwise returns the current display unit).

        @see Documentation - [`targetTime()`](#targetTime)
        @version 1.15.0
         */
        TimeChart.prototype.targetDisplayUnit = function () {
            var impl = this._impl;
            var u = impl.scrolling.targetUnit || impl.displayUnit || impl.scene.displayUnit;
            return u ? u.toString() : null;
        };
        TimeChart.prototype.addData = function (data, sourceId) {
            if (sourceId == null)
                sourceId = "default";
            this._impl.addData(data, sourceId);
        };
        TimeChart.prototype.replaceData = function (data, sourceId) {
            if (sourceId == null)
                sourceId = "default";
            this._impl.replaceData(data, sourceId);
        };
        /** Set displayed time range using period and anchor.
        
        See [`initialDisplayAnchor` and `initialDisplayPeriod` documentation][doc] for possible period / anchor values.
        
        [doc]: https://zoomcharts.com/developers/en/time-chart/api-reference/settings.html#doc_navigation.initialDisplayAnchor
        @version 1.12.0 - `period` parameter now takes UTC timestamps and not the chart internal timestamps.
        */
        TimeChart.prototype.setDisplayPeriod = function (period, anchor, animate) {
            var _this = this;
            if (animate === void 0) { animate = true; }
            if (this._cachedApiCalls) {
                this._cachedApiCalls.push(function () {
                    _this.setDisplayPeriod(period, anchor, animate);
                });
                return;
            }
            this._impl.setDisplayPeriod(period, anchor, null, animate);
        };
        /** Gets or sets the current display unit. Note that setting the display unit might also result in changes
        of the current time range to ensure that the unit follows the min/max widths.

        If `unit: "auto"` is used to select the best-fit display unit, the chart determines the correct display unit
        based on [`timeAxis.unitSizePolicy`](time-chart/api-reference/settings/timeAxis/unitSizePolicy.html) setting.

        Note that this method can be used to set a display unit that the chart is not configured to use but in this
        case a warning will be displayed in the browser console because user interactions will not preserve this setting.
        To avoid this, specify the needed display units in [`area.displayUnits`](time-chart/api-reference/settings/area/displayUnits.html).

        @param unit - If specified, updates the current display unit. Example values: `m`, `s`, `h`, `2 h`, `10 m`, `auto`.
        @param animate - When setting the display unit, specifies if the chart animates the transition.
        @param rescale - Deprecated as of 1.14.0.
        @return The current display unit in format `{count} {unit}` or `null` if the display unit is not yet set.
        @version 1.14.0 - Removed the support for `rescale` parameter. Added the support for setting the `auto` display unit. */
        TimeChart.prototype.displayUnit = function (unit, animate, rescale) {
            var _this = this;
            if (animate === void 0) { animate = true; }
            if (rescale !== void 0) {
                ZoomCharts.Internal.Base.Helpers.warn("TimeChart.displayUnit() no longer supports the `rescale` parameter.");
            }
            if (unit) {
                if (this._cachedApiCalls) {
                    this._cachedApiCalls.push(function () {
                        _this.displayUnit(unit, animate);
                    });
                    return null;
                }
                this._impl.setDisplayUnit(unit, animate, "api", true);
            }
            return this._impl.displayUnit ? (this._impl.displayUnit.toString()) : null;
        };
        /** Gets or sets the  selection in javascript timestamp (milliseconds). All timestamps are in UTC.
        
        Use `from: null, to: null` to remove selection. If the chart does not have a selection, the method
        returns `[null, null]`.

        Note that this method will return `[null, null]` if `moment-timezone` library is still being downloaded.
        
        @version 1.12.0 - parameters now take an UTC timestamp and not the chart internal timestamp.
        @version 1.15.0 - parameters that are `Date` or `moment` instances are now accepted.
        */
        TimeChart.prototype.selection = function (from, to) {
            var _this = this;
            var impl = this._impl;
            var scene = impl.scene;
            var difs = ZoomCharts.Internal.TimeChart.TimeStep.timeUnitDiffs;
            var hasTimePart = impl.displayUnit ? difs[impl.displayUnit.unit] < difs["d"] : true;
            if (from !== void 0 && to !== void 0) {
                if (this._cachedApiCalls) {
                    this._cachedApiCalls.push(function () {
                        _this.selection(from, to);
                    });
                    return [null, null];
                }
                impl.setSelection(from === null ? null : scene.timestampToInternal(+from, hasTimePart), to === null ? null : scene.timestampToInternal(+to, hasTimePart));
            }
            return [
                scene.timestampFromInternal(impl.scene.selectionStart, hasTimePart),
                scene.timestampFromInternal(impl.scene.selectionEnd, hasTimePart)
            ];
        };
        /** Scrolls the visible chart area left or right.

        The `amount` property format: `< amount unit` or `> amount unit`.
            
        - `<` scrolls to the left, `>` scrolls to the right
        - `amount`: integer amount of units to scroll
        - `unit`: one of the following: `page`, `bar`, `y`, `M`, `d`, `w`, `h`, `m`, `s`, `ms`.
            
            Examples:
        
        - `scroll("< 1 s")` - scrolls left 1 second, no animation
        - `scroll("> 10 y", true)` - scrolls right, 10 years with animation
        */
        TimeChart.prototype.scroll = function (amount, animate) {
            if (animate === void 0) { animate = true; }
            return this._impl.scroll(amount, animate);
        };
        /**
         * Increases the visible time range on the chart.
         *
         * Has no effect if the chart data has not been yet loaded.
         * @param unit - the target unit in form `1 d`; if not specified, the unit is determined automatically.
         * @param animate - determines if the zoom animation is executed.
         */
        TimeChart.prototype.zoomOut = function (unit, animate) {
            var _this = this;
            if (animate === void 0) { animate = true; }
            if (this._cachedApiCalls) {
                this._cachedApiCalls.push(function () {
                    _this.zoomOut(unit, animate);
                });
                return;
            }
            this._impl.zoomOut(animate, "api", ZoomCharts.Internal.TimeChart.TimeStep.parse(unit));
        };
        /**
         * Decreases the visible time range on the chart.
         *
         * Has no effect if the chart data has not been yet loaded.
         * @param unit - the target unit in form `1 d`; if not specified, the unit is determined automatically.
         * @param center - the UTC timestamp that should be the new center of the visible area.
         * @param animate - determines if the zoom animation is executed.
         *
         * @version 1.12.0 - `center` parameter now takes an UTC timestamp and not the chart internal timestamp.
         * @version 1.15.0 - `center` parameter can now be passed as `Date` or `moment` instance.
         */
        TimeChart.prototype.zoomIn = function (unit, center, animate) {
            var _this = this;
            if (center === void 0) { center = null; }
            if (animate === void 0) { animate = true; }
            if (this._cachedApiCalls) {
                this._cachedApiCalls.push(function () {
                    _this.zoomIn(unit, center, animate);
                });
                return;
            }
            var impl = this._impl;
            var parsedUnit = ZoomCharts.Internal.TimeChart.TimeStep.parse(unit);
            if (center != null) {
                var effectiveUnit = parsedUnit || impl.displayUnit;
                var difs = ZoomCharts.Internal.TimeChart.TimeStep.timeUnitDiffs;
                var hasTimePart = effectiveUnit ? difs[effectiveUnit.unit] < difs["d"] : true;
                center = impl.scene.timestampToInternal(+center, hasTimePart);
            }
            impl.zoomIn(parsedUnit, center, animate, "api");
        };
        /** Replaces the existing series configuration with new one instead of merging it like `updateSettings`.
        @deprecated - Use `replaceSettings({series: seriesData})` instead. */
        TimeChart.prototype.replaceSeries = function (series) {
            this._impl.deprecated("replaceSeries", "replaceSettings");
            return this.replaceSettings({ series: series });
        };
        TimeChart.prototype.exportVisibleData = function () {
            return this._impl.exportVisibleData();
        };
        /**
         * Displays the info popup for a specified time interval. The interval must be visible on screen.
         *
         * Note that if [`info.enabled`](time-chart/api-reference/settings/info/enabled.html) is set to `false` this method
         * still works. In this case the info popup shown by this method will not be hidden as the user hovers the mouse over
         * the chart.
         *
         * @version 1.12.2
         * @version 1.15.0 - parameters can now be passed as `Date` or `moment` instances.
         */
        TimeChart.prototype.showInfoPopup = function (
            /** UTC timestamp of the start of the interval (inclusive). The value will be automatically rounded down based on the current display unit.
                Passing `null` will hide the info popup. */
            from, 
            /** UTC timestamp of the end of the interval (non-inclusive). The value will be automatically rounded up based on the current display unit.
                If not specified, selects a single unit starting with the `from` timestamp. */
            to, 
            /** Optional HTML code that will be used as the contents of the info popup. If this is not specified, the default contents will be generated. */
            contents) {
            var _this = this;
            if (this._cachedApiCalls) {
                this._cachedApiCalls.push(function () {
                    _this.showInfoPopup(from, to, contents);
                });
                return;
            }
            var impl = this._impl;
            var scene = impl.scene;
            var difs = ZoomCharts.Internal.TimeChart.TimeStep.timeUnitDiffs;
            var hasTimePart = impl.displayUnit ? difs[impl.displayUnit.unit] < difs["d"] : true;
            impl.showInfoPopup(from == null ? null : scene.timestampToInternal(+from, hasTimePart), to == null ? null : scene.timestampToInternal(+to, hasTimePart), contents);
        };
        /** Gets the currently enabled series
            @version 1.14.0
        */
        TimeChart.prototype.getEnabledSeries = function () {
            return this._impl.getEnabledSeries();
        };
        TimeChart.themes = {
            "flat": ZoomCharts.Internal.TimeChart.Settings.FlatTheme,
            "round": ZoomCharts.Internal.TimeChart.Settings.RoundTheme,
            "gradient": ZoomCharts.Internal.TimeChart.Settings.GradientTheme,
            "static": ZoomCharts.Internal.TimeChart.Settings.StaticChart,
            "dark": ZoomCharts.Internal.TimeChart.Settings.DarkTheme,
        };
        /**
         * An internal method that is used by the test runner engine to automatically pass the generated settings when a new chart instance is created.
         * @ignore
         */
        TimeChart.chartFactoryMethod = null;
        return TimeChart;
    }(ZoomCharts.Internal.Base.Api));
    ZoomCharts.TimeChart = TimeChart;
    ZoomCharts.Internal.Base.Helpers.exportSymbol("TimeChart", ZoomCharts.TimeChart);
})(ZoomCharts || (ZoomCharts = {}));
/// <reference path="PieChart.ts" />
/// <reference path="TimeChart.ts" />
/// <reference path="NetChart.ts" />
/// <reference path="GeoChart.ts" />
/// <reference path="FacetChart.ts" />
//# sourceMappingURL=everything-dev.js.map